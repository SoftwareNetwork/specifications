<h1 id="toml11">toml11</h1>
<p><a href="https://github.com/ToruNiina/toml11/actions"><img src="https://github.com/ToruNiina/toml11/workflows/build/badge.svg" alt="Build Status on GitHub Actions" /></a> <a href="https://travis-ci.org/ToruNiina/toml11"><img src="https://travis-ci.org/ToruNiina/toml11.svg?branch=master" alt="Build Status on TravisCI" /></a> <a href="https://ci.appveyor.com/project/ToruNiina/toml11/branch/master"><img src="https://ci.appveyor.com/api/projects/status/m2n08a926asvg5mg/branch/master?svg=true" alt="Build status on Appveyor" /></a> <a href="https://circleci.com/gh/ToruNiina/toml11/tree/master"><img src="https://circleci.com/gh/ToruNiina/toml11/tree/master.svg?style=svg" alt="Build status on CircleCI" /></a> <a href="https://github.com/ToruNiina/toml11/releases"><img src="https://img.shields.io/github/release/ToruNiina/toml11.svg?style=flat" alt="Version" /></a> <a href="LICENSE"><img src="https://img.shields.io/github/license/ToruNiina/toml11.svg?style=flat" alt="License" /></a> <a href="https://doi.org/10.5281/zenodo.1209136"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1209136.svg" alt="DOI" /></a></p>
<p>toml11 is a C++11 (or later) header-only toml parser/encoder depending only on C++ standard library.</p>
<ul>
<li>It is compatible to the latest version of <a href="https://toml.io/en/v1.0.0">TOML v1.0.0</a>.</li>
<li>It is one of the most TOML standard compliant libraries, tested with <a href="https://github.com/BurntSushi/toml-test">the language agnostic test suite for TOML parsers by BurntSushi</a>.</li>
<li>It shows highly informative error messages. You can see the error messages about invalid files at <a href="https://circleci.com/gh/ToruNiina/toml11">CircleCI</a>.</li>
<li>It has configurable container. You can use any random-access containers and key-value maps as backend containers.</li>
<li>It optionally preserves comments without any overhead.</li>
<li>It has configurable serializer that supports comments, inline tables, literal strings and multiline strings.</li>
<li>It supports user-defined type conversion from/into toml values.</li>
<li>It correctly handles UTF-8 sequences, with or without BOM, both on posix and Windows.</li>
</ul>
<h2 id="example">Example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;toml.hpp&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ```toml</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// title = &quot;an example toml file&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// nums  = [3, 1, 4, 1, 5]</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ```</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find a value with the specified type from a table</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>title <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;title&quot;</span><span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// convert the whole array into any container automatically</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;nums&quot;</span><span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// access with STL-like manner</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(!</span>data<span class="op">.</span>contains<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">))</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        data<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pass a fallback</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>name <span class="op">=</span> toml<span class="op">::</span>find_or<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="st">&quot;not found&quot;</span><span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// width-dependent formatting</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">80</span><span class="op">)</span> <span class="op">&lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#integration">Integration</a></li>
<li><a href="#decoding-a-toml-file">Decoding a toml file</a>
<ul>
<li><a href="#in-the-case-of-syntax-error">In the case of syntax error</a></li>
<li><a href="#invalid-utf-8-codepoints">Invalid UTF-8 Codepoints</a></li>
</ul></li>
<li><a href="#finding-a-toml-value">Finding a toml value</a>
<ul>
<li><a href="#finding-a-value-in-a-table">Finding a value in a table</a></li>
<li><a href="#in-case-of-error">In case of error</a></li>
<li><a href="#dotted-keys">Dotted keys</a></li>
</ul></li>
<li><a href="#casting-a-toml-value">Casting a toml value</a></li>
<li><a href="#checking-value-type">Checking value type</a></li>
<li><a href="#more-about-conversion">More about conversion</a>
<ul>
<li><a href="#converting-an-array">Converting an array</a></li>
<li><a href="#converting-a-table">Converting a table</a></li>
<li><a href="#getting-an-array-of-tables">Getting an array of tables</a></li>
<li><a href="#cost-of-conversion">Cost of conversion</a></li>
<li><a href="#converting-datetime-and-its-variants">Converting datetime and its variants</a></li>
</ul></li>
<li><a href="#getting-with-a-fallback">Getting with a fallback</a></li>
<li><a href="#expecting-conversion">Expecting conversion</a></li>
<li><a href="#visiting-a-tomlvalue">Visiting a toml::value</a></li>
<li><a href="#constructing-a-tomlvalue">Constructing a toml::value</a></li>
<li><a href="#preserving-comments">Preserving Comments</a></li>
<li><a href="#customizing-containers">Customizing containers</a></li>
<li><a href="#toml-literal">TOML literal</a></li>
<li><a href="#conversion-between-toml-value-and-arbitrary-types">Conversion between toml value and arbitrary types</a></li>
<li><a href="#formatting-user-defined-error-messages">Formatting user-defined error messages</a></li>
<li><a href="#obtaining-location-information">Obtaining location information</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#colorize-error-messages">Colorize Error Messages</a></li>
<li><a href="#serializing-toml-data">Serializing TOML data</a></li>
<li><a href="#underlying-types">Underlying types</a></li>
<li><a href="#unreleased-toml-features">Unreleased TOML features</a></li>
<li><a href="#breaking-changes-from-v2">Breaking Changes from v2</a></li>
<li><a href="#running-tests">Running Tests</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#licensing-terms">Licensing Terms</a></li>
</ul>
<h2 id="integration">Integration</h2>
<p>Just include the file after adding it to the include path.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;toml.hpp&gt;</span><span class="pp"> </span><span class="co">// that&#39;s all! now you can use it.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> data  <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> title <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;title&quot;</span><span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;the title is &quot;</span> <span class="op">&lt;&lt;</span> title <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The convenient way is to add this repository as a git-submodule or to install it in your system by CMake.</p>
<p>Note for MSVC: We recommend to set <code>/Zc:__cplusplus</code> to detect C++ version correctly.</p>
<h2 id="decoding-a-toml-file">Decoding a toml file</h2>
<p>To parse a toml file, the only thing you have to do is to pass a filename to the <code>toml::parse</code> function.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>fname<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span>fname<span class="op">);</span></span></code></pre></div>
<p>As required by the TOML specification, the top-level value is always a table. You can find a value inside it, cast it into a table explicitly, and insert it as a value into other <code>toml::value</code>.</p>
<p>If it encounters an error while opening a file, it will throw <code>std::runtime_error</code>.</p>
<p>You can also pass a <code>std::istream</code> to the <code>toml::parse</code> function. To show a filename in an error message, however, it is recommended to pass the filename with the stream.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ifstream<span class="op"> </span>ifs<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">,</span> <span class="bu">std::</span>ios_base<span class="bu">::</span>binary<span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>ifs<span class="op">.</span>good<span class="op">());</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span>ifs<span class="op">,</span> <span class="co">/*optional -&gt; */</span> <span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span></code></pre></div>
<p><strong>Note</strong>: When you are <strong>on Windows, open a file in binary mode</strong>. If a file is opened in text-mode, CRLF (“”) will automatically be converted to LF (“”) and this causes inconsistency between file size and the contents that would be read. This causes weird error.</p>
<h3 id="in-the-case-of-syntax-error">In the case of syntax error</h3>
<p>If there is a syntax error in a toml file, <code>toml::parse</code> will throw <code>toml::syntax_error</code> that inherits <code>std::exception</code>.</p>
<p>toml11 has clean and informative error messages inspired by Rust and it looks like the following.</p>
<pre class="console"><code>terminate called after throwing an instance of &#39;toml::syntax_error&#39;
  what():  [error] toml::parse_table: invalid line format # error description
 --&gt; example.toml                                         # file name
 3 | a = 42 = true                                        # line num and content
   |        ^------ expected newline, but got &#39;=&#39;.        # error reason</code></pre>
<p>If you (mistakenly) duplicate tables and got an error, it is helpful to see where they are. toml11 shows both at the same time like the following.</p>
<pre class="console"><code>terminate called after throwing an instance of &#39;toml::syntax_error&#39;
  what():  [error] toml::insert_value: table (&quot;table&quot;) already exists.
 --&gt; duplicate-table.toml
 1 | [table]
   | ~~~~~~~ table already exists here
 ...
 3 | [table]
   | ~~~~~~~ table defined twice</code></pre>
<p>When toml11 encounters a malformed value, it tries to detect what type it is. Then it shows hints to fix the format. An error message while reading one of the malformed files in <a href="https://github.com/BurntSushi/toml-test">the language agnostic test suite</a>. is shown below.</p>
<pre class="console"><code>what(): [error] bad time: should be HH:MM:SS.subsec
 --&gt; ./datetime-malformed-no-secs.toml
 1 | no-secs = 1987-07-05T17:45Z
   |                     ^------- HH:MM:SS.subsec
   |
Hint: pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999
Hint: fail: 1979-05-27T7:32:00, 1979-05-27 17:32</code></pre>
<p>You can find other examples in a job named <code>output_result</code> on <a href="https://circleci.com/gh/ToruNiina/toml11">CircleCI</a>.</p>
<p>Since the error message generation is generally a difficult task, the current status is not ideal. If you encounter a weird error message, please let us know and contribute to improve the quality!</p>
<h3 id="invalid-utf-8-codepoints">Invalid UTF-8 codepoints</h3>
<p>It throws <code>syntax_error</code> if a value of an escape sequence representing unicode character is not a valid UTF-8 codepoint.</p>
<pre class="console"><code>  what():  [error] toml::read_utf8_codepoint: input codepoint is too large.
 --&gt; utf8.toml
 1 | exceeds_unicode = &quot;\U0011FFFF example&quot;
   |                              ^--------- should be in [0x00..0x10FFFF]</code></pre>
<h2 id="finding-a-toml-value">Finding a toml value</h2>
<p>After parsing successfully, you can obtain the values from the result of <code>toml::parse</code> using <code>toml::find</code> function.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sample.toml</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">answer</span>  <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">pi</span>      <span class="op">=</span> <span class="fl">3.14</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">numbers</span> <span class="op">=</span> <span class="op">[</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">]</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="dt">time</span>    <span class="op">=</span> <span class="bn">1979-05-27T07:32:00Z</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data      <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> answer    <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>int64_t<span class="op"> </span>   <span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;answer&quot;</span><span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> pi        <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">double</span>          <span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;pi&quot;</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> numbers   <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;numbers&quot;</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> timepoint <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>time_point<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;time&quot;</span><span class="op">);</span></span></code></pre></div>
<p>By default, <code>toml::find</code> returns a <code>toml::value</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value<span class="op">&amp;</span> answer <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;answer&quot;</span><span class="op">);</span></span></code></pre></div>
<p>When you pass an exact TOML type that does not require type conversion, <code>toml::find</code> returns a reference without copying the value.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span>  data   <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> answer <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span>toml<span class="op">::</span>integer<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;answer&quot;</span><span class="op">);</span></span></code></pre></div>
<p>If the specified type requires conversion, you can’t take a reference to the value. See also <a href="#underlying-types">underlying types</a>.</p>
<p><strong>NOTE</strong>: For some technical reason, automatic conversion between <code>integer</code> and <code>floating</code> is not supported. If you want to get a floating value even if a value has integer value, you need to convert it manually after obtaining a value, like the following.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> vx <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;x&quot;</span><span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x <span class="op">=</span> vx<span class="op">.</span>is_floating<span class="op">()</span> <span class="op">?</span> vx<span class="op">.</span>as_floating<span class="op">(</span><span class="bu">std::</span>nothrow<span class="op">)</span> <span class="op">:</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>           <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>vx<span class="op">.</span>as_integer<span class="op">());</span> <span class="co">// it throws if vx is neither</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                                                 <span class="co">// floating nor integer.</span></span></code></pre></div>
<h3 id="finding-a-value-in-a-table">Finding a value in a table</h3>
<p>There are several way to get a value defined in a table. First, you can get a table as a normal value and find a value from the table.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">fruit</span><span class="kw">]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;apple&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">fruit</span><span class="kw">.</span><span class="dt">physical</span><span class="kw">]</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="dt">color</span> <span class="op">=</span> <span class="st">&quot;red&quot;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">shape</span> <span class="op">=</span> <span class="st">&quot;round&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span>  data  <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;fruit.toml&quot;</span><span class="op">);</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> fruit <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;fruit&quot;</span><span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span>  name  <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>fruit<span class="op">,</span> <span class="st">&quot;name&quot;</span><span class="op">);</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> physical <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>fruit<span class="op">,</span> <span class="st">&quot;physical&quot;</span><span class="op">);</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span>  color    <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>physical<span class="op">,</span> <span class="st">&quot;color&quot;</span><span class="op">);</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span>  shape    <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>physical<span class="op">,</span> <span class="st">&quot;shape&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Here, variable <code>fruit</code> is a <code>toml::value</code> and can be used as the first argument of <code>toml::find</code>.</p>
<p>Second, you can pass as many arguments as the number of subtables to <code>toml::find</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data  <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;fruit.toml&quot;</span><span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> color <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;fruit&quot;</span><span class="op">,</span> <span class="st">&quot;physical&quot;</span><span class="op">,</span> <span class="st">&quot;color&quot;</span><span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> shape <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;fruit&quot;</span><span class="op">,</span> <span class="st">&quot;physical&quot;</span><span class="op">,</span> <span class="st">&quot;shape&quot;</span><span class="op">);</span></span></code></pre></div>
<h3 id="finding-a-value-in-an-array">Finding a value in an array</h3>
<p>You can find n-th value in an array by <code>toml::find</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">values</span> <span class="op">=</span> <span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">]</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data   <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> values <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;values&quot;</span><span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> bar    <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>values<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p><code>toml::find</code> can also search array recursively.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;fruit.toml&quot;</span><span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> bar  <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;values&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>Before calling <code>toml::find</code>, you can check if a value corresponding to a key exists. You can use both <code>bool toml::value::contains(const key&amp;) const</code> and <code>std::size_t toml::value::count(const key&amp;) const</code>. Those behaves like the <code>std::map::contains</code> and <code>std::map::count</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;fruit.toml&quot;</span><span class="op">);</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>data<span class="op">.</span>contains<span class="op">(</span><span class="st">&quot;fruit&quot;</span><span class="op">)</span> <span class="op">&amp;&amp;</span> data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;fruit&quot;</span><span class="op">).</span>count<span class="op">(</span><span class="st">&quot;physical&quot;</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="in-case-of-error">In case of error</h3>
<p>If the value does not exist, <code>toml::find</code> throws <code>std::out_of_range</code> with the location of the table.</p>
<pre class="console"><code>terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  [error] key &quot;answer&quot; not found
 --&gt; example.toml
 6 | [tab]
   | ~~~~~ in this table</code></pre>
<hr />
<p>If the specified type differs from the actual value contained, it throws <code>toml::type_error</code> that inherits <code>std::exception</code>.</p>
<p>Similar to the case of syntax error, toml11 also displays clean error messages. The error message when you choose <code>int</code> to get <code>string</code> value would be like this.</p>
<pre class="console"><code>terminate called after throwing an instance of &#39;toml::type_error&#39;
  what():  [error] toml::value bad_cast to integer
 --&gt; example.toml
 3 | title = &quot;TOML Example&quot;
   |         ~~~~~~~~~~~~~~ the actual type is string</code></pre>
<p><strong>NOTE</strong>: In order to show this kind of error message, all the toml values have a pointer to represent its range in a file. The entire contents of a file is shared by <code>toml::value</code>s and remains on the heap memory. It is recommended to destruct all the <code>toml::value</code> classes after configuring your application if you have a large TOML file compared to the memory resource.</p>
<h3 id="dotted-keys">Dotted keys</h3>
<p>TOML v0.5.0 has a new feature named “dotted keys”. You can chain keys to represent the structure of the data.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">physical</span><span class="er">.color</span> <span class="op">=</span> <span class="st">&quot;orange&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">physical</span><span class="er">.shape</span> <span class="op">=</span> <span class="st">&quot;round&quot;</span></span></code></pre></div>
<p>This is equivalent to the following.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">physical</span><span class="kw">]</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">color</span> <span class="op">=</span> <span class="st">&quot;orange&quot;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">shape</span> <span class="op">=</span> <span class="st">&quot;round&quot;</span></span></code></pre></div>
<p>You can get both of the above tables with the same c++ code.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> physical <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;physical&quot;</span><span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> color    <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>physical<span class="op">,</span> <span class="st">&quot;color&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The following code does not work for the above toml file.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// XXX this does not work!</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> color <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;physical.color&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The above code works with the following toml file.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&quot;physical.color&quot;</span> <span class="op">=</span> <span class="st">&quot;orange&quot;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co"># equivalent to {&quot;physical.color&quot;: &quot;orange&quot;},</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"># NOT {&quot;physical&quot;: {&quot;color&quot;: &quot;orange&quot;}}.</span></span></code></pre></div>
<h2 id="casting-a-toml-value">Casting a toml value</h2>
<h3 id="tomlget"><code>toml::get</code></h3>
<p><code>toml::parse</code> returns <code>toml::value</code>. <code>toml::value</code> is a union type that can contain one of the following types.</p>
<ul>
<li><code>toml::boolean</code> (<code>bool</code>)</li>
<li><code>toml::integer</code> (<code>std::int64_t</code>)</li>
<li><code>toml::floating</code> (<code>double</code>)</li>
<li><code>toml::string</code> (a type convertible to std::string)</li>
<li><code>toml::local_date</code></li>
<li><code>toml::local_time</code></li>
<li><code>toml::local_datetime</code></li>
<li><code>toml::offset_datetime</code></li>
<li><code>toml::array</code> (by default, <code>std::vector&lt;toml::value&gt;</code>)
<ul>
<li>It depends. See <a href="#customizing-containers">customizing containers</a> for detail.</li>
</ul></li>
<li><code>toml::table</code> (by default, <code>std::unordered_map&lt;toml::key, toml::value&gt;</code>)
<ul>
<li>It depends. See <a href="#customizing-containers">customizing containers</a> for detail.</li>
</ul></li>
</ul>
<p>To get a value inside, you can use <code>toml::get&lt;T&gt;()</code>. The usage is the same as <code>toml::find&lt;T&gt;</code> (actually, <code>toml::find</code> internally uses <code>toml::get</code> after casting a value to <code>toml::table</code>).</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value  data    <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value  <span class="va">answer_</span> <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>table <span class="op">&gt;(</span>data<span class="op">).</span>at<span class="op">(</span><span class="st">&quot;answer&quot;</span><span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>int64_t<span class="op"> </span>answer  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>int64_t<span class="op">&gt;(</span><span class="va">answer_</span><span class="op">);</span></span></code></pre></div>
<p>When you pass an exact TOML type that does not require type conversion, <code>toml::get</code> returns a reference through which you can modify the content (if the <code>toml::value</code> is <code>const</code>, it returns <code>const</code> reference).</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value   data    <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value   <span class="va">answer_</span> <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>table <span class="op">&gt;(</span>data<span class="op">).</span>at<span class="op">(</span><span class="st">&quot;answer&quot;</span><span class="op">);</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>integer<span class="op">&amp;</span> answer <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>integer<span class="op">&gt;(</span><span class="va">answer_</span><span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>answer <span class="op">=</span> <span class="dv">6</span> <span class="op">*</span> <span class="dv">9</span><span class="op">;</span> <span class="co">// write to data.answer. now `answer_` contains 54.</span></span></code></pre></div>
<p>If the specified type requires conversion, you can’t take a reference to the value. See also <a href="#underlying-types">underlying types</a>.</p>
<p>It also throws a <code>toml::type_error</code> if the type differs.</p>
<h3 id="as_xxx"><code>as_xxx</code></h3>
<p>You can also use a member function to cast a value.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>int64_t<span class="op"> </span>answer <span class="op">=</span> data<span class="op">.</span>as_table<span class="op">().</span>at<span class="op">(</span><span class="st">&quot;answer&quot;</span><span class="op">).</span>as_integer<span class="op">();</span></span></code></pre></div>
<p>It also throws a <code>toml::type_error</code> if the type differs. If you are sure that the value <code>v</code> contains a value of the specified type, you can suppress checking by passing <code>std::nothrow</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> answer <span class="op">=</span> data<span class="op">.</span>as_table<span class="op">().</span>at<span class="op">(</span><span class="st">&quot;answer&quot;</span><span class="op">);</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>answer<span class="op">.</span>is_integer<span class="op">()</span> <span class="op">&amp;&amp;</span> answer<span class="op">.</span>as_integer<span class="op">(</span><span class="bu">std::</span>nothrow<span class="op">)</span> <span class="op">==</span> <span class="dv">42</span><span class="op">)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;value is 42&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If <code>std::nothrow</code> is passed, the functions are marked as noexcept.</p>
<p>By casting a <code>toml::value</code> into an array or a table, you can iterate over the elements.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;keys in the top-level table are the following: </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>k<span class="op">,</span> v<span class="op">]</span> <span class="op">:</span> data<span class="op">.</span>as_table<span class="op">())</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> fruits <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;fruits&quot;</span><span class="op">);</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> v <span class="op">:</span> fruits<span class="op">.</span>as_array<span class="op">())</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;name&quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The full list of the functions is below.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> value <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> boolean<span class="op">&amp;</span>         as_boolean<span class="op">()</span>         <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> integer<span class="op">&amp;</span>         as_integer<span class="op">()</span>         <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> floating<span class="op">&amp;</span>        as_floating<span class="op">()</span>        <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> string<span class="op">&amp;</span>          as_string<span class="op">()</span>          <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> offset_datetime<span class="op">&amp;</span> as_offset_datetime<span class="op">()</span> <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> local_datetime<span class="op">&amp;</span>  as_local_datetime<span class="op">()</span>  <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> local_date<span class="op">&amp;</span>      as_local_date<span class="op">()</span>      <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> local_time<span class="op">&amp;</span>      as_local_time<span class="op">()</span>      <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> array<span class="op">&amp;</span>           as_array<span class="op">()</span>           <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> table<span class="op">&amp;</span>           as_table<span class="op">()</span>           <span class="at">const</span><span class="op">&amp;;</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --------------------------------------------------------</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// non-const version</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    boolean<span class="op">&amp;</span>               as_boolean<span class="op">()</span>         <span class="op">&amp;;</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ditto...</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --------------------------------------------------------</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rvalue version</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    boolean<span class="op">&amp;&amp;</span>              as_boolean<span class="op">()</span>         <span class="op">&amp;&amp;;</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ditto...</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --------------------------------------------------------</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// noexcept versions ...</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> boolean<span class="op">&amp;</span>         as_boolean<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>nothrow_t<span class="op">&amp;)</span> <span class="at">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    boolean<span class="op">&amp;</span>               as_boolean<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>nothrow_t<span class="op">&amp;)</span> <span class="op">&amp;</span>      <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    boolean<span class="op">&amp;&amp;</span>              as_boolean<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>nothrow_t<span class="op">&amp;)</span> <span class="op">&amp;&amp;</span>     <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ditto...</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<h3 id="at"><code>at()</code></h3>
<p>You can access to the element of a table and an array by <code>toml::basic_value::at</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> v<span class="op">.</span>at<span class="op">(</span><span class="dv">2</span><span class="op">).</span>as_integer<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// 3</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">}};</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> v<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">).</span>as_integer<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// 42</span></span></code></pre></div>
<p>If an invalid key (integer for a table, string for an array), it throws <code>toml::type_error</code> for the conversion. If the provided key is out-of-range, it throws <code>std::out_of_range</code>.</p>
<p>Note that, although <code>std::string</code> has <code>at()</code> member function, <code>toml::value::at</code> throws if the contained type is a string. Because <code>std::string</code> does not contain <code>toml::value</code>.</p>
<h3 id="operator"><code>operator[]</code></h3>
<p>You can also access to the element of a table and an array by <code>toml::basic_value::operator[]</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> v<span class="op">[</span><span class="dv">2</span><span class="op">].</span>as_integer<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// 3</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">}};</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> v<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>as_integer<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// 42</span></span></code></pre></div>
<p>When you access to a <code>toml::value</code> that is not initialized yet via <code>operator[](const std::string&amp;)</code>, the <code>toml::value</code> will be a table, just like the <code>std::map</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">;</span> <span class="co">// not initialized as a table.</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span> <span class="co">// OK. `v` will be a table.</span></span></code></pre></div>
<p>Contrary, if you access to a <code>toml::value</code> that contains an array via <code>operator[]</code>, it does not check anything. It converts <code>toml::value</code> without type check and then access to the n-th element without boundary check, just like the <code>std::vector::operator[]</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">;</span> <span class="co">// not initialized as an array</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>     <span class="co">// error! UB</span></span></code></pre></div>
<p>Please make sure that the <code>toml::value</code> has an array inside when you access to its element via <code>operator[]</code>.</p>
<h2 id="checking-value-type">Checking value type</h2>
<p>You can check the type of a value by <code>is_xxx</code> function.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v <span class="op">=</span> <span class="co">/* ... */</span><span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>v<span class="op">.</span>is_integer<span class="op">())</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;value is an integer&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complete list of the functions is below.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> value <span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_boolean<span class="op">()</span>         <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_integer<span class="op">()</span>         <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_floating<span class="op">()</span>        <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_string<span class="op">()</span>          <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_offset_datetime<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_local_datetime<span class="op">()</span>  <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_local_date<span class="op">()</span>      <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_local_time<span class="op">()</span>      <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_array<span class="op">()</span>           <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_table<span class="op">()</span>           <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_uninitialized<span class="op">()</span>   <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p>Also, you can get <code>enum class value_t</code> from <code>toml::value::type()</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span><span class="op">(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;something&quot;</span><span class="op">).</span>type<span class="op">())</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> toml<span class="op">::</span><span class="dt">value_t</span><span class="op">::</span>integer<span class="op">:</span>  <span class="co">/*do some stuff*/</span> <span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> toml<span class="op">::</span><span class="dt">value_t</span><span class="op">::</span>floating<span class="op">:</span> <span class="co">/*do some stuff*/</span> <span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> toml<span class="op">::</span><span class="dt">value_t</span><span class="op">::</span>string <span class="op">:</span>  <span class="co">/*do some stuff*/</span> <span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span> <span class="op">:</span> <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;unexpected type : &quot;</span> <span class="op">+</span> toml<span class="op">::</span>stringize<span class="op">(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;something&quot;</span><span class="op">).</span>type<span class="op">()));</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complete list of the <code>enum</code>s can be found in the section <a href="#underlying-types">underlying types</a>.</p>
<p>The <code>enum</code>s can be used as a parameter of <code>toml::value::is</code> function like the following.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v <span class="op">=</span> <span class="co">/* ... */</span><span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>v<span class="op">.</span>is<span class="op">(</span>toml<span class="op">::</span><span class="dt">value_t</span><span class="op">::</span>boolean<span class="op">))</span> <span class="co">// ...</span></span></code></pre></div>
<h2 id="more-about-conversion">More about conversion</h2>
<p>Since <code>toml::find</code> internally uses <code>toml::get</code>, all the following examples work with both <code>toml::get</code> and <code>toml::find</code>.</p>
<h3 id="converting-an-array">Converting an array</h3>
<p>You can get any kind of <code>container</code> class from a <code>toml::array</code> except for <code>map</code>-like classes.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// # sample.toml</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">// numbers = [1,2,3]</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> numbers <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;numbers&quot;</span><span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> vc  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>  <span class="op">&gt;(</span>numbers<span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ls  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>    <span class="op">&gt;(</span>numbers<span class="op">);</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dq  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>deque<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>   <span class="op">&gt;(</span>numbers<span class="op">);</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ar  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;&gt;(</span>numbers<span class="op">);</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co">// if the size of data.at(&quot;numbers&quot;) is larger than that of std::array,</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co">// it will throw toml::type_error because std::array is not resizable.</span></span></code></pre></div>
<p>Surprisingly, you can convert <code>toml::array</code> into <code>std::pair</code> and <code>std::tuple</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// numbers = [1,2,3]</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> tp <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">short</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">int</span><span class="op">&gt;&gt;(</span>numbers<span class="op">);</span></span></code></pre></div>
<p>This functionality is helpful when you have a toml file like the following.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">array_of_arrays</span> <span class="op">=</span> <span class="op">[[</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">],</span> <span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">]]</span> <span class="co"># toml allows this</span></span></code></pre></div>
<p>What is the corresponding C++ type? Obviously, it is a <code>std::pair</code> of <code>std::vector</code>s.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> array_of_arrays <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;array_of_arrays&quot;</span><span class="op">);</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> aofa <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;(</span>array_of_arrays<span class="op">);</span></span></code></pre></div>
<p>If you don’t know the type of the elements, you can use <code>toml::array</code>, which is a <code>std::vector</code> of <code>toml::value</code>, instead.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> a_of_a <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>array<span class="op">&gt;(</span>array_of_arrays<span class="op">);</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> first  <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>a_of_a<span class="op">.</span>at<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span></code></pre></div>
<p>You can change the implementation of <code>toml::array</code> with <code>std::deque</code> or some other array-like container. See <a href="#customizing-containers">Customizing containers</a> for detail.</p>
<h3 id="converting-a-table">Converting a table</h3>
<p>When all the values of the table have the same type, toml11 allows you to convert a <code>toml::table</code> to a <code>map</code> that contains the convertible type.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">tab</span><span class="kw">]</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="dt">key1</span> <span class="op">=</span> <span class="st">&quot;foo&quot;</span> <span class="co"># all the values are</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="dt">key2</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span> <span class="co"># toml String</span></span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> tab <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;tab&quot;</span><span class="op">);</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> tab<span class="op">[</span><span class="st">&quot;key1&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// foo</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> tab<span class="op">[</span><span class="st">&quot;key2&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="co">// bar</span></span></code></pre></div>
<p>But since <code>toml::table</code> is just an alias of <code>std::unordered_map&lt;toml::key, toml::value&gt;</code>, normally you don’t need to convert it because it has all the functionalities that <code>std::unordered_map</code> has (e.g. <code>operator[]</code>, <code>count</code>, and <code>find</code>). In most cases <code>toml::table</code> is sufficient.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>table tab <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>table<span class="op">&gt;(</span>data<span class="op">);</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>data<span class="op">.</span>count<span class="op">(</span><span class="st">&quot;title&quot;</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    data<span class="op">[</span><span class="st">&quot;title&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>string<span class="op">(</span><span class="st">&quot;TOML example&quot;</span><span class="op">);</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can change the implementation of <code>toml::table</code> with <code>std::map</code> or some other map-like container. See <a href="#customizing-containers">Customizing containers</a> for detail.</p>
<h3 id="getting-an-array-of-tables">Getting an array of tables</h3>
<p>An array of tables is just an array of tables. You can get it in completely the same way as the other arrays and tables.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sample.toml</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="dt">array_of_inline_tables</span> <span class="op">=</span> <span class="op">[{</span><span class="dt">key</span><span class="op"> =</span> <span class="st">&quot;value1&quot;</span><span class="op">},</span> <span class="op">{</span><span class="dt">key</span><span class="op"> =</span> <span class="st">&quot;value2&quot;</span><span class="op">},</span> <span class="op">{</span><span class="dt">key</span><span class="op"> =</span> <span class="st">&quot;value3&quot;</span><span class="op">}]</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[[</span><span class="dt">array_of_tables</span><span class="kw">]]</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="dt">key</span> <span class="op">=</span> <span class="st">&quot;value4&quot;</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="kw">[[</span><span class="dt">array_of_tables</span><span class="kw">]]</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="dt">key</span> <span class="op">=</span> <span class="st">&quot;value5&quot;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="kw">[[</span><span class="dt">array_of_tables</span><span class="kw">]]</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="dt">key</span> <span class="op">=</span> <span class="st">&quot;value6&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> aot1 <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>toml<span class="op">::</span>table<span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;array_of_inline_tables&quot;</span><span class="op">);</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> aot2 <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>toml<span class="op">::</span>table<span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;array_of_tables&quot;</span><span class="op">);</span></span></code></pre></div>
<h3 id="cost-of-conversion">Cost of conversion</h3>
<p>Although conversion through <code>toml::(get|find)</code> is convenient, it has additional copy-cost because it copies data contained in <code>toml::value</code> to the user-specified type. Of course in some cases this overhead is not ignorable.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// the following code constructs a std::vector.</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">// it requires heap allocation for vector and element conversion.</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> array <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>data<span class="op">,</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span></code></pre></div>
<p>By passing the exact types, <code>toml::get</code> returns reference that has no overhead.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> tab     <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span>toml<span class="op">::</span>table<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;tab&quot;</span><span class="op">);</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> numbers <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span>toml<span class="op">::</span>array<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;numbers&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Also, <code>as_xxx</code> are zero-overhead because they always return a reference.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> tab     <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;tab&quot;</span>    <span class="op">).</span>as_table<span class="op">();</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> numbers <span class="op">=</span> toml<span class="op">::</span>find<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;numbers&quot;</span><span class="op">).</span>as_array<span class="op">();</span></span></code></pre></div>
<p>In this case you need to call <code>toml::get</code> each time you access to the element of <code>toml::array</code> because <code>toml::array</code> is an array of <code>toml::value</code>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> num0 <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>integer<span class="op">&gt;(</span>numbers<span class="op">.</span>at<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> num1 <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>integer<span class="op">&gt;(</span>numbers<span class="op">.</span>at<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> num2 <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span>toml<span class="op">::</span>integer<span class="op">&gt;(</span>numbers<span class="op">.</span>at<span class="op">(</span><span class="dv">2</span><span class="op">));</span></span></code></pre></div>
<h3 id="converting-datetime-and-its-variants">Converting datetime and its variants</h3>
<p>TOML v0.5.0 has 4 different datetime objects, <code>local_date</code>, <code>local_time</code>, <code>local_datetime</code>, and <code>offset_datetime</code>.</p>
<p>Since <code>local_date</code>, <code>local_datetime</code>, and <code>offset_datetime</code> represent a time point, you can convert them to <code>std::chrono::system_clock::time_point</code>.</p>
<p>Contrary, <code>local_time</code> does not represents a time point because they lack a date information, but it can be converted to <code>std::chrono::duration</code> that represents a duration from the beginning of the day, <code>00:00:00.000</code>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sample.toml</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="dt">date</span> <span class="op">=</span> <span class="bn">2018-12-23</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="dt">time</span> <span class="op">=</span> <span class="dv">12</span><span class="er">:30:00</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="dt">l_dt</span> <span class="op">=</span> <span class="bn">2018-12-23T12:30:00</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="dt">o_dt</span> <span class="op">=</span> <span class="bn">2018-12-23T12:30:00+09:30</span></span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;sample.toml&quot;</span><span class="op">);</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> date <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>time_point<span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;date&quot;</span><span class="op">));</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> l_dt <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>time_point<span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;l_dt&quot;</span><span class="op">));</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> o_dt <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>time_point<span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;o_dt&quot;</span><span class="op">));</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> time <span class="op">=</span> toml<span class="op">::</span>get<span class="op">&lt;</span><span class="bu">std::</span>chrono<span class="bu">::</span>minutes<span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;time&quot;</span><span class="op">));</span> <span class="co">// 12 * 60 + 30 min</span></span></code></pre></div>
<p><code>local_date</code> and <code>local_datetime</code> are assumed to be in the local timezone when they are converted into <code>time_point</code>. On the other hand, <code>offset_datetime</code> only uses the offset part of the data and it does not take local timezone into account.</p>
<p>To contain datetime data, toml11 defines its own datetime types. For more detail, you can see the definitions in <a href="toml/datetime.hpp">toml/datetime.hpp</a>.</p>
<h2 id="getting-with-a-fallback">Getting with a fallback</h2>
<p><code>toml::find_or</code> returns a default value if the value is not found or has a different type.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> num  <span class="op">=</span> toml<span class="op">::</span>find_or<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">);</span></span></code></pre></div>
<p>It works recursively if you pass several keys for subtables. In that case, the last argument is considered to be the optional value. All other arguments between <code>toml::value</code> and the optinoal value are considered as keys.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// [fruit.physical]</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">// color = &quot;red&quot;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> data  <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;fruit.toml&quot;</span><span class="op">);</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> color <span class="op">=</span> toml<span class="op">::</span>find_or<span class="op">(</span>data<span class="op">,</span> <span class="st">&quot;fruit&quot;</span><span class="op">,</span> <span class="st">&quot;physical&quot;</span><span class="op">,</span> <span class="st">&quot;color&quot;</span><span class="op">,</span> <span class="st">&quot;red&quot;</span><span class="op">);</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="co">//                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="co">//                               arguments                     optional value</span></span></code></pre></div>
<p>Also, <code>toml::get_or</code> returns a default value if <code>toml::get&lt;T&gt;</code> failed.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">);</span> <span class="co">// v contains String</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> value <span class="op">=</span> toml<span class="op">::</span>get_or<span class="op">(</span>v<span class="op">,</span> <span class="dv">42</span><span class="op">);</span> <span class="co">// conversion fails. it returns 42.</span></span></code></pre></div>
<p>These functions automatically deduce what type you want to get from the default value you passed.</p>
<p>To get a reference through this function, take care about the default value.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">);</span> <span class="co">// v contains String</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>integer<span class="op">&amp;</span> i <span class="op">=</span> toml<span class="op">::</span>get_or<span class="op">(</span>v<span class="op">,</span> <span class="dv">42</span><span class="op">);</span> <span class="co">// does not work because binding `42`</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// to `integer&amp;` is invalid</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>integer opt <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>integer<span class="op">&amp;</span> i <span class="op">=</span> toml<span class="op">::</span>get_or<span class="op">(</span>v<span class="op">,</span> opt<span class="op">);</span> <span class="co">// this works.</span></span></code></pre></div>
<h2 id="expecting-conversion">Expecting conversion</h2>
<p>By using <code>toml::expect</code>, you will get your expected value or an error message without throwing <code>toml::type_error</code>.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> value <span class="op">=</span> toml<span class="op">::</span>expect<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;title&quot;</span><span class="op">));</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>value<span class="op">.</span>is_ok<span class="op">())</span> <span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> value<span class="op">.</span>unwrap<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> value<span class="op">.</span>unwrap_err<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Also, you can pass a function object to modify the expected value.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> value <span class="op">=</span> toml<span class="op">::</span>expect<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;number&quot;</span><span class="op">))</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map<span class="op">(</span><span class="co">// function that receives expected type (here, int)</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span><span class="at">const</span> <span class="dt">int</span> number<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> number <span class="op">*</span> <span class="fl">1.5</span> <span class="op">+</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}).</span>unwrap_or<span class="op">(</span><span class="co">/*default value =*/</span> <span class="fl">3.14</span><span class="op">);</span></span></code></pre></div>
<h2 id="visiting-a-tomlvalue">Visiting a toml::value</h2>
<p>toml11 provides <code>toml::visit</code> to apply a function to <code>toml::value</code> in the same way as <code>std::variant</code>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">(</span><span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>visit<span class="op">([](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> val<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> val <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span> v<span class="op">);</span></span></code></pre></div>
<p>The function object that would be passed to <code>toml::visit</code> must be able to receive all the possible TOML types. Also, the result types should be the same each other.</p>
<h2 id="constructing-a-tomlvalue">Constructing a toml::value</h2>
<p><code>toml::value</code> can be constructed in various ways.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="kw">true</span><span class="op">);</span>     <span class="co">// boolean</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="dv">42</span><span class="op">);</span>       <span class="co">// integer</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="fl">3.14</span><span class="op">);</span>     <span class="co">// floating</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="st">&quot;foobar&quot;</span><span class="op">);</span> <span class="co">// string</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>local_date<span class="op">(</span><span class="dv">2019</span><span class="op">,</span> toml<span class="op">::</span><span class="dt">month_t</span><span class="op">::</span>Apr<span class="op">,</span> <span class="dv">1</span><span class="op">));</span> <span class="co">// date</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span>                                 <span class="co">// array</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;baz&quot;</span><span class="op">,</span> <span class="st">&quot;qux&quot;</span><span class="op">}};</span>    <span class="co">// table</span></span></code></pre></div>
<p>When constructing a string, you can choose to use either literal or basic string. By default, it will be a basic string.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="st">&quot;foobar&quot;</span><span class="op">,</span> toml<span class="op">::</span><span class="dt">string_t</span><span class="op">::</span>basic  <span class="op">);</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="st">&quot;foobar&quot;</span><span class="op">,</span> toml<span class="op">::</span><span class="dt">string_t</span><span class="op">::</span>literal<span class="op">);</span></span></code></pre></div>
<p>Datetime objects can be constructed from <code>std::tm</code> and <code>std::chrono::system_clock::time_point</code>. But you need to specify what type you use to avoid ambiguity.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> now <span class="op">=</span> <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now<span class="op">();</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>local_date<span class="op">(</span>now<span class="op">));</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>local_datetime<span class="op">(</span>now<span class="op">));</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>offset_datetime<span class="op">(</span>now<span class="op">));</span></span></code></pre></div>
<p>Since local time is not equivalent to a time point, because it lacks date information, it will be constructed from <code>std::chrono::duration</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>local_time<span class="op">(</span><span class="bu">std::</span>chrono<span class="bu">::</span>hours<span class="op">(</span><span class="dv">10</span><span class="op">)));</span></span></code></pre></div>
<p>You can construct an array object not only from <code>initializer_list</code>, but also from STL containers. In that case, the element type must be convertible to <code>toml::value</code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>vec<span class="op">);</span></span></code></pre></div>
<p>When you construct an array value, all the elements of <code>initializer_list</code> must be convertible into <code>toml::value</code>.</p>
<p>If a <code>toml::value</code> has an array, you can <code>push_back</code> an element in it.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>push_back<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span></code></pre></div>
<p><code>emplace_back</code> also works.</p>
<h2 id="preserving-comments">Preserving comments</h2>
<p>toml11 v3 or later allows you yo choose whether comments are preserved or not via template parameter</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data1 <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">&lt;</span>toml<span class="op">::</span>discard_comments <span class="op">&gt;(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data2 <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span></code></pre></div>
<p>or macro definition.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TOML11_PRESERVE_COMMENTS_BY_DEFAULT</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;toml11/toml.hpp&gt;</span></span></code></pre></div>
<p>This feature is controlled by template parameter in <code>toml::basic_value&lt;...&gt;</code>. <code>toml::value</code> is an alias of <code>toml::basic_value&lt;...&gt;</code>.</p>
<p>If template parameter is explicitly specified, the return value of <code>toml::parse</code> will be <code>toml::basic_value&lt;toml::preserve_comments&gt;</code>. If the macro is defined, the alias <code>toml::value</code> will be <code>toml::basic_value&lt;toml::preserve_comments&gt;</code>.</p>
<p>Comments related to a value can be obtained by <code>toml::value::comments()</code>. The return value has the same interface as <code>std::vector&lt;std::string&gt;</code>.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> com <span class="op">=</span> v<span class="op">.</span>comments<span class="op">();</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> c <span class="op">:</span> com<span class="op">)</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> c <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Comments just before and just after (within the same line) a value are kept in a value.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># this is a comment for v1.</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="dt">v1</span> <span class="op">=</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="dt">v2</span> <span class="op">=</span> <span class="st">&quot;bar&quot;</span> <span class="co"># this is a comment for v2.</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Note that this comment is NOT a comment for v2.</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="co"># this comment is not related to any value</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="co"># because there are empty lines between v3.</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="co"># this comment will be ignored even if you set `preserve_comments`.</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="co"># this is a comment for v3</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a><span class="co"># this is also a comment for v3.</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="dt">v3</span> <span class="op">=</span> <span class="st">&quot;baz&quot;</span> <span class="co"># ditto.</span></span></code></pre></div>
<p>Each comment line becomes one element of a <code>std::vector</code>.</p>
<p>Hash signs will be removed, but spaces after hash sign will not be removed.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>v1<span class="op">.</span>comments<span class="op">().</span>at<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot; this is a comment for v1.&quot;</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>v2<span class="op">.</span>comments<span class="op">().</span>at<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot; this is a comment for v1.&quot;</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>v3<span class="op">.</span>comments<span class="op">().</span>at<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot; this is a comment for v3.&quot;</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>v3<span class="op">.</span>comments<span class="op">().</span>at<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot; this is also a comment for v3.&quot;</span><span class="bu">s</span><span class="op">;</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>v3<span class="op">.</span>comments<span class="op">().</span>at<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">==</span> <span class="st">&quot; ditto.&quot;</span><span class="bu">s</span><span class="op">;</span></span></code></pre></div>
<p>Note that a comment just after an opening brace of an array will not be a comment for the array.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># this is a comment for a.</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="dt">a</span> <span class="op">=</span> <span class="op">[</span> <span class="co"># this is not a comment for a. this will be ignored.</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this is a comment for `42`.</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">42</span><span class="op">,</span> <span class="co"># this is also a comment for `42`.</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>  <span class="dv">5</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="op">]</span> <span class="co"># this is a comment for a.</span></span></code></pre></div>
<p>You can also append and modify comments. The interfaces are the same as <code>std::vector&lt;std::string&gt;</code>.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>basic_value<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;</span> v<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>comments<span class="op">().</span>push_back<span class="op">(</span><span class="st">&quot; add this comment.&quot;</span><span class="op">);</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">// # add this comment.</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="co">// i = 42</span></span></code></pre></div>
<p>Also, you can pass a <code>std::vector&lt;std::string&gt;</code> when constructing a <code>toml::basic_value&lt;toml::preserve_comments&gt;</code>.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> comments<span class="op">{</span><span class="st">&quot;comment 1&quot;</span><span class="op">,</span> <span class="st">&quot;comment 2&quot;</span><span class="op">};</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>basic_value<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;</span> v1<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>comments<span class="op">));</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>basic_value<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;</span> v2<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="op">{</span><span class="st">&quot;comment 1&quot;</span><span class="op">,</span> <span class="st">&quot;comment 2&quot;</span><span class="op">});</span></span></code></pre></div>
<p>When <code>toml::discard_comments</code> is chosen, comments will not be contained in a value. <code>value::comments()</code> will always be kept empty. All the modification on comments would be ignored. All the element access in a <code>discard_comments</code> causes the same error as accessing an element of an empty <code>std::vector</code>.</p>
<p>The comments will also be serialized. If comments exist, those comments will be added just before the values.</p>
<p><strong>NOTE</strong>: Result types from <code>toml::parse(...)</code> and <code>toml::parse&lt;toml::preserve_comments&gt;(...)</code> are different.</p>
<h2 id="customizing-containers">Customizing containers</h2>
<p>Actually, <code>toml::basic_value</code> has 3 template arguments.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Comment<span class="op">,</span> <span class="co">// discard/preserve_comment</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>         <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> Table <span class="op">=</span> <span class="bu">std::</span>unordered_map<span class="op">,</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> Array <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&gt;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> basic_value<span class="op">;</span></span></code></pre></div>
<p>This enables you to change the containers used inside. E.g. you can use <code>std::map</code> to contain a table object instead of <code>std::unordered_map</code>. And also can use <code>std::deque</code> as a array object instead of <code>std::vector</code>.</p>
<p>You can set these parameters while calling <code>toml::parse</code> function.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">&lt;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>preserve_comments<span class="op">,</span> <span class="bu">std::</span>map<span class="op">,</span> <span class="bu">std::</span>deque</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="op"> </span>   <span class="op">&gt;(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Needless to say, the result types from <code>toml::parse(...)</code> and <code>toml::parse&lt;Com, Map, Cont&gt;(...)</code> are different (unless you specify the same types as default).</p>
<p>Note that, since <code>toml::table</code> and <code>toml::array</code> is an alias for a table and an array of a default <code>toml::value</code>, so it is different from the types actually contained in a <code>toml::basic_value</code> when you customize containers. To get the actual type in a generic way, use <code>typename toml::basic_type&lt;C, T, A&gt;::table_type</code> and <code>typename toml::basic_type&lt;C, T, A&gt;::array_type</code>.</p>
<h2 id="toml-literal">TOML literal</h2>
<p>toml11 supports <code>"..."_toml</code> literal. It accept both a bare value and a file content.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> toml<span class="op">::</span>literals<span class="op">::</span>toml_literals<span class="op">;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="co">// `_toml` can convert a bare value without key</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v <span class="op">=</span> <span class="st">u8&quot;0xDEADBEEF&quot;_toml</span><span class="op">;</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="co">// v is an Integer value containing 0xDEADBEEF.</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="co">// raw string literal (`R&quot;(...)&quot;` is useful for this purpose)</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value t <span class="op">=</span> <span class="st">u8R&quot;(</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="st">    title = &quot;this is TOML literal&quot;</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="st">    [table]</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="st">    key = &quot;value&quot;</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a><span class="st">)&quot;</span>_toml<span class="op">;</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a><span class="co">// the literal will be parsed and the result will be contained in t</span></span></code></pre></div>
<p>The literal function is defined in the same way as the standard library literals such as <code>std::literals::string_literals::operator""s</code>.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">namespace</span> literals</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">namespace</span> toml_literals</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value <span class="kw">operator</span><span class="st">&quot;&quot;</span> _toml<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> str<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>len<span class="op">);</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml_literals</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// literals</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p>Access to the operator can be gained with <code>using namespace toml::literals;</code>, <code>using namespace toml::toml_literals</code>, and <code>using namespace toml::literals::toml_literals</code>.</p>
<p>Note that a key that is composed only of digits is allowed in TOML. And, unlike the file parser, toml-literal allows a bare value without a key. Thus it is difficult to distinguish arrays having integers and definitions of tables that are named as digits. Currently, literal <code>[1]</code> becomes a table named “1”. To ensure a literal to be considered as an array with one element, you need to add a comma after the first element (like <code>[1,]</code>).</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[1,2,3]&quot;_toml</span><span class="op">;</span>   <span class="co">// This is an array</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[table]&quot;_toml</span><span class="op">;</span>   <span class="co">// This is a table that has an empty table named &quot;table&quot; inside.</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[[1,2,3]]&quot;_toml</span><span class="op">;</span> <span class="co">// This is an array of arrays</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[[table]]&quot;_toml</span><span class="op">;</span> <span class="co">// This is a table that has an array of tables inside.</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[[1]]&quot;_toml</span><span class="op">;</span>     <span class="co">// This literal is ambiguous.</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>                  <span class="co">// Currently, it becomes a table that has array of table &quot;1&quot;.</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;1 = [</span><span class="sc">{}</span><span class="st">]&quot;_toml</span><span class="op">;</span>  <span class="co">// This is a table that has an array of table named 1.</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[[1,]]&quot;_toml</span><span class="op">;</span>    <span class="co">// This is an array of arrays.</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;[[1],]&quot;_toml</span><span class="op">;</span>    <span class="co">// ditto.</span></span></code></pre></div>
<p>NOTE: <code>_toml</code> literal returns a <code>toml::value</code> that does not have comments.</p>
<h2 id="conversion-between-toml-value-and-arbitrary-types">Conversion between toml value and arbitrary types</h2>
<p>You can also use <code>toml::get</code> and other related functions with the types you defined after you implement a way to convert it.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> data <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a><span class="co">// to do this</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> foo f <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span>ext<span class="op">::</span>foo<span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span></code></pre></div>
<p>There are 3 ways to use <code>toml::get</code> with the types that you defined.</p>
<p>The first one is to implement <code>from_toml(const toml::value&amp;)</code> member function.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> from_toml<span class="op">(</span><span class="at">const</span> toml<span class="op">::</span>value<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>a <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span>        <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">);</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>b <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">double</span>     <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">);</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>c <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">);</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span></code></pre></div>
<p>In this way, because <code>toml::get</code> first constructs <code>foo</code> without arguments, the type should be default-constructible.</p>
<p>The second is to implement <code>constructor(const toml::value&amp;)</code>.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> foo<span class="op">(</span><span class="at">const</span> toml<span class="op">::</span>value<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> a<span class="op">(</span>toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">)),</span> b<span class="op">(</span>toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">)),</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>          c<span class="op">(</span>toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">))</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span></code></pre></div>
<p>Note that implicit default constructor declaration will be suppressed when a constructor is defined. If you want to use the struct (here, <code>foo</code>) in a container (e.g. <code>std::vector&lt;foo&gt;</code>), you may need to define default constructor explicitly.</p>
<p>The third is to implement specialization of <code>toml::from</code> for your type.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> from<span class="op">&lt;</span>ext<span class="op">::</span>foo<span class="op">&gt;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> ext<span class="op">::</span>foo from_toml<span class="op">(</span><span class="at">const</span> value<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        ext<span class="op">::</span>foo f<span class="op">;</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>a <span class="op">=</span> find<span class="op">&lt;</span><span class="dt">int</span>        <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">);</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>b <span class="op">=</span> find<span class="op">&lt;</span><span class="dt">double</span>     <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">);</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>c <span class="op">=</span> find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">);</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f<span class="op">;</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p>In this way, since the conversion function is defined outside of the class, you can add conversion between <code>toml::value</code> and classes defined in another library.</p>
<p>In some cases, a class has a templatized constructor that takes a template, <code>T</code>. It confuses <code>toml::get/find&lt;T&gt;</code> because it makes the class “constructible” from <code>toml::value</code>. To avoid this problem, <code>toml::from</code> and <code>from_toml</code> always precede constructor. It makes easier to implement conversion between <code>toml::value</code> and types defined in other libraries because it skips constructor.</p>
<p>But, importantly, you cannot define <code>toml::from&lt;T&gt;</code> and <code>T.from_toml</code> at the same time because it causes ambiguity in the overload resolution of <code>toml::get&lt;T&gt;</code> and <code>toml::find&lt;T&gt;</code>.</p>
<p>So the precedence is <code>toml::from&lt;T&gt;</code> == <code>T.from_toml()</code> &gt; <code>T(toml::value)</code>.</p>
<p>If you want to convert any versions of <code>toml::basic_value</code>, you need to templatize the conversion function as follows.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">,</span> <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> M<span class="op">,</span> <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> from_toml<span class="op">(</span><span class="at">const</span> toml<span class="op">::</span>basic_value<span class="op">&lt;</span>C<span class="op">,</span> M<span class="op">,</span> A<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>a <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span>        <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">);</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>b <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">double</span>     <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">);</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>c <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">);</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="co">// or</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> from<span class="op">&lt;</span>ext<span class="op">::</span>foo<span class="op">&gt;</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">,</span> <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> M<span class="op">,</span> <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...&gt;</span> <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> ext<span class="op">::</span>foo from_toml<span class="op">(</span><span class="at">const</span> basic_value<span class="op">&lt;</span>C<span class="op">,</span> M<span class="op">,</span> A<span class="op">&gt;&amp;</span> v<span class="op">)</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>        ext<span class="op">::</span>foo f<span class="op">;</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>a <span class="op">=</span> find<span class="op">&lt;</span><span class="dt">int</span>        <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">);</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>b <span class="op">=</span> find<span class="op">&lt;</span><span class="dt">double</span>     <span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">);</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>        f<span class="op">.</span>c <span class="op">=</span> find<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>v<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">);</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f<span class="op">;</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<hr />
<p>The opposite direction is also supported in a similar way. You can directly pass your type to <code>toml::value</code>’s constructor by introducing <code>into_toml</code> or <code>toml::into&lt;T&gt;</code>.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>value into_toml<span class="op">()</span> <span class="at">const</span> <span class="co">// you need to mark it const.</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> toml<span class="op">::</span>value<span class="op">{{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">-&gt;</span>a<span class="op">},</span> <span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">-&gt;</span>b<span class="op">},</span> <span class="op">{</span><span class="st">&quot;c&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">-&gt;</span>c<span class="op">}};</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>ext<span class="op">::</span>foo    f<span class="op">{</span><span class="dv">42</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">,</span> <span class="st">&quot;foobar&quot;</span><span class="op">};</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>f<span class="op">);</span></span></code></pre></div>
<p>The definition of <code>toml::into&lt;T&gt;</code> is similar to <code>toml::from&lt;T&gt;</code>.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> ext</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         a<span class="op">;</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      b<span class="op">;</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>c<span class="op">;</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ext</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> into<span class="op">&lt;</span>ext<span class="op">::</span>foo<span class="op">&gt;</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> toml<span class="op">::</span>value into_toml<span class="op">(</span><span class="at">const</span> ext<span class="op">::</span>foo<span class="op">&amp;</span> f<span class="op">)</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> toml<span class="op">::</span>value<span class="op">{{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> f<span class="op">.</span>a<span class="op">},</span> <span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">,</span> f<span class="op">.</span>b<span class="op">},</span> <span class="op">{</span><span class="st">&quot;c&quot;</span><span class="op">,</span> f<span class="op">.</span>c<span class="op">}};</span></span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>ext<span class="op">::</span>foo    f<span class="op">{</span><span class="dv">42</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">,</span> <span class="st">&quot;foobar&quot;</span><span class="op">};</span></span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>f<span class="op">);</span></span></code></pre></div>
<p>Any type that can be converted to <code>toml::value</code>, e.g. <code>int</code>, <code>toml::table</code> and <code>toml::array</code> are okay to return from <code>into_toml</code>.</p>
<p>You can also return a custom <code>toml::basic_value</code> from <code>toml::into</code>.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> into<span class="op">&lt;</span>ext<span class="op">::</span>foo<span class="op">&gt;</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> toml<span class="op">::</span>basic_value<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;</span> into_toml<span class="op">(</span><span class="at">const</span> ext<span class="op">::</span>foo<span class="op">&amp;</span> f<span class="op">)</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        toml<span class="op">::</span>basic_value<span class="op">&lt;</span>toml<span class="op">::</span>preserve_comments<span class="op">&gt;</span> v<span class="op">{{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> f<span class="op">.</span>a<span class="op">},</span> <span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">,</span> f<span class="op">.</span>b<span class="op">},</span> <span class="op">{</span><span class="st">&quot;c&quot;</span><span class="op">,</span> f<span class="op">.</span>c<span class="op">}};</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>comments<span class="op">().</span>push_back<span class="op">(</span><span class="st">&quot; comment&quot;</span><span class="op">);</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p>But note that, if this <code>basic_value</code> would be assigned into other <code>toml::value</code> that discards <code>comments</code>, the comments would be dropped.</p>
<h3 id="macro-to-automatically-define-conversion-functions">Macro to automatically define conversion functions</h3>
<p>There is a helper macro that automatically generates conversion functions <code>from</code> and <code>into</code> for a simple struct.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> foo</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">;</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>      d<span class="op">;</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>         i<span class="op">;</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// foo</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>TOML11_DEFINE_CONVERSION_NON_INTRUSIVE<span class="op">(</span>foo<span class="op">::</span>Foo<span class="op">,</span> s<span class="op">,</span> d<span class="op">,</span> i<span class="op">)</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> file <span class="op">=</span> toml<span class="op">::</span>parse<span class="op">(</span><span class="st">&quot;example.toml&quot;</span><span class="op">);</span></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span>foo<span class="op">::</span>Foo<span class="op">&gt;(</span>file<span class="op">,</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And then you can use <code>toml::find&lt;foo::Foo&gt;(file, "foo");</code></p>
<p><strong>Note</strong> that, because of a slight difference in implementation of preprocessor between gcc/clang and MSVC, <a href="https://github.com/ToruNiina/toml11/issues/139#issuecomment-803683682">you need to define <code>/Zc:preprocessor</code></a> to use it in MSVC (Thank you <span class="citation" data-cites="glebm">@glebm</span> !).</p>
<h2 id="formatting-user-defined-error-messages">Formatting user-defined error messages</h2>
<p>When you encounter an error after you read the toml value, you may want to show the error with the value.</p>
<p>toml11 provides you a function that formats user-defined error message with related values. With a code like the following,</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> value <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>data<span class="op">,</span> <span class="st">&quot;num&quot;</span><span class="op">);</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>value <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr<span class="op"> &lt;&lt;</span> toml<span class="op">::</span>format_error<span class="op">(</span><span class="st">&quot;[error] value should be positive&quot;</span><span class="op">,</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>                                    data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;num&quot;</span><span class="op">),</span> <span class="st">&quot;positive number required&quot;</span><span class="op">)</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>you will get an error message like this.</p>
<pre class="console"><code>[error] value should be positive
 --&gt; example.toml
 3 | num = -42
   |       ~~~ positive number required</code></pre>
<p>When you pass two values to <code>toml::format_error</code>,</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> min <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>range<span class="op">,</span> <span class="st">&quot;min&quot;</span><span class="op">);</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> max <span class="op">=</span> toml<span class="op">::</span>find<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>range<span class="op">,</span> <span class="st">&quot;max&quot;</span><span class="op">);</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>max <span class="op">&lt;</span> min<span class="op">)</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr<span class="op"> &lt;&lt;</span> toml<span class="op">::</span>format_error<span class="op">(</span><span class="st">&quot;[error] max should be larger than min&quot;</span><span class="op">,</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>                                    data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;min&quot;</span><span class="op">),</span> <span class="st">&quot;minimum number here&quot;</span><span class="op">,</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>                                    data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;max&quot;</span><span class="op">),</span> <span class="st">&quot;maximum number here&quot;</span><span class="op">);</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>              <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>you will get an error message like this.</p>
<pre class="console"><code>[error] max should be larger than min
 --&gt; example.toml
 3 | min = 54
   |       ~~ minimum number here
 ...
 4 | max = 42
   |       ~~ maximum number here</code></pre>
<p>You can print hints at the end of the message.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> hints<span class="op">;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>hints<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;positive number means n &gt;= 0.&quot;</span><span class="op">);</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>hints<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;negative number is not positive.&quot;</span><span class="op">);</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cerr<span class="op"> &lt;&lt;</span> toml<span class="op">::</span>format_error<span class="op">(</span><span class="st">&quot;[error] value should be positive&quot;</span><span class="op">,</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>                                data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;num&quot;</span><span class="op">),</span> <span class="st">&quot;positive number required&quot;</span><span class="op">,</span> hints<span class="op">)</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<pre class="console"><code>[error] value should be positive
 --&gt; example.toml
 2 | num = 42
   |       ~~ positive number required
   |
Hint: positive number means n &gt;= 0.
Hint: negative number is not positive.</code></pre>
<h2 id="obtaining-location-information">Obtaining location information</h2>
<p>You can also format error messages in your own way by using <code>source_location</code>.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> source_location</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>uint_least32_t<span class="op"> </span>line<span class="op">()</span>      <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>uint_least32_t<span class="op"> </span>column<span class="op">()</span>    <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>uint_least32_t<span class="op"> </span>region<span class="op">()</span>    <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span><span class="op">&amp;</span>  file_name<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span><span class="op">&amp;</span>  line_str<span class="op">()</span>  <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="co">// +-- line()       +--- length of the region (here, region() == 9)</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="co">// v            .---+---.</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 12 | value = &quot;foo bar&quot; &lt;- line_str() returns the line itself.</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a><span class="co">//              ^-------- column() points here</span></span></code></pre></div>
<p>You can get this by</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value           v   <span class="op">=</span> <span class="co">/*...*/</span><span class="op">;</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>source_location loc <span class="op">=</span> v<span class="op">.</span>location<span class="op">();</span></span></code></pre></div>
<h2 id="exceptions">Exceptions</h2>
<p>The following <code>exception</code> classes inherits <code>toml::exception</code> that inherits <code>std::exception</code>.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml <span class="op">{</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> exception      <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>exception<span class="op"> </span> <span class="op">{</span><span class="co">/**/</span><span class="op">};</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> syntax_error   <span class="op">:</span> <span class="kw">public</span> toml<span class="op">::</span>exception <span class="op">{</span><span class="co">/**/</span><span class="op">};</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> type_error     <span class="op">:</span> <span class="kw">public</span> toml<span class="op">::</span>exception <span class="op">{</span><span class="co">/**/</span><span class="op">};</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> internal_error <span class="op">:</span> <span class="kw">public</span> toml<span class="op">::</span>exception <span class="op">{</span><span class="co">/**/</span><span class="op">};</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p><code>toml::exception</code> has <code>toml::exception::location()</code> member function that returns <code>toml::source_location</code>, in addition to <code>what()</code>.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> toml <span class="op">{</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> exception <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>exception</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    source_location <span class="at">const</span><span class="op">&amp;</span> location<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// toml</span></span></code></pre></div>
<p>It represents where the error occurs.</p>
<p><code>syntax_error</code> will be thrown from <code>toml::parse</code> and <code>_toml</code> literal. <code>type_error</code> will be thrown from <code>toml::get/find</code>, <code>toml::value::as_xxx()</code>, and other functions that takes a content inside of <code>toml::value</code>.</p>
<p>Note that, currently, from <code>toml::value::at()</code> and <code>toml::find(value, key)</code> may throw an <code>std::out_of_range</code> that does not inherits <code>toml::exception</code>.</p>
<p>Also, in some cases, most likely in the file open error, it will throw an <code>std::runtime_error</code>.</p>
<h2 id="colorize-error-messages">Colorize Error Messages</h2>
<p>By defining <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, the error messages from <code>toml::parse</code> and <code>toml::find|get</code> will be colorized. By default, this feature is turned off.</p>
<p>With the following toml file taken from <code>toml-lang/toml/tests/hard_example.toml</code>,</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">error</span><span class="kw">]</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="dt">array</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;This might most likely happen in multiline arrays&quot;</span><span class="op">,</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">Like</span> <span class="op">here,</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;or here,</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">and</span> <span class="op">here</span><span class="st">&quot;</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span>     <span class="er">End</span> <span class="er">of</span> <span class="er">array</span> <span class="er">comment,</span> <span class="er">forgot</span> <span class="er">the</span> <span class="co">#</span></span></code></pre></div>
<p>the error message would be like this.</p>
<figure>
<img src="https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-1.png" alt="error-message-1" /><figcaption aria-hidden="true">error-message-1</figcaption>
</figure>
<p>With the following,</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">error</span><span class="kw">]</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="co"># array = [</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="co">#          &quot;This might most likely happen in multiline arrays&quot;,</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="co">#          Like here,</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="co">#          &quot;or here,</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="co">#          and here&quot;</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="co">#         ]     End of array comment, forgot the #</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="dt">number</span> <span class="op">=</span> <span class="fl">3.14</span>  <span class="er">pi</span> <span class="er">&lt;--again</span> <span class="er">forgot</span> <span class="er">the</span> <span class="co">#</span></span></code></pre></div>
<p>the error message would be like this.</p>
<figure>
<img src="https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-2.png" alt="error-message-2" /><figcaption aria-hidden="true">error-message-2</figcaption>
</figure>
<p>The message would be messy when it is written to a file, not a terminal because it uses <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code</a>.</p>
<p>Without <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, you can still colorize user-defined error message by passing <code>true</code> to the <code>toml::format_error</code> function. If you define <code>TOML11_COLORIZE_ERROR_MESSAGE</code>, the value is <code>true</code> by default. If not, the default value would be <code>false</code>.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cerr<span class="op"> &lt;&lt;</span> toml<span class="op">::</span>format_error<span class="op">(</span><span class="st">&quot;[error] value should be positive&quot;</span><span class="op">,</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>                                data<span class="op">.</span>at<span class="op">(</span><span class="st">&quot;num&quot;</span><span class="op">),</span> <span class="st">&quot;positive number required&quot;</span><span class="op">,</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>                                hints<span class="op">,</span> <span class="co">/*colorize = */</span> <span class="kw">true</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Note: It colorize <code>[error]</code> in red. That means that it detects <code>[error]</code> prefix at the front of the error message. If there is no <code>[error]</code> prefix, <code>format_error</code> adds it to the error message.</p>
<h2 id="serializing-toml-data">Serializing TOML data</h2>
<p>toml11 enables you to serialize data into toml format.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value data<span class="op">{{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">}};</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="co">// bar = &quot;baz&quot;</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="co">// foo = 42</span></span></code></pre></div>
<p>toml11 automatically makes a small table and small array inline. You can specify the width to make them inline by <code>std::setw</code> for streams.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value data<span class="op">{</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;qux&quot;</span><span class="op">,</span>    <span class="op">{{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;baz&quot;</span><span class="op">}}},</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;quux&quot;</span><span class="op">,</span>   <span class="op">{</span><span class="st">&quot;small&quot;</span><span class="op">,</span> <span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="st">&quot;of&quot;</span><span class="op">,</span> <span class="st">&quot;strings&quot;</span><span class="op">}},</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;foobar&quot;</span><span class="op">,</span> <span class="op">{</span><span class="st">&quot;this&quot;</span><span class="op">,</span> <span class="st">&quot;array&quot;</span><span class="op">,</span> <span class="st">&quot;of&quot;</span><span class="op">,</span> <span class="st">&quot;strings&quot;</span><span class="op">,</span> <span class="st">&quot;is&quot;</span><span class="op">,</span> <span class="st">&quot;too&quot;</span><span class="op">,</span> <span class="st">&quot;long&quot;</span><span class="op">,</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;to&quot;</span><span class="op">,</span> <span class="st">&quot;print&quot;</span><span class="op">,</span> <span class="st">&quot;into&quot;</span><span class="op">,</span> <span class="st">&quot;single&quot;</span><span class="op">,</span> <span class="st">&quot;line&quot;</span><span class="op">,</span> <span class="st">&quot;isn&#39;t&quot;</span><span class="op">,</span> <span class="st">&quot;it?&quot;</span><span class="op">}},</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="co">// the threshold becomes 80.</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">80</span><span class="op">)</span> <span class="op">&lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="co">// foobar = [</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;this&quot;,&quot;array&quot;,&quot;of&quot;,&quot;strings&quot;,&quot;is&quot;,&quot;too&quot;,&quot;long&quot;,&quot;to&quot;,&quot;print&quot;,&quot;into&quot;,</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;single&quot;,&quot;line&quot;,&quot;isn&#39;t&quot;,&quot;it?&quot;,</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a><span class="co">// ]</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a><span class="co">// quux = [&quot;small&quot;,&quot;array&quot;,&quot;of&quot;,&quot;strings&quot;]</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="co">// qux = {bar=&quot;baz&quot;,foo=42}</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a><span class="co">// the width is 0. nothing become inline.</span></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setw<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a><span class="co">// foobar = [</span></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;this&quot;,</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a><span class="co">// ... (snip)</span></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;it?&quot;,</span></span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a><span class="co">// ]</span></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a><span class="co">// quux = [</span></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;small&quot;,</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;array&quot;,</span></span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;of&quot;,</span></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;strings&quot;,</span></span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a><span class="co">// ]</span></span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a><span class="co">// [qux]</span></span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a><span class="co">// bar = &quot;baz&quot;</span></span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a><span class="co">// foo = 42</span></span></code></pre></div>
<p>It is recommended to set width before printing data. Some I/O functions changes width to 0, and it makes all the stuff (including <code>toml::array</code>) multiline. The resulting files becomes too long.</p>
<p>To control the precision of floating point numbers, you need to pass <code>std::setprecision</code> to stream.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value data<span class="op">{</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;pi&quot;</span><span class="op">,</span> <span class="fl">3.141592653589793</span><span class="op">},</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;e&quot;</span><span class="op">,</span>  <span class="fl">2.718281828459045</span><span class="op">}</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setprecision<span class="op">(</span><span class="dv">17</span><span class="op">)</span> <span class="op">&lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co">// e = 2.7182818284590451</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co">// pi = 3.1415926535897931</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>setprecision<span class="op">(</span> <span class="dv">7</span><span class="op">)</span> <span class="op">&lt;&lt;</span> data <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="co">// e = 2.718282</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="co">// pi = 3.141593</span></span></code></pre></div>
<p>There is another way to format toml values, <code>toml::format()</code>. It returns <code>std::string</code> that represents a value.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">}};</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>fmt <span class="op">=</span> toml<span class="op">::</span>format<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="co">// a = 42</span></span></code></pre></div>
<p>Note that since <code>toml::format</code> formats a value, the resulting string may lack the key value.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> toml<span class="op">::</span>value v<span class="op">{</span><span class="fl">3.14</span><span class="op">};</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>fmt <span class="op">=</span> toml<span class="op">::</span>format<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 3.14</span></span></code></pre></div>
<p>To control the width and precision, <code>toml::format</code> receives optional second and third arguments to set them. By default, the width is 80 and the precision is <code>std::numeric_limits&lt;double&gt;::max_digit10</code>.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> serial <span class="op">=</span> toml<span class="op">::</span>format<span class="op">(</span>data<span class="op">,</span> <span class="co">/*width = */</span> <span class="dv">0</span><span class="op">,</span> <span class="co">/*prec = */</span> <span class="dv">17</span><span class="op">);</span></span></code></pre></div>
<p>When you pass a comment-preserving-value, the comment will also be serialized. An array or a table containing a value that has a comment would not be inlined.</p>
<h2 id="underlying-types">Underlying types</h2>
<p>The toml types (can be used as <code>toml::*</code> in this library) and corresponding <code>enum</code> names are listed in the table below.</p>
<table>
<thead>
<tr class="header">
<th>TOML type</th>
<th>underlying c++ type</th>
<th>enum class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Boolean</td>
<td><code>bool</code></td>
<td><code>toml::value_t::boolean</code></td>
</tr>
<tr class="even">
<td>Integer</td>
<td><code>std::int64_t</code></td>
<td><code>toml::value_t::integer</code></td>
</tr>
<tr class="odd">
<td>Float</td>
<td><code>double</code></td>
<td><code>toml::value_t::floating</code></td>
</tr>
<tr class="even">
<td>String</td>
<td><code>toml::string</code></td>
<td><code>toml::value_t::string</code></td>
</tr>
<tr class="odd">
<td>LocalDate</td>
<td><code>toml::local_date</code></td>
<td><code>toml::value_t::local_date</code></td>
</tr>
<tr class="even">
<td>LocalTime</td>
<td><code>toml::local_time</code></td>
<td><code>toml::value_t::local_time</code></td>
</tr>
<tr class="odd">
<td>LocalDatetime</td>
<td><code>toml::local_datetime</code></td>
<td><code>toml::value_t::local_datetime</code></td>
</tr>
<tr class="even">
<td>OffsetDatetime</td>
<td><code>toml::offset_datetime</code></td>
<td><code>toml::value_t::offset_datetime</code></td>
</tr>
<tr class="odd">
<td>Array</td>
<td><code>array-like&lt;toml::value&gt;</code></td>
<td><code>toml::value_t::array</code></td>
</tr>
<tr class="even">
<td>Table</td>
<td><code>map-like&lt;toml::key, toml::value&gt;</code></td>
<td><code>toml::value_t::table</code></td>
</tr>
</tbody>
</table>
<p><code>array-like</code> and <code>map-like</code> are the STL containers that works like a <code>std::vector</code> and <code>std::unordered_map</code>, respectively. By default, <code>std::vector</code> and <code>std::unordered_map</code> are used. See <a href="#customizing-containers">Customizing containers</a> for detail.</p>
<p><code>toml::string</code> is effectively the same as <code>std::string</code> but has an additional flag that represents a kind of a string, <code>string_t::basic</code> and <code>string_t::literal</code>. Although <code>std::string</code> is not an exact toml type, still you can get a reference that points to internal <code>std::string</code> by using <code>toml::get&lt;std::string&gt;()</code> for convenience. The most important difference between <code>std::string</code> and <code>toml::string</code> is that <code>toml::string</code> will be formatted as a TOML string when outputted with <code>ostream</code>. This feature is introduced to make it easy to write a custom serializer.</p>
<p><code>Datetime</code> variants are <code>struct</code> that are defined in this library. Because <code>std::chrono::system_clock::time_point</code> is a <strong>time point</strong>, not capable of representing a Local Time independent from a specific day.</p>
<h2 id="unreleased-toml-features">Unreleased TOML features</h2>
<p>Since TOML v1.0.0-rc.1 has been released, those features are now activated by default. We no longer need to define <code>TOML11_USE_UNRELEASED_FEATURES</code>.</p>
<ul>
<li>Leading zeroes in exponent parts of floats are permitted.
<ul>
<li>e.g. <code>1.0e+01</code>, <code>5e+05</code></li>
<li><a href="https://github.com/toml-lang/toml/pull/656">toml-lang/toml/PR/656</a></li>
</ul></li>
<li>Allow raw tab characters in basic strings and multi-line basic strings.
<ul>
<li><a href="https://github.com/toml-lang/toml/pull/627">toml-lang/toml/PR/627</a></li>
</ul></li>
<li>Allow heterogeneous arrays
<ul>
<li><a href="https://github.com/toml-lang/toml/pull/676">toml-lang/toml/PR/676</a></li>
</ul></li>
</ul>
<h2 id="note-about-heterogeneous-arrays">Note about heterogeneous arrays</h2>
<p>Although <code>toml::parse</code> allows heterogeneous arrays, constructor of <code>toml::value</code> does not. Here the reason is explained.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this won&#39;t be compiled</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">},</span> <span class="op">{{</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;value&quot;</span><span class="op">}}</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There is a workaround for this. By explicitly converting values into <code>toml::value</code>, you can initialize <code>toml::value</code> with a heterogeneous array. Also, you can first initialize a <code>toml::value</code> with an array and then <code>push_back</code> into it.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co">// OK!</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>value<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">),</span> toml<span class="op">::</span>value<span class="op">(</span><span class="fl">3.14</span><span class="op">),</span> toml<span class="op">::</span>value<span class="op">(</span><span class="dv">42</span><span class="op">),</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>value<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">},</span> toml<span class="op">::</span>value<span class="op">{{</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;value&quot;</span><span class="op">}}</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a><span class="co">// OK!</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span>toml<span class="op">::</span>array<span class="op">{});</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>push_back<span class="op">(</span><span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a><span class="co">// OK!</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>array a<span class="op">;</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>push_back<span class="op">(</span><span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">));</span></span></code></pre></div>
<p>The reason why the first example is not allowed is the following. Let’s assume that you are initializing a <code>toml::value</code> with a table.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// # expecting TOML table.</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span>      <span class="co">// [v]</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;answer&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">},</span> <span class="co">// answer = 42</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;pi&quot;</span><span class="op">,</span>   <span class="fl">3.14</span><span class="op">},</span> <span class="co">// pi = 3.14</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">}</span>  <span class="co">// foo = &quot;bar&quot;</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This is indistinguishable from a (heterogeneous) TOML array definition.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode toml"><code class="sourceCode toml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="dt">v</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span><span class="st">&quot;answer&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">],</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span><span class="st">&quot;pi&quot;</span><span class="op">,</span>   <span class="fl">3.14</span><span class="op">],</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">],</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="op">]</span></span></code></pre></div>
<p>This means that the above C++ code makes constructor’s overload resolution ambiguous. So a constructor that allows both “table as an initializer-list” and “heterogeneous array as an initializer-list” cannot be implemented.</p>
<p>Thus, although it is painful, we need to explicitly cast values into <code>toml::value</code> when you initialize heterogeneous array in a C++ code.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>toml<span class="op">::</span>value v<span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>value<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">),</span> toml<span class="op">::</span>value<span class="op">(</span><span class="fl">3.14</span><span class="op">),</span> toml<span class="op">::</span>value<span class="op">(</span><span class="dv">42</span><span class="op">),</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    toml<span class="op">::</span>value<span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">},</span> toml<span class="op">::</span>value<span class="op">{{</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;value&quot;</span><span class="op">}}</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="breaking-changes-from-v2">Breaking Changes from v2</h2>
<p>Although toml11 is relatively new library (it’s three years old now), it had some confusing and inconvenient user-interfaces because of historical reasons.</p>
<p>Between v2 and v3, those interfaces are rearranged.</p>
<ul>
<li><code>toml::parse</code> now returns a <code>toml::value</code>, not <code>toml::table</code>.</li>
<li><code>toml::value</code> is now an alias of <code>toml::basic_value&lt;discard_comment, std::vector, std::unordered_map&gt;</code>.
<ul>
<li>See <a href="#customizing-containers">Customizing containers</a> for detail.</li>
</ul></li>
<li>The elements of <code>toml::value_t</code> are renamed as <code>snake_case</code>.
<ul>
<li>See <a href="#underlying-types">Underlying types</a> for detail.</li>
</ul></li>
<li>Supports for the CamelCaseNames are dropped.
<ul>
<li>See <a href="#underlying-types">Underlying types</a> for detail.</li>
</ul></li>
<li><code>(is|as)_float</code> has been removed to make the function names consistent with others.
<ul>
<li>Since <code>float</code> is a keyword, toml11 named a float type as <code>toml::floating</code>.</li>
<li>Also a <code>value_t</code> corresponds to <code>toml::floating</code> is named <code>value_t::floating</code>.</li>
<li>So <code>(is|as)_floating</code> is introduced and <code>is_float</code> has been removed.</li>
<li>See <a href="#casting-a-tomlvalue">Casting a toml::value</a> and <a href="#checking-value-type">Checking value type</a> for detail.</li>
</ul></li>
<li>An overload of <code>toml::find</code> for <code>toml::table</code> has been dropped. Use <code>toml::value</code> version instead.
<ul>
<li>Because type conversion between a table and a value causes ambiguity while overload resolution</li>
<li>Since <code>toml::parse</code> now returns a <code>toml::value</code>, this feature becomes less important.</li>
<li>Also because <code>toml::table</code> is a normal STL container, implementing utility function is easy.</li>
<li>See <a href="#finding-a-toml-value">Finding a toml::value</a> for detail.</li>
</ul></li>
<li>An overload of <code>operator&lt;&lt;</code> and <code>toml::format</code> for <code>toml::table</code>s are dropped.
<ul>
<li>Use <code>toml::value</code> instead.</li>
<li>See <a href="#serializing-toml-data">Serializing TOML data</a> for detail.</li>
</ul></li>
<li>Interface around comments.
<ul>
<li>See <a href="#preserving-comments">Preserving Comments</a> for detail.</li>
</ul></li>
<li>An ancient <code>from_toml/into_toml</code> has been removed. Use arbitrary type conversion support.
<ul>
<li>See <a href="#conversion-between-toml-value-and-arbitrary-types">Conversion between toml value and arbitrary types</a> for detail.</li>
</ul></li>
</ul>
<p>Such a big change will not happen in the coming years.</p>
<h2 id="running-tests">Running Tests</h2>
<p>After cloning this repository, run the following command (thank you <span class="citation" data-cites="jwillikers">@jwillikers</span> for automating test set fetching!).</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> mkdir build</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cd build</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cmake .. <span class="at">-Dtoml11_BUILD_TEST</span><span class="op">=</span>ON</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> make</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> make test</span></code></pre></div>
<p>To run the language agnostic test suite, you need to compile <code>tests/check_toml_test.cpp</code> and pass it to the tester.</p>
<h2 id="contributors">Contributors</h2>
<p>I appreciate the help of the contributors who introduced the great feature to this library.</p>
<ul>
<li>Guillaume Fraux (<span class="citation" data-cites="Luthaf">@Luthaf</span>)
<ul>
<li>Windows support and CI on Appvayor</li>
<li>Intel Compiler support</li>
</ul></li>
<li>Quentin Khan (<span class="citation" data-cites="xaxousis">@xaxousis</span>)
<ul>
<li>Found &amp; Fixed a bug around ODR</li>
<li>Improved error messages for invalid keys to show the location where the parser fails</li>
</ul></li>
<li>Petr Beneš (<span class="citation" data-cites="wbenny">@wbenny</span>)
<ul>
<li>Fixed warnings on MSVC</li>
</ul></li>
<li>Ivan Shynkarenka (<span class="citation" data-cites="chronoxor">@chronoxor</span>)
<ul>
<li>Fixed Visual Studio 2019 warnings</li>
</ul></li>
<li>Khoi Dinh Trinh (<span class="citation" data-cites="khoitd1997">@khoitd1997</span>)
<ul>
<li>Fixed warnings while type conversion</li>
</ul></li>
<li><span class="citation" data-cites="KerstinKeller">@KerstinKeller</span>
<ul>
<li>Added installation script to CMake</li>
</ul></li>
<li>J.C. Moyer (<span class="citation" data-cites="jcmoyer">@jcmoyer</span>)
<ul>
<li>Fixed an example code in the documentation</li>
</ul></li>
<li>Jt Freeman (<span class="citation" data-cites="blockparty-sh">@blockparty-sh</span>)
<ul>
<li>Fixed feature test macro around <code>localtime_s</code></li>
<li>Suppress warnings in Debug mode</li>
</ul></li>
<li>OGAWA Kenichi (<span class="citation" data-cites="kenichiice">@kenichiice</span>)
<ul>
<li>Suppress warnings on intel compiler</li>
</ul></li>
<li>Jordan Williams (<span class="citation" data-cites="jwillikers">@jwillikers</span>)
<ul>
<li>Fixed clang range-loop-analysis warnings</li>
<li>Fixed feature test macro to suppress -Wundef</li>
<li>Use cache variables in CMakeLists.txt</li>
<li>Automate test set fetching, update and refactor CMakeLists.txt</li>
</ul></li>
<li>Scott McCaskill
<ul>
<li>Parse 9 digits (nanoseconds) of fractional seconds in a <code>local_time</code></li>
</ul></li>
<li>Shu Wang (<span class="citation" data-cites="halfelf">@halfelf</span>)
<ul>
<li>fix “Finding a value in an array” example in README</li>
</ul></li>
<li><span class="citation" data-cites="maass-tv">@maass-tv</span> and <span class="citation" data-cites="SeverinLeonhardt">@SeverinLeonhardt</span>
<ul>
<li>Fix MSVC warning C4866</li>
</ul></li>
<li>OGAWA KenIchi (<span class="citation" data-cites="kenichiice">@kenichiice</span>)
<ul>
<li>Fix include path in README</li>
</ul></li>
<li>Mohammed Alyousef (<span class="citation" data-cites="MoAlyousef">@MoAlyousef</span>)
<ul>
<li>Made testing optional in CMake</li>
</ul></li>
<li>Ivan Shynkarenka (<span class="citation" data-cites="chronoxor">@chronoxor</span>)
<ul>
<li>Fix compilation error in <code>&lt;filesystem&gt;</code> with MinGW</li>
</ul></li>
<li>Alex Merry (<span class="citation" data-cites="amerry">@amerry</span>)
<ul>
<li>Add missing include files</li>
</ul></li>
<li>sneakypete81 (<span class="citation" data-cites="sneakypete81">@sneakypete81</span>)
<ul>
<li>Fix typo in error message</li>
</ul></li>
<li>Oliver Kahrmann (<span class="citation" data-cites="founderio">@founderio</span>)
<ul>
<li>Fix missing filename in error message if parsed file is empty</li>
</ul></li>
<li>Karl Nilsson (<span class="citation" data-cites="karl-nilsson">@karl-nilsson</span>)
<ul>
<li>Fix many spelling errors</li>
</ul></li>
<li>ohdarling88 (<span class="citation" data-cites="ohdarling">@ohdarling</span>)
<ul>
<li>Fix a bug in a constructor of serializer</li>
</ul></li>
<li>estshorter (<span class="citation" data-cites="estshorter">@estshorter</span>)
<ul>
<li>Fix MSVC warning C26478</li>
</ul></li>
<li>Philip Top (<span class="citation" data-cites="phlptp">@phlptp</span>)
<ul>
<li>Improve checking standard library feature availability check</li>
</ul></li>
<li>Louis Marascio (<span class="citation" data-cites="marascio">@marascio</span>)
<ul>
<li>Fix free-nonheap-object warning</li>
</ul></li>
<li>Axel Huebl (<span class="citation" data-cites="ax3l">@ax3l</span>)
<ul>
<li>Make installation optional if the library is embedded</li>
</ul></li>
</ul>
<h2 id="licensing-terms">Licensing terms</h2>
<p>This product is licensed under the terms of the <a href="LICENSE">MIT License</a>.</p>
<ul>
<li>Copyright (c) 2017-2022 Toru Niina</li>
</ul>
<p>All rights reserved.</p>
