<h1 id="rapid-yaml">Rapid YAML</h1>
<p><a href="https://github.com/biojppm/rapidyaml/blob/master/LICENSE.txt"><img src="https://img.shields.io/badge/License-MIT-green.svg" alt="MIT Licensed" /></a> <a href="https://github.com/biojppm/rapidyaml/releases"><img src="https://img.shields.io/github/v/release/biojppm/rapidyaml?color=g&amp;include_prereleases&amp;label=release%20&amp;sort=semver" alt="release" /></a> <a href="https://pypi.org/project/rapidyaml/"><img src="https://img.shields.io/pypi/v/rapidyaml?color=g" alt="PyPI" /></a> <a href="https://rapidyaml.docsforge.com/"><img src="https://img.shields.io/badge/docs-docsforge-blue" alt="Docs" /></a> <a href="https://gitter.im/rapidyaml/community"><img src="https://badges.gitter.im/rapidyaml/community.svg" alt="Gitter" /></a></p>
<p><a href="https://github.com/biojppm/rapidyaml/actions"><img src="https://github.com/biojppm/rapidyaml/workflows/test/badge.svg?branch=master" alt="test" /></a> <a href="https://coveralls.io/github/biojppm/rapidyaml"><img src="https://coveralls.io/repos/github/biojppm/rapidyaml/badge.svg?branch=master" alt="Coveralls" /></a> <a href="https://codecov.io/gh/biojppm/rapidyaml"><img src="https://codecov.io/gh/biojppm/rapidyaml/branch/master/graph/badge.svg?branch=master" alt="Codecov" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/alerts/"><img src="https://img.shields.io/lgtm/alerts/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Total alerts" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/context:cpp"><img src="https://img.shields.io/lgtm/grade/cpp/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Language grade: C/C++" /></a></p>
<p>Or ryml, for short. ryml is a C++ library to parse and emit YAML, and do it fast, on everything from x64 to bare-metal chips without operating system. (If you are looking to use your programs with a YAML tree as a configuration tree with override facilities, take a look at <a href="https://github.com/biojppm/c4conf">c4conf</a>).</p>
<p>ryml parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your direct request, after parsing / before emitting. Internally, the data tree representation stores only string views and has no knowledge of types, but of course, every node can have a YAML type tag. ryml makes it easy and fast to read and modify the data tree.</p>
<p>ryml is available as a single header file, or it can be used as a simple library with cmake – both separately (ie build-&gt;install-&gt;<code>find_package()</code>) or together with your project (ie with <code>add_subdirectory()</code>). (See below for examples).</p>
<p>ryml can use custom global and per-tree memory allocators and error handler callbacks, and is exception-agnostic. ryml provides a default implementation for the allocator (using <code>std::malloc()</code>) and error handlers (using using <code>std::abort()</code> is provided, but you can opt out and provide your own memory allocation and eg, exception-throwing callbacks.</p>
<p>ryml does not depend on the STL, ie, it does not use any std container as part of its data structures), but it can serialize and deserialize these containers into the data tree, with the use of optional headers. ryml ships with <a href="https://github.com/biojppm/c4core">c4core</a> a small C++ utilities multiplatform library.</p>
<p>ryml is written in C++11, and compiles cleanly with: * Visual Studio 2015 and later * clang++ 3.9 and later * g++ 4.8 and later * Intel Compiler</p>
<p>ryml is <a href="https://github.com/biojppm/rapidyaml/actions">extensively unit-tested in Linux, Windows and MacOS</a>. The tests cover x64, x86, wasm (emscripten), arm, aarch64, ppc64le and s390x architectures, and include analysing ryml with: * valgrind * clang-tidy * clang sanitizers: * memory * address * undefined behavior * thread * <a href="https://lgtm.com/projects/g/biojppm/rapidyaml">LGTM.com</a></p>
<p>ryml also <a href="https://github.com/biojppm/rapidyaml/issues/193">runs in bare-metal</a>, and <a href="https://github.com/biojppm/c4core/pull/69">RISC-V architectures</a>. Both of these are pending implementation of CI actions for continuous validation, but ryml has been proven to work there.</p>
<p>ryml is <a href="https://pypi.org/project/rapidyaml/">available in Python</a>, and can very easily be compiled to JavaScript through emscripten (see below).</p>
<p>See also <a href="https://github.com/biojppm/rapidyaml/tree/master/changelog">the changelog</a> and <a href="https://github.com/biojppm/rapidyaml/tree/master/ROADMAP.md">the roadmap</a>.</p>
<!-- endpythonreadme -->
<hr />
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#is-it-rapid">Is it rapid?</a>
<ul>
<li><a href="#comparison-with-yaml-cpp">Comparison with yaml-cpp</a></li>
<li><a href="#performance-reading-json">Performance reading JSON</a></li>
<li><a href="#performance-emitting">Performance emitting</a></li>
</ul></li>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#using-ryml-in-your-project">Using ryml in your project</a>
<ul>
<li><a href="#package-managers">Package managers</a></li>
<li><a href="#single-header-file">Single header file</a></li>
<li><a href="#as-a-library">As a library</a></li>
<li><a href="#quickstart-samples">Quickstart samples</a></li>
<li><a href="#cmake-build-settings-for-ryml">CMake build settings for ryml</a>
<ul>
<li><a href="#forcing-ryml-to-use-a-different-c4core-version">Forcing ryml to use a different c4core version</a></li>
</ul></li>
</ul></li>
<li><a href="#other-languages">Other languages</a>
<ul>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#python">Python</a></li>
</ul></li>
<li><a href="#yaml-standard-conformance">YAML standard conformance</a>
<ul>
<li><a href="#test-suite-status">Test suite status</a></li>
</ul></li>
<li><a href="#known-limitations">Known limitations</a></li>
<li><a href="#alternative-libraries">Alternative libraries</a></li>
<li><a href="#license">License</a></li>
</ul>
<hr />
<h2 id="is-it-rapid">Is it rapid?</h2>
<p>You bet! On a i7-6800K CPU <span class="citation" data-cites="3.40GHz">@3.40GHz</span>: * ryml parses YAML at about ~150MB/s on Linux and ~100MB/s on Windows (vs2017). * <strong>ryml parses JSON at about ~450MB/s on Linux</strong>, faster than sajson (didn’t try yet on Windows). * compared against the other existing YAML libraries for C/C++: * ryml is in general between 2 and 3 times faster than <a href="https://github.com/yaml/libyaml">libyaml</a> * ryml is in general between 10 and 70 times faster than <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>, and in some cases as much as 100x and <a href="https://github.com/biojppm/c4core/pull/16#issuecomment-700972614">even 200x</a> faster.</p>
<p><a href="./bm/bm_parse.cpp">Here’s the benchmark</a>. Using different approaches within ryml (in-situ/read-only vs. with/without reuse), a YAML / JSON buffer is repeatedly parsed, and compared against other libraries.</p>
<h3 id="comparison-with-yaml-cpp">Comparison with yaml-cpp</h3>
<p>The first result set is for Windows, and is using a <a href="./bm/cases/appveyor.yml">appveyor.yml config file</a>. A comparison of these results is summarized on the table below:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>appveyor / vs2017 / Release</td>
<td>101.5</td>
<td>5.3</td>
<td>20x / 5.2%</td>
</tr>
<tr class="even">
<td>appveyor / vs2017 / Debug</td>
<td>6.4</td>
<td>0.0844</td>
<td>76x / 1.3%</td>
</tr>
</tbody>
</table>
<p>The next set of results is taken in Linux, comparing g++ 8.2 and clang++ 7.0.1 in parsing a YAML buffer from a <a href="./bm/cases/travis.yml">travis.yml config file</a> or a JSON buffer from a <a href="./bm/cases/compile_commands.json">compile_commands.json file</a>. You can <a href="./bm/results/parse.linux.i7_6800K.md">see the full results here</a>. Summarizing:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>json / clang++ / Release</td>
<td>453.5</td>
<td>15.1</td>
<td>30x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Release</td>
<td>430.5</td>
<td>16.3</td>
<td>26x / 4%</td>
</tr>
<tr class="odd">
<td>json / clang++ / Debug</td>
<td>61.9</td>
<td>1.63</td>
<td>38x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Debug</td>
<td>72.6</td>
<td>1.53</td>
<td>47x / 2%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Release</td>
<td>131.6</td>
<td>8.08</td>
<td>16x / 6%</td>
</tr>
<tr class="even">
<td>travis / g++ / Release</td>
<td>176.4</td>
<td>8.23</td>
<td>21x / 5%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Debug</td>
<td>10.2</td>
<td>1.08</td>
<td>9x / 1%</td>
</tr>
<tr class="even">
<td>travis / g++ / Debug</td>
<td>12.5</td>
<td>1.01</td>
<td>12x / 8%</td>
</tr>
</tbody>
</table>
<p>The 450MB/s read rate for JSON puts ryml squarely in the same ballpark as <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and other fast json readers (<a href="https://lemire.me/blog/2018/05/03/how-fast-can-you-parse-json/">data from here</a>). Even parsing full YAML is at ~150MB/s, which is still in that performance ballpark, albeit at its lower end. This is something to be proud of, as the YAML specification is much more complex than JSON: <a href="https://www.arp242.net/yaml-config.html#its-pretty-complex">23449 vs 1969 words</a>.</p>
<h3 id="performance-reading-json">Performance reading JSON</h3>
<p>So how does ryml compare against other JSON readers? Well, it’s one of the fastest!</p>
<p>The benchmark is the <a href="./bm/parse.cpp">same as above</a>, and it is reading the <a href="./bm/cases/compile_commands.json">compile_commands.json</a>, The <code>_arena</code> suffix notes parsing a read-only buffer (so buffer copies are performed), while the <code>_inplace</code> suffix means that the source buffer can be parsed in place. The <code>_reuse</code> means the data tree and/or parser are reused on each benchmark repeat.</p>
<p>Here’s what we get with g++ 8.2:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Benchmark</th>
<th style="text-align: right;">Release,MB/s</th>
<th style="text-align: right;">Debug,MB/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">rapidjson_arena</td>
<td style="text-align: right;">509.9</td>
<td style="text-align: right;">43.4</td>
</tr>
<tr class="even">
<td style="text-align: left;">rapidjson_inplace</td>
<td style="text-align: right;">1329.4</td>
<td style="text-align: right;">68.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sajson_inplace</td>
<td style="text-align: right;">434.2</td>
<td style="text-align: right;">176.5</td>
</tr>
<tr class="even">
<td style="text-align: left;">sajson_arena</td>
<td style="text-align: right;">430.7</td>
<td style="text-align: right;">175.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">jsoncpp_arena</td>
<td style="text-align: right;">183.6</td>
<td style="text-align: right;">? 187.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">nlohmann_json_arena</td>
<td style="text-align: right;">115.8</td>
<td style="text-align: right;">21.5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">yamlcpp_arena</td>
<td style="text-align: right;">16.6</td>
<td style="text-align: right;">1.6</td>
</tr>
<tr class="even">
<td style="text-align: left;">libyaml_arena</td>
<td style="text-align: right;">113.9</td>
<td style="text-align: right;">35.7</td>
</tr>
<tr class="odd">
<td style="text-align: left;">libyaml_arena_reuse</td>
<td style="text-align: right;">114.6</td>
<td style="text-align: right;">35.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">ryml_arena</td>
<td style="text-align: right;">388.6</td>
<td style="text-align: right;">36.9</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ryml_inplace</td>
<td style="text-align: right;">393.7</td>
<td style="text-align: right;">36.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">ryml_arena_reuse</td>
<td style="text-align: right;">446.2</td>
<td style="text-align: right;">74.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ryml_inplace_reuse</td>
<td style="text-align: right;">457.1</td>
<td style="text-align: right;">74.9</td>
</tr>
</tbody>
</table>
<p>You can verify that (at least for this test) ryml beats most json parsers at their own game, with the only exception of <a href="https://github.com/Tencent/rapidjson">rapidjson</a>. And actually, in Debug, <a href="https://github.com/Tencent/rapidjson">rapidjson</a> is slower than ryml, and <a href="https://github.com/chadaustin/sajson">sajson</a> manages to be faster (but not sure about jsoncpp; need to scrutinize there the suspicious fact that the Debug result is faster than the Release result).</p>
<h3 id="performance-emitting">Performance emitting</h3>
<p><a href="bm/bm_emit.cpp">Emitting benchmarks</a> also show similar speedups from the existing libraries, also anecdotally reported by some users <a href="https://github.com/biojppm/rapidyaml/issues/28#issue-553855608">(eg, here’s a user reporting 25x speedup from yaml-cpp)</a>. Also, in some cases (eg, block folded multiline scalars), the speedup is as high as 200x (eg, 7.3MB/s -&gt; 1.416MG/s).</p>
<h3 id="ci-results-and-request-for-files">CI results and request for files</h3>
<p>While a more effective way of showing the benchmark results is not available yet, you can browse through the <a href="https://github.com/biojppm/rapidyaml/actions/workflows/benchmarks.yml">runs of the benchmark workflow in the CI</a> to scroll through the results for yourself.</p>
<p>Also, if you have a case where ryml behaves very nicely or not as nicely as claimed above, we would definitely like to see it! Please submit a pull request adding the file to <a href="bm/cases">bm/cases</a>, or just send us the files.</p>
<hr />
<h2 id="quick-start">Quick start</h2>
<p>If you’re wondering whether ryml’s speed comes at a usage cost, you need not: with ryml, you can have your cake and eat it too. Being rapid is definitely NOT the same as being unpractical, so ryml was written with easy AND efficient usage in mind, and comes with a two level API for accessing and traversing the data tree.</p>
<p>The following snippet is a quick overview taken from <a href="samples/quickstart.cpp">the quickstart sample</a>. After cloning ryml (don’t forget the <code>--recursive</code> flag for git), you can very easily build and run this executable using any of the build samples, eg the <a href="samples/add_subdirectory/"><code>add_subdirectory()</code> sample</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Parse YAML code in place, potentially mutating the buffer.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// It is also possible to:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//   - parse a read-only buffer using parse_in_arena()</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">//   - reuse an existing tree (advised)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   - reuse an existing parser (advised)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> yml_buf<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;{foo: 1, bar: [2, 3], john: doe}&quot;</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>Tree tree <span class="op">=</span> ryml<span class="op">::</span>parse_in_place<span class="op">(</span>ryml<span class="op">::</span>substr<span class="op">(</span>yml_buf<span class="op">));</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: it will always be significantly faster to use mutable</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">// buffers and reuse tree+parser.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Below you will find samples that show how to achieve reuse; but</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">// please note that for brevity and clarity, many of the examples</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">// here are parsing immutable buffers, and not reusing tree or</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">// parser.</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">// API overview</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co">// ryml has a two-level API:</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">// The lower level index API is based on the indices of nodes,</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">// where the node&#39;s id is the node&#39;s position in the tree&#39;s data</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">// array. This API is very efficient, but somewhat difficult to use:</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> root_id <span class="op">=</span> tree<span class="op">.</span>root_id<span class="op">();</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> bar_id <span class="op">=</span> tree<span class="op">.</span>find_child<span class="op">(</span>root_id<span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">);</span> <span class="co">// need to get the index right</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">.</span>is_map<span class="op">(</span>root_id<span class="op">));</span> <span class="co">// all of the index methods are in the tree</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">.</span>is_seq<span class="op">(</span>bar_id<span class="op">));</span>  <span class="co">// ... and receive the subject index</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">// The node API is a lightweight abstraction sitting on top of the</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co">// index API, but offering a much more convenient interaction:</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>NodeRef root <span class="op">=</span> tree<span class="op">.</span>rootref<span class="op">();</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>NodeRef bar <span class="op">=</span> tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">];</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>is_map<span class="op">());</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>bar<span class="op">.</span>is_seq<span class="op">());</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">// NodeRef is a lightweight handle to the tree and associated id:</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>tree<span class="op">()</span> <span class="op">==</span> <span class="op">&amp;</span>tree<span class="op">);</span> <span class="co">// NodeRef points at its tree, WITHOUT refcount</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>id<span class="op">()</span> <span class="op">==</span> root_id<span class="op">);</span> <span class="co">// NodeRef&#39;s id is the index of the node</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>bar<span class="op">.</span>id<span class="op">()</span> <span class="op">==</span> bar_id<span class="op">);</span>   <span class="co">// NodeRef&#39;s id is the index of the node</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co">// The node API translates very cleanly to the index API, so most</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co">// of the code examples below are using the node API.</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="co">// One significant point of the node API is that it holds a raw</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="co">// pointer to the tree. Care must be taken to ensure the lifetimes</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="co">// match, so that a node will never access the tree after the tree</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co">// went out of scope.</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="co">// To read the parsed tree</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co">// Node::operator[] does a lookup, is O(num_children[node]).</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co">// maps use string keys, seqs use integral keys.</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>is_keyval<span class="op">());</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;1&quot;</span><span class="op">);</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>is_seq<span class="op">());</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>has_key<span class="op">());</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;bar&quot;</span><span class="op">);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;2&quot;</span><span class="op">);</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;3&quot;</span><span class="op">);</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;doe&quot;</span><span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="co">// An integral key is the position of the child within its parent,</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="co">// so even maps can also use int keys, if the key position is</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="co">// known.</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">0</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">1</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">2</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="co">// Tree::operator[](int) searches a root child by its position.</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">0</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>id<span class="op">());</span>  <span class="co">// 0: first child of root</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">1</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>id<span class="op">());</span>  <span class="co">// 1: first child of root</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="dv">2</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> tree<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>id<span class="op">());</span> <span class="co">// 2: first child of root</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="co">// NodeRef::operator[](int) searches a node child by its position</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a><span class="co">// on __the node__&#39;s children list:</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>bar<span class="op">[</span><span class="dv">0</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;2&quot;</span><span class="op">);</span> <span class="co">// 0 means first child of bar</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>bar<span class="op">[</span><span class="dv">1</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;3&quot;</span><span class="op">);</span> <span class="co">// 1 means second child of bar</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="co">// NodeRef::operator[](string):</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="co">// A string key is the key of the node: lookup is by name. So it</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="co">// is only available for maps, and it is NOT available for seqs,</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="co">// since seq members do not have keys.</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;bar&quot;</span><span class="op">);</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;john&quot;</span><span class="op">);</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>bar<span class="op">.</span>is_seq<span class="op">());</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co">// CHECK(bar[&quot;BOOM!&quot;].is_seed()); // error, seqs do not have key lookup</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that maps can also use index keys as well as string keys:</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">[</span><span class="dv">0</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">[</span><span class="dv">1</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">[</span><span class="dv">2</span><span class="op">].</span>id<span class="op">());</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="co">// Please note that since a ryml tree uses indexed linked lists for storing</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a><span class="co">// children, the complexity of `Tree::operator[csubstr]` and</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="co">// `Tree::operator[size_t]` is linear on the number of root children. If you use</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="co">// it with a large tree where the root has many children, you may get a</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="co">// performance hit. To avoid this hit, you can create your own accelerator</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="co">// structure. For example, before doing a lookup, do a single traverse at the</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="co">// root level to fill an `std::map&lt;csubstr,size_t&gt;` mapping key names to node</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co">// indices; with a node index, a lookup (via `Tree::get()`) is O(1), so this way</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="co">// you can get O(log n) lookup from a key.</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a><span class="co">// As for `NodeRef`, the difference from `NodeRef::operator[]`</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="co">// to `Tree::operator[]` is that the latter refers to the root node, whereas</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a><span class="co">// the former can be invoked on any node. But the lookup process is the same for</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="co">// both and their algorithmic complexity is the same: they are both linear in</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="co">// the number of direct children; but depending on the data, that number may</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="co">// be very different from one to another.</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="co">// Hierarchy:</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>    ryml<span class="op">::</span>NodeRef foo <span class="op">=</span> root<span class="op">.</span>first_child<span class="op">();</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    ryml<span class="op">::</span>NodeRef john <span class="op">=</span> root<span class="op">.</span>last_child<span class="op">();</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>tree<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">6</span><span class="op">);</span> <span class="co">// O(1) number of nodes in the tree</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// O(num_children[root])</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>num_siblings<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// O(num_children[parent(foo)])</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>parent<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">.</span>id<span class="op">());</span> <span class="co">// parent() is O(1)</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>root<span class="op">.</span>first_child<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>id<span class="op">());</span> <span class="co">// first_child() is O(1)</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>root<span class="op">.</span>last_child<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>id<span class="op">());</span> <span class="co">// last_child() is O(1)</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>john<span class="op">.</span>first_sibling<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> foo<span class="op">.</span>id<span class="op">());</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>last_sibling<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> john<span class="op">.</span>id<span class="op">());</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prev_sibling(), next_sibling(): (both are O(1))</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>num_siblings<span class="op">()</span> <span class="op">==</span> root<span class="op">.</span>num_children<span class="op">());</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>prev_sibling<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> ryml<span class="op">::</span>NONE<span class="op">);</span> <span class="co">// foo is the first_child()</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>next_sibling<span class="op">().</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;bar&quot;</span><span class="op">);</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>next_sibling<span class="op">().</span>next_sibling<span class="op">().</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;john&quot;</span><span class="op">);</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo<span class="op">.</span>next_sibling<span class="op">().</span>next_sibling<span class="op">().</span>next_sibling<span class="op">().</span>id<span class="op">()</span> <span class="op">==</span> ryml<span class="op">::</span>NONE<span class="op">);</span> <span class="co">// john is the last_child()</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a><span class="co">// Iterating:</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>    ryml<span class="op">::</span>csubstr expected_keys<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;bar&quot;</span><span class="op">,</span> <span class="st">&quot;john&quot;</span><span class="op">};</span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterate children using the high-level node API:</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>ryml<span class="op">::</span>NodeRef <span class="at">const</span><span class="op">&amp;</span> child <span class="op">:</span> root<span class="op">.</span>children<span class="op">())</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>            CHECK<span class="op">(</span>child<span class="op">.</span>key<span class="op">()</span> <span class="op">==</span> expected_keys<span class="op">[</span>count<span class="op">++]);</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterate siblings using the high-level node API:</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>ryml<span class="op">::</span>NodeRef <span class="at">const</span><span class="op">&amp;</span> child <span class="op">:</span> root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>siblings<span class="op">())</span></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>            CHECK<span class="op">(</span>child<span class="op">.</span>key<span class="op">()</span> <span class="op">==</span> expected_keys<span class="op">[</span>count<span class="op">++]);</span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterate children using the lower-level tree index API:</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> child_id <span class="op">=</span> tree<span class="op">.</span>first_child<span class="op">(</span>root_id<span class="op">);</span> child_id <span class="op">!=</span> ryml<span class="op">::</span>NONE<span class="op">;</span> child_id <span class="op">=</span> tree<span class="op">.</span>next_sibling<span class="op">(</span>child_id<span class="op">))</span></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>            CHECK<span class="op">(</span>tree<span class="op">.</span>key<span class="op">(</span>child_id<span class="op">)</span> <span class="op">==</span> expected_keys<span class="op">[</span>count<span class="op">++]);</span></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>    <span class="co">// iterate siblings using the lower-level tree index API:</span></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (notice the only difference from above is in the loop</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>    <span class="co">// preamble, which calls tree.first_sibling(bar_id) instead of</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>    <span class="co">// tree.first_child(root_id))</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> child_id <span class="op">=</span> tree<span class="op">.</span>first_sibling<span class="op">(</span>bar_id<span class="op">);</span> child_id <span class="op">!=</span> ryml<span class="op">::</span>NONE<span class="op">;</span> child_id <span class="op">=</span> tree<span class="op">.</span>next_sibling<span class="op">(</span>child_id<span class="op">))</span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>            CHECK<span class="op">(</span>tree<span class="op">.</span>key<span class="op">(</span>child_id<span class="op">)</span> <span class="op">==</span> expected_keys<span class="op">[</span>count<span class="op">++]);</span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a><span class="co">// Gotchas:</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>has_val<span class="op">());</span>          <span class="co">// seq is a container, so no val</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">].</span>has_key<span class="op">());</span>       <span class="co">// belongs to a seq, so no key</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>tree<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">].</span>has_key<span class="op">());</span>       <span class="co">// belongs to a seq, so no key</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a><span class="co">//CHECK(tree[&quot;bar&quot;].val() == BOOM!);    // ... so attempting to get a val is undefined behavior</span></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a><span class="co">//CHECK(tree[&quot;bar&quot;][0].key() == BOOM!); // ... so attempting to get a key is undefined behavior</span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a><span class="co">//CHECK(tree[&quot;bar&quot;][1].key() == BOOM!); // ... so attempting to get a key is undefined behavior</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a><span class="co">// Deserializing: use operator&gt;&gt;</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> bar0 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> bar1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>john<span class="op">;</span></span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>    root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">]</span> <span class="op">&gt;&gt;</span> foo<span class="op">;</span></span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>    root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;&gt;</span> bar0<span class="op">;</span></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>    root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;&gt;</span> bar1<span class="op">;</span></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>    root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">]</span> <span class="op">&gt;&gt;</span> john<span class="op">;</span> <span class="co">// requires from_chars(std::string). see serialization samples below.</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>foo <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>bar0 <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>bar1 <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>    CHECK<span class="op">(</span>john <span class="op">==</span> <span class="st">&quot;doe&quot;</span><span class="op">);</span></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a><span class="co">// Modifying existing nodes: operator&lt;&lt; vs operator=</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a><span class="co">// operator= assigns an existing string to the receiving node.</span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a><span class="co">// This pointer will be in effect until the tree goes out of scope</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a><span class="co">// so beware to only assign from strings outliving the tree.</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;says you&quot;</span><span class="op">;</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;-2&quot;</span><span class="op">;</span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;-3&quot;</span><span class="op">;</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;ron&quot;</span><span class="op">;</span></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a><span class="co">// Now the tree is _pointing_ at the memory of the strings above.</span></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a><span class="co">// That is OK because those are static strings and will outlive</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a><span class="co">// the tree.</span></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;says you&quot;</span><span class="op">);</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;-2&quot;</span><span class="op">);</span></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;-3&quot;</span><span class="op">);</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;ron&quot;</span><span class="op">);</span></span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a><span class="co">// WATCHOUT: do not assign from temporary objects:</span></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="co">// {</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a><span class="co">//     std::string crash(&quot;will dangle&quot;);</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a><span class="co">//     root[&quot;john&quot;] = ryml::to_csubstr(crash);</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a><span class="co">// CHECK(root[&quot;john&quot;] == &quot;dangling&quot;); // CRASH! the string was deallocated</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a><span class="co">// operator&lt;&lt; first serializes the input to the tree&#39;s arena, then</span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a><span class="co">// assigns the serialized string to the receiving node. This avoids</span></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a><span class="co">// constraints with the lifetime, since the arena lives with the tree.</span></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">().</span>empty<span class="op">());</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;says who&quot;</span><span class="op">;</span>  <span class="co">// requires to_chars(). see serialization samples below.</span></span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;deere&quot;</span><span class="op">;</span></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;foo&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;says who&quot;</span><span class="op">);</span></span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">0</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;20&quot;</span><span class="op">);</span></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;30&quot;</span><span class="op">);</span></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;deere&quot;</span><span class="op">);</span></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;says who2030deere&quot;</span><span class="op">);</span> <span class="co">// the result of serializations to the tree arena</span></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a><span class="co">// using operator&lt;&lt; instead of operator=, the crash above is avoided:</span></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>ok<span class="op">(</span><span class="st">&quot;in_scope&quot;</span><span class="op">);</span></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>    <span class="co">// root[&quot;john&quot;] = ryml::to_csubstr(ok); // don&#39;t, will dangle</span></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>    root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">]</span> <span class="op">&lt;&lt;</span> ryml<span class="op">::</span>to_csubstr<span class="op">(</span>ok<span class="op">);</span> <span class="co">// OK, copy to the tree&#39;s arena</span></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;john&quot;</span><span class="op">]</span> <span class="op">==</span> <span class="st">&quot;in_scope&quot;</span><span class="op">);</span> <span class="co">// OK!</span></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;says who2030deerein_scope&quot;</span><span class="op">);</span> <span class="co">// the result of serializations to the tree arena</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a><span class="co">// Adding new nodes:</span></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a><span class="co">// adding a keyval node to a map:</span></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;newkeyval&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;shiny and new&quot;</span><span class="op">;</span> <span class="co">// using these strings</span></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>root<span class="op">.</span>append_child<span class="op">()</span> <span class="op">&lt;&lt;</span> ryml<span class="op">::</span>key<span class="op">(</span><span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;shiny and new (serialized)&quot;</span><span class="op">;</span> <span class="co">// serializes and assigns the serialization</span></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newkeyval&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;newkeyval&quot;</span><span class="op">);</span></span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newkeyval&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;shiny and new&quot;</span><span class="op">);</span></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">].</span>key<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">);</span></span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;shiny and new (serialized)&quot;</span><span class="op">);</span></span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span> <span class="op">!</span> root<span class="op">[</span><span class="st">&quot;newkeyval&quot;</span><span class="op">].</span>key<span class="op">().</span>is_sub<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()));</span> <span class="co">// it&#39;s using directly the static string above</span></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span> <span class="op">!</span> root<span class="op">[</span><span class="st">&quot;newkeyval&quot;</span><span class="op">].</span>val<span class="op">().</span>is_sub<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()));</span> <span class="co">// it&#39;s using directly the static string above</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>   root<span class="op">[</span><span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">].</span>key<span class="op">().</span>is_sub<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()));</span> <span class="co">// it&#39;s using a serialization of the string above</span></span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>   root<span class="op">[</span><span class="st">&quot;newkeyval (serialized)&quot;</span><span class="op">].</span>val<span class="op">().</span>is_sub<span class="op">(</span>tree<span class="op">.</span>arena<span class="op">()));</span> <span class="co">// it&#39;s using a serialization of the string above</span></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a><span class="co">// adding a val node to a seq:</span></span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;oh so nice&quot;</span><span class="op">;</span></span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">3</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;oh so nice (serialized)&quot;</span><span class="op">;</span></span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">2</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;oh so nice&quot;</span><span class="op">);</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">3</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;oh so nice (serialized)&quot;</span><span class="op">);</span></span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a><span class="co">// adding a seq node:</span></span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;newseq&quot;</span><span class="op">]</span> <span class="op">|=</span> ryml<span class="op">::</span>SEQ<span class="op">;</span></span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a>root<span class="op">.</span>append_child<span class="op">()</span> <span class="op">&lt;&lt;</span> ryml<span class="op">::</span>key<span class="op">(</span><span class="st">&quot;newseq (serialized)&quot;</span><span class="op">)</span> <span class="op">|=</span> ryml<span class="op">::</span>SEQ<span class="op">;</span></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newseq&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newseq (serialized)&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a><span class="co">// adding a map node:</span></span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a>root<span class="op">[</span><span class="st">&quot;newmap&quot;</span><span class="op">]</span> <span class="op">|=</span> ryml<span class="op">::</span>MAP<span class="op">;</span></span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a>root<span class="op">.</span>append_child<span class="op">()</span> <span class="op">&lt;&lt;</span> ryml<span class="op">::</span>key<span class="op">(</span><span class="st">&quot;newmap (serialized)&quot;</span><span class="op">)</span> <span class="op">|=</span> ryml<span class="op">::</span>SEQ<span class="op">;</span></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">9</span><span class="op">);</span></span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newmap&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;newmap (serialized)&quot;</span><span class="op">].</span>num_children<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a><span class="co">// operator[] does not mutate the tree until the returned node is</span></span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a><span class="co">// written to.</span></span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a><span class="co">// Until such time, the NodeRef object keeps in itself the required</span></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a><span class="co">// information to write to the proper place in the tree. This is</span></span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a><span class="co">// called being in a &quot;seed&quot; state.</span></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a><span class="co">// This means that passing a key/index which does not exist will</span></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a><span class="co">// not mutate the tree, but will instead store (in the node) the</span></span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a><span class="co">// proper place of the tree to do so if and when it is required.</span></span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a significant difference from eg, the behavior of</span></span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a><span class="co">// std::map, which mutates the map immediately within the call to</span></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a><span class="co">// operator[].</span></span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>root<span class="op">.</span>has_child<span class="op">(</span><span class="st">&quot;I am nobody&quot;</span><span class="op">));</span></span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>NodeRef nobody <span class="op">=</span> root<span class="op">[</span><span class="st">&quot;I am nobody&quot;</span><span class="op">];</span></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>nobody<span class="op">.</span>valid<span class="op">());</span>   <span class="co">// points at the tree, and a specific place in the tree</span></span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>nobody<span class="op">.</span>is_seed<span class="op">());</span> <span class="co">// ... but nothing is there yet.</span></span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>root<span class="op">.</span>has_child<span class="op">(</span><span class="st">&quot;I am nobody&quot;</span><span class="op">));</span> <span class="co">// same as above</span></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>NodeRef somebody <span class="op">=</span> root<span class="op">[</span><span class="st">&quot;I am somebody&quot;</span><span class="op">];</span></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>root<span class="op">.</span>has_child<span class="op">(</span><span class="st">&quot;I am somebody&quot;</span><span class="op">));</span> <span class="co">// same as above</span></span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>somebody<span class="op">.</span>valid<span class="op">());</span></span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>somebody<span class="op">.</span>is_seed<span class="op">());</span> <span class="co">// same as above</span></span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a>somebody <span class="op">=</span> <span class="st">&quot;indeed&quot;</span><span class="op">;</span>  <span class="co">// this will commit to the tree, mutating at the proper place</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>somebody<span class="op">.</span>valid<span class="op">());</span></span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(!</span>somebody<span class="op">.</span>is_seed<span class="op">());</span> <span class="co">// now the tree has this node, and it is no longer a seed</span></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">.</span>has_child<span class="op">(</span><span class="st">&quot;I am somebody&quot;</span><span class="op">));</span></span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>root<span class="op">[</span><span class="st">&quot;I am somebody&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;indeed&quot;</span><span class="op">);</span></span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a><span class="co">// Emitting:</span></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a><span class="co">// emit to a FILE*</span></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span><span class="ex">emit</span><span class="op">(</span>tree<span class="op">,</span> stdout<span class="op">);</span></span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a><span class="co">// emit to a stream</span></span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stringstream<span class="op"> </span>ss<span class="op">;</span></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a>ss <span class="op">&lt;&lt;</span> tree<span class="op">;</span></span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>stream_result <span class="op">=</span> ss<span class="op">.</span>str<span class="op">();</span></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a><span class="co">// emit to a buffer:</span></span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>str_result <span class="op">=</span> ryml<span class="op">::</span>emitrs<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>tree<span class="op">);</span></span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a><span class="co">// can emit to any given buffer:</span></span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> buf<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>csubstr buf_result <span class="op">=</span> ryml<span class="op">::</span><span class="ex">emit</span><span class="op">(</span>tree<span class="op">,</span> buf<span class="op">);</span></span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a><span class="co">// now check</span></span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>csubstr expected_result <span class="op">=</span> <span class="st">R&quot;(foo: says who</span></span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a><span class="st">bar:</span></span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a><span class="st">- 20</span></span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a><span class="st">- 30</span></span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a><span class="st">- oh so nice</span></span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a><span class="st">- oh so nice (serialized)</span></span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a><span class="st">john: in_scope</span></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a><span class="st">newkeyval: shiny and new</span></span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a><span class="st">newkeyval (serialized): shiny and new (serialized)</span></span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a><span class="st">newseq: []</span></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a><span class="st">newseq (serialized): []</span></span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a><span class="st">newmap: {}</span></span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a><span class="st">newmap (serialized): []</span></span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a><span class="st">I am somebody: indeed</span></span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a><span class="st">)&quot;</span><span class="op">;</span></span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>buf_result <span class="op">==</span> expected_result<span class="op">);</span></span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>str_result <span class="op">==</span> expected_result<span class="op">);</span></span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>stream_result <span class="op">==</span> expected_result<span class="op">);</span></span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a><span class="co">// There are many possibilities to emit to buffer;</span></span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a><span class="co">// please look at the emit sample functions below.</span></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a><span class="co">// Dealing with UTF8</span></span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>Tree langs <span class="op">=</span> ryml<span class="op">::</span>parse_in_arena<span class="op">(</span><span class="st">R&quot;(</span></span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a><span class="st">en: Planet (Gas)</span></span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a><span class="st">fr: Planète (Gazeuse)</span></span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a><span class="st">ru: Планета (Газ)</span></span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a><span class="st">ja: 惑星（ガス）</span></span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a><span class="st">zh: 行星（气体）</span></span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a><span class="st">decode this: &quot;\u263A \xE2\x98\xBA&quot;</span></span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a><span class="st">and this as well: &quot;\u2705 \U0001D11E&quot;</span></span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a><span class="st">)&quot;</span><span class="op">);</span></span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a><span class="co">// in-place UTF8 just works:</span></span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;en&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Planet (Gas)&quot;</span><span class="op">);</span></span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;fr&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Planète (Gazeuse)&quot;</span><span class="op">);</span></span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;ru&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Планета (Газ)&quot;</span><span class="op">);</span></span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;ja&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;惑星（ガス）&quot;</span><span class="op">);</span></span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;zh&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;行星（气体）&quot;</span><span class="op">);</span></span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a><span class="co">// and \x \u \U codepoints are decoded (but only when</span></span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a><span class="co">// they appear inside double-quoted strings):</span></span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;decode this&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;☺ ☺&quot;</span><span class="op">);</span></span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>langs<span class="op">[</span><span class="st">&quot;and this as well&quot;</span><span class="op">].</span>val<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;✅ 𝄞&quot;</span><span class="op">);</span></span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a><span class="co">// Getting the location of nodes in the source:</span></span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>Parser parser<span class="op">;</span></span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>Tree tree2 <span class="op">=</span> parser<span class="op">.</span>parse_in_arena<span class="op">(</span><span class="st">&quot;expected.yml&quot;</span><span class="op">,</span> expected_result<span class="op">);</span></span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a>ryml<span class="op">::</span>Location loc <span class="op">=</span> parser<span class="op">.</span>location<span class="op">(</span>tree2<span class="op">[</span><span class="st">&quot;bar&quot;</span><span class="op">][</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>parser<span class="op">.</span>location_contents<span class="op">(</span>loc<span class="op">).</span>begins_with<span class="op">(</span><span class="st">&quot;30&quot;</span><span class="op">));</span></span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>loc<span class="op">.</span>line <span class="op">==</span> <span class="dv">3</span><span class="bu">u</span><span class="op">);</span></span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a>CHECK<span class="op">(</span>loc<span class="op">.</span>col <span class="op">==</span> <span class="dv">4</span><span class="bu">u</span><span class="op">);</span></span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a><span class="co">// For further details in location tracking, refer to the sample function.</span></span></code></pre></div>
<p>The <a href="./samples/quickstart.cpp">quickstart.cpp sample</a> (from which the above overview was taken) has many more detailed examples, and should be your first port of call to find out any particular point about ryml’s API. It is tested in the CI, and thus has the correct behavior. There you can find the following subjects being addressed:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sample_substr<span class="op">();</span>               <span class="co">///&lt; about ryml&#39;s string views (from c4core)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>sample_parse_file<span class="op">();</span>           <span class="co">///&lt; ready-to-go example of parsing a file from disk</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>sample_parse_in_place<span class="op">();</span>       <span class="co">///&lt; parse a mutable YAML source buffer</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>sample_parse_in_arena<span class="op">();</span>       <span class="co">///&lt; parse a read-only YAML source buffer</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>sample_parse_reuse_tree<span class="op">();</span>     <span class="co">///&lt; parse into an existing tree, maybe into a node</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>sample_parse_reuse_parser<span class="op">();</span>   <span class="co">///&lt; reuse an existing parser</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>sample_parse_reuse_tree_and_parser<span class="op">();</span> <span class="co">///&lt; how to reuse existing trees and parsers</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>sample_iterate_trees<span class="op">();</span>        <span class="co">///&lt; visit individual nodes and iterate through trees</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>sample_create_trees<span class="op">();</span>         <span class="co">///&lt; programatically create trees</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>sample_tree_arena<span class="op">();</span>           <span class="co">///&lt; interact with the tree&#39;s serialization arena</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>sample_fundamental_types<span class="op">();</span>    <span class="co">///&lt; serialize/deserialize fundamental types</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>sample_formatting<span class="op">();</span>           <span class="co">///&lt; control formatting when serializing/deserializing</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>sample_base64<span class="op">();</span>               <span class="co">///&lt; encode/decode base64</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>sample_user_scalar_types<span class="op">();</span>    <span class="co">///&lt; serialize/deserialize scalar (leaf/string) types</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>sample_user_container_types<span class="op">();</span> <span class="co">///&lt; serialize/deserialize container (map or seq) types</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>sample_std_types<span class="op">();</span>            <span class="co">///&lt; serialize/deserialize STL containers</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>sample_emit_to_container<span class="op">();</span>    <span class="co">///&lt; emit to memory, eg a string or vector-like container</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>sample_emit_to_stream<span class="op">();</span>       <span class="co">///&lt; emit to a stream, eg std::ostream</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>sample_emit_to_file<span class="op">();</span>         <span class="co">///&lt; emit to a FILE*</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>sample_emit_nested_node<span class="op">();</span>     <span class="co">///&lt; pick a nested node as the root when emitting</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>sample_json<span class="op">();</span>                 <span class="co">///&lt; JSON parsing and emitting: notes and constraints</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>sample_anchors_and_aliases<span class="op">();</span>  <span class="co">///&lt; deal with YAML anchors and aliases</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>sample_tags<span class="op">();</span>                 <span class="co">///&lt; deal with YAML type tags</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>sample_docs<span class="op">();</span>                 <span class="co">///&lt; deal with YAML docs</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>sample_error_handler<span class="op">();</span>        <span class="co">///&lt; set a custom error handler</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>sample_global_allocator<span class="op">();</span>     <span class="co">///&lt; set a global allocator for ryml</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>sample_per_tree_allocator<span class="op">();</span>   <span class="co">///&lt; set per-tree allocators</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>sample_location_tracking<span class="op">();</span>    <span class="co">///&lt; track node locations in the parsed source tree</span></span></code></pre></div>
<hr />
<h2 id="using-ryml-in-your-project">Using ryml in your project</h2>
<h3 id="package-managers">Package managers</h3>
<p>If you opt for package managers, here’s where ryml is available so far (thanks to all the contributors!): * <a href="https://vcpkg.io/en/packages.html">vcpkg</a>: <code>vcpkg install ryml</code> * Arch Linux/Manjaro: * <a href="https://aur.archlinux.org/packages/rapidyaml-git/">rapidyaml-git (AUR)</a> * <a href="https://aur.archlinux.org/packages/python-rapidyaml-git/">python-rapidyaml-git (AUR)</a> * <a href="https://pypi.org/project/rapidyaml/">PyPI</a></p>
<p>Although package managers are very useful for quickly getting up to speed, the advised way is still to bring ryml as a submodule of your project, building both together. This makes it easy to track any upstream changes in ryml. Also, ryml is small and quick to build, so there’s not much of a cost for building it with your project.</p>
<h3 id="single-header-file">Single header file</h3>
<p>ryml is provided chiefly as a cmake library project, but it can also be used as a single header file, and there is a <a href="./tools/amalgamate.py">tool to amalgamate</a> the code into a single header file. The amalgamated header file is provided with each release, but you can also generate a customized file suiting your particular needs (or commit):</p>
<pre class="console"><code>[user@host rapidyaml]$ python tools/amalgamate.py -h
usage: amalgamate.py [-h] [--c4core | --no-c4core] [--fastfloat | --no-fastfloat] [--stl | --no-stl] [output]

positional arguments:
  output          output file. defaults to stdout

optional arguments:
  -h, --help      show this help message and exit
  --c4core        amalgamate c4core together with ryml. this is the default.
  --no-c4core     amalgamate c4core together with ryml. the default is --c4core.
  --fastfloat     enable fastfloat library. this is the default.
  --no-fastfloat  enable fastfloat library. the default is --fastfloat.
  --stl           enable stl interop. this is the default.
  --no-stl        enable stl interop. the default is --stl.</code></pre>
<p>The amalgamated header file contains all the function declarations and definitions. To use it in the project, <code>#include</code> the header at will in any header or source file in the project, but in one source file, and only in that one source file, <code>#define</code> the macro <code>RYML_SINGLE_HDR_DEFINE_NOW</code> <strong>before including the header</strong>. This will enable the function definitions. For example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// foo.h</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ryml_all.hpp&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">// foo.cpp</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ensure that foo.h is not included before this define!</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define RYML_SINGLE_HDR_DEFINE_NOW</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ryml_all.hpp&gt;</span></span></code></pre></div>
<p>If you wish to package the single header into a shared library, then you will need to define the preprocessor symbol <code>RYML_SHARED</code> during compilation.</p>
<h3 id="as-a-library">As a library</h3>
<p>The single header file is a good approach to quickly try the library, but if you wish to make good use of CMake and its tooling ecosystem, (and get better compile times), then ryml has you covered.</p>
<p>As with any other cmake library, you have the option to integrate ryml into your project’s build setup, thereby building ryml together with your project, or – prior to configuring your project – you can have ryml installed either manually or through package managers.</p>
<p>Currently <a href="https://cmake.org/">cmake</a> is required to build ryml; we recommend a recent cmake version, at least 3.13.</p>
<p>Note that ryml uses submodules. Take care to use the <code>--recursive</code> flag when cloning the repo, to ensure ryml’s submodules are checked out as well:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone <span class="at">--recursive</span> https://github.com/biojppm/rapidyaml</span></code></pre></div>
<p>If you omit <code>--recursive</code>, after cloning you will have to do <code>git submodule init</code> and <code>git submodule update</code> to ensure ryml’s submodules are checked out.</p>
<h3 id="quickstart-samples">Quickstart samples</h3>
<p>These samples show different ways of getting ryml into your application. All the samples use <a href="./samples/quickstart.cpp">the same quickstart executable source</a>, but are built in different ways, showing several alternatives to integrate ryml into your project. We also encourage you to refer to the <a href="./samples/quickstart.cpp">quickstart source</a> itself, which extensively covers most of the functionality that you may want out of ryml.</p>
<p>Each sample brings a <code>run.sh</code> script with the sequence of commands required to successfully build and run the application (this is a bash script and runs in Linux and MacOS, but it is also possible to run in Windows via Git Bash or the WSL). Click on the links below to find out more about each sample:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 27%" />
<col style="width: 35%" />
<col style="width: 18%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Sample name</th>
<th>ryml is part of build?</th>
<th style="text-align: left;">cmake file</th>
<th style="text-align: left;">commands</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="./samples/singleheader"><code>singleheader</code></a></td>
<td><strong>yes</strong><br>ryml brought as a single header file,<br>not as a library</td>
<td style="text-align: left;"><a href="./samples/singleheader/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/singleheader/run.sh"><code>run.sh</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="./samples/singleheaderlib"><code>singleheaderlib</code></a></td>
<td><strong>yes</strong><br>ryml brought as a library<br>but from the single header file</td>
<td style="text-align: left;"><a href="./samples/singleheaderlib/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/singleheaderlib/run_shared.sh"><code>run_shared.sh</code> (shared library)</a><br> <a href="./samples/singleheaderlib/run_static.sh"><code>run_static.sh</code> (static library)</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="./samples/add_subdirectory"><code>add_subdirectory</code></a></td>
<td><strong>yes</strong></td>
<td style="text-align: left;"><a href="./samples/add_subdirectory/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/add_subdirectory/run.sh"><code>run.sh</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="./samples/fetch_content"><code>fetch_content</code></a></td>
<td><strong>yes</strong></td>
<td style="text-align: left;"><a href="./samples/fetch_content/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/fetch_content/run.sh"><code>run.sh</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="./samples/find_package"><code>find_package</code></a></td>
<td><strong>no</strong><br>needs prior install or package</td>
<td style="text-align: left;"><a href="./samples/find_package/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/find_package/run.sh"><code>run.sh</code></a></td>
</tr>
</tbody>
</table>
<h3 id="cmake-build-settings-for-ryml">CMake build settings for ryml</h3>
<p>The following cmake variables can be used to control the build behavior of ryml:</p>
<ul>
<li><code>RYML_WITH_TAB_TOKENS=ON/OFF</code>. Enable/disable support for tabs as valid container tokens after <code>:</code> and <code>-</code>. Defaults to <code>OFF</code>, because this may cost up to 10% in processing time.</li>
<li><code>RYML_DEFAULT_CALLBACKS=ON/OFF</code>. Enable/disable ryml’s default implementation of error and allocation callbacks. Defaults to <code>ON</code>.</li>
<li><code>RYML_STANDALONE=ON/OFF</code>. ryml uses <a href="https://github.com/biojppm/c4core">c4core</a>, a C++ library with low-level multi-platform utilities for C++. When <code>RYML_STANDALONE=ON</code>, c4core is incorporated into ryml as if it is the same library. Defaults to <code>ON</code>.</li>
</ul>
<p>If you’re developing ryml or just debugging problems with ryml itself, the following cmake variables can be helpful: * <code>RYML_DEV=ON/OFF</code>: a bool variable which enables development targets such as unit tests, benchmarks, etc. Defaults to <code>OFF</code>. * <code>RYML_DBG=ON/OFF</code>: a bool variable which enables verbose prints from parsing code; can be useful to figure out parsing problems. Defaults to <code>OFF</code>.</p>
<h4 id="forcing-ryml-to-use-a-different-c4core-version">Forcing ryml to use a different c4core version</h4>
<p>ryml is strongly coupled to c4core, and this is reinforced by the fact that c4core is a submodule of the current repo. However, it is still possible to use a c4core version different from the one in the repo (of course, only if there are no incompatibilities between the versions). You can find out how to achieve this by looking at the <a href="./samples/custom_c4core/CMakeLists.txt"><code>custom_c4core</code> sample</a>.</p>
<hr />
<h2 id="other-languages">Other languages</h2>
<p>One of the aims of ryml is to provide an efficient YAML API for other languages. JavaScript is fully available, and there is already a cursory implementation for Python using only the low-level API. After ironing out the general approach, other languages are likely to follow (all of this is possible because we’re using <a href="http://www.swig.org/">SWIG</a>, which makes it easy to do so).</p>
<h3 id="javascript">JavaScript</h3>
<p>A JavaScript+WebAssembly port is available, compiled through <a href="https://emscripten.org/">emscripten</a>.</p>
<h3 id="python">Python</h3>
<p>(Note that this is a work in progress. Additions will be made and things will be changed.) With that said, here’s an example of the Python API:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ryml</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ryml cannot accept strings because it does not take ownership of the</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># source buffer; only bytes or bytearrays are accepted.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>src <span class="op">=</span> b<span class="st">&quot;{HELLO: a, foo: b, bar: c, baz: d, seq: [0, 1, 2, 3]}&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check(tree):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for now, only the index-based low-level API is implemented</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.size() <span class="op">==</span> <span class="dv">10</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.root_id() <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.first_child(<span class="dv">0</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.next_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.first_sibling(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.last_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># use bytes objects for queries</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;foo&quot;</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.key(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;foo&quot;</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.val(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;b&quot;</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;seq&quot;</span>) <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree.is_seq(<span class="dv">5</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># to loop over children:</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.children(tree, <span class="dv">5</span>)):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> tree.val(ch) <span class="op">==</span> [b<span class="st">&quot;0&quot;</span>, b<span class="st">&quot;1&quot;</span>, b<span class="st">&quot;2&quot;</span>, b<span class="st">&quot;3&quot;</span>][i]</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># to loop over siblings:</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, sib <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.siblings(tree, <span class="dv">5</span>)):</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> tree.key(sib) <span class="op">==</span> [b<span class="st">&quot;HELLO&quot;</span>, b<span class="st">&quot;foo&quot;</span>, b<span class="st">&quot;bar&quot;</span>, b<span class="st">&quot;baz&quot;</span>, b<span class="st">&quot;seq&quot;</span>][i]</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># to walk over all elements</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> tree.size()</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n, indentation_level <span class="kw">in</span> ryml.walk(tree):</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># just a dumb emitter</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> <span class="st">&quot;  &quot;</span> <span class="op">*</span> indentation_level</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tree.is_keyval(n):</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.key(n), tree.val(n))</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tree.is_val(n):</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>           <span class="bu">print</span>(<span class="st">&quot;- </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.val(n))</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tree.is_keyseq(n):</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">:&quot;</span>.<span class="bu">format</span>(left, tree.key(n))</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        visited[inode] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="va">False</span> <span class="kw">not</span> <span class="kw">in</span> visited</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># </span><span class="al">NOTE</span><span class="co"> about encoding!</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> tree.get_key(<span class="dv">5</span>)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(k)  <span class="co"># &#39;&lt;memory at 0x7f80d5b93f48&gt;&#39;</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> k <span class="op">==</span> b<span class="st">&quot;seq&quot;</span>               <span class="co"># ok, as expected</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> k <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>                <span class="co"># not ok - </span><span class="al">NOTE</span><span class="co"> THIS! </span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">str</span>(k) <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>           <span class="co"># not ok</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">str</span>(k, <span class="st">&quot;utf8&quot;</span>) <span class="op">==</span> <span class="st">&quot;seq&quot;</span>   <span class="co"># ok again</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="co"># parse immutable buffer</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> ryml.parse(src)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>check(tree) <span class="co"># OK</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="co"># also works, but requires bytearrays or</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="co"># objects offering writeable memory</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>mutable <span class="op">=</span> <span class="bu">bytearray</span>(src)</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> ryml.parse_in_place(mutable)</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>check(tree) <span class="co"># OK</span></span></code></pre></div>
<p>As expected, the performance results so far are encouraging. In a <a href="api/python/parse_bm.py">timeit benchmark</a> compared against <a href="https://pyyaml.org/">PyYaml</a> and <a href="https://yaml.readthedocs.io/en/latest/">ruamel.yaml</a>, ryml parses quicker by a factor of 30x-50x:</p>
<pre><code>+-----------------------+-------+----------+---------+----------------+
| case                  | iters | time(ms) | avg(ms) | avg_read(MB/s) |
+-----------------------+-------+----------+---------+----------------+
| parse:RuamelYaml      |    88 | 800.483  |  9.096  |      0.234     |
| parse:PyYaml          |    88 | 541.370  |  6.152  |      0.346     |
| parse:RymlRo          |  3888 | 776.020  |  0.200  |     10.667     |
| parse:RymlRoReuse     |  1888 | 381.558  |  0.202  |     10.535     |
| parse:RymlRw          |  3888 | 775.121  |  0.199  |     10.679     |
| parse:RymlRwReuse     |  3888 | 774.534  |  0.199  |     10.687     |
+-----------------------+-------+----------+---------+----------------+</code></pre>
<p>(Note that the results above are somewhat biased towards ryml, because it does not perform any type conversions: return types are merely <code>memoryviews</code> to the source buffer.)</p>
<hr />
<h2 id="yaml-standard-conformance">YAML standard conformance</h2>
<p>ryml is close to feature complete. Most of the YAML features are well covered in the unit tests, and expected to work, unless in the exceptions noted below.</p>
<p>Of course, there are many dark corners in YAML, and there certainly can appear cases which ryml fails to parse. Your <a href="https://github.com/biojppm/rapidyaml/issues">bug reports or pull requests</a> are very welcome.</p>
<p>See also <a href="./ROADMAP.md">the roadmap</a> for a list of future work.</p>
<h3 id="known-limitations">Known limitations</h3>
<p>ryml deliberately makes no effort to follow the standard in the following situations:</p>
<ul>
<li>Containers are not accepted as mapping keys: keys must be scalars.</li>
<li>Tab characters after <code>:</code> and <code>-</code> are not accepted tokens, unless ryml is compiled with the macro <code>RYML_WITH_TAB_TOKENS</code>. This requirement exists because checking for tabs introduces branching into the parser’s hot code and in some cases costs as much as 10% in parsing time.</li>
<li>Anchor names must not end with a terminating colon: eg <code>&amp;anchor: key: val</code>.</li>
<li><code>%YAML</code> directives have no effect and are ignored.</li>
<li><code>%TAG</code> directives are limited to a default maximum of 4 instances per <code>Tree</code>. To increase this maximum, define the preprocessor symbol <code>RYML_MAX_TAG_DIRECTIVES</code> to a suitable value. This arbitrary limit reflects the usual practice of having at most 1 or 2 tag directives; also, be aware that this feature is under consideration for removal in YAML 1.3.</li>
</ul>
<p>Also, ryml tends to be on the permissive side where the YAML standard dictates there should be an error; in many of these cases, ryml will tolerate the input. This may be good or bad, but in any case is being improved on (meaning ryml will grow progressively less tolerant of YAML errors in the coming releases). So we strongly suggest to stay away from those dark corners of YAML which are generally a source of problems, which is a good practice anyway.</p>
<p>If you do run into trouble and would like to investigate conformance of your YAML code, beware of existing online YAML linters, many of which are not fully conformant; instead, try using <a href="https://play.yaml.io">https://play.yaml.io</a>, an amazing tool which lets you dynamically input your YAML and continuously see the results from all the existing parsers (kudos to <span class="citation" data-cites="ingydotnet">@ingydotnet</span> and the people from the YAML test suite). And of course, if you detect anything wrong with ryml, please <a href="https://github.com/biojppm/rapidyaml/issues">open an issue</a> so that we can improve.</p>
<h3 id="test-suite-status">Test suite status</h3>
<p>As part of its CI testing, ryml uses the <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a>. This is an extensive set of reference cases covering the full YAML spec. Each of these cases have several subparts: * <code>in-yaml</code>: mildly, plainly or extremely difficult-to-parse YAML * <code>in-json</code>: equivalent JSON (where possible/meaningful) * <code>out-yaml</code>: equivalent standard YAML * <code>emit-yaml</code>: equivalent standard YAML * <code>events</code>: reference results (ie, expected tree)</p>
<p>When testing, ryml parses each of the 4 yaml/json parts, then emits the parsed tree, then parses the emitted result and verifies that emission is idempotent, ie that the emitted result is semantically the same as its input without any loss of information. To ensure consistency, this happens over four levels of parse/emission pairs. And to ensure correctness, each of the stages is compared against the <code>events</code> spec from the test, which constitutes the reference. The tests also check for equality between the reference events in the test case and the events emitted by ryml from the data tree parsed from the test case input. All of this is then carried out combining several variations: both unix <code>\n</code> vs windows <code>\r\n</code> line endings, emitting to string, file or streams, which results in ~250 tests per case part. With multiple parts per case and ~400 reference cases in the test suite, this makes over several hundred thousand individual tests to which ryml is subjected, which are added to the unit tests in ryml, which also employ the same extensive combinatorial approach.</p>
<p>Also, note that in <a href="http://matrix.yaml.io/">their own words</a>, the tests from the YAML test suite <em>contain a lot of edge cases that don’t play such an important role in real world examples</em>. And yet, despite the extreme focus of the test suite, currently ryml only fails a minor fraction of the test cases, mostly related with the deliberate limitations noted above. Other than those limitations, by far the main issue with ryml is that several standard-mandated parse errors fail to materialize. For the up-to-date list of ryml failures in the test-suite, refer to the <a href="test/test_suite/test_suite_parts.cpp">list of known exceptions</a> from ryml’s test suite runner, which is used as part of ryml’s CI process.</p>
<hr />
<h2 id="alternative-libraries">Alternative libraries</h2>
<p>Why this library? Because none of the existing libraries was quite what I wanted. When I started this project in 2018, I was aware of these two alternative C/C++ libraries:</p>
<ul>
<li><a href="https://github.com/yaml/libyaml">libyaml</a>. This is a bare C library. It does not create a representation of the data tree, so I don’t see it as practical. My initial idea was to wrap parsing and emitting around libyaml’s convenient event handling, but to my surprise I found out it makes heavy use of allocations and string duplications when parsing. I briefly pondered on sending PRs to reduce these allocation needs, but not having a permanent tree to store the parsed data was too much of a downside.</li>
<li><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>. This library may be full of functionality, but is heavy on the use of node-pointer-based structures like <code>std::map</code>, allocations, string copies, polymorphism and slow C++ stream serializations. This is generally a sure way of making your code slower, and strong evidence of this can be seen in the benchmark results above.</li>
</ul>
<p>Recently <a href="https://github.com/pantoniou/libfyaml">libfyaml</a> appeared. This is a newer C library, fully conformant to the YAML standard with an amazing 100% success in the test suite; it also offers the tree as a data structure. As a downside, it does not work in Windows, and it is also multiple times slower parsing and emitting.</p>
<p>When performance and low latency are important, using contiguous structures for better cache behavior and to prevent the library from trampling caches, parsing in place and using non-owning strings is of central importance. Hence this Rapid YAML library which, with minimal compromise, bridges the gap from efficiency to usability. This library takes inspiration from <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and <a href="http://rapidxml.sourceforge.net/">RapidXML</a>.</p>
<hr />
<h2 id="license">License</h2>
<p>ryml is permissively licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
