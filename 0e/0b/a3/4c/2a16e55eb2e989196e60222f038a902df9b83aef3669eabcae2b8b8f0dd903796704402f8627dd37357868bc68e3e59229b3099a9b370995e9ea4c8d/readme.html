<h1 id="rapid-yaml">Rapid YAML</h1>
<p><a href="https://github.com/biojppm/rapidyaml/blob/master/LICENSE.txt"><img src="https://img.shields.io/badge/License-MIT-green.svg" alt="MIT Licensed" /></a> <a href="https://travis-ci.org/biojppm/rapidyaml"><img src="https://travis-ci.org/biojppm/rapidyaml.svg?branch=master" alt="Build Status" /></a> <a href="https://ci.appveyor.com/project/biojppm/rapidyaml"><img src="https://ci.appveyor.com/api/projects/status/github/biojppm/rapidyaml?branch=master&amp;svg=true" alt="Build status" /></a> <a href="https://coveralls.io/github/biojppm/rapidyaml"><img src="https://coveralls.io/repos/github/biojppm/rapidyaml/badge.svg" alt="Coverage: coveralls" /></a> <a href="https://codecov.io/gh/biojppm/rapidyaml"><img src="https://codecov.io/gh/biojppm/rapidyaml/branch/master/graph/badge.svg" alt="Coverage: codecov" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/alerts/"><img src="https://img.shields.io/lgtm/alerts/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Total alerts" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/context:cpp"><img src="https://img.shields.io/lgtm/grade/cpp/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Language grade: C/C++" /></a></p>
<p>Or ryml, for short. ryml is a library to parse and emit YAML, and do it fast.</p>
<p>ryml parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your request, after parsing / before emitting. Internally the data tree representation has no knowledge of types (but of course, every node can have a YAML type tag). It is easy and fast to read, write and iterate through the data tree.</p>
<p>ryml can use custom per-tree memory allocators, and is exception-agnostic. Errors are reported via a custom error handler callback (and a default implementation using std::abort is provided, but you can opt out).</p>
<p>ryml has respect for your compilation times and therefore it is NOT header-only. (Work is still needed on installing it, but you can just add it as a subdirectory of your CMake project).</p>
<p>ryml has no dependencies, not even on the STL (although it does use the libc). But it provides optional headers that let you serialize/deserialize STL strings and containers (or show you how to do it).</p>
<p>ryml is written in C++11, and is known to compile with: * Visual Studio 2015 and later * clang++ 3.9 and later * g++ 5 and later</p>
<p>ryml is extensively unit-tested in <a href="https://travis-ci.org/biojppm/rapidyaml">Linux</a> and <a href="https://ci.appveyor.com/project/biojppm/rapidyaml">Windows</a>. The tests include analysing ryml with: * <a href="https://lgtm.com/projects/g/biojppm/rapidyaml">LGTM.com</a> * valgrind * clang-tidy * clang sanitizers: * memory * address * undefined behavior * thread</p>
<p>ryml is also partially available in Python, with more languages to follow (see below).</p>
<hr />
<h2 id="is-it-rapid">Is it rapid?</h2>
<p>You bet!</p>
<p>The first benchmarks results are extremely satisfying. On a i7-6800K CPU @ 3.40GHz: * ryml parses YAML at about ~150MB/s on Linux and ~100MB/s on Windows (vs2017). * <strong>ryml parses JSON at about ~450MB/s on Linux</strong>, faster than sajson (didn't try yet on Windows). * compared against the other existing YAML libraries for C/C++: * ryml is in general between 2 and 3 times faster than <a href="https://github.com/yaml/libyaml">libyaml</a> * ryml is in general between 20 and 70 times faster than <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></p>
<p>(The results presented below are a bit scattered; and they need to be sistematized.) <a href="./bm/parse.cpp">Here's the benchmark</a>. Using different approaches within ryml (in-situ/read-only vs. with/without reuse), a YAML / JSON buffer is repeatedly parsed, and compared against other libraries.</p>
<h3 id="comparison-with-yaml-cpp">Comparison with yaml-cpp</h3>
<p>The first result set is for Windows, and is using a <a href="./bm/cases/appveyor.yml">appveyor.yml config file</a>. A comparison of these results is summarized on the table below:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>appveyor / vs2017 / Release</td>
<td>101.5</td>
<td>5.3</td>
<td>20x / 5.2%</td>
</tr>
<tr class="even">
<td>appveyor / vs2017 / Debug</td>
<td>6.4</td>
<td>0.0844</td>
<td>76x / 1.3%</td>
</tr>
</tbody>
</table>
<p>The next set of results is taken in Linux, comparing g++ 8.2 and clang++ 7.0.1 in parsing a YAML buffer from a <a href="./bm/cases/travis.yml">travis.yml config file</a> or a JSON buffer from a <a href="./bm/cases/compile_commands.json">compile_commands.json file</a>. You can <a href="./bm/results/parse.linux.i7_6800K.md">see the full results here</a>. Summarizing:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>json / clang++ / Release</td>
<td>453.5</td>
<td>15.1</td>
<td>30x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Release</td>
<td>430.5</td>
<td>16.3</td>
<td>26x / 4%</td>
</tr>
<tr class="odd">
<td>json / clang++ / Debug</td>
<td>61.9</td>
<td>1.63</td>
<td>38x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Debug</td>
<td>72.6</td>
<td>1.53</td>
<td>47x / 2%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Release</td>
<td>131.6</td>
<td>8.08</td>
<td>16x / 6%</td>
</tr>
<tr class="even">
<td>travis / g++ / Release</td>
<td>176.4</td>
<td>8.23</td>
<td>21x / 5%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Debug</td>
<td>10.2</td>
<td>1.08</td>
<td>9x / 1%</td>
</tr>
<tr class="even">
<td>travis / g++ / Debug</td>
<td>12.5</td>
<td>1.01</td>
<td>12x / 8%</td>
</tr>
</tbody>
</table>
<p>The 450MB/s read rate for JSON puts ryml squarely in the same ballpark as <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and other fast json readers (<a href="https://lemire.me/blog/2018/05/03/how-fast-can-you-parse-json/">data from here</a>). Even parsing full YAML is at ~150MB/s, which is still in that performance ballpark, allbeit at its lower end. This is something to be proud of, as the YAML specification is much more complex than JSON.</p>
<h3 id="performance-reading-json">Performance reading JSON</h3>
<p>So how does ryml compare against other JSON readers? Well, it's one of the fastest!</p>
<p>The benchmark is the <a href="./bm/parse.cpp">same as above</a>, and it is reading the <a href="./bm/cases/compile_commands.json">compile_commands.json</a>, The <code>_ro</code> suffix notes parsing a read-only buffer (so buffer copies are performed), while the <code>_rw</code> suffix means that the source buffer can be parsed in situ. The <code>_reuse</code> means the data tree and/or parser are reused on each benchmark repeat.</p>
<p>Here's what we get with g++ 8.2:</p>
<pre><code>|------------------|-------------------------------|-------------------------------
|                  |           Release             |           Debug               
| Benchmark        |  Iterations    Bytes/sec      |  Iterations    Bytes/sec      
|------------------|-------------------------------|-------------------------------
| rapidjson_ro     |        7941    509.855M/s     |         633    43.3632M/s     
| rapidjson_rw     |       21400    1.32937G/s     |        1067    68.171M/s     
| sajson_rw        |        6808    434.245M/s     |        2770    176.478M/s     
| sajson_ro        |        6726    430.723M/s     |        2748    175.613M/s     
| jsoncpp_ro       |        2871    183.616M/s     |        2941    187.937M/s     
| nlohmann_json_ro |        1807    115.801M/s     |         337    21.5237M/s     
| yamlcpp_ro       |         261    16.6322M/s     |          25    1.58178M/s     
| libyaml_ro       |        1786    113.909M/s     |         560    35.6599M/s     
| libyaml_ro_reuse |        1797    114.594M/s     |         561    35.8531M/s     
| ryml_ro          |        6088    388.585M/s     |         576    36.8634M/s     
| ryml_rw          |        6179    393.658M/s     |         577    36.8474M/s     
| ryml_ro_reuse    |        6986    446.248M/s     |        1164    74.636M/s      
| ryml_rw_reuse    |        7157    457.076M/s     |        1175    74.8721M/s     
|------------------|-------------------------------|-------------------------------</code></pre>
<p>You can verify that (at least for this test) ryml beats most json parsers at their own game, with the notable exception of <a href="https://github.com/Tencent/rapidjson">rapidjson</a> --- <em>but this occurs only in Release mode</em>. When in Debug mode, <a href="https://github.com/Tencent/rapidjson">rapidjson</a> is actually slower than ryml, and only <a href="https://github.com/chadaustin/sajson">sajson</a> manages to be faster.</p>
<p>More json comparison benchmarks will be added, but seem unlikely to significantly alter these results.</p>
<hr />
<h2 id="quick-start">Quick start</h2>
<p>If you're wondering whether ryml's speed comes at a usage cost, you need not. With ryml, you can have your cake and eat it too: being rapid is definitely NOT the same as being unpractical! ryml was written with easy AND efficient usage in mind, and comes with a two level API for accessing and traversing the data tree.</p>
<p>The low-level interface is an index-based API available through the <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> class (see examples below). This class is essentially a contiguous array of <code>NodeData</code> elements; these are linked to parent, children and siblings via indices.</p>
<p>On top of this index-based API, there is a thin abstraction <a href="src/c4/yml/node.hpp"><code>ryml::NodeRef</code></a> which is essentially a non-owning pointer to a <code>NodeData</code> element. It provides convenient methods for accessing the <code>NodeData</code> properties wrapping it via a class allowing for a more object-oriented use.</p>
<h3 id="parsing">Parsing</h3>
<p>A parser takes a source buffer and fills a <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ryml.hpp&gt;</span>

<span class="co">// not needed by ryml, just for these examples (and below)</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="co">// convenience functions to print a node</span>
<span class="dt">void</span> show_keyval(ryml::NodeRef n)
{
    assert(n.has_keyval());
    <span class="bu">std::</span>cout &lt;&lt; n.key() &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; n.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}
<span class="dt">void</span> show_val(ryml::NodeRef n)
{
    assert(n.has_val());
    <span class="bu">std::</span>cout &lt;&lt; n.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}
    
<span class="dt">int</span> main()
{
    <span class="co">// ryml can parse in situ (and read-only buffers too):</span>
    <span class="dt">char</span> src[] = <span class="st">&quot;{foo: 1, bar: [a: 2, b: 3]}&quot;</span>;
    <span class="co">// there are also overloads for reusing the tree and parser</span>
    ryml::Tree tree = ryml::parse(src);

    <span class="co">// get a reference to the &quot;foo&quot; node</span>
    ryml::NodeRef node = tree[<span class="st">&quot;foo&quot;</span>];

    show_keyval(node);  <span class="co">// &quot;foo: 1&quot;</span>
    show_val(node[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>]);  <span class="co">// &quot;2&quot;</span>
    show_val(node[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>]);  <span class="co">// &quot;3&quot;</span>

    <span class="co">// deserializing:</span>
    <span class="dt">int</span> foo;
    node &gt;&gt; foo; <span class="co">// now foo == 1</span>
}</code></pre></div>
<p>It is also possible to parse read-only buffers, but note these will be copied over to an arena buffer in the tree object, and that buffer copy will be the one to be parsed:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &quot;{foo: 1}&quot; is a read-only buffer; it will be</span>
<span class="co">// copied to the tree&#39;s arena before parsing</span>
ryml::Tree tree = ryml::parse(<span class="st">&quot;{foo: 1}&quot;</span>);</code></pre></div>
<p>When parsing, you can reuse the existing trees and parsers. You can also parse into particular tree nodes, so that you can parse an entire file into a node which is deep in the hierarchy of an existing tree. To see the various parse overloads, consult the <a href="src/c4/yml/parse.hpp">c4/yml/parse.hpp header</a>. The free-standing <code>parse()</code> functions (towards the end of the file) are just convenience wrappers for calling the several <code>Parser::parse()</code> overloads.</p>
<h3 id="browsing-the-tree">Browsing the tree</h3>
<p>The data tree is an index-linked array of <code>NodeData</code> elements. These are defined roughly as (browse the <a href="src/c4/yml/tree.hpp">c4/yml/tree.hpp header</a>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// (inside namespace c4::yml)</span>

<span class="kw">typedef</span> <span class="kw">enum</span> : <span class="dt">int</span> <span class="co">// bitflags for marking node features</span>
{
   KEY=<span class="dv">1</span>&lt;&lt;<span class="dv">0</span>,
   VAL=<span class="dv">1</span>&lt;&lt;<span class="dv">1</span>,
   MAP=<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>,
   SEQ=<span class="dv">1</span>&lt;&lt;<span class="dv">4</span>,
   DOC=<span class="dv">1</span>&lt;&lt;<span class="dv">5</span>,
   TAG=...,
   REF=...,
   ANCHOR=..., <span class="co">// etc </span>
} NodeType_e;
<span class="kw">struct</span> NodeType
{
   NodeType_e <span class="va">m_flags</span>;
   <span class="co">// ... predicate methods such as</span>
   <span class="co">// has_key(), is_map(), is_seq(), etc</span>
};
<span class="kw">struct</span> NodeScalar <span class="co">// this is both for keys and vals</span>
{
    csubstr tag;
    csubstr scalar;
    csubstr anchor;
    <span class="co">// csubstr is a constant substring:</span>
    <span class="co">// a non-owning read-only string view</span>
    <span class="co">// consisting of a pointer and a length</span>
}
<span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">size_t</span> NONE = (<span class="dt">size_t</span>)<span class="dv">-1</span>;
<span class="kw">struct</span> NodeData
{
    NodeType   type;
    NodeScalar key; <span class="co">// data for the key (if applicable)</span>
    NodeScalar val; <span class="co">// data for the value</span>
    
    <span class="dt">size_t</span>     parent;      <span class="co">// NONE when this is the root node</span>
    <span class="dt">size_t</span>     first_child; <span class="co">// NONE if this is a leaf node</span>
    <span class="dt">size_t</span>     last_child;  <span class="co">// etc</span>
    <span class="dt">size_t</span>     next_sibling;
    <span class="dt">size_t</span>     prev_sibling;
}</code></pre></div>
<p>Please note that you should not rely on this particular structure; the above definitions are given only to provide an idea on how the tree is structured. To access and modify node properties, please use the APIs provided through the Tree (low-level) or the NodeRef (high-level) classes.</p>
<p>You may have noticed above the use of a <code>csubstr</code> class. This class is defined in another library, <a href="https://github.com/biojppm/c4core">c4core</a>, which is imported by ryml (so technically it's not a dependency, is it?). This is a library I use with my projects consisting of multiplatform low-level utilities. One of these is <code>c4::csubstr</code> (the name comes from &quot;constant substring&quot;) which is a non-owning read-only string view, with many methods that make it practical to use (I would certainly argue more practical than <code>std::string</code>). (In fact, <code>c4::csubstr</code> and its writeable counterpart <code>c4::substr</code> are the workhorses of the ryml parsing and serialization code; you can browse these classes here: <a href="https://github.com/biojppm/c4core/blob/master/src/c4/substr.hpp">c4/substr.hpp</a>.)</p>
<p>Now, let's parse and go through a tree. To obtain a <code>NodeRef</code> from the tree, you only need to invoke <code>operator[]</code>. This operator can take indices (when invoked on sequence and map nodes) and also strings (only when invoked on map nodes):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ryml::Tree tree = ryml::parse(<span class="st">&quot;[a, b, {c: 0, d: 1}]&quot;</span>);

<span class="co">// note: show_val() was defined above</span>

show_val(tree[<span class="dv">0</span>]); <span class="co">// &quot;a&quot;</span>
show_val(tree[<span class="dv">1</span>]); <span class="co">// &quot;b&quot;</span>
show_val(tree[<span class="dv">2</span>][ <span class="dv">0</span> ]); <span class="co">// &quot;0&quot; // index-based</span>
show_val(tree[<span class="dv">2</span>][ <span class="dv">1</span> ]); <span class="co">// &quot;1&quot; // index-based</span>
show_val(tree[<span class="dv">2</span>][<span class="st">&quot;c&quot;</span>]); <span class="co">// &quot;0&quot; // string-based</span>
show_val(tree[<span class="dv">2</span>][<span class="st">&quot;d&quot;</span>]); <span class="co">// &quot;1&quot; // string-based</span>

<span class="co">// note that trying to obtain the value on a non-value</span>
<span class="co">// node such as a container will fail an assert:</span>
<span class="co">// ERROR, assertion triggered: a container has no value</span>
show_val(tree[<span class="dv">2</span>]);
<span class="co">// ERROR: the same</span>
show_val(tree.rootref());

<span class="co">// the same for keys:</span>
show_keyval(tree[<span class="dv">0</span>]); <span class="co">// ERROR: sequence element has no key</span>
show_keyval(tree[<span class="dv">2</span>][<span class="dv">0</span>]); <span class="co">// ok</span></code></pre></div>
<p>Please note that since a ryml tree uses linear storage, the complexity of <code>operator[]</code> is linear on the number of children of the node on which it is invoked. If you use it with a large tree with many siblings at the root level, you may get a performance hit. To avoid this, you can create your own accelerator structure (eg, do a single loop at the root level to fill an <code>std::map&lt;csubstr,size_t&gt;</code> mapping key names to node indices; with a node index, a lookup is O(1), so this way you can get O(log n) lookup from a key.)</p>
<p>What about <code>NodeRef</code>? Let's consider when a non-existing key or index is requested via <code>operator[]</code>. Unlike with <code>std::map</code>, <strong>this operator does not modify the tree</strong>. Instead you get a seed-state <code>NodeRef</code>, and the tree will be modified only when this seed-state reference is written to. Thus <code>NodeRef</code> can either point to a valid tree node, or if no such node exists it will be in seed-state by holding the index or name passed to <code>operator[]</code>. To allow for this, <code>NodeRef</code> is a simple structure with a declaration like:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> NodeRef
{
    <span class="co">// a pointer to the tree</span>
    Tree * <span class="va">m_tree</span>; 
    
    <span class="co">// either the (tree-scoped) index of an existing node or the (node-scoped) index of a seed state</span>
    <span class="dt">size_t</span> <span class="va">m_node_or_seed_id</span>;
    
    <span class="co">// the key name of a seed state. null when valid</span>
    <span class="at">const</span> <span class="dt">char</span>* <span class="va">m_seed_name</span>;

<span class="kw">public</span>:

    <span class="co">// this can be used to query whether a node is in seed state</span>
    <span class="dt">bool</span> valid()
    {
        <span class="cf">return</span> <span class="va">m_node_or_seed_id</span> != NONE
               &amp;&amp;
               <span class="va">m_seed_name</span> == <span class="kw">nullptr</span>;
    }

    <span class="co">// forward all calls to m_tree. For example:</span>
    csubstr val() <span class="at">const</span> { assert(valid()); <span class="cf">return</span> <span class="va">m_tree</span>-&gt;val(<span class="va">m_node_or_seed_id</span>); }
    <span class="dt">void</span> set_val(csubstr v) { <span class="cf">if</span>(!valid()) {<span class="co">/*create node in tree*/</span>;} <span class="va">m_tree</span>-&gt;set_val(<span class="va">m_node_or_seed_id</span>, v); }

    <span class="co">// etc...</span>
};</code></pre></div>
<p>To iterate over children:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span>(NodeRef c : node.children())
{
    <span class="bu">std::</span>cout &lt;&lt; c.key() &lt;&lt; <span class="st">&quot;---&quot;</span> &lt;&lt; c.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<p>To iterate over siblings:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span>(NodeRef c : node.siblings())
{
    <span class="bu">std::</span>cout &lt;&lt; c.key() &lt;&lt; <span class="st">&quot;---&quot;</span> &lt;&lt; c.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<h3 id="creating-a-tree">Creating a tree</h3>
<p>To create a tree programatically:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ryml::Tree tree;
NodeRef r = tree.rootref();

<span class="co">// Each container node must be explicitly set (either MAP or SEQ):</span>
r |= ryml::MAP;

r[<span class="st">&quot;foo&quot;</span>] = <span class="st">&quot;1&quot;</span>; <span class="co">// ryml works only with strings.</span>
<span class="co">// Note that the tree will be __pointing__ at the</span>
<span class="co">// strings &quot;foo&quot; and &quot;1&quot; used here. You need</span>
<span class="co">// to make sure they have at least the same</span>
<span class="co">// lifetime as the tree.</span>

<span class="co">// does not change the tree until s is written to.</span>
ryml::NodeRef s = r[<span class="st">&quot;seq&quot;</span>]; <span class="co">// here, s is not valid()</span>
s |= ryml::SEQ; <span class="co">// now s is valid()</span>

s.append_child() = <span class="st">&quot;bar0&quot;</span>; <span class="co">// this child is now __pointing__ at &quot;bar0&quot;</span>
s.append_child() = <span class="st">&quot;bar1&quot;</span>;
s.append_child() = <span class="st">&quot;bar2&quot;</span>;

<span class="co">// emit to stdout (can also emit to FILE* or ryml::span)</span>
<span class="ex">emit</span>(tree); <span class="co">// prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>

<span class="co">// serializing: using operator&lt;&lt; instead of operator=</span>
<span class="co">// will make the tree serialize the value into a char</span>
<span class="co">// arena inside the tree. This arena can be reserved at will.</span>
<span class="dt">int</span> ch3 = <span class="dv">33</span>, ch4 = <span class="dv">44</span>;
s.append_child() &lt;&lt; ch3;
s.append_child() &lt;&lt; ch4;

{
    <span class="bu">std::</span>string tmp = <span class="st">&quot;child5&quot;</span>;
    s.append_child() &lt;&lt; tmp;
    <span class="co">// now tmp can go safely out of scope, as it was</span>
    <span class="co">// serialized to the tree&#39;s internal string arena</span>
}

<span class="ex">emit</span>(tree); <span class="co">// now prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>
            <span class="co">//  - 33</span>
            <span class="co">//  - 44</span>
            <span class="co">//  - child5</span>

<span class="co">// to serialize keys:</span>
r.append_child() &lt;&lt; ryml::key(<span class="dv">66</span>) &lt;&lt; <span class="dv">7</span>;

<span class="ex">emit</span>(tree); <span class="co">// now prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>
            <span class="co">//  - 33</span>
            <span class="co">//  - 44</span>
            <span class="co">//  - child5</span>
            <span class="co">// 66: 7</span>
}</code></pre></div>
<h3 id="low-level-api">Low-level API</h3>
<p>The low-level api is an index-based API accessible from the <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> object. Here are some examples:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> print_keyval(Tree <span class="at">const</span>&amp; t, <span class="dt">size_t</span> elm_id)
{
    <span class="bu">std::</span>cout &lt;&lt; t.get_key(elm_id)
              &lt;&lt; <span class="st">&quot;: &quot;</span>
              &lt;&lt; t.get_val(elm_id) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}

ryml::Tree t = parse(<span class="st">&quot;{foo: 1, bar: 2, baz: 3}&quot;</span>)

<span class="dt">size_t</span> root_id = t.root_id();
<span class="dt">size_t</span> foo_id  = t.first_child(root_id);
<span class="dt">size_t</span> bar_id  = t.next_sibling(foo_id);
<span class="dt">size_t</span> baz_id  = t.last_child(root_id);

assert(baz == t.next_sibling(bar_id));
assert(bar == t.prev_sibling(baz_id));

print_keyval(t, foo_id); <span class="co">// &quot;foo: 1&quot;</span>
print_keyval(t, bar_id); <span class="co">// &quot;bar: 2&quot;</span>
print_keyval(t, baz_id); <span class="co">// &quot;baz: 3&quot;</span>

<span class="co">// to iterate over the children of a node:</span>
<span class="cf">for</span>(<span class="dt">size_t</span> i  = t.first_child(root_id);
           i != ryml::NONE;
           i  = t.next_sibling(i))
{
    <span class="co">// ...</span>
}

<span class="co">// to iterate over the siblings of a node:</span>
<span class="cf">for</span>(<span class="dt">size_t</span> i  = t.first_sibling(foo_id);
           i != ryml::NONE;
           i  = t.next_sibling(i))
{
    <span class="co">// ...</span>
}</code></pre></div>
<h3 id="custom-types">Custom types</h3>
<p>ryml provides code to serialize the basic intrinsic types (integers, floating points and strings): you can see it in the <a href="https://github.com/biojppm/c4core/blob/master/src/c4/to_chars.hpp">the <code>c4/to_chars.hpp</code> header</a>. For types other than these, you need to instruct ryml how to serialize your type.</p>
<p>There are two distinct type categories when serializing to a YAML tree:</p>
<ul>
<li>Container types requiring child nodes (ie, either sequences or maps). For these, overload the <code>write()/read()</code> functions. For example, ```c++ namespace foo { struct MyStruct; // a container-type struct { int subject; std::map<std::string, int> counts; };</li>
</ul>
<p>// ... will need these functions to convert to YAML: void write(c4::yml::NodeRef <em>n, MyStruct const&amp; v); void read(c4::yml::NodeRef const&amp; n, MyStruct </em>v); } // namespace foo <code>which could be implemented as:</code>c++ #include <c4/yml/std/map.hpp> #include <c4/yml/std/string.hpp></p>
<p>void foo::read(c4::yml::NodeRef const&amp; n, MyStruct *v) { n[&quot;subject&quot;] &gt;&gt; v-&gt;subject; n[&quot;counts&quot;] &gt;&gt; v-&gt;counts; }</p>
<p>void foo::write(c4::yml::NodeRef <em>n, MyStruct const&amp; v) { </em>n |= c4::yml::MAP;</p>
<pre><code>  NodeRef ch = n-&gt;append_child();
  ch.set_key(&quot;subject&quot;);
  ch.set_val_serialized(v.subject);
  
  ch = n-&gt;append_child();
  ch.set_key(&quot;counts&quot;);
  write(&amp;ch, v.counts);</code></pre>
<p>} ``<code>To harness [C++'s ADL rules](http://en.cppreference.com/w/cpp/language/adl),   it is important to overload these functions in the namespace where the type   you're serializing was defined (or in the c4::yml namespace). Generic   examples can be seen in the (optional) implementations of</code>std::vector<code>or</code>std::map<code>, at their respective headers    [</code>c4/yml/std/vector.hpp<code>](src/c4/yml/std/vector.hpp) and   [</code>c4/yml/std/map.hpp`](src/c4/yml/std/map.hpp).</p>
<ul>
<li>The second category is for types which should serialize to a string, resulting in leaf node in the YAML tree. For these, overload the <code>to_chars(c4::substr, T)/from_chars(c4::csubstr,   *T)</code> functions. Here's an example for a 3D vector type: ```c++ struct vec3 { float x, y, z; };</li>
</ul>
<p>// format v to the given string view + return the number of // characters written into it. The view size (buf.len) must // be strictly respected. Return the number of characters // that need to be written. So if the return value // is larger than buf.len, ryml will resize the buffer and // call this again with a larger buffer. size_t to_chars(c4::substr buf, vec3 v) { // this call to c4::format() is a type-safe version // of snprintf(buf.str, buf.len, &quot;(%f,%f,%f)&quot;, v.x, v.y, v.z) return c4::format(buf, &quot;({},{},{})&quot;, v.x, v.y, v.z); }</p>
<p>bool from_chars(c4::csubstr buf, vec3 *v) { // equivalent to sscanf(buf.str, &quot;(%f,%f,%f)&quot;, &amp;v.x, &amp;v.y, &amp;v.z) // --- actually snscanf(buf.str, buf.len, ...) but there's // no such function in the standard. size_t ret = c4::unformat(buf, &quot;({},{},{})&quot;, v.x, v.y, v.z); return ret != c4::csubstr::npos; } ``<code>You can also look at [the</code>std::string` serialization code](https://github.com/biojppm/c4core/blob/master/src/c4/std/string.hpp).</p>
<h3 id="stl-interoperation">STL interoperation</h3>
<p>ryml does not use the STL internally, but you can use ryml to serialize and deserialize STL containers. That is, the use of STL is opt-in: you need to <code>#include</code> the proper ryml header for the container you want to serialize, or provide an implementation of your own, as above. Having done that, you can serialize / deserialize your containers with a single step. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ryml_std.hpp&gt;</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="dt">int</span>&gt; m({{<span class="st">&quot;foo&quot;</span>, <span class="dv">1</span>}, {<span class="st">&quot;bar&quot;</span>, <span class="dv">2</span>}});
    ryml::Tree t;
    t.rootref() &lt;&lt; m; <span class="co">// serialization of the map happens here</span>
    
    <span class="ex">emit</span>(t);
    <span class="co">// foo: 1</span>
    <span class="co">// bar: 2</span>
    
    t[<span class="st">&quot;foo&quot;</span>] &lt;&lt; <span class="dv">1111</span>;  <span class="co">// serialize an integer into</span>
                       <span class="co">// the tree&#39;s arena, and make</span>
                       <span class="co">// foo&#39;s value point at it</span>
    t[<span class="st">&quot;bar&quot;</span>] &lt;&lt; <span class="dv">2222</span>;  <span class="co">// the same, but for bar</span>
    
    <span class="ex">emit</span>(t);
    <span class="co">// foo: 1111</span>
    <span class="co">// bar: 2222</span>
    
    m.clear();
    t.rootref() &gt;&gt; m; <span class="co">// deserialization of the map happens here</span>

    assert(m[<span class="st">&quot;foo&quot;</span>] == <span class="dv">1111</span>); <span class="co">// ok</span>
    assert(m[<span class="st">&quot;bar&quot;</span>] == <span class="dv">2222</span>); <span class="co">// ok</span>
}</code></pre></div>
<p>The <a href="src/ryml_std.hpp"><code>&lt;ryml_std.hpp&gt;</code></a> header includes every std type implementation available in ryml. But you can include just a specific header if you are interested only in a particular container; these headers are located under a specific directory in the ryml source folder: <a href="src/c4/yml/std">c4/yml/std</a>. You can browse them to learn how to implement your custom type: for containers, see for example <a href="src/c4/yml/std/vector.hpp">the <code>std::vector</code> implementation</a>, or <a href="src/c4/yml/std/map.hpp">the <code>std::map</code> implementation</a>; for an example of value nodes, see <a href="https://github.com/biojppm/c4core/src/c4/std/string.hpp">the <code>std::string</code> implementation</a>. If you'd like to see a particular STL container implemented, feel free to <a href="https://github.com/biojppm/rapidyaml/issues">submit a pull request or open an issue</a>.</p>
<h3 id="custom-allocators-and-error-handlers">Custom allocators and error handlers</h3>
<p>ryml accepts your own allocators and error handlers. Read through <a href="src/c4/yml/common.hpp">this header file</a> to set it up.</p>
<p>Please note the following about the use of custom allocators with ryml. If you use static ryml trees or parsers, you need to make sure that their allocator has the same lifetime. So you can't use ryml's default allocator, as it is declared in a ryml file, and the standard provides no guarantee on the relative initialization order, such that the allocator is constructed before and destroyed after your variables (in fact you are pretty much guaranteed to see this fail). So please carefully consider your choices, and ponder whether you really need to use ryml static trees and parsers. If you do need this, then you will need to declare and use an allocator from a ryml memory resource that outlives the tree and/or parser.</p>
<hr />
<h2 id="other-languages">Other languages</h2>
<p>One of the aims of ryml is to provide an efficient YAML API for other languages. There's already a cursory implementation for Python (using only the low-level API). After ironing out the general approach, other languages are likely to follow: probably (in order) JavaScript, C#, Java, Ruby, PHP, Octave and R (all of this is possible because we're using <a href="http://www.swig.org/">SWIG</a>, which makes it easy to do so).</p>
<h3 id="python">Python</h3>
<p>(Note that this is a work in progress. Additions will be made and things will be changed.) With that said, here's an example of the Python API:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> ryml

<span class="co"># because ryml does not take ownership of the source buffer</span>
<span class="co"># ryml cannot accept strings; only bytes or bytearrays</span>
src <span class="op">=</span> b<span class="st">&quot;{HELLO: a, foo: b, bar: c, baz: d, seq: [0, 1, 2, 3]}&quot;</span>

<span class="kw">def</span> check(tree):
    <span class="co"># for now, only the index-based low-level API is implemented</span>
    <span class="cf">assert</span> tree.size() <span class="op">==</span> <span class="dv">10</span>
    <span class="cf">assert</span> tree.root_id() <span class="op">==</span> <span class="dv">0</span>
    <span class="cf">assert</span> tree.first_child(<span class="dv">0</span>) <span class="op">==</span> <span class="dv">1</span>
    <span class="cf">assert</span> tree.next_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">2</span>
    <span class="cf">assert</span> tree.first_sibling(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">2</span>
    <span class="cf">assert</span> tree.last_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">5</span>
    <span class="co"># use bytes objects for queries</span>
    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;foo&quot;</span>) <span class="op">==</span> <span class="dv">1</span>
    <span class="cf">assert</span> tree.key(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;foo&quot;</span>)
    <span class="cf">assert</span> tree.val(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;b&quot;</span>)
    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;seq&quot;</span>) <span class="op">==</span> <span class="dv">5</span>
    <span class="cf">assert</span> tree.is_seq(<span class="dv">5</span>)
    <span class="co"># to loop over children:</span>
    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.children(tree, <span class="dv">5</span>)):
        <span class="cf">assert</span> tree.val(ch) <span class="op">==</span> [b<span class="st">&quot;0&quot;</span>, b<span class="st">&quot;1&quot;</span>, b<span class="st">&quot;2&quot;</span>, b<span class="st">&quot;3&quot;</span>][i]
    <span class="co"># to loop over siblings:</span>
    <span class="cf">for</span> i, sib <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.siblings(tree, <span class="dv">5</span>)):
        <span class="cf">assert</span> tree.key(sib) <span class="op">==</span> [b<span class="st">&quot;HELLO&quot;</span>, b<span class="st">&quot;foo&quot;</span>, b<span class="st">&quot;bar&quot;</span>, b<span class="st">&quot;baz&quot;</span>, b<span class="st">&quot;seq&quot;</span>][i]
    <span class="co"># to walk over all elements</span>
    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> tree.size()
    <span class="cf">for</span> n, indentation_level <span class="kw">in</span> ryml.walk(tree):
        <span class="co"># just a dumb emitter</span>
        left <span class="op">=</span> <span class="st">&quot;  &quot;</span> <span class="op">*</span> indentation_level
        <span class="cf">if</span> tree.is_keyval(n):
           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.key(n), tree.val(n))
        <span class="cf">elif</span> tree.is_val(n):
           <span class="bu">print</span>(<span class="st">&quot;- </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.val(n))
        <span class="cf">elif</span> tree.is_keyseq(n):
           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">:&quot;</span>.<span class="bu">format</span>(left, tree.key(n))
        visited[inode] <span class="op">=</span> <span class="va">True</span>
    <span class="cf">assert</span> <span class="va">False</span> <span class="kw">not</span> <span class="kw">in</span> visited
    <span class="co"># </span><span class="al">NOTE</span><span class="co"> about encoding!</span>
    k <span class="op">=</span> tree.get_key(<span class="dv">5</span>)
    <span class="bu">print</span>(k)  <span class="co"># &#39;&lt;memory at 0x7f80d5b93f48&gt;&#39;</span>
    <span class="cf">assert</span> k <span class="op">==</span> b<span class="st">&quot;seq&quot;</span>               <span class="co"># ok, as expected</span>
    <span class="cf">assert</span> k <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>                <span class="co"># not ok - </span><span class="al">NOTE</span><span class="co"> THIS! </span>
    <span class="cf">assert</span> <span class="bu">str</span>(k) <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>           <span class="co"># not ok</span>
    <span class="cf">assert</span> <span class="bu">str</span>(k, <span class="st">&quot;utf8&quot;</span>) <span class="op">==</span> <span class="st">&quot;seq&quot;</span>   <span class="co"># ok again</span>

<span class="co"># parse immutable buffer</span>
tree <span class="op">=</span> ryml.parse(src)
check(tree) <span class="co"># OK</span>

<span class="co"># also works, but requires bytearrays or</span>
<span class="co"># objects offering writeable memory</span>
mutable <span class="op">=</span> <span class="bu">bytearray</span>(src)
tree <span class="op">=</span> ryml.parse_in_situ(mutable)
check(tree) <span class="co"># OK</span></code></pre></div>
<p>As expected, the performance results so far are encouraging. In a <a href="api/python/parse_bm.py">timeit benchmark</a> compared against <a href="https://pyyaml.org/">PyYaml</a> and <a href="https://yaml.readthedocs.io/en/latest/">ruamel.yaml</a>, ryml parses quicker by a factor of 30x-50x:</p>
<pre><code>+-----------------------+-------+----------+---------+----------------+
| case                  | iters | time(ms) | avg(ms) | avg_read(MB/s) |
+-----------------------+-------+----------+---------+----------------+
| parse:RuamelYaml      |    88 | 800.483  |  9.096  |      0.234     |
| parse:PyYaml          |    88 | 541.370  |  6.152  |      0.346     |
| parse:RymlRo          |  3888 | 776.020  |  0.200  |     10.667     |
| parse:RymlRoReuse     |  1888 | 381.558  |  0.202  |     10.535     |
| parse:RymlRw          |  3888 | 775.121  |  0.199  |     10.679     |
| parse:RymlRwReuse     |  3888 | 774.534  |  0.199  |     10.687     |
+-----------------------+-------+----------+---------+----------------+</code></pre>
<p>(Note that the results above are somewhat biased towards ryml, because it does not perform any type conversions: return types are merely <code>memoryviews</code> to the source buffer.)</p>
<hr />
<h2 id="yaml-standard-conformance">YAML standard conformance</h2>
<p>ryml is under active development, but is close to feature complete. (With the notable exception of UTF8 support, which we haven't had the chance to verify.)</p>
<p>The following core features are tested: * mappings * sequences * complex keys * literal blocks * quoted scalars * tags * anchors and references</p>
<p>Of course, there are <em>many</em> dark corners in YAML, and there certainly can appear some cases which ryml fails to parse. So we welcome your <a href="https://github.com/biojppm/rapidyaml/issues">bug reports or pull requests!</a>.</p>
<p>Integration of the ~300 cases in the <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a> is ongoing work.</p>
<hr />
<h2 id="alternative-libraries">Alternative libraries</h2>
<p>Why this library? Because none of the existing libraries was quite what I wanted. There are two C/C++ libraries that I know of:</p>
<ul>
<li><a href="https://github.com/yaml/libyaml">libyaml</a></li>
<li><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></li>
</ul>
<p>The standard <a href="https://github.com/yaml/libyaml">libyaml</a> is a bare C library. It does not create a representation of the data tree, so it can't qualify as practical. My initial idea was to wrap parsing and emitting around libyaml, but to my surprise I found out it makes heavy use of allocations and string duplications when parsing. I briefly pondered on sending PRs to reduce these allocation needs, but not having a permanent tree to store the parsed data was too much of a downside.</p>
<p><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a> is full of functionality, but is heavy on the use of node-pointer-based structures like <code>std::map</code>, allocations, string copies and slow C++ stream serializations. This is generally a sure way of making your code slower, and strong evidence of this can be seen in the benchmark results above.</p>
<p>When performance and low latency are important, using contiguous structures for better cache behavior and to prevent the library from trampling over the client's caches, parsing in place and using non-owning strings is of central importance. Hence this Rapid YAML library which, with minimal compromise, bridges the gap from efficiency to usability. This library takes inspiration from <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and <a href="http://rapidxml.sourceforge.net/">RapidXML</a>.</p>
<hr />
<h2 id="license">License</h2>
<p>ryml is permissively licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
