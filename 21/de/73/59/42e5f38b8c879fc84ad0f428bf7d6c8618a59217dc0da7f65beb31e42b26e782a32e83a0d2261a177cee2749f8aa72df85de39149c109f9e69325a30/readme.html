<h1 id="libkeccak-tiny">libkeccak-tiny</h1>
<p>An implementation of the FIPS-202-defined SHA-3 and SHAKE functions in 120 cloc (156 lines). One C file, one header.</p>
<p>The <code>Keccak-f[1600]</code> permutation is fully unrolled; it's nearly as fast as the Keccak team's optimized permutation.</p>
<h2 id="building">Building</h2>
<pre><code>&gt; clang -O3 -march=native -std=c11 -Wextra -dynamic -shared keccak-tiny.c -o libkeccak-tiny.dylib</code></pre>
<p>If you don't have a modern libc that includes the <code>memset_s</code> function, you can just add <code>-D&quot;memset_s(W,WL,V,OL)=memset(W,V,OL)</code> to the command line.</p>
<h2 id="using">Using</h2>
<p>Build the library, include the header, and do, e.g.,</p>
<pre><code>shake256(out, 256, in, inlen);</code></pre>
<p>That's it.</p>
<p>(Note: You can request less output from the fixed-output-length functions, but not more.)</p>
<h2 id="tweetshake">TweetShake</h2>
<p>The relevant tweets:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// @hashbreaker Inspired by TweetNaCl!</span>
<span class="co">// Keccak and SHA-3 are supposedly hard to implement. So, how many tweets does it take to get to the center of a sponge...?</span>
<span class="pp">#define decshake(bits) int shake##bits(unsigned char* o, unsigned long, unsigned char*, unsigned long);                   </span><span class="co">/*begin keccak.h*/</span>
<span class="pp">#define decsha3(bits) int sha3_##bits(unsigned char*,unsigned long,unsigned char*,unsigned long);</span>
decshake(<span class="dv">128</span>) decshake(<span class="dv">256</span>) decsha3(<span class="dv">224</span>) decsha3(<span class="dv">256</span>) decsha3(<span class="dv">384</span>) decsha3(<span class="dv">512</span>)                                             <span class="co">/*end keccak.h*/</span>
<span class="pp">#define K static const </span><span class="co">/* Keccak constants: rho rotations, pi lanes, and iota RCs */</span><span class="pp">                                      </span><span class="co">/*begin keccak.c*/</span>
<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">char</span> byte;<span class="kw">typedef</span> byte*bytes;<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> z;<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> u8;K u8 V=1ULL&lt;&lt;<span class="dv">63</span>;K u8 W=1ULL&lt;&lt;<span class="dv">31</span>;<span class="co">/*!gcc*/</span>
<span class="pp">#define V (1ULL&lt;&lt;63)</span>
<span class="pp">#define W (1ULL&lt;31)</span>
K byte rho[<span class="dv">24</span>]={<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">21</span>,<span class="dv">28</span>,<span class="dv">36</span>,<span class="dv">45</span>,<span class="dv">55</span>,<span class="dv">2</span>,<span class="dv">14</span>,<span class="dv">27</span>,<span class="dv">41</span>,<span class="dv">56</span>,<span class="dv">8</span>,<span class="dv">25</span>,<span class="dv">43</span>,<span class="dv">62</span>,<span class="dv">18</span>,<span class="dv">39</span>,<span class="dv">61</span>,<span class="dv">20</span>,<span class="dv">44</span>};K u8 RC[<span class="dv">24</span>]={<span class="dv">1</span>,<span class="bn">0x8082</span>,V|<span class="bn">0x808a</span>,V|W|<span class="bn">0x8000</span>,<span class="bn">0x808b</span>,W|<span class="dv">1</span>,V|W
|<span class="bn">0x8081</span>,V|<span class="bn">0x8009</span>,<span class="dv">138</span>,<span class="dv">136</span>,W|<span class="bn">0x8009</span>,W|<span class="dv">10</span>,W|<span class="bn">0x808b</span>,V|<span class="bn">0x8b</span>,V|<span class="bn">0x8089</span>,V|<span class="bn">0x8003</span>,V|<span class="bn">0x8002</span>,V|<span class="bn">0x80</span>,<span class="bn">0x800a</span>,V|W|<span class="bn">0xa</span>,V|W|<span class="bn">0x8081</span>,V|<span class="bn">0x8080</span>,W|<span class="dv">1</span>,V|W|<span class="bn">0x8008</span>};
K byte pi[<span class="dv">25</span>]={<span class="dv">10</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">17</span>,<span class="dv">18</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">16</span>,<span class="dv">8</span>,<span class="dv">21</span>,<span class="dv">24</span>,<span class="dv">4</span>,<span class="dv">15</span>,<span class="dv">23</span>,<span class="dv">19</span>,<span class="dv">13</span>,<span class="dv">12</span>,<span class="dv">2</span>,<span class="dv">20</span>,<span class="dv">14</span>,<span class="dv">22</span>,<span class="dv">9</span>,<span class="dv">6</span>,<span class="dv">1</span>}; <span class="co">/**helpers:*/</span><span class="dt">static</span> <span class="kw">inline</span> z min(z a,z b){<span class="cf">return</span> (a&lt;b)?a:b;}
<span class="pp">#define ROL(x, s) </span><span class="co">/* rotary shift */</span><span class="pp"> (((x) &lt;&lt; s) | ((x) &gt;&gt; (64-s)))              </span><span class="co">/**macros to fully unroll the Keccak-f[1600] permutation:*/</span>
<span class="pp">#define R24(e) </span><span class="co">/* repeat 24 times */</span><span class="pp"> e e e e e e e e e e e e e e e e e e e e e e e e</span>
<span class="pp">#define L5(v,s,e) </span><span class="co">/* 5-unroll a loop */</span><span class="pp"> v=0; e; v+=s; e; v+=s; e; v+=s; e; v+=s; e; v+=s;                              </span><span class="co">/**the permutation:*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> keccakf(u8* a){u8 b[<span class="dv">5</span>]={<span class="dv">0</span>};u8 t=<span class="dv">0</span>;byte x,y,i=<span class="dv">0</span>; <span class="co">/*24 rounds:*/</span>R24( L5(x,<span class="dv">1</span>,b[x]=<span class="dv">0</span>;L5(y,<span class="dv">5</span>, <span class="co">/*parity*/</span> b[x] ^= a[x+y]))
L5(x,<span class="dv">1</span>,L5(y,<span class="dv">5</span>,<span class="co">/*theta*/</span>a[y+x] ^= b[(x+<span class="dv">4</span>)%<span class="dv">5</span>] ^ ROL(b[(x+<span class="dv">1</span>)%<span class="dv">5</span>],<span class="dv">1</span>))) t=a[<span class="dv">1</span>];x=<span class="dv">0</span>;R24(b[<span class="dv">0</span>]=a[pi[x]];<span class="co">/*rho*/</span>a[pi[x]]=ROL(t, rho[x]);t=b[<span class="dv">0</span>];x++;)
L5(y,<span class="dv">5</span>,L5(x,<span class="dv">1</span>, <span class="co">/*chi*/</span> b[x] = a[y+x]) L5(x,<span class="dv">1</span>, a[y+x] = b[x] ^ ~b[(x+<span class="dv">1</span>)%<span class="dv">5</span>] &amp; b[(x+<span class="dv">2</span>)%<span class="dv">5</span>])) <span class="co">/*iota*/</span> a[<span class="dv">0</span>] ^= RC[i]; i++; )}     <span class="co">/**keccak-f!**/</span>
<span class="pp">#define FOR(i, ST, L, S) </span><span class="co">/*obvious*/</span><span class="pp"> do { for (z i = 0; i &lt; L; i += ST) { S; } } while (0)   </span><span class="co">/**now, the sponge construction in hash mode**/</span>
<span class="pp">#define appl(NAME, S) </span><span class="co">/*macro to define array comprehensions*/</span><span class="pp"> static inline void NAME(bytes dst, bytes src, z len) { FOR(i, 1, len, S); }</span>
<span class="co">/*helpers:*/</span> <span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> clear(bytes a) { FOR(i,<span class="dv">1</span>,<span class="dv">200</span>,a[i]=<span class="dv">0</span>); } appl(xorin, dst[i] ^= src[i])  appl(set, src[i] = dst[i])
<span class="pp">#define foldP(I, L, F) </span><span class="co">/* macro to fold app P F */</span><span class="pp"> while (L &gt;= r) { </span><span class="co">/*apply F*/</span><span class="pp"> F(a, I, r); </span><span class="co">/*permute*/</span><span class="pp"> keccakf(A); I += r; L -= r; }</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> hash(bytes o,z olen,bytes in,z ilen,z r,byte D){ <span class="cf">if</span>((o == (<span class="dt">void</span>*)<span class="dv">0</span>)||((in == (<span class="dt">void</span>*)<span class="dv">0</span>)&amp;&amp;ilen != <span class="dv">0</span>)||(r &gt;= <span class="dv">200</span>))<span class="cf">return</span> <span class="dv">-1</span>;
<span class="co">/*absorb*/</span>u8 A[<span class="dv">25</span>]={<span class="dv">0</span>};bytes a=(bytes)A;<span class="co">/*full blocks*/</span>foldP(in,ilen,xorin);<span class="co">/*last block*/</span>xorin(a,in,ilen);<span class="co">/**ds+padstart*/</span>a[ilen]^=D;
<span class="co">/*padend:*/</span>a[r<span class="dv">-1</span>]^=<span class="bn">0x80</span>; <span class="co">/**permute**/</span>keccakf(A); <span class="co">/**squeeze:**/</span>foldP(o,olen,set);<span class="co">/*last bytes*/</span>set(a,o,olen);<span class="co">/*done!*/</span>clear(a);<span class="cf">return</span> <span class="dv">0</span>;}
<span class="pp">#define defshake(bits) int shake##bits(bytes o, z olen, bytes in, z ilen) {return hash(o,olen,in,ilen,200-(bits/4),0x1f);}</span>
<span class="pp">#define defsha3(bits) int sha3_##bits(bytes o,z olen,bytes in,z ilen) {return hash(o,min(olen,200-(bits/4)),in,ilen,200-(bits/4),0x06);}</span>
<span class="co">/*define the SHA3 and SHAKE instances:*/</span>defshake(<span class="dv">128</span>) defshake(<span class="dv">256</span>) defsha3(<span class="dv">224</span>) defsha3(<span class="dv">256</span>) defsha3(<span class="dv">384</span>) defsha3(<span class="dv">512</span>)<span class="co">/*end keccak.c*/</span>
<span class="co">// ...chomp. 24 kinda legible tweets (3232 bytes). And a simple interface: shake256(digest, digestlen, in, inlen)</span>
<span class="co">// Clang recommended. GCC users will need to insert &quot;#define V (1ULL&lt;&lt;63)&quot; and &quot;#define W (1ULL&lt;31)&quot; at the point marked &quot;/*!gcc*/&quot;</span>
<span class="co">// If you&#39;re using as a prefix MAC, you MUST replace the body of &quot;clear&quot; with &quot;memset_s(a, 200, 0, 200)&quot; to avoid misoptimization.</span>
<span class="co">// @everyone_who_is_still_using_sha1 Please stop using SHA-1.</span>
<span class="co">// Oh, one more thing: a C11-threaded, memmapped shake256sum in 10 tweets. (Your libc may need a shim for C11 thread support.)</span>
<span class="co">// echo -n string stdio stdint fcntl sys/mman sys/stat sys/types unistd threads|tr &#39; &#39; \\n|xargs -n1 -I_ echo &#39;#include &lt;_.h&gt;&#39;</span>
<span class="pp">#include </span><span class="im">&quot;kcksum_tweet.h&quot;</span>
<span class="pp">#define E(LABEL, MSG) if (err != 0) { strerror_r(err, serr, 1024); fprintf(stderr, &quot;%s: &#39;%s&#39; %s\n&quot;, serr, fn, MSG); goto LABEL;}</span>
<span class="dt">static</span> mtx_t iomtx;<span class="dt">void</span> h(<span class="dt">void</span>* v);<span class="dt">void</span> h(<span class="dt">void</span>* v){<span class="dt">char</span>* fn=(<span class="dt">char</span>*)v;<span class="dt">int</span> err=<span class="dv">0</span>;<span class="dt">char</span> serr[<span class="dv">1024</span>]={<span class="dv">0</span>};<span class="co">/*open file*/</span><span class="dt">int</span> fd=open(fn, O_RDONLY);
err=!fd;E(ret,<span class="st">&quot;couldn&#39;t be opened.&quot;</span>);<span class="co">/*stat it*/</span><span class="kw">struct</span> stat stat;err=fstat(fd,&amp;stat);E(close,<span class="st">&quot;doesn&#39;t exist.&quot;</span>);err=!!(stat.st_mode&amp;S_IFDIR);
E(close,<span class="st">&quot;not a regular file.&quot;</span>);z length=(<span class="dt">size_t</span>)stat.st_size;<span class="co">/*mmap the file*/</span>bytes in=length?mmap(<span class="dv">0</span>,length,PROT_READ,MAP_SHARED,fd,<span class="dv">0</span>):NULL;
<span class="cf">if</span>(length&amp;&amp;(in==MAP_FAILED)){E(close,<span class="st">&quot;mmap-ing failed.&quot;</span>);}byte out[<span class="dv">64</span>]={<span class="dv">0</span>};<span class="co">/*hash it*/</span>shake256(out,<span class="dv">64</span>,in,length);length&amp;&amp;munmap(in,length);
<span class="co">/*lock io*/</span>mtx_lock(&amp;iomtx);printf(<span class="st">&quot;SHAKE256(&#39;%s&#39;) = &quot;</span>, fn);FOR(i,<span class="dv">1</span>,<span class="dv">64</span>,printf(<span class="st">&quot;%02x&quot;</span>,out[i]));printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);mtx_unlock(&amp;iomtx);<span class="co">/*unlock io*/</span>
close:close(fd);ret:thrd_exit(err);}<span class="dt">int</span> main(<span class="dt">int</span> argc,<span class="dt">char</span>** argv){<span class="dt">int</span> err=<span class="dv">0</span>; mtx_init(&amp;iomtx, mtx_plain); thrd_t t[<span class="dv">4</span>]; <span class="dt">int</span> res[<span class="dv">4</span>],i,j,k;
<span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;argc;i+=<span class="dv">4</span>){<span class="cf">for</span>(j=<span class="dv">0</span>;j&lt;<span class="dv">4</span>;j++){<span class="cf">if</span>((j+i)==argc){<span class="co">/*out of files*/</span><span class="cf">goto</span> join;} <span class="co">/*spawn*/</span> thrd_create(t + j,h,argv[i + j]);}
join: <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; j; k++) { <span class="co">/*wait*/</span> err |= thrd_join(t[k], res + k); err |= res[k];} } mtx_destroy(&amp;iomtx); <span class="cf">return</span> err; } <span class="co">/* done! */</span></code></pre></div>
<h2 id="license">License</h2>
<p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a></p>
