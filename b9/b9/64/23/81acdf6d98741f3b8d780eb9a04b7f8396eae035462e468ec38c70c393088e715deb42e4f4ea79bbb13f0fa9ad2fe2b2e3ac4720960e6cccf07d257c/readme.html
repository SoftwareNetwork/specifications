<h1 id="robin_hood-unordered-map-set-release-github-license">âžµ robin_hood unordered map &amp; set <a href="https://github.com/martinus/robin-hood-hashing/releases"><img src="https://img.shields.io/github/release/martinus/robin-hood-hashing.svg" alt="Release" /></a> <a href="https://raw.githubusercontent.com/martinus/robin-hood-hashing/master/LICENSE"><img src="https://img.shields.io/github/license/martinus/robin-hood-hashing.svg" alt="GitHub license" /></a></h1>
<p><a href="https://travis-ci.com/martinus/robin-hood-hashing"><img src="https://travis-ci.com/martinus/robin-hood-hashing.svg?branch=master" alt="Travis CI Build Status" /></a> <a href="https://ci.appveyor.com/project/martinus/robin-hood-hashing"><img src="https://ci.appveyor.com/api/projects/status/github/martinus/robin-hood-hashing?branch=master&amp;svg=true" alt="Appveyor Build Status" /></a> <a href="https://www.codacy.com/app/martinus/robin-hood-hashing?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=martinus/robin-hood-hashing&amp;utm_campaign=Badge_Grade"><img src="https://api.codacy.com/project/badge/Grade/9308495247b542c9802016caa6fd3461" alt="Codacy Badge" /></a> <a href="https://lgtm.com/projects/g/martinus/robin-hood-hashing/alerts/"><img src="https://img.shields.io/lgtm/alerts/g/martinus/robin-hood-hashing.svg?logo=lgtm&amp;logoWidth=18" alt="Total alerts" /></a> <a href="https://lgtm.com/projects/g/martinus/robin-hood-hashing/context:cpp"><img src="https://img.shields.io/lgtm/grade/cpp/g/martinus/robin-hood-hashing.svg?logo=lgtm&amp;logoWidth=18" alt="Language grade: C/C++" /></a> <a href="https://coveralls.io/github/martinus/robin-hood-hashing"><img src="https://coveralls.io/repos/github/martinus/robin-hood-hashing/badge.svg" alt="Coverage Status" /></a></p>
<p><code>robin_hood::unordered_map</code> and <code>robin_hood::unordered_set</code> is a platform independent replacement for <code>std::unordered_map</code> / <code>std::unordered_set</code> which is both faster and more memory efficient for real-world use cases.</p>
<h2 id="installation-usage">Installation &amp; Usage</h2>
<ol style="list-style-type: decimal">
<li>Add <a href="https://github.com/martinus/robin-hood-hashing/releases"><code>robin_hood.h</code></a> to your C++ project.</li>
<li>Use <code>robin_hood::unordered_map</code> instead of <code>std::unordered_map</code></li>
<li>Use <code>robin_hood::unordered_set</code> instead of <code>std::unordered_set</code></li>
</ol>
<h2 id="benchmarks">Benchmarks</h2>
<p>Please see extensive benchmarks at <a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/">Hashmaps Benchmarks</a>. In short: <code>robin_hood</code> is always among the fastest maps and uses far less memory than <code>std::unordered_map</code>.</p>
<h2 id="design-choices">Design Choices</h2>
<ul>
<li><p><strong>Two memory layouts</strong>. Data is either stored in a flat array, or with node indirection. Access for <code>unordered_flat_map</code> is extremely fast due to no indirection, but references to elements are not stable. It also causes allocation spikes when the map resizes, and will need plenty of memory for large objects. Node based map has stable references and uses <code>const Key</code> in the pair. It is a bit slower due to indirection. The choice is yours; you can either use <code>robin_hood::unordered_flat_map</code> or <code>robin_hood::unordered_node_map</code> directly. If you use <code>robin_hood::unordered_map</code> It tries to choose the layout that seems appropriate for your data.</p></li>
<li><p><strong>Custom allocator</strong>. Node based representation has a custom bulk allocator that tries to make few memory allocations. All allocated memory is reused, so there won't be any allocation spikes. It's very fast as well.</p></li>
<li><p><strong>Optimized hash</strong>. <code>robin_hood::hash</code> has custom implementations for integer types and for <code>std::string</code> that are very fast and falls back to <code>std::hash</code> for everything else.</p></li>
<li><p><strong>Depends on good Hashing</strong>. For a really bad hash the performance will not only degrade like in <code>std::unordered_map</code>, the map will simply fail with an <code>std::overflow_error</code>. In practice, when using the standard <code>robin_hood::hash</code>, I have never seen this happening.</p></li>
</ul>
<h2 id="license">License</h2>
<p>Licensed under the MIT License. See the <a href="https://github.com/martinus/robin-hood-hashing/blob/master/LICENSE">LICENSE</a> file for details.</p>
<p>by martinus</p>
