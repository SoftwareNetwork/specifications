<h1 id="re2-a-regular-expression-library">RE2, a regular expression
library</h1>
<p>RE2 is an efficient, principled regular expression library that has
been used in production at Google and many other places since 2006.</p>
<p><em><strong>Safety is RE2’s primary goal.</strong></em></p>
<p>RE2 was designed and implemented with an explicit goal of being able
to handle regular expressions from untrusted users without risk. One of
its primary guarantees is that the match time is linear in the length of
the input string. It was also written with production concerns in mind:
the parser, the compiler and the execution engines limit their memory
usage by working within a configurable budget—failing gracefully when
exhausted—and they avoid stack overflow by eschewing recursion.</p>
<p>It is not a goal to be faster than all other engines under all
circumstances. Although RE2 guarantees a running time that is
asymptotically linear in the length of the input, more complex
expressions may incur larger constant factors; longer expressions
increase the overhead required to handle those expressions safely. In a
sense, RE2 is pessimistic where a backtracking engine is optimistic: A
backtracking engine tests each alternative sequentially, making it fast
when the first alternative is common. By contrast RE2 evaluates all
alternatives in parallel, avoiding the performance penalty for the last
alternative, at the cost of some overhead. This pessimism is what makes
RE2 secure.</p>
<p>It is also not a goal to implement all of the features offered by
Perl, PCRE and other engines. As a matter of principle, RE2 does not
support constructs for which only backtracking solutions are known to
exist. Thus, backreferences and look-around assertions are not
supported.</p>
<p>For more information, please refer to Russ Cox’s articles on regular
expression theory and practice:</p>
<ul>
<li><a href="https://swtch.com/~rsc/regexp/regexp1.html">Regular
Expression Matching Can Be Simple And Fast</a></li>
<li><a href="https://swtch.com/~rsc/regexp/regexp2.html">Regular
Expression Matching: the Virtual Machine Approach</a></li>
<li><a href="https://swtch.com/~rsc/regexp/regexp3.html">Regular
Expression Matching in the Wild</a></li>
</ul>
<h3 id="syntax">Syntax</h3>
<p>In POSIX mode, RE2 accepts standard POSIX (egrep) syntax regular
expressions. In Perl mode, RE2 accepts most Perl operators. The only
excluded ones are those that require backtracking (and its potential for
exponential runtime) to implement. These include backreferences
(submatching is still okay) and generalized assertions. The <a
href="https://github.com/google/re2/wiki/Syntax">Syntax wiki page</a>
documents the supported Perl-mode syntax in detail. The default is Perl
mode.</p>
<h3 id="c-api">C++ API</h3>
<p>RE2’s native language is C++, although there are <a
href="#ports-and-wrappers">ports and wrappers</a> listed below.</p>
<h4 id="matching-interface">Matching Interface</h4>
<p>There are two basic operators: <code>RE2::FullMatch</code> requires
the regexp to match the entire input text, and
<code>RE2::PartialMatch</code> looks for a match for a substring of the
input text, returning the leftmost-longest match in POSIX mode and the
same match that Perl would have chosen in Perl mode.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;h.*o&quot;</span><span class="op">))</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(!</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;e&quot;</span><span class="op">))</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>PartialMatch<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;h.*o&quot;</span><span class="op">))</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>PartialMatch<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;e&quot;</span><span class="op">))</span></span></code></pre></div>
<h4 id="submatch-extraction">Submatch Extraction</h4>
<p>Both matching functions take additional arguments in which submatches
will be stored. The argument can be a <code>string*</code>, or an
integer type, or the type <code>absl::string_view*</code>. (The
<code>absl::string_view</code> type is very similar to the
<code>std::string_view</code> type, but for historical reasons, RE2 uses
the former.) A <code>string_view</code> is a pointer to the original
input text, along with a count. It behaves like a string but doesn’t
carry its own storage. Like when using a pointer, when using a
<code>string_view</code> you must be careful not to use it once the
original text has been deleted or gone out of scope.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Successful parsing.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>string s<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> <span class="st">&quot;(</span><span class="sc">\\</span><span class="st">w+):(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">,</span> <span class="op">&amp;</span>s<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>s <span class="op">==</span> <span class="st">&quot;ruby&quot;</span><span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>i <span class="op">==</span> <span class="dv">1234</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Fails: &quot;ruby&quot; cannot be parsed as an integer.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(!</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby&quot;</span><span class="op">,</span> <span class="st">&quot;(.+)&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Success; does not extract the number.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> <span class="st">&quot;(</span><span class="sc">\\</span><span class="st">w+):(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">,</span> <span class="op">&amp;</span>s<span class="op">));</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Success; skips NULL argument.</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> <span class="st">&quot;(</span><span class="sc">\\</span><span class="st">w+):(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)</span>NULL<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Fails: integer overflow keeps value from being stored in i.</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(!</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:123456789123&quot;</span><span class="op">,</span> <span class="st">&quot;(</span><span class="sc">\\</span><span class="st">w+):(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">,</span> <span class="op">&amp;</span>s<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span></code></pre></div>
<h4 id="pre-compiled-regular-expressions">Pre-Compiled Regular
Expressions</h4>
<p>The examples above all recompile the regular expression on each call.
Instead, you can compile it once to an RE2 object and reuse that object
for each call.</p>
<p>Example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>RE2 re<span class="op">(</span><span class="st">&quot;(</span><span class="sc">\\</span><span class="st">w+):(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>re<span class="op">.</span>ok<span class="op">());</span>  <span class="co">// compiled; if not, see re.error();</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> re<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> re<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">));</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:1234&quot;</span><span class="op">,</span> re<span class="op">,</span> <span class="op">(</span><span class="dt">void</span><span class="op">*)</span>NULL<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(!</span>RE2<span class="op">::</span>FullMatch<span class="op">(</span><span class="st">&quot;ruby:123456789123&quot;</span><span class="op">,</span> re<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">));</span></span></code></pre></div>
<h4 id="options">Options</h4>
<p>The constructor takes an optional second argument that can be used to
change RE2’s default options. For example, <code>RE2::Quiet</code>
silences the error messages that are usually printed when a regular
expression fails to parse:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>RE2 re<span class="op">(</span><span class="st">&quot;(ab&quot;</span><span class="op">,</span> RE2<span class="op">::</span>Quiet<span class="op">);</span>  <span class="co">// don&#39;t write to stderr for parser failure</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(!</span>re<span class="op">.</span>ok<span class="op">());</span>  <span class="co">// can check re.error() for details</span></span></code></pre></div>
<p>Other useful predefined options are <code>Latin1</code> (disable
UTF-8) and <code>POSIX</code> (use POSIX syntax and leftmost longest
matching).</p>
<p>You can also declare your own <code>RE2::Options</code> object and
then configure it as you like. See the <a
href="https://github.com/google/re2/blob/main/re2/re2.h">header</a> for
the full set of options.</p>
<h4 id="unicode-normalization">Unicode Normalization</h4>
<p>RE2 operates on Unicode code points: it makes no attempt at
normalization. For example, the regular expression /ü/ (U+00FC, u with
diaeresis) does not match the input “ü” (U+0075 U+0308, u followed by
combining diaeresis). Normalization is a long, involved topic. The
simplest solution, if you need such matches, is to normalize both the
regular expressions and the input in a preprocessing step before using
RE2. For more details on the general topic, see <a
href="https://www.unicode.org/reports/tr15/"
class="uri">https://www.unicode.org/reports/tr15/</a>.</p>
<h4 id="additional-tips-and-tricks">Additional Tips and Tricks</h4>
<p>For advanced usage, like constructing your own argument lists, or
using RE2 as a lexer, or parsing hex, octal, and C-radix numbers, see <a
href="https://github.com/google/re2/blob/main/re2/re2.h">re2.h</a>.</p>
<h3 id="installation">Installation</h3>
<p>RE2 can be built and installed using GNU make, CMake, or Bazel. The
simplest installation instructions are:</p>
<pre><code>make
make test
make benchmark
make install
make testinstall</code></pre>
<p>Building RE2 requires a C++17 compiler and the <a
href="https://github.com/abseil/abseil-cpp">Abseil</a> library. Building
the tests and benchmarks requires <a
href="https://github.com/google/googletest">GoogleTest</a> and <a
href="https://github.com/google/benchmark">Benchmark</a>. To obtain
those:</p>
<ul>
<li>Linux:
<code>apt install libabsl-dev libgtest-dev libbenchmark-dev</code></li>
<li>macOS:
<code>brew install abseil googletest google-benchmark pkg-config-wrapper</code></li>
<li>Windows: <code>vcpkg install abseil gtest benchmark</code><br />
or <code>vcpkg add port abseil gtest benchmark</code></li>
</ul>
<p>Once those are installed, the build has to be able to find them. If
the standard Makefile has trouble, then switching to CMake can help:</p>
<pre><code>rm -rf build
cmake -DRE2_TEST=ON -DRE2_BENCHMARK=ON -S . -B build
cd build
make
make test
make install</code></pre>
<p>When using CMake, with benchmarks enabled, <code>make test</code>
builds and runs test binaries and builds a <code>regexp_benchmark</code>
binary but does not run it. If you don’t need the tests or benchmarks at
all, you can omit the corresponding <code>-D</code> arguments, and then
you don’t need the GoogleTest or Benchmark dependencies either.</p>
<p>Another useful option is <code>-DRE2_USE_ICU=ON</code>, which adds a
dependency on the ICU Unicode library but also extends the list of
property names available in the <code>\p</code> and <code>\P</code>
patterns.</p>
<p>CMake can also be used to generate Visual Studio and Xcode projects,
as well as Cygwin, MinGW, and MSYS makefiles.</p>
<ul>
<li>Visual Studio users: You need Visual Studio 2019 or later.</li>
<li>Cygwin users: You must run CMake from the Cygwin command line, not
the Windows command line.</li>
</ul>
<p>If you are adding RE2 to your own CMake project, CMake has two ways
to use a dependency: <code>add_subdirectory()</code>, which is when the
dependency’s <strong><em>sources</em></strong> are in a subdirectory of
your project; and <code>find_package()</code>, which is when the
dependency’s <strong><em>binaries</em></strong> have been built and
installed somewhere on your system. The Abseil documentation walks
through the former <a
href="https://abseil.io/docs/cpp/quickstart-cmake">here</a> versus the
latter <a
href="https://abseil.io/docs/cpp/tools/cmake-installs">here</a>. Once
you get Abseil working, getting RE2 working will be a very similar
process and, either way, <code>target_link_libraries(… re2::re2)</code>
should Just Work™.</p>
<p>If you are using <a href="https://bazel.io">Bazel</a>, it will handle
the dependencies for you, although you still need to download Bazel,
which you can do with <a
href="https://github.com/bazelbuild/bazelisk">Bazelisk</a>.</p>
<pre><code>go install github.com/bazelbuild/bazelisk@latest
# or on mac: brew install bazelisk

bazelisk build :all
bazelisk test :all</code></pre>
<p>If you are using RE2 from another project, you need to make sure you
are using at least C++17. See the RE2 <a
href="https://github.com/google/re2/blob/main/.bazelrc">.bazelrc</a>
file for an example.</p>
<h3 id="ports-and-wrappers">Ports and Wrappers</h3>
<p>RE2 is implemented in C++.</p>
<p>The official Python wrapper is <a
href="https://github.com/google/re2/tree/main/python">in the
<code>python</code> directory</a> and <a
href="https://pypi.org/project/google-re2/">published on PyPI as
<code>google-re2</code></a>. Note that there is also a PyPI
<code>re2</code> but it is not by the RE2 authors and is unmaintained.
Use <code>google-re2</code>.</p>
<p>There are also other unofficial wrappers:</p>
<ul>
<li>A C wrapper is at <a href="https://github.com/marcomaggi/cre2/"
class="uri">https://github.com/marcomaggi/cre2/</a>.</li>
<li>A D wrapper is at <a href="https://github.com/ShigekiKarita/re2d/"
class="uri">https://github.com/ShigekiKarita/re2d/</a> and <a
href="https://code.dlang.org/packages/re2d">on DUB</a>.</li>
<li>An Erlang wrapper is at <a href="https://github.com/dukesoferl/re2/"
class="uri">https://github.com/dukesoferl/re2/</a> and <a
href="https://hex.pm/packages/re2">on Hex</a>.</li>
<li>An Inferno wrapper is at <a
href="https://github.com/powerman/inferno-re2/"
class="uri">https://github.com/powerman/inferno-re2/</a>.</li>
<li>A Node.js wrapper is at <a href="https://github.com/uhop/node-re2/"
class="uri">https://github.com/uhop/node-re2/</a> and <a
href="https://www.npmjs.com/package/re2">on NPM</a>.</li>
<li>An OCaml wrapper is at <a href="https://github.com/janestreet/re2/"
class="uri">https://github.com/janestreet/re2/</a> and <a
href="https://opam.ocaml.org/packages/re2/">on OPAM</a>.</li>
<li>A Perl wrapper is at <a href="https://github.com/dgl/re-engine-RE2/"
class="uri">https://github.com/dgl/re-engine-RE2/</a> and <a
href="https://metacpan.org/pod/re::engine::RE2">on CPAN</a>.</li>
<li>An R wrapper is at <a href="https://github.com/girishji/re2/"
class="uri">https://github.com/girishji/re2/</a> and <a
href="https://cran.r-project.org/web/packages/re2/index.html">on
CRAN</a>.</li>
<li>A Ruby wrapper is at <a href="https://github.com/mudge/re2/"
class="uri">https://github.com/mudge/re2/</a> and on RubyGems
(rubygems.org).</li>
<li>A WebAssembly wrapper is at <a
href="https://github.com/google/re2-wasm/"
class="uri">https://github.com/google/re2-wasm/</a> and on NPM
(npmjs.com).</li>
</ul>
<p><a href="https://github.com/google/re2j">RE2J</a> is a port of the
RE2 C++ code to pure Java, and <a
href="https://github.com/le0pard/re2js">RE2JS</a> is a port of RE2J to
JavaScript.</p>
<p>The <a href="https://go.dev/pkg/regexp">Go <code>regexp</code>
package</a> and <a href="https://docs.rs/regex">Rust <code>regex</code>
crate</a> do not share code with RE2, but they follow the same
principles, accept the same syntax, and provide the same efficiency
guarantees.</p>
<h3 id="contact">Contact</h3>
<p>The <a href="https://github.com/google/re2/issues">issue tracker</a>
is the best place for discussions.</p>
<p>There is a <a href="https://groups.google.com/group/re2-dev">mailing
list</a> for keeping up with code changes.</p>
<p>Please read the <a
href="https://github.com/google/re2/wiki/Contribute">contribution
guide</a> before sending changes. In particular, note that RE2 does not
use GitHub pull requests.</p>
