<p>:last-update-label!: :source-highlighter: coderay :icons: font :toclevels: 3 :toc: left :toc-title: Boost QVM :sectnumlevels: 2</p>
<p>= Boost QVM Generic {CPP} library for working with Quaternions Vectors and Matrices :keywords: c++, boost, matrix, vector, quaternion</p>
<p>[abstract] == Abstract Boost QVM is a generic library for working with Quaternions, Vectors and Matrices of static size with the emphasis on 2, 3 and 4-dimensional operations needed in graphics, video games and simulation applications.</p>
<p>All operations are implemented in terms of free function templates using https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error[SFINAE], compatible with any user-defined quaternion, vector or matrix type. Binary operations are able to work with disparate value types.</p>
<p>The library also provides &lt;<view_proxy,view proxies>&gt; that can be used to map one lvalue type to another with zero overhead, and without the creating temporary objects.</p>
<p>== Distribution</p>
<p>QVM is part of https://www.boost.org/[Boost] and is distributed under the http://www.boost.org/LICENSE_1_0.txt[Boost Software License, Version 1.0].</p>
<p>The source code is available in https://github.com/boostorg/qvm[BOOST QVM GitHub repository].</p>
<ol start="3" style="list-style-type: upper-alpha">
<li>2008-2018 Emil Dotchevski and Reverge Studios, Inc.</li>
</ol>
<p>== Feedback / support</p>
<p>Please use the link:https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers mailing list].</p>
<p>== Portability</p>
<p>See the link:https://travis-ci.org/boostorg/qvm[Boost QVM Travis CI Builds].</p>
<p>== Tutorial</p>
<p>=== Quaternions, Vectors, Matrices</p>
<p>Out of the box Boost QVM defines generic yet simple &lt;<quat,`quat`>&gt;, &lt;<vec,`vec`>&gt; and &lt;<mat,`mat`>&gt; types. For example, the following snippet creates a quaternion object that rotates around the X axis:</p>
<h2 id="sourcec">[source,c++]</h2>
<h2 id="quat-rx-rotx_quat3.14159f">quat<float> rx = rotx_quat(3.14159f);</h2>
<p>Similarly, a matrix that translates by a given vector can be created as follows:</p>
<h2 id="sourcec-1">[source,c++]</h2>
<p>vec<float,3> v = {0,0,7}; mat<float,4,4> tr = translation_mat(v); ----</p>
<p>The usual quaternion, vector and matrix operations work on these Boost QVM types, however the operations are decoupled from any specific type: they work on any suitable type that has been registered by specializing the &lt;<quat_traits,`quat_traits`>&gt;, &lt;<vec_traits,`vec_traits`>&gt; and &lt;<mat_traits,`mat_traits`>&gt; templates.</p>
<p>For example, a user-defined 3D vector type <code>float3</code> can be introduced to Boost QVM as follows:</p>
<h2 id="sourcec-2">[source,c++]</h2>
<p>struct float3 { float a[3]; };</p>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct vec_traits&lt;float3&gt; {

    static int const dim=3;
    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
        return v.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( float3 const &amp; v ) {
        return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
        return v.a[i];
    } //optional

    static inline scalar_type read_element_idx( int i, float3 const &amp; v ) {
        return v.a[i];
    } //optional

};</code></pre>
<h2 id="section">} }</h2>
<p>Equivalently, using the &lt;<vec_traits_defaults,`vec_traits_defaults`>&gt; template the above can be shortened to:</p>
<h2 id="sourcec-3">[source,c++]</h2>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct vec_traits&lt;float3&gt;: vec_traits_defaults&lt;float3,float,3&gt; {

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
        return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
        return v.a[i];
    } //optional

};</code></pre>
<h2 id="section-1">} }</h2>
<p>After a similar specialization of the &lt;<mat_traits,`mat_traits`>&gt; template for a user-defined 3x3 matrix type <code>float33</code>, the full range of vector and matrix operations defined by Boost QVM headers becomes available automatically:</p>
<h2 id="sourcec-4">[source,c++]</h2>
<p>float3 v; X(v) = 0; Y(v) = 0; Z(v) = 7; float vmag = mag(v); float33 m = rotx_mat&lt;3&gt;(3.14159f); float3 vrot = m * v; ----</p>
<p>User-defined quaternion types are similarly introduced to Boost QVM by specializing the &lt;<quat_traits,`quat_traits`>&gt; template.</p>
<p>'''</p>
<p>=== C Arrays</p>
<p>In &lt;<boost/qvm/quat_traits_array.hpp,`boost/qvm/quat_traits_array.hpp`>&gt;, &lt;<boost/qvm/vec_traits_array.hpp,`boost/qvm/vec_traits_array.hpp`>&gt; and &lt;<boost/qvm/mat_traits_array.hpp,`boost/qvm/mat_traits_array.hpp`>&gt; Boost QVM defines appropriate &lt;<quat_traits,`quat_traits`>&gt;, &lt;<vec_traits,`vec_traits`>&gt; and &lt;<mat_traits,`mat_traits`>&gt; specializations that allow Boost QVM functions to operate directly on plain old C arrays:</p>
<h2 id="sourcec-5">[source,c++]</h2>
<p>float v[3] = {0,0,7}; float3 vrot = rotx_mat&lt;3&gt;(3.14159f) * v; ----</p>
<p>Naturally, operator overloads cannot kick in if all elements of an expression are of built-in types. The following is still illegal:</p>
<h2 id="sourcec-6">[source,c++]</h2>
<p>float v[3] = {0,0,7}; v *= 42; ----</p>
<p>The &lt;<vref,`vref`>&gt; and &lt;<mref,`mref`>&gt; function templates can be used to work around this issue:</p>
<h2 id="sourcec-7">[source,c++]</h2>
<p>float v[3] = {0,0,7}; vref(v) *= 42; ----</p>
<p>'''</p>
<p>[[view_proxy]] === View proxies</p>
<p>Boost QVM defines various function templates that provide static mapping between (possibly user-defined) quaternion, vector and matrix types. The example below multiplies column 1 (Boost QVM indexes are always zero-based) of the matrix <code>m</code> by a scalar:</p>
<h2 id="sourcec-8">[source,c++]</h2>
<p>void multiply_column1( float33 &amp; m, float scalar ) { col&lt;1&gt;(m) *= scalar; } ----</p>
<p>The expression &lt;<col,`col<1>(m)<code>&gt;&gt; is an lvalue of an unspecified 3D vector type that refers to column 1 of</code>m<code>. Note however that this does not create any temporary objects; instead</code>operator*=<code>above works directly with a reference to</code>m`.</p>
<p>Here is another example, multiplying a transposed view of a matrix by a vector of some user-defined type <code>float3</code>:</p>
<h2 id="sourcec-9">[source,c++]</h2>
<p>float3 v = {0,0,7}; float3 vrot = transposed(rotx_mat&lt;3&gt;(3.14159f)) * v; ----</p>
<p>In general, the various view proxy functions return references of unspecified, non-copyable types that refer to the original object. They can be assigned from or converted to any compatible vector or matrix type.</p>
<p>'''</p>
<p>=== Swizzling</p>
<p>Boost QVM allows accessing vector elements by swizzling, exposing vector views of different dimensions, and/or views with reordered elements. The example below rotates <code>v</code> around the X axis, and stores the resulting vector back in <code>v</code> but with the X and Y elements swapped:</p>
<h2 id="sourcec-10">[source,c++]</h2>
<p>float3 v = {0,0,7}; YXZ(v) = rotx_mat&lt;3&gt;(3.14159f) * v; ----</p>
<p>A special case of swizzling provides next-dimension-view of a vector object, adding either 0 or 1 as its last component. Assuming <code>float3</code> is a 3D vector type, and <code>float4</code> is a 4D vector type, the following statements are valid:</p>
<h2 id="sourcec-11">[source,c++]</h2>
<p>float3 v = {0,0,7}; float4 point = XYZ1(v); //{0,0,7,1} float4 vector = XYZ0(v); //{0,0,7,0} ----</p>
<p>It is also valid for swizzling to address vector elements more than once:</p>
<h2 id="sourcec-12">[source,c++]</h2>
<p>float3 v = {0,0,7}; float4 v1 = ZZZZ(v); //{7,7,7,7} ----</p>
<p>Boost QVM defines all permutations of <code>X</code>, <code>Y</code>, <code>Z</code>, <code>W</code> for 1D, 2D, 3D and 4D swizzling, plus each dimension defines variants with 0 or 1 used at any position (if 0 or 1 appear at the first position, the swizzling function name begins with underscore, e.g. <code>_1XY</code>).</p>
<p>The swizzling syntax can also be used to bind scalars as vectors. For example:</p>
<h2 id="sourcec-13">[source,c++]</h2>
<p>float3 v = _00X(42.0f); //{0,0,42} ----</p>
<p>'''</p>
<p>[[enable_if]] === SFINAE/enable_if</p>
<p>SFINAE stands for Substitution Failure Is Not An Error. This refers to a situation in {CPP} where an invalid substitution of template parameters (including when those parameters are deduced implicitly as a result of an unqualified call) is not in itself an error.</p>
<p>In absence of concepts support, SFINAE can be used to disable function template overloads that would otherwise present a signature that is too generic. More formally, this is supported by the Boost <code>enable_if</code> library.</p>
<p>For example, Boost QVM defines <code>operator*</code> overload which works with any user-defined matrix and vector types. The naive approach would be to declare this overload as follows:</p>
<h2 id="sourcec-14">[source,c++]</h2>
<p>template <class Matrix,class Vector> Vector operator*( Matrix const &amp; m, Vector const &amp; v ); ----</p>
<p>Even if the function definition might contain code that would compile only for <code>Matrix</code> and <code>Vector</code> types, because the function declaration itself is valid, it will participate in overload rezolutions when multiplying objects of any two types whatsoever. This typically renders overload resolutions ambiguous and the compiler (correctly) issues an error.</p>
<p>Using <code>enable_if</code>, Boost QVM declares such overloads in a way that preserves their generic signature but only participate in overload resolutions if the passed parameters make sense depending on the semantics of the operation being defined:</p>
<h2 id="sourcec-15">[source,c++]</h2>
<p>template <class A,class B> typename enable_if_c&lt; is_mat<A>::value &amp;&amp; is_vec<B>::value &amp;&amp; mat_traits<A>::cols==vec_traits<B>::dim, //Condition B&gt;::type //Return type operator*( A const &amp; a, B const &amp; b ); ----</p>
<p>For brevity, function declarations throughout this documentation specify the condition which controls whether they are enabled or not without specifying exactly what <code>enable_if</code> construct is used to achieve this effect.</p>
<p>'''</p>
<p>=== Interoperability</p>
<p>An important design goal of Boost QVM is that it works seamlessly with 3rd-party quaternion, vector and matrix types and libraries. Even when such libraries overload the same {CPP} operators as Boost QVM, it is safe to bring the entire <code>boost::qvm</code> namespace in scope by specifying:</p>
<h2 id="sourcec-16">[source,c++]</h2>
<h2 id="using-namespace-boostqvm">using namespace boost::qvm;</h2>
<p>The above using directive does not introduce ambiguities with function and operator overloads defined by a 3rd-party library because:</p>
<ul>
<li><p>Most <code>boost::qvm</code> function overloads and all operator overloads use SFINAE/<code>enable_if</code>, which makes them &quot;disappear&quot; unless an expression uses types that have the appropriate Boost QVM-specific type traits defined;</p></li>
<li><p>Whenever such overloads are compatible with a given expression, their signature is extremely generic, which means that any other (user-defined) compatible overload will be a better match in any overload resolution.</p></li>
</ul>
<p>NOTE: Bringing the entire boost::qvm namespace in scope may introduce ambiguities when accessing types (as opposed to functions) defined by 3rd-party libraries. In that case, you can safely bring namespace <code>boost::qvm::sfinae</code> in scope instead, which contains only function and operator overloads that use SFINAE/<code>enable_if</code>.</p>
<p>==== Specifying return types for binary operations</p>
<p>Bringing the <code>boost::qvm</code> namespace in scope lets you mix vector and matrix types that come from different APIs into a common, type-safe framework. In this case however, it should be considered what types should be returned by binary operations that return an object by value. For example, if you multiply a 3x3 matrix <code>m1</code> of type <code>user_matrix1</code> by a 3x3 matrix <code>m2</code> of type <code>user_matrix2</code>, what type should that operation return?</p>
<p>The answer is that by default, Boost QVM returns some kind of compatible matrix type, so it is always safe to write:</p>
<h2 id="sourcec-17">[source,c++]</h2>
<h2 id="auto-m-m1-m2">auto &amp; m = m1 * m2;</h2>
<p>However, the type deduced by default converts implicitly to any compatible matrix type, so the following is also valid, at the cost of a temporary:</p>
<h2 id="sourcec-18">[source,c++]</h2>
<h2 id="user_matrix1-m-m1-m2">user_matrix1 m = m1 * m2;</h2>
<p>While the temporary object can be optimized away by many compilers, it can be avoided altogether by specializing the &lt;<deduce_mat2,`deduce_mat2`>&gt; template. For example, to specify that multiplying a <code>user_matrix1</code> by a <code>user_matrix2</code> should always produce a <code>user_matrix1</code> object, you could write:</p>
<h2 id="sourcec-19">[source,c++]</h2>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct deduce_mat2&lt;user_matrix1,user_matrix2,3,3&gt; {
    typedef user_matrix1 type;
};

template &lt;&gt;
struct deduce_mat2&lt;user_matrix2,user_matrix1,3,3&gt; {
    typedef user_matrix1 type;
};</code></pre>
<h2 id="section-2">} }</h2>
<h1 id="warning">[WARNING]</h1>
<p>Be mindful of potential ODR violation when using &lt;<deduce_quat2,`deduce_quat2`>&gt;, &lt;<deduce_vec2,`deduce_vec2`>&gt; and &lt;<deduce_mat2,`deduce_mat2`>&gt; in independent libraries. For example, this could happen if <code>lib1</code> defines <code>deduce_vec2&lt;lib1::vec,lib2::vec&gt;::type</code> as <code>lib1::vec</code> and in the same program <code>lib2</code> defines <code>deduce_vec2&lt;lib1::vec,lib2::vec&gt;::type</code> as <code>lib2::vec</code>.</p>
<h1 id="it-is-best-to-keep-such-specializations-out-of-lib1-and-lib2.-of-course-it-is-always-safe-for-lib1-and-lib2-to-use-to-convert-between-the-lib1vec-and-lib2vec-types-as-needed.">It is best to keep such specializations out of <code>lib1</code> and <code>lib2</code>. Of course, it is always safe for <code>lib1</code> and <code>lib2</code> to use &lt;<convert_to,`convert_to`>&gt; to convert between the <code>lib1::vec</code> and <code>lib2::vec</code> types as needed.</h1>
<p>==== Specifying return types for unary operations</p>
<p>Perhaps surprisingly, unary operations that return an object by value have a similar, though simpler issue. That's because the argument they're called with may not be copyable, as in:</p>
<h2 id="sourcec-20">[source,c++]</h2>
<p>float m[3][3]; auto &amp; inv = inverse(m); ----</p>
<p>Above, the object returned by &lt;<mat_inverse,`inverse`>&gt; and captured by <code>inv</code> can not be of type <code>float[3][3]</code>, because that type isn't copyable. By default, Boost QVM &quot;just works&quot;, returning an object of suitable matrix type that is copyable. This deduction process can be controlled, by specializing the &lt;<deduce_mat,`deduce_mat`>&gt; template.</p>
<p>==== Converting between different quaternion, vector and matrix types</p>
<p>Any time you need to create a matrix of a particular {CPP} type from any other compatible matrix type, you can use the &lt;<convert_to,`convert_to`>&gt; function:</p>
<h2 id="sourcec-21">[source,c++]</h2>
<h2 id="user_matrix2-mconvert_tom1-m2">user_matrix2 m=convert_to<user_matrix2>(m1 * m2);</h2>
<p>'''</p>
<p>=== Header files</p>
<p>Boost QVM is split into multiple headers to allow different compilation units to <code>#include</code> only the components they need. Each function in this document specifies the exact header that must be <code>#included</code> in order to use it.</p>
<p>The tables below list commonly used components and the headers they're found in. Header names containing a number define functions that only work with objects of that dimension; e.g. <code>vec_operations2.hpp</code> contains only functions for working with 2D vectors.</p>
<p>The header <code>boost/qvm/all.hpp</code> is provided for convenience. It includes all other QVM headers.</p>
<p>.Quaternion header files [cols=&quot;1,2l&quot;] |==== | Quaternion traits |#include <boost/qvm/quat_traits.hpp> #include <boost/qvm/quat_traits_array.hpp> #include <boost/qvm/deduce_quat.hpp> | Quaternion element access |#include <boost/qvm/quat_access.hpp> | Quaternion operations |#include <boost/qvm/quat_operations.hpp> | &lt;<quat,`quat`>&gt; class template |#include <boost/qvm/quat.hpp> |====</p>
<p>.Vector header files [cols=&quot;1,2l&quot;] |==== | Vector traits |#include <boost/qvm/vec_traits.hpp> #include <boost/qvm/vec_traits_array.hpp> #include <boost/qvm/deduce_vec.hpp> | Vector element access |#include <boost/qvm/vec_access.hpp> | Vector &lt;<swizzling,swizzling>&gt; |#include <boost/qvm/swizzle.hpp> #include <boost/qvm/swizzle2.hpp> #include <boost/qvm/swizzle3.hpp> #include <boost/qvm/swizzle4.hpp> | Vector operations |#include <boost/qvm/vec_operations.hpp> #include <boost/qvm/vec_operations2.hpp> #include <boost/qvm/vec_operations3.hpp> #include <boost/qvm/vec_operations4.hpp> | Quaternion-vector operations |#include <boost/qvm/quat_vec_operations.hpp> | Vector-matrix operations |#include <boost/qvm/vec_mat_operations.hpp> | Vector-matrix &lt;<view_proxy,view proxies>&gt; |#include <boost/qvm/map_vec_mat.hpp> | &lt;<vec,`vec`>&gt; class template |#include <boost/qvm/vec.hpp> |====</p>
<p>.Matrix header files [cols=&quot;1,2l&quot;] |==== | Matrix traits |#include <boost/qvm/mat_traits.hpp> #include <boost/qvm/mat_traits_array.hpp> #include <boost/qvm/deduce_mat.hpp> | Matrix element access |#include <boost/qvm/mat_access.hpp> | Matrix operations |#include <boost/qvm/mat_operations.hpp> #include <boost/qvm/mat_operations2.hpp> #include <boost/qvm/mat_operations3.hpp> #include <boost/qvm/mat_operations4.hpp> | Matrix-matrix &lt;<view_proxy,view proxies>&gt; |#include <boost/qvm/map_mat_mat.hpp> | Matrix-vector &lt;<view_proxy,view proxies>&gt; |#include <boost/qvm/map_mat_vec.hpp> | &lt;<mat,`mat`>&gt; class template |#include <boost/qvm/mat.hpp> |====</p>
<p>== Reference</p>
<p>[[type_traits]] === Type traits system</p>
<p>Boost QVM is designed to work with user-defined quaternion, vector and matrix types, as well as user-defined scalar types. This section formally defines the way such types can be integrated.</p>
<p>'''</p>
<p>[[scalar_requirements]] ==== Scalar requirements</p>
<p>A valid scalar type <code>S</code> must have accessible destructor, default constructor, copy constructor and assignment operator, and must support the following operations:</p>
<p>==== [source,c++] ---- S operator*( S, S ); S operator/( S, S ); S operator+( S, S ); S operator-( S, S );</p>
<p>S &amp; operator*=( S &amp;, S ); S &amp; operator/=( S &amp;, S ); S &amp; operator+=( S &amp;, S ); S &amp; operator-=( S &amp;, S );</p>
<p>bool operator==( S, S ); bool operator!=( S, S ); ---- ====</p>
<p>In addition, the expression <code>S(0)</code> should construct a scalar of value zero, and <code>S(1)</code> should construct a scalar of value one, or else the &lt;<scalar_traits,`scalar_traits`>&gt; template must be specialized appropriately.</p>
<p>'''</p>
<p>[[is_scalar]] ==== <code>is_scalar</code></p>
<p>==== .#include <boost/qvm/scalar_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
struct is_scalar {
    static bool const value=false;
};

template &lt;&gt; struct is_scalar&lt;char&gt;           { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;signed char&gt;    { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;unsigned char&gt;  { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;signed short&gt;   { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;unsigned short&gt; { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;signed int&gt;     { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;unsigned int&gt;   { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;signed long&gt;    { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;unsigned long&gt;  { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;float&gt;          { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;double&gt;         { static bool const value=true; };
template &lt;&gt; struct is_scalar&lt;long double&gt;    { static bool const value=true; };</code></pre>
<h2 id="section-3">} }</h2>
<p>====</p>
<p>This template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a valid scalar type. It must be specialized together with the &lt;<scalar_traits,`scalar_traits`>&gt; template in order to introduce a user-defined scalar type to Boost QVM. Such types must satisfy the &lt;<scalar_requirements,scalar requirements>&gt;.</p>
<p>'''</p>
<p>[[scalar_traits]] ==== <code>scalar_traits</code></p>
<p>==== .#include <boost/qvm/scalar_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class Scalar&gt;
struct scalar_traits {

    BOOST_QVM_INLINE_CRITICAL
    static Scalar value( int v ) {
        return Scalar(v);
    }

};</code></pre>
<h2 id="section-4">} }</h2>
<p>====</p>
<p>This template may be specialized for user-defined scalar types to define the appropriate conversion from <code>int</code>; this is primarily used whenever Boost QVM needs to deduce a zero or one value.</p>
<p>'''</p>
<p>[[deduce_scalar]] ==== <code>deduce_scalar</code></p>
<p>==== .#include <boost/qvm/deduce_scalar.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class A,class B&gt;
struct deduce_scalar
{
    typedef typename impl&lt;A,B&gt;::type type;
};</code></pre>
<h2 id="section-5">} }</h2>
<p>====</p>
<p>Requirements: :: <code>A</code> and <code>B</code> satisfy the &lt;<scalar_requirements,scalar requirements>&gt;.</p>
<p>Returns: ::</p>
<p>If <code>A</code> and <code>B</code> are the same type, <code>impl&lt;A,B&gt;::type</code> returns that type. Otherwise, <code>impl&lt;A,B&gt;::type</code> is well defined for the following types only: <code>signed</code>/<code>unsigned char</code>, <code>signed</code>/<code>unsigned short</code>, <code>signed</code>/<code>unsigned int</code>, <code>signed</code>/<code>unsigned long</code>, <code>float</code> and <code>double</code>. The deduction logic is as follows:</p>
<ul>
<li>if either of <code>A</code> and <code>B</code> is <code>double</code>, the result is <code>double</code>;</li>
<li>else, if one of <code>A</code> or <code>B</code> is an integer type and the other is <code>float</code>, the result is <code>float</code>;</li>
<li>else, if one of <code>A</code> or <code>B</code> is a signed integer and the other type is unsigned integer, the signed type is changed to unsigned, and then the lesser of the two integers is promoted to the other.</li>
</ul>
<p>NOTE: This template is used by generic binary operations that return a scalar, to deduce the return type based on the (possibly different) scalars of their arguments.</p>
<p>'''</p>
<p>[[scalar]] ==== <code>scalar</code></p>
<p>==== .#include <boost/qvm/scalar_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    template &lt;class T&gt;
    struct scalar {
        typedef /*exact definition unspecified*/ type;
    };</code></pre>
<h2 id="section-6">} }</h2>
<p>====</p>
<p>The expression &lt;<quat_traits,`quat_traits<T>::scalar_type<code>&gt;&gt; evaluates to the scalar type of the quaternion type</code>T<code>(if &lt;&lt;is_quat,</code>is_quat<T>::value<code>&gt;&gt; is</code>true`).</p>
<p>The expression &lt;<vec_traits,`vec_traits<T>::scalar_type<code>&gt;&gt; evaluates to the scalar type of the vector type</code>T<code>(if &lt;&lt;is_vec,</code>is_vec<T>::value<code>&gt;&gt; is</code>true`).</p>
<p>The expression &lt;<mat_traits,`mat_traits<T>::scalar_type<code>&gt;&gt; evaluates to the scalar type of the matrix type</code>T<code>(if &lt;&lt;is_mat,</code>is_mat<T>::value<code>&gt;&gt; is</code>true`).</p>
<p>The expression <code>scalar&lt;T&gt;::type</code> is similar, except that it automatically detects whether <code>T</code> is a vector or a matrix or a quaternion type.</p>
<p>'''</p>
<p>[[is_quat]] ==== <code>is_quat</code></p>
<p>==== .#include <boost/qvm/quat_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
struct is_quat {

    static bool const value = false;

};</code></pre>
<h2 id="section-7">} }</h2>
<p>====</p>
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a quaternion type. For quaternion types, the &lt;<quat_traits,`quat_traits`>&gt; template can be used to access their elements generically, or to obtain their <code>scalar type</code>.</p>
<p>'''</p>
<p>[[quat_traits]] ==== <code>quat_traits</code></p>
<p>==== .#include <boost/qvm/quat_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class Q&gt;
struct quat_traits {

    /*main template members unspecified*/

};

/*
User-defined (possibly partial) specializations:

template &lt;&gt;
struct quat_traits&lt;Q&gt; {

    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;        

    template &lt;int I&gt;
    static inline scalar_type read_element( Quaternion const &amp; q );        

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( Quaternion &amp; q );        

};
*/</code></pre>
<h2 id="section-8">} }</h2>
<p>====</p>
<p>The <code>quat_traits</code> template must be specialized for (user-defined) quaternion types in order to enable quaternion operations defined in Boost QVM headers for objects of those types.</p>
<p>NOTE: QVM quaternion operations do not require that quaternion types are copyable.</p>
<p>The main <code>quat_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
<ul>
<li><code>scalar_type</code>: the expression <code>quat_traits&lt;Quaternion&gt;::scalar_type</code> must be a value type which satisfies the &lt;<scalar_requirements,`scalar requirements`>&gt;.</li>
</ul>
<p>In addition, valid specializations of the <code>quat_traits</code> template must define at least one of the following access functions as static members, where <code>q</code> is an object of type <code>Quaternion</code>, and <code>I</code> is compile-time integer constant:</p>
<ul>
<li><p><code>read_element</code>: the expression <code>quat_traits&lt;Quaternion&gt;::read_element&lt;I&gt;(q)</code> returns either a copy of or a <code>const</code> reference to the <code>I</code>-th element of <code>q</code>.</p></li>
<li><p><code>write_element</code>: the expression <code>quat_traits&lt;Quaternion&gt;::write_element&lt;I&gt;(q)</code> returns mutable reference to the <code>I</code>-th element of <code>q</code>.</p></li>
</ul>
<p>NOTE: For the quaternion <code>a + bi + cj + dk</code>, the elements are assumed to be in the following order: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>; that is, <code>I</code>=<code>0</code>/<code>1</code>/<code>2</code>/<code>3</code> would access <code>a</code>/<code>b</code>/<code>c</code>/<code>d</code>.</p>
<p>It is illegal to call any of the above functions unless <code>is_quat&lt;Quaternion&gt;::value</code> is true. Even then, quaternion types are allowed to define only a subset of the access functions.</p>
<p>Below is an example of a user-defined quaternion type, and its corresponding specialization of the quat_traits template:</p>
<h2 id="sourcec-22">[source,c++]</h2>
<h1 id="include">include <boost/qvm/quat_traits.hpp></h1>
<p>struct fquat { float a[4]; };</p>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct quat_traits&lt;fquat&gt; {

    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( fquat &amp; q ) {
        return q.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( fquat const &amp; q ) {
        return q.a[I];
    }

};</code></pre>
<h2 id="section-9">} }</h2>
<p>Equivalently, using the &lt;<quat_traits_defaults,`quat_traits_defaults`>&gt; template the above can be shortened to:</p>
<h2 id="sourcec-23">[source,c++]</h2>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct quat_traits&lt;fquat&gt;: quat_traits_defaults&lt;fquat,float&gt; {

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( fquat &amp; q ) {
        return q.a[I];
    }

};</code></pre>
<h2 id="section-10">} }</h2>
<p>'''</p>
<p>[[quat_traits_defaults]] ==== <code>quat_traits_defaults</code></p>
<p>==== .#include <boost/qvm/quat_traits_defaults.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class QuatType,class ScalarType&gt;
struct quat_traits_defaults {

    typedef QuatType quat_type;

    typedef ScalarType scalar_type;

    template &lt;int I&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element( quat_type const &amp; x ) {
        return quat_traits&lt;quat_type&gt;::template
            write_element&lt;I&gt;(const_cast&lt;quat_type &amp;&gt;(x));
    }

};</code></pre>
<h2 id="section-11">} }</h2>
<p>====</p>
<p>The <code>quat_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the &lt;<quat_traits,`quat_traits`>&gt; template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>quat_traits</code> specialization is <code>write_element</code>; the <code>quat_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code> automatically.</p>
<p>'''</p>
<p>[[deduce_quat]] ==== <code>deduce_quat</code></p>
<p>==== .#include <boost/qvm/deduce_quat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class Q&gt;
struct deduce_quat {
    typedef Q type;
};</code></pre>
<h2 id="section-12">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li><code>&lt;&lt;is_quat,is_quat&gt;&gt;&lt;Q&gt;::value</code> is <code>true</code>;</li>
<li><code>&lt;&lt;is_quat,is_quat&gt;&gt;&lt;deduce_quat&lt;Q&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_quat&lt;Q&gt;::type</code> must be copyable.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a copyable quaternion type from a single user-supplied function parameter of quaternion type. Note that <code>Q</code> itself may be non-copyable.</p>
<p>The main template definition returns <code>Q</code>, which means that it is suitable only for copyable quaternion types. Boost QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the <code>deduce_quat</code> template is for specifying the preferred quaternion type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>[[deduce_quat2]] ==== <code>deduce_quat2</code></p>
<p>==== .#include <boost/qvm/deduce_quat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class A,class B&gt;
struct deduce_quat2 {
    typedef /*unspecified*/ type;
};</code></pre>
<h2 id="section-13">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li>Both <code>&lt;&lt;scalar,scalar&gt;&gt;&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</li>
<li><code>&lt;&lt;is_quat,is_quat&gt;&gt;&lt;A&gt;::value</code> || <code>is_quat&lt;B&gt;::value</code> is <code>true</code>;</li>
<li><code>is_quat&lt;deduce_quat2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_quat2&lt;A,B&gt;::type</code> must be copyable.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a quaternion type from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may not be a quaternion type.)</p>
<p>The main template definition returns an unspecified quaternion type with &lt;<quat_traits,`scalar_type`>&gt; obtained by <code>&lt;&lt;deduce_scalar,deduce_scalar&gt;&gt;&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same quaternion type <code>Q</code>, in which case <code>Q</code> is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable quaternion types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the <code>deduce_quat2</code> template is for specifying the preferred quaternion type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>[[is_vec]] ==== <code>is_vec</code></p>
<p>==== .#include <boost/qvm/vec_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
struct is_vec {

    static bool const value = false;

};</code></pre>
<h2 id="section-14">} }</h2>
<p>====</p>
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a vector type. For vector types, the &lt;<vec_traits,`vec_traits`>&gt; template can be used to access their elements generically, or to obtain their dimension and <code>scalar type</code>.</p>
<p>'''</p>
<p>[[vec_traits]] ==== <code>vec_traits</code></p>
<p>==== .#include <boost/qvm/vec_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class V&gt;
struct vec_traits {

    /*main template members unspecified*/

};

/*
User-defined (possibly partial) specializations:

template &lt;&gt;
struct vec_traits&lt;V&gt; {

    static int const dim = &lt;&lt;user-defined&gt;&gt;;        

    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;        

    template &lt;int I&gt;
    static inline scalar_type read_element( Vector const &amp; v );

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( Vector &amp; v );

    static inline scalar_type read_element_idx( int i, Vector const &amp; v );        
    static inline scalar_type &amp; write_element_idx( int i, Vector &amp; v );        

};
*/</code></pre>
<h2 id="section-15">} }</h2>
<p>====</p>
<p>The <code>vec_traits</code> template must be specialized for (user-defined) vector types in order to enable vector and matrix operations defined in Boost QVM headers for objects of those types.</p>
<p>NOTE: QVM vector operations do not require that vector types are copyable.</p>
<p>The main <code>vec_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
<ul>
<li><p><code>dim</code>: the expression <code>vec_traits&lt;Vector&gt;::dim</code> must evaluate to a compile-time integer constant greater than 0 that specifies the vector size.</p></li>
<li><p><code>scalar_type</code>: the expression <code>vec_traits&lt;Vector&gt;::scalar_type</code> must be a value type which satisfies the &lt;<scalar_requirements,`scalar requirements`>&gt;.</p></li>
</ul>
<p>In addition, valid specializations of the <code>vec_traits</code> template may define the following access functions as static members, where <code>v</code> is an object of type <code>Vector</code>, <code>I</code> is a compile-time integer constant, and <code>i</code> is a variable of type <code>int</code>:</p>
<ul>
<li><p><code>read_element</code>: the expression <code>vec_traits&lt;Vector&gt;::read_element&lt;I&gt;(v)</code> returns either a copy of or a const reference to the <code>I</code>-th element of <code>v</code>.</p></li>
<li><p><code>write_element</code>: the expression <code>vec_traits&lt;Vector&gt;::write_element&lt;I&gt;(v)</code> returns mutable reference to the <code>I</code>-th element of <code>v</code>.</p></li>
<li><p><code>read_element_idx</code>: the expression <code>vec_traits&lt;Vector&gt;::read_element_idx(i,v)</code> returns either a copy of or a <code>const</code> reference to the <code>i</code>-th element of <code>v</code>.</p></li>
<li><p><code>write_element_idx</code>: the expression <code>vec_traits&lt;Vector&gt;::write_element_idx(i,v)</code> returns mutable reference to the <code>i</code>-th element of <code>v</code>.</p></li>
</ul>
<p>It is illegal to call any of the above functions unless <code>is_vec&lt;Vector&gt;::value</code> is true. Even then, vector types are allowed to define only a subset of the access functions. The general requirements are:</p>
<ul>
<li>At least one of <code>read_element</code> or <code>write_element</code> must be defined;</li>
<li>If <code>read_element_idx</code> is defined, <code>read_element</code> must also be defined;</li>
<li>If <code>write_element_idx</code> is defined, <code>write_element</code> must also be defined.</li>
</ul>
<p>Below is an example of a user-defined 3D vector type, and its corresponding specialization of the <code>vec_traits</code> template:</p>
<h2 id="sourcec-24">[source,c++]</h2>
<h1 id="include-1">include <boost/qvm/vec_traits.hpp></h1>
<p>struct float3 { float a[3]; };</p>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct vec_traits&lt;float3&gt; {

    static int const dim=3;

    typedef float scalar_type;

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
        return v.a[I];
    }

    template &lt;int I&gt;
    static inline scalar_type read_element( float3 const &amp; v ) {
        return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
        return v.a[i];
    } //optional

    static inline scalar_type read_element_idx( int i, float3 const &amp; v ) {
        return v.a[i];
    } //optional

};</code></pre>
<h2 id="section-16">} }</h2>
<p>Equivalently, using the &lt;<vec_traits_defaults,`vec_traits_defaults`>&gt; template the above can be shortened to:</p>
<h2 id="sourcec-25">[source,c++]</h2>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct vec_traits&lt;float3&gt;: vec_traits_defaults&lt;float3,float,3&gt;
{

    template &lt;int I&gt;
    static inline scalar_type &amp; write_element( float3 &amp; v ) {
        return v.a[I];
    }

    static inline scalar_type &amp; write_element_idx( int i, float3 &amp; v ) {
        return v.a[i];
    } //optional

};</code></pre>
<h2 id="section-17">} }</h2>
<p>'''</p>
<p>[[vec_traits_defaults]] ==== <code>vec_traits_defaults</code></p>
<p>==== .#include <boost/qvm/vec_traits_defaults.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class VecType,class ScalarType,int Dim&gt;
struct vec_traits_defaults {

    typedef VecType vec_type;
    typedef ScalarType scalar_type;
    static int const dim=Dim;

    template &lt;int I&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type write_element( vec_type const &amp; x ) {
        return vec_traits&lt;vec_type&gt;::template write_element&lt;I&gt;(const_cast&lt;vec_type &amp;&gt;(x));
    }

    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element_idx( int i, vec_type const &amp; x ) {
        return vec_traits&lt;vec_type&gt;::write_element_idx(i,const_cast&lt;vec_type &amp;&gt;(x));
    }

    protected:

    static BOOST_QVM_INLINE_TRIVIAL
    scalar_type &amp; write_element_idx( int i, vec_type &amp; m ) {
        /* unspecified */
    }
};</code></pre>
<h2 id="section-18">} }</h2>
<p>====</p>
<p>The <code>vec_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the &lt;<vec_traits,`vec_traits`>&gt; template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>vec_traits</code> specialization is <code>write_element</code>; the <code>vec_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code> and <code>dim</code> automatically.</p>
<p>Optionally, the user may also define <code>write_element_idx</code>, in which case the <code>vec_traits_defaults</code> base will provide a suitable <code>read_element_idx</code> definition automatically. If not, <code>vec_traits_defaults</code> defines a protected implementation of <code>write_element_idx</code> which may be made publicly available by the deriving <code>vec_traits</code> specialization in case the vector type for which it is being specialized can not be indexed efficiently. This <code>write_element_idx</code> function is less efficient (using meta-programming), implemented in terms of the required user-defined <code>write_element</code>.</p>
<p>'''</p>
<p>[[deduce_vec]] ==== <code>deduce_vec</code></p>
<p>==== .#include <boost/qvm/deduce_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class V, int Dim=vec_traits&lt;Vector&gt;::dim&gt;
struct deduce_vec {

    typedef /*unspecified*/ type;

};</code></pre>
<h2 id="section-19">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li><code>&lt;&lt;is_vec,is_vec&gt;&gt;&lt;V&gt;::value</code> is <code>true</code>;</li>
<li><code>is_vec&lt;deduce_vec&lt;V&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_vec&lt;V&gt;::type</code> must be copyable;</li>
<li><code>vec_traits&lt;deduce_vec&lt;V&gt;::type&gt;::dim==Dim</code>.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a copyable vector type of certain dimension from a single user-supplied function parameter of vector type. The returned type must have accessible copy constructor. Note that <code>V</code> may be non-copyable.</p>
<p>The main template definition returns an unspecified copyable vector type of size <code>Dim</code>, except if <code>&lt;&lt;vec_traits,vec_traits&gt;&gt;&lt;V&gt;::dim==Dim</code>, in which case it returns <code>V</code>, which is suitable only if <code>V</code> is a copyable type. Boost QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the <code>deduce_vec</code> template is for specifying the preferred vector type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>[[deduce_vec2]] ==== <code>deduce_vec2</code></p>
<p>==== .#include <boost/qvm/deduce_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class A,class B,int Dim&gt;
struct deduce_vec2 {
    typedef /*unspecified*/ type;
};</code></pre>
<h2 id="section-20">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li>Both <code>&lt;&lt;scalar,scalar&gt;&gt;&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</li>
<li><code>&lt;&lt;is_vec,is_vec&gt;&gt;&lt;A&gt;::value || is_vec&lt;B&gt;::value</code> is <code>true</code>;</li>
<li><code>is_vec&lt;deduce_vec2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_vec2&lt;A,B&gt;::type</code> must be copyable;</li>
<li><code>vec_traits&lt;deduce_vec2&lt;A,B&gt;::type&gt;::dim==Dim</code>.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a vector type of certain dimension from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may not be a vector type.)</p>
<p>The main template definition returns an unspecified vector type of the requested dimension with &lt;<vec_traits,`scalar_type`>&gt; obtained by <code>&lt;&lt;deduce_scalar,deduce_scalar&gt;&gt;&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same vector type <code>V</code> of dimension <code>Dim</code>, in which case <code>V</code> is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable vector types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the <code>deduce_vec2</code> template is for specifying the preferred vector type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>[[is_mat]] ==== <code>is_mat</code></p>
<p>==== .#include <boost/qvm/mat_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
struct is_mat {

    static bool const value = false;

};</code></pre>
<h2 id="section-21">} }</h2>
<p>====</p>
<p>This type template defines a compile-time boolean constant value which can be used to determine whether a type <code>T</code> is a matrix type. For matrix types, the &lt;<mat_traits,`mat_traits`>&gt; template can be used to access their elements generically, or to obtain their dimensions and scalar type.</p>
<p>'''</p>
<p>[[mat_traits]] ==== <code>mat_traits</code></p>
<p>==== .#include <boost/qvm/mat_traits.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class M&gt;
struct mat_traits {

    /*main template members unspecified*/

};

/*
User-defined (possibly partial) specializations:

template &lt;&gt;
struct mat_traits&lt;M&gt; {

    static int const rows = &lt;&lt;user-defined&gt;&gt;;        
    static int const cols = &lt;&lt;user-defined&gt;&gt;;        
    typedef &lt;&lt;user-defined&gt;&gt; scalar_type;        

    template &lt;int R,int C&gt;
    static inline scalar_type read_element( Matrix const &amp; m );

    template &lt;int R,int C&gt;
    static inline scalar_type &amp; write_element( Matrix &amp; m );

    static inline scalar_typeread_element_idx( int r, int c, Matrix const &amp; m );
    static inline scalar_type &amp; write_element_idx( int r, int c, Matrix &amp; m );

};
*/</code></pre>
<h2 id="section-22">} }</h2>
<p>====</p>
<p>The <code>mat_traits</code> template must be specialized for (user-defined) matrix types in order to enable vector and matrix operations defined in Boost QVM headers for objects of those types.</p>
<p>NOTE: The matrix operations defined by Boost QVM do not require matrix types to be copyable.</p>
<p>The main <code>mat_traits</code> template members are not specified. Valid specializations are required to define the following members:</p>
<ul>
<li><code>rows</code>: the expression <code>mat_traits&lt;Matrix&gt;::rows</code> must evaluate to a compile-time integer constant greater than 0 that specifies the number of rows in a matrix.</li>
<li><code>cols</code> must evaluate to a compile-time integer constant greater than 0 that specifies the number of columns in a matrix.</li>
<li><code>scalar_type</code>: the expression <code>mat_traits&lt;Matrix&gt;::scalar_type</code> must be a value type which satisfies the scalar requirements.</li>
</ul>
<p>In addition, valid specializations of the <code>mat_traits</code> template may define the following access functions as static members, where <code>m</code> is an object of type <code>Matrix</code>, <code>R</code> and <code>C</code> are compile-time integer constants, and <code>r</code> and <code>c</code> are variables of type <code>int</code>:</p>
<ul>
<li><code>read_element</code>: the expression <code>mat_traits&lt;Matrix&gt;::read_element&lt;R,C&gt;(m)</code> returns either a copy of or a const reference to the element at row <code>R</code> and column <code>C</code> of <code>m</code>.</li>
<li><code>write_element</code>: the expression <code>mat_traits&lt;Matrix&gt;::write_element&lt;R,C&gt;(m)</code> returns mutable reference to the element at row <code>R</code> and column <code>C</code> of <code>m</code>.</li>
<li><code>read_element_idx</code>: the expression <code>mat_traits&lt;Matrix&gt;::read_element_idx(r,c,m)</code> returns either a copy of or a const reference to the element at row <code>r</code> and column <code>c</code> of <code>m</code>.</li>
<li><code>write_element_idx</code>: the expression <code>mat_traits&lt;Matrix&gt;::write_element_idx(r,c,m)</code> returns mutable reference to the element at row <code>r</code> and column <code>c</code> of <code>m</code>.</li>
</ul>
<p>It is illegal to call any of the above functions unless <code>is_mat&lt;Matrix&gt;::value</code> is true. Even then, matrix types are allowed to define only a subset of the access functions. The general requirements are:</p>
<ul>
<li>At least one of <code>read_element</code> or <code>write_element</code> must be defined;</li>
<li>If <code>read_element_idx</code> is defined, <code>read_element</code> must also be defined;</li>
<li>If <code>write_element_idx</code> is defined, <code>write_element</code> must also be defined.</li>
</ul>
<p>Below is an example of a user-defined 3x3 matrix type, and its corresponding specialization of the <code>mat_traits</code> template:</p>
<h2 id="sourcec-26">[source,c++]</h2>
<h1 id="include-2">include <boost/qvm/mat_traits.hpp></h1>
<p>struct float33 { float a[3][3]; };</p>
<p>namespace boost { namespace qvm {</p>
<pre><code>template &lt;&gt;
struct mat_traits&lt;float33&gt; {

    static int const rows=3;
    static int const cols=3;
    typedef float scalar_type;

    template &lt;int R,int C&gt;
    static inline scalar_type &amp; write_element( float33 &amp; m ) {
        return m.a[R][C];
    }

    template &lt;int R,int C&gt;
    static inline scalar_type read_element( float33 const &amp; m ) {
        return m.a[R][C];
    }

    static inline scalar_type &amp; write_element_idx( int r, int c, float33 &amp; m ) {
        return m.a[r][c];
    }

    static inline scalar_type read_element_idx( int r, int c, float33 const &amp; m ) {
        return m.a[r][c];
    }

};</code></pre>
<h2 id="section-23">} }</h2>
<p>Equivalently, we could use the &lt;<mat_traits_defaults,`mat_traits_defaults` template to shorten the above to:

[source,c++]
----
namespace boost { namespace qvm {

    template <> struct mat_traits<float33>: mat_traits_defaults<float33,float,3,3> {</p>
<pre><code>    template &lt;int R,int C&gt; static inline scalar_type &amp; write_element( float33 &amp; m ) { return m.a[R][C]; }

    static inline scalar_type &amp; write_element_idx( int r, int c, float33 &amp; m ) {
        return m.a[r][c];
    }

};</code></pre>
<h2 id="section-24">} }</h2>
<p>'''</p>
<p>[[mat_traits_defaults]] ==== <code>mat_traits_defaults</code></p>
<p>==== .#include <boost/qvm/mat_traits_defaults.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class MatType,class ScalarType,int Rows,int Cols&gt;
struct mat_traits_defaults
{
    typedef MatType mat_type;
    typedef ScalarType scalar_type;
    static int const rows=Rows;
    static int const cols=Cols;

    template &lt;int Row,int Col&gt;
    static BOOST_QVM_INLINE_CRITICAL
    scalar_type write_element( mat_type const &amp; x ) {
        return mat_traits&lt;mat_type&gt;::template write_element&lt;Row,Col&gt;(const_cast&lt;mat_type &amp;&gt;(x));
    }

    static BOOST_QVM_INLINE_CRITICAL
    scalar_type read_element_idx( int r, int c, mat_type const &amp; x ) {
        return mat_traits&lt;mat_type&gt;::write_element_idx(r,c,const_cast&lt;mat_type &amp;&gt;(x));
    }

    protected:

    static BOOST_QVM_INLINE_TRIVIAL
    scalar_type &amp; write_element_idx( int r, int c, mat_type &amp; m ) {
        /* unspecified */
    }
};</code></pre>
<h2 id="section-25">} }</h2>
<p>====</p>
<p>The <code>mat_traits_defaults</code> template is designed to be used as a public base for user-defined specializations of the &lt;<mat_traits,`mat_traits`>&gt; template, to easily define the required members. If it is used, the only member that must be defined by the user in a <code>mat_traits</code> specialization is <code>write_element</code>; the <code>mat_traits_defaults</code> base will define <code>read_element</code>, as well as <code>scalar_type</code>, <code>rows</code> and <code>cols</code> automatically.</p>
<p>Optionally, the user may also define <code>write_element_idx</code>, in which case the <code>mat_traits_defaults</code> base will provide a suitable <code>read_element_idx</code> definition automatically. Otherwise, <code>mat_traits_defaults</code> defines a protected implementation of <code>write_element_idx</code> which may be made publicly available by the deriving <code>mat_traits</code> specialization in case the matrix type for which it is being specialized can not be indexed efficiently. This <code>write_element_idx</code> function is less efficient (using meta-programming), implemented in terms of the required user-defined <code>write_element</code>.</p>
<p>'''</p>
<p>[[deduce_mat]] ==== <code>deduce_mat</code></p>
<p>==== .#include <boost/qvm/deduce_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;
    class M,
    int Rows=mat_traits&lt;Matrix&gt;::rows,
    int Cols=mat_traits&lt;Matrix&gt;::cols&gt;
struct deduce_mat {

    typedef /*unspecified*/ type;

};</code></pre>
<h2 id="section-26">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li><code>&lt;&lt;is_mat,is_mat&gt;&gt;&lt;M&gt;::value</code> is <code>true</code>;</li>
<li><code>is_mat&lt;deduce_mat&lt;M&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_mat&lt;M&gt;::type</code> must be copyable;</li>
<li><code>&lt;&lt;mat_traits,mat_traits&gt;&gt;&lt;deduce_mat&lt;M&gt;::type&gt;::rows==Rows</code>;</li>
<li><code>mat_traits&lt;deduce_mat&lt;M&gt;::type&gt;::cols==Cols</code>.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a copyable matrix type of certain dimensions from a single user-supplied function parameter of matrix type. The returned type must have accessible copy constructor. Note that M itself may be non-copyable.</p>
<p>The main template definition returns an unspecified copyable matrix type of size <code>Rows</code> x <code>Cols</code>, except if <code>&lt;&lt;mat_traits,mat_traits&gt;&gt;&lt;M&gt;::rows==Rows &amp;&amp; mat_traits&lt;M&gt;::cols==Cols</code>, in which case it returns <code>M</code>, which is suitable only if <code>M</code> is a copyable type. Boost QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the deduce_mat template is for specifying the preferred matrix type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>[[deduce_mat2]] ==== <code>deduce_mat2</code></p>
<p>==== .#include <boost/qvm/deduce_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class A,class B,int Rows,int Cols&gt;
struct deduce_mat2 {

    typedef /*unspecified*/ type;

};</code></pre>
<h2 id="section-27">} }</h2>
<p>====</p>
<p>Requirements: ::</p>
<ul>
<li>Both <code>&lt;&lt;scalar,scalar&gt;&gt;&lt;A&gt;::type</code> and <code>scalar&lt;B&gt;::type</code> are well defined;</li>
<li><code>&lt;&lt;is_mat,is_mat&gt;&gt;&lt;A&gt;::value || is_mat&lt;B&gt;::value</code> is <code>true</code>;</li>
<li><code>is_mat&lt;deduce_mat2&lt;A,B&gt;::type&gt;::value</code> must be <code>true</code>;</li>
<li><code>deduce_mat2&lt;A,B&gt;::type</code> must be copyable;</li>
<li><code>&lt;&lt;mat_traits,mat_traits&gt;&gt;&lt;deduce_mat2&lt;A,B&gt;::type&gt;::rows==Rows</code>;</li>
<li><code>mat_traits&lt;deduce_mat2&lt;A,B&gt;::type&gt;::cols==Cols</code>.</li>
</ul>
<p>This template is used by Boost QVM whenever it needs to deduce a matrix type of certain dimensions from the types of two user-supplied function parameters. The returned type must have accessible copy constructor (the <code>A</code> and <code>B</code> types themselves could be non-copyable, and either one of them may be a non-matrix type.)</p>
<p>The main template definition returns an unspecified matrix type of the requested dimensions with &lt;<mat_traits,`scalar_type`>&gt; obtained by <code>&lt;&lt;deduce_scalar,deduce_scalar&gt;&gt;&lt;A,B&gt;::type</code>, except if <code>A</code> and <code>B</code> are the same matrix type <code>M</code> of dimensions <code>Rows</code> x <code>Cols</code>, in which case <code>M</code> is returned, which is only suitable for copyable types. Boost QVM also defines (partial) specializations for the non-copyable matrix types it produces. Users can define other (partial) specializations for their own types.</p>
<p>A typical use of the <code>deduce_mat2</code> template is for specifying the preferred matrix type to be returned by the generic function template overloads in Boost QVM depending on the type of their arguments.</p>
<p>'''</p>
<p>=== Built-in quaternion, vector and matrix types</p>
<p>Boost QVM defines several class templates (together with appropriate specializations of &lt;<quat_traits,`quat_traits`>&gt;, &lt;<vec_traits,`vec_traits`>&gt; and &lt;<mat_traits,`mat_traits`>&gt; templates) which can be used as generic quaternion, vector and matrix types. Using these types directly wouldn't be typical though, the main design goal of Boost QVM is to allow users to plug in their own quaternion, vector and matrix types.</p>
<p>[[quat]] ==== <code>quat</code></p>
<p>==== .#include <boost/qvm/quat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    template &lt;class T&gt;
    struct quat {

        T a[4];
    
        template &lt;class R&gt;
        operator R() const {
            R r;
            assign(r,*this);
            return r;
        }

    };
    
    template &lt;class Quaternion&gt;
    struct quat_traits;
    
    template &lt;class T&gt;
    struct quat_traits&lt; quat&lt;T&gt; &gt; {

        typedef T scalar_type;
    
        template &lt;int I&gt;
        static scalar_type read_element( quat&lt;T&gt; const &amp; x ) {
            return x.a[I];
        }

        template &lt;int I&gt;
        static scalar_type &amp; write_element( quat&lt;T&gt; &amp; x ) {
            return x.a[I];
        }

    };</code></pre>
<h2 id="section-28">} }</h2>
<p>====</p>
<p>This is a simple quaternion type. It converts to any other quaternion type.</p>
<p>The partial specialization of the &lt;<quat_traits,`quat_traits`>&gt; template makes the <code>quat</code> template compatible with the generic operations defined by Boost QVM.</p>
<p>'''</p>
<p>[[vec]] ==== <code>vec</code></p>
<p>==== .#include <boost/qvm/vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    template &lt;class T,int Dim&gt;
    struct vec {

        T a[Dim];
    
        template &lt;class R&gt;
        operator R() const {
            R r;
            assign(r,*this);
            return r;
        }

    };
    
    template &lt;class Vector&gt;
    struct vec_traits;
    
    template &lt;class T,int Dim&gt;
    struct vec_traits&lt; vec&lt;T,Dim&gt; &gt; {

        typedef T scalar_type;
        static int const dim=Dim;
    
        template &lt;int I&gt;
        static scalar_type read_element( vec&lt;T,Dim&gt; const &amp; x ) {
            return x.a[I];
        }
        template &lt;int I&gt;
        static scalar_type &amp; write_element( vec&lt;T,Dim&gt; &amp; x ) {
            return x.a[I];
        }
    
        static scalar_type read_element_idx( int i, vec&lt;T,Dim&gt; const &amp; x ) {
            return x.a[i];
        }

        static scalar_type &amp; write_element_idx( int i, vec&lt;T,Dim&gt; &amp; x ) {
            return x.a[i];
        }
    };</code></pre>
<h2 id="section-29">} }</h2>
<p>====</p>
<p>This is a simple vector type. It converts to any other vector type of compatible size.</p>
<p>The partial specialization of the &lt;<vec_traits,`vec_traits`>&gt; template makes the <code>vec</code> template compatible with the generic operations defined by Boost QVM.</p>
<p>'''</p>
<p>[[mat]] ==== <code>mat</code></p>
<p>==== .#include <boost/qvm/mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T,int Rows,int Cols&gt;
struct mat {

    T a[Rows][Cols];

    template &lt;class R&gt;
    operator R() const {
        R r;
        assign(r,*this);
        return r;
    }

};

template &lt;class Matrix&gt;
struct mat_traits;

template &lt;class T,int Rows,int Cols&gt;
struct mat_traits&lt; mat&lt;T,Rows,Cols&gt; &gt; {

    typedef T scalar_type;
    static int const rows=Rows;
    static int const cols=Cols;

    template &lt;int Row,int Col&gt;
    static scalar_type read_element( mat&lt;T,Rows,Cols&gt; const &amp; x ) {
        return x.a[Row][Col];
    }

    template &lt;int Row,int Col&gt;
    static scalar_type &amp; write_element( mat&lt;T,Rows,Cols&gt; &amp; x ) {
        return x.a[Row][Col];
    }

    static scalar_type read_element_idx( int row, int col, mat&lt;T,Rows,Cols&gt; const &amp; x ) {
        return x.a[row][col];
    }

    static scalar_type &amp; write_element_idx( int row, int col, mat&lt;T,Rows,Cols&gt; &amp; x ) {
        return x.a[row][col];
    }

};</code></pre>
<h2 id="section-30">} }</h2>
<p>====</p>
<p>This is a simple matrix type. It converts to any other matrix type of compatible size.</p>
<p>The partial specialization of the &lt;<mat_traits,`mat_traits`>&gt; template makes the <code>mat</code> template compatible with the generic operations defined by Boost QVM.</p>
<p>'''</p>
<p>=== Generic element access</p>
<p>[[quat_access]] ==== Quaternions</p>
<p>==== .#include <boost/qvm/quat_access.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;Q&gt;::value

template &lt;class Q&gt; -unspecified-return-type- S( Q &amp; q );
template &lt;class Q&gt; -unspecified-return-type- V( Q &amp; q );
template &lt;class Q&gt; -unspecified-return-type- X( Q &amp; q );
template &lt;class Q&gt; -unspecified-return-type- Y( Q &amp; q );
template &lt;class Q&gt; -unspecified-return-type- Z( Q &amp; q );</code></pre>
<h2 id="section-31">} }</h2>
<p>====</p>
<p>An expression of the form <code>S(q)</code> can be used to access the scalar component of the quaternion <code>q</code>. For example,</p>
<h2 id="sourcec-27">[source,c++]</h2>
<p>S(q) *= 42; ----</p>
<p>multiplies the scalar component of <code>q</code> by the scalar 42.</p>
<p>An expression of the form <code>V(q)</code> can be used to access the vector component of the quaternion <code>q</code>. For example,</p>
<h2 id="sourcec-28">[source,c++]</h2>
<p>V(q) *= 42 ----</p>
<p>multiplies the vector component of <code>q</code> by the scalar 42.</p>
<p>The <code>X</code>, <code>Y</code> and <code>Z</code> elements of the vector component can also be accessed directly using <code>X(q)</code>, <code>Y(q)</code> and <code>Z(q)</code>.</p>
<p>TIP: The return types are lvalues.</p>
<p>[[vec_access]] ==== Vectors</p>
<p>==== .#include <boost/qvm/vec_access.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_vec&lt;V&gt;::value

template &lt;int I,class V&gt; -unspecified-return-type- A( V &amp; v );
template &lt;class V&gt; -unspecified-return-type- A0( V &amp; v );
template &lt;class V&gt; -unspecified-return-type- A1( V &amp; v );
...
template &lt;class V&gt; -unspecified-return-type- A9( V &amp; v );

template &lt;class V&gt; -unspecified-return-type- X( V &amp; v );
template &lt;class V&gt; -unspecified-return-type- Y( V &amp; v );
template &lt;class V&gt; -unspecified-return-type- Z( V &amp; v );
template &lt;class V&gt; -unspecified-return-type- W( V &amp; v );</code></pre>
<h2 id="section-32">} }</h2>
<p>====</p>
<p>An expression of the form of <code>A&lt;I&gt;(v)</code> can be used to access the <code>I</code>-th element a vector object <code>v</code>. For example, the expression:</p>
<h2 id="sourcec-29">[source,c++]</h2>
<p>A&lt;1&gt;(v) *= 42; ----</p>
<p>can be used to multiply the element at index 1 (indexing in Boost QVM is always zero-based) of a vector <code>v</code> by 42.</p>
<p>For convenience, there are also non-template overloads for <code>I</code> from 0 to 9; an alternative way to write the above expression is:</p>
<h2 id="sourcec-30">[source,c++]</h2>
<p>A1(v) *= 42; ----</p>
<p><code>X</code>, <code>Y</code>, <code>Z</code> and <code>W</code> act the same as <code>A0</code>/<code>A1</code>/<code>A2</code>/<code>A3</code>; yet another alternative way to write the above expression is:</p>
<h2 id="sourcec-31">[source,c++]</h2>
<p>Y(v) *= 42; ----</p>
<p>TIP: The return types are lvalues.</p>
<p>[[swizzling]] ==== Vector element swizzling</p>
<p>==== .#include <boost/qvm/swizzle.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//*** Accessing vector elements by swizzling ***

//2D view proxies, only enabled if:
//  is_vec&lt;V&gt;::value
template &lt;class V&gt; -unspecified-2D-vector-type- XX( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- XY( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- XZ( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- XW( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- X0( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- X1( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- YX( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- YY( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- YZ( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- YW( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- Y0( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- Y1( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- ZX( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- ZY( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- ZZ( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- ZW( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- Z0( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- Z1( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- WX( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- WY( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- WZ( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- WW( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- W0( V &amp; v );
template &lt;class V&gt; -unspecified-2D-vector-type- W1( V &amp; v );
...
//2D view proxies, only enabled if:
//  is_scalar&lt;S&gt;::value
template &lt;class S&gt; -unspecified-2D-vector-type- X0( S &amp; s );
template &lt;class S&gt; -unspecified-2D-vector-type- X1( S &amp; s );
template &lt;class S&gt; -unspecified-2D-vector-type- XX( S &amp; s );
...
-unspecified-2D-vector-type- _00();
-unspecified-2D-vector-type- _01();
-unspecified-2D-vector-type- _10();
-unspecified-2D-vector-type- _11();

//3D view proxies, only enabled if:
//  is_vec&lt;V&gt;::value
template &lt;class V&gt; -unspecified-3D-vector-type- XXX( V &amp; v );
...
template &lt;class V&gt; -unspecified-3D-vector-type- XXW( V &amp; v );
template &lt;class V&gt; -unspecified-3D-vector-type- XX0( V &amp; v );
template &lt;class V&gt; -unspecified-3D-vector-type- XX1( V &amp; v );
template &lt;class V&gt; -unspecified-3D-vector-type- XYX( V &amp; v );
...
template &lt;class V&gt; -unspecified-3D-vector-type- XY1( V &amp; v );
...
template &lt;class V&gt; -unspecified-3D-vector-type- WW1( V &amp; v );
...
//3D view proxies, only enabled if:
//  is_scalar&lt;S&gt;::value
template &lt;class S&gt; -unspecified-3D-vector-type- X00( S &amp; s );
template &lt;class S&gt; -unspecified-3D-vector-type- X01( S &amp; s );
...
template &lt;class S&gt; -unspecified-3D-vector-type- XXX( S &amp; s );
template &lt;class S&gt; -unspecified-3D-vector-type- XX0( S &amp; s );
...
-unspecified-3D-vector-type- _000();
-unspecified-3D-vector-type- _001();
-unspecified-3D-vector-type- _010();
...
-unspecified-3D-vector-type- _111();

//4D view proxies, only enabled if:
//  is_vec&lt;V&gt;::value
template &lt;class V&gt; -unspecified-4D-vector-type- XXXX( V &amp; v );
...
template &lt;class V&gt; -unspecified-4D-vector-type- XXXW( V &amp; v );
template &lt;class V&gt; -unspecified-4D-vector-type- XXX0( V &amp; v );
template &lt;class V&gt; -unspecified-4D-vector-type- XXX1( V &amp; v );
template &lt;class V&gt; -unspecified-4D-vector-type- XXYX( V &amp; v );
...
template &lt;class V&gt; -unspecified-4D-vector-type- XXY1( V &amp; v );
...
template &lt;class V&gt; -unspecified-4D-vector-type- WWW1( V &amp; v );
...
//4D view proxies, only enabled if:
//  is_scalar&lt;S&gt;::value
template &lt;class S&gt; -unspecified-4D-vector-type- X000( S &amp; s );
template &lt;class S&gt; -unspecified-4D-vector-type- X001( S &amp; s );
...
template &lt;class S&gt; -unspecified-4D-vector-type- XXXX( S &amp; s );
template &lt;class S&gt; -unspecified-4D-vector-type- XX00( S &amp; s );
...
-unspecified-4D-vector-type- _0000();
-unspecified-4D-vector-type- _0001();
-unspecified-4D-vector-type- _0010();
...
-unspecified-4D-vector-type- _1111();         </code></pre>
<h2 id="section-33">} }</h2>
<p>====</p>
<p>Swizzling allows zero-overhead direct access to a (possibly rearranged) subset of the elements of 2D, 3D and 4D vectors. For example, if <code>v</code> is a 4D vector, the expression <code>YX(v) is a 2D view proxy whose</code>X<code>element refers to the</code>Y<code>element of</code>v<code>, and whose</code>Y<code>element refers to the</code>X<code>element of</code>v<code>. Like other view proxies</code>YX<code>is an lvalue, that is, if</code>v2` is a 2D vector, one could write:</p>
<h2 id="sourcec-32">[source,c++]</h2>
<h2 id="yxv-v2">YX(v) = v2;</h2>
<p>The above will leave the <code>Z</code> and <code>W</code> elements of <code>v</code> unchanged but assign the <code>Y</code> element of <code>v2</code> to the <code>X</code> element of <code>v</code> and the <code>X</code> element of <code>v2</code> to the <code>Y</code> element of <code>v</code>.</p>
<p>All permutations of <code>X</code>, <code>Y</code>, <code>Z</code>, <code>W</code>, <code>0</code>, <code>1</code> for 2D, 3D and 4D swizzling are available (if the first character of the swizzle identifier is <code>0</code> or <code>1</code>, it is preceded by a <code>_</code>, for example <code>_11XY</code>).</p>
<p>It is valid to use the same vector element more than once: the expression <code>ZZZ(v)</code> is a 3D vector whose <code>X</code>, <code>Y</code> and <code>Z</code> elements all refer to the <code>Z</code> element of <code>v</code>.</p>
<p>Finally, scalars can be &quot;swizzled&quot; to access them as vectors: the expression <code>_0X01(42.0f)</code> is a 4D vector with <code>X</code>=0, <code>Y</code>=42.0, <code>Z</code>=0, <code>W</code>=1.</p>
<p>[[mat_access]] ==== Matrices</p>
<p>==== .#include <boost/qvm/mat_access.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;Q&gt;::value

template &lt;int R,int C,class M&gt; -unspecified-return-type- A( M &amp; m );

template &lt;class M&gt; -unspecified-return-type- A00( M &amp; m );
template &lt;class M&gt; -unspecified-return-type- A01( M &amp; m );
...
template &lt;class M&gt; -unspecified-return-type- A09( M &amp; m );
template &lt;class M&gt; -unspecified-return-type- A10( M &amp; m );
...
template &lt;class M&gt; -unspecified-return-type- A99( M &amp; m );</code></pre>
<h2 id="section-34">} }</h2>
<p>====</p>
<p>An expression of the form <code>A&lt;R,C&gt;(m)</code> can be used to access the element at row <code>R</code> and column <code>C</code> of a matrix object <code>m</code>. For example, the expression:</p>
<h2 id="sourcec-33">[source,c++]</h2>
<p>A&lt;4,2&gt;(m) *= 42; ----</p>
<p>can be used to multiply the element at row 4 and column 2 of a matrix <code>m</code> by 42.</p>
<p>For convenience, there are also non-template overloads for <code>R</code> from <code>0</code> to <code>9</code> and <code>C</code> from <code>0</code> to <code>9</code>; an alternative way to write the above expression is:</p>
<h2 id="sourcec-34">[source,c++]</h2>
<p>A42(m) *= 42; ----</p>
<p>TIP: The return types are lvalues.</p>
<p>'''</p>
<p>=== Generic quaternion operations</p>
<p>[[quat_assign]] ==== <code>assign</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; assign( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-35">} }</h2>
<p>====</p>
<p>Effects: :: Copies all elements of the quaternion <code>b</code> to the quaternion <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[quat_convert_to]] ==== <code>convert_to</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;R&gt;::value &amp;&amp; is_quat&lt;A&gt;::value
template &lt;class R,class A&gt;
R convert_to( A const &amp; a );

//Only enabled if:
//  is_quat&lt;R&gt;::value &amp;&amp; is_mat&lt;A&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==3 &amp;&amp; mat_traits&lt;A&gt;::cols==3
template &lt;class R,class A&gt;
R convert_to( A const &amp; m );</code></pre>
<h2 id="section-36">} }</h2>
<p>====</p>
<p>Requirements: :: <code>R</code> must be copyable.</p>
<p>Effects: ::</p>
<ul>
<li><p>The first overload is equivalent to: <code>R r; assign(r,a); return r;</code></p></li>
<li><p>The second overload assumes that <code>m</code> is an orthonormal rotation matrix and converts it to a quaternion that performs the same rotation.</p></li>
</ul>
<p>'''</p>
<p>[[quat_minus_eq]] ==== <code>operator-=</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator-=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-37">} }</h2>
<p>====</p>
<p>Effects: :: Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[quat_minus_unary]] ==== <code>operator-</code> (unary)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<p>//Only enabled if: is_quat<A>::value template <class A> typename deduce_quat<A>::type operator-( A const &amp; a );</p>
<p>} }</p>
<h1 id="section-38">----</h1>
<p>Returns: :: A quaternion of the negated elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[quat_minus]] ==== <code>operator-</code> (binary)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_quat2&lt;A,B&gt;::type
operator-( A const &amp; a, B const &amp; b );</code></pre>
<p>} }</p>
<h1 id="section-39">----</h1>
<p>Returns: :: A quaternion with elements equal to the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_quat2,`deduce_quat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[quat_plus_eq]] ==== <code>operator+=</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator+=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-40">} }</h2>
<p>====</p>
<p>Effects: :: Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[quat_plus]] ==== <code>operator+</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value &amp;&amp;
template &lt;class A,class B&gt;
typename deduce_quat2&lt;A,B&gt;::type
operator+( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-41">} }</h2>
<p>====</p>
<p>Returns: :: A quaternion with elements equal to the elements of <code>a</code> added to the corresponding elements of <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_quat2,`deduce_quat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[quat_div_eq_scalar]] ==== <code>operator/=</code> (scalar)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator/=( A &amp; a, B b );</code></pre>
<h2 id="section-42">} }</h2>
<p>====</p>
<p>Effects: :: This operation divides a quaternion by a scalar.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[quat_div_scalar]] ==== <code>operator/</code> (scalar)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_quat&lt;A&gt;::type
operator/( A const &amp; a, B b );</code></pre>
<h2 id="section-43">} }</h2>
<p>====</p>
<p>Returns: :: A quaternion that is the result of dividing the quaternion <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[quat_mul_eq_scalar]] ==== <code>operator*=</code> (scalar)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator*=( A &amp; a, B b );</code></pre>
<h2 id="section-44">} }</h2>
<p>====</p>
<p>Effects: :: This operation multiplies the quaternion <code>a</code> by the scalar <code>b</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[quat_mul_eq]] ==== <code>operator*=</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator*=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-45">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- A tmp(a); a = tmp * b; return a; ----</p>
<p>'''</p>
<p>[[quat_mul_scalar]] ==== <code>operator*</code> (scalar)</p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_quat&lt;A&gt;::type
operator*( A const &amp; a, B b );</code></pre>
<h2 id="section-46">} }</h2>
<p>====</p>
<p>Returns: :: A quaternion that is the result of multiplying the quaternion <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[quat_mul]] ==== <code>operator*</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_quat2&lt;A,B&gt;::type
operator*( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-47">} }</h2>
<p>====</p>
<p>Returns: :: The result of multiplying the quaternions <code>a</code> and <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_quat2,`deduce_quat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[quat_eq]] ==== <code>operator==</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
bool operator==( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-48">} }</h2>
<p>====</p>
<p>Returns: :: <code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
<p>'''</p>
<p>[[quat_neq]] ==== <code>operator!=</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
bool operator!=( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-49">} }</h2>
<p>====</p>
<p>Returns: :: <code>!(a == b)</code>.</p>
<p>'''</p>
<p>[[quat_cmp]] ==== <code>cmp</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B,class Cmp&gt;
bool cmp( A const &amp; a, B const &amp; b, Cmp pred );</code></pre>
<h2 id="section-50">} }</h2>
<p>====</p>
<p>Returns: :: Similar to &lt;<quat_eq,`operator==`>&gt;, except that it uses the binary predicate <code>pred</code> to compare the individual quaternion elements.</p>
<p>'''</p>
<p>[[quat_mag_sqr]] ==== <code>mag_sqr</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
typename quat_traits&lt;A&gt;::scalar_type
mag_sqr( A const &amp; a );</code></pre>
<h2 id="section-51">} }</h2>
<p>====</p>
<p>Returns: :: The squared magnitude of the quaternion <code>a</code>.</p>
<p>'''</p>
<p>[[quat_mag]] ==== <code>mag</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
typename quat_traits&lt;A&gt;::scalar_type
mag( A const &amp; a );</code></pre>
<h2 id="section-52">} }</h2>
<p>====</p>
<p>Returns: :: The magnitude of the quaternion <code>a</code>.</p>
<p>'''</p>
<p>[[quat_normalized]] ==== <code>normalized</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
typename deduce_quat&lt;A&gt;::type
normalized( A const &amp; a );</code></pre>
<h2 id="section-53">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- typename deduce_quat<A>::type tmp; assign(tmp,a); normalize(tmp); return tmp; ----</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[quat_normalize]] ==== <code>normalize</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void normalize( A &amp; a );</code></pre>
<h2 id="section-54">} }</h2>
<p>====</p>
<p>Effects: :: Normalizes <code>a</code>.</p>
<p>Postcondition: :: <code>mag(a)==scalar_traits&lt;typename quat_traits&lt;A&gt;::scalar_type&gt;::value(1).</code></p>
<p>Throws: :: If the magnitude of <code>a</code> is zero, throws &lt;<zero_magnitude_error,`zero_magnitude_error`>&gt;.</p>
<p>'''</p>
<p>[[quat_dot]] ==== <code>dot</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_scalar&lt;A,B&gt;::type
dot( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-55">} }</h2>
<p>====</p>
<p>Returns: :: The dot product of the quaternions <code>a</code> and <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_scalar,`deduce_scalar`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[conjugate]] ==== <code>conjugate</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
typename deduce_quat&lt;A&gt;::type
conjugate( A const &amp; a );</code></pre>
<h2 id="section-56">} }</h2>
<p>====</p>
<p>Returns: :: Computes the conjugate of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[quat_inverse]] ==== <code>inverse</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
typename deduce_quat&lt;A&gt;::type
inverse( A const &amp; a );</code></pre>
<h2 id="section-57">} }</h2>
<p>====</p>
<p>Returns: :: Computes the multiplicative inverse of <code>a</code>, or the conjugate-to-norm ratio.</p>
<p>Throws: :: If the magnitude of <code>a</code> is zero, throws &lt;<zero_magnitude_error,`zero_magnitude_error`>&gt;.</p>
<p>TIP: If <code>a</code> is known to be unit length, <code>conjugate</code> is equivalent to &lt;<quat_inverse,`inverse`>&gt;, yet it is faster to compute.</p>
<p>NOTE: The &lt;<deduce_quat,`deduce_quat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[slerp]] ==== <code>slerp</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp; is_quat&lt;B&gt;::value &amp;&amp; is_scalar&lt;C&gt;
template &lt;class A,class B,class C&gt;
typename deduce_quat2&lt;A,B&gt; &gt;::type
slerp( A const &amp; a, B const &amp; b, C c );</code></pre>
<h2 id="section-58">} }</h2>
<p>====</p>
<p>Preconditions: :: <code>t&gt;=0 &amp;&amp; t\&lt;=1</code>.</p>
<p>Returns: :: A quaternion that is the result of Spherical Linear Interpolation of the quaternions <code>a</code> and <code>b</code> and the interpolation parameter <code>c</code>. When <code>slerp</code> is applied to unit quaternions, the quaternion path maps to a path through 3D rotations in a standard way. The effect is a rotation with uniform angular velocity around a fixed rotation axis.</p>
<p>NOTE: The &lt;<deduce_quat2,`deduce_quat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[zero_quat]] ==== <code>zero_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
-unspecified-return-type- zero_quat();</code></pre>
<h2 id="section-59">} }</h2>
<p>====</p>
<p>Returns: :: A read-only quaternion of unspecified type with &lt;<scalar_traits,`scalar_type`>&gt; <code>T</code>, with all elements equal to &lt;<scalar_traits,`scalar_traits<T>::value(0)`&gt;&gt;.</p>
<p>'''</p>
<p>[[quat_set_zero]] ==== <code>set_zero</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void set_zero( A &amp; a );</code></pre>
<h2 id="section-60">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign(a, zero_quat<typename quat_traits<A>::scalar_type&gt;()); ----</p>
<p>'''</p>
<p>[[identity_quat]] ==== <code>identity_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class S&gt;
-unspecified-return-type- identity_quat();</code></pre>
<h2 id="section-61">} }</h2>
<p>====</p>
<p>Returns: :: An identity quaternion with scalar type <code>S</code>.</p>
<p>'''</p>
<p>[[quat_set_identity]] ==== <code>set_identity</code> ==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void set_identity( A &amp; a );</code></pre>
<h2 id="section-62">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, identity_quat<typename quat_traits<A>::scalar_type&gt;()); ----</p>
<p>'''</p>
<p>[[rot_quat]] ==== <code>rot_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_vec&lt;A&gt;::value &amp;&amp; vec_traits&lt;A&gt;::dim==3
template &lt;class A&gt;
-unspecified-return-type- rot_quat( A const &amp; axis, typename vec_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-63">} }</h2>
<p>====</p>
<p>Returns: :: A quaternion of unspecified type which performs a rotation around the <code>axis</code> at <code>angle</code> radians.</p>
<p>Throws: :: In case the axis vector has zero magnitude, throws &lt;<zero_magnitude_error,`zero_magnitude_error`>&gt;.</p>
<p>NOTE: The <code>rot_quat</code> function is not a &lt;<view_proxy,view proxy>&gt;; it returns a temp object.</p>
<p>'''</p>
<p>[[quat_set_rot]] ==== <code>set_rot</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp;
//  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
template &lt;class A&gt;
void set_rot( A &amp; a, B const &amp; axis, typename vec_traits&lt;B&gt;::scalar_type angle );</code></pre>
<h2 id="section-64">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, rot_quat(axis,angle)); ----</p>
<p>'''</p>
<p>[[quat_rotate]] ==== <code>rotate</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_quat&lt;A&gt;::value &amp;&amp;
//  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
template &lt;class A,class B&gt;
void rotate( A &amp; a, B const &amp; axis, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-65">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a *= &lt;&lt;rot_quat,rot_quat&gt;&gt;(axis,angle)</code>.</p>
<p>'''</p>
<p>[[rotx_quat]] ==== <code>rotx_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class Angle&gt;
-unspecified-return-type- rotx_quat( Angle const &amp; angle );</code></pre>
<h2 id="section-66">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the X axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[quat_set_rotx]] ==== <code>set_rotx</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void set_rotx( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-67">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, rotx_quat(angle)); ----</p>
<p>'''</p>
<p>[[quat_rotate_x]] ==== <code>rotate_x</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void rotate_x( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-68">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a *= &lt;&lt;rotx_quat,rotx_quat&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[roty_quat]] ==== <code>roty_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class Angle&gt;
-unspecified-return-type- roty_quat( Angle const &amp; angle );</code></pre>
<h2 id="section-69">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the Y axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[quat_set_roty]] ==== <code>set_roty</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void set_rotz( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-70">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, roty_quat(angle)); ----</p>
<p>'''</p>
<p>[[quat_rotate_y]] ==== <code>rotate_y</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void rotate_y( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-71">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a *= &lt;&lt;roty_quat,roty_quat&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[rotz_quat]] ==== <code>rotz_quat</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    template &lt;class Angle&gt;
    -unspecified-return-type- rotz_quat( Angle const &amp; angle );</code></pre>
<h2 id="section-72">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; quaternion of unspecified type and scalar type <code>Angle</code>, which performs a rotation around the Z axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[quat_set_rotz]] ==== <code>set_rotz</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void set_rotz( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-73">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, rotz_quat(angle)); ----</p>
<p>'''</p>
<p>[[quat_rotate_z]] ==== <code>rotate_z</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
void rotate_z( A &amp; a, typename quat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-74">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a *= &lt;&lt;rotz_quat,rotz_quat&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[quat_scalar_cast]] ==== <code>scalar_cast</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class Scalar,class A&gt;
-unspecified-return_type- scalar_cast( A const &amp; a );</code></pre>
<h2 id="section-75">} }</h2>
<p>====</p>
<p>Returns: :: A read-only &lt;<view_proxy,view proxy>&gt; of <code>a</code> that looks like a quaternion of the same dimensions as <code>a</code>, but with &lt;<quat_traits,`scalar_type`>&gt; <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
<p>'''</p>
<p>[[qref]] ==== <code>qref</code></p>
<p>==== .#include <boost/qvm/quat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_quat&lt;A&gt;::value
template &lt;class A&gt;
-unspecified-return-type- qref( A &amp; a );</code></pre>
<h2 id="section-76">} }</h2>
<p>====</p>
<p>Returns: :: An identity view proxy of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
<p>TIP: <code>qref</code> allows calling Boost QVM operations when <code>a</code> is of built-in type, for example a plain old C array.</p>
<p>'''</p>
<p>=== Generic vector operations</p>
<p>[[vec_assign]] ==== <code>assign</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; assign( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-77">} }</h2>
<p>====</p>
<p>Effects: :: Copies all elements of the vector <code>b</code> to the vector <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[vec_convert_to]] ==== <code>convert_to</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;R&gt;::value &amp;&amp; is_vec&lt;A&gt;::value &amp;&amp;
    //  vec_traits&lt;R&gt;::dim==vec_traits&lt;A&gt;::dim
    template &lt;class R,class A&gt;
    R convert_to( A const &amp; a );</code></pre>
<h2 id="section-78">} }</h2>
<p>====</p>
<p>Requirements: :: <code>R</code> must be copyable.</p>
<p>Effects: :: As if: <code>R r; assign(r,a); return r;</code></p>
<p>'''</p>
<p>[[vec_minus_eq]] ==== <code>operator-=</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; operator-=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-79">} }</h2>
<p>====</p>
<p>Effects: :: Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[vec_minus_unary]] ==== <code>operator-</code> (unary)</p>
<p>operator-(vec)</p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    operator-( A const &amp; a );</code></pre>
<h2 id="section-80">} }</h2>
<p>====</p>
<p>Returns: :: A vector of the negated elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_vec,`deduce_vec`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[vec_minus]] ==== <code>operator-</code> (binary)</p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,vec_traits&lt;A&gt;::dim&gt;::type
    operator-( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-81">} }</h2>
<p>====</p>
<p>Returns: :: A vector of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_vec2,`deduce_vec2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[vec_plus_eq]] ==== <code>operator+=</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    A &amp; operator+=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-82">} }</h2>
<p>====</p>
<p>Effects: :: Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[vec_plus]] ==== <code>operator+</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,vec_traits&lt;A&gt;::dim&gt;::type
    operator+( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-83">} }</h2>
<p>====</p>
<p>Returns: :: A vector of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> added to the corresponding elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_vec2,`deduce_vec2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[vec_div_eq_scalar]] ==== <code>operator/=</code> (scalar)</p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    A &amp; operator/=( A &amp; a, B b );</code></pre>
<h2 id="section-84">} }</h2>
<p>====</p>
<p>Effects: :: This operation divides a vector by a scalar.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[vec_div_scalar]] ==== <code>operator/</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    typename deduce_vec&lt;A&gt;::type
    operator/( A const &amp; a, B b );</code></pre>
<h2 id="section-85">} }</h2>
<p>====</p>
<p>Returns: :: A vector that is the result of dividing the vector <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_vec,`deduce_vec`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[vec_mul_eq_scalar]] ==== <code>operator*=</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A,class B&gt;
    A &amp; operator*=( A &amp; a, B b );</code></pre>
<h2 id="section-86">} }</h2>
<p>====</p>
<p>Effects: :: This operation multiplies the vector <code>a</code> by the scalar <code>b</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[vec_mul_scalar]] ==== <code>operator*</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    operator*( A const &amp; a, B b );</code></pre>
<h2 id="section-87">} }</h2>
<p>====</p>
<p>Returns: :: A vector that is the result of multiplying the vector <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_vec,`deduce_vec`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[vec_eq]] ==== <code>operator==</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    bool operator==( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-88">} }</h2>
<p>====</p>
<p>Returns: :: <code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
<p>'''</p>
<p>[[vec_neq]] ==== <code>operator!=</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    bool operator!=( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-89">} }</h2>
<p>====</p>
<p>Returns: :: <code>!(a == b)</code>.</p>
<p>'''</p>
<p>[[vec_cmp]] ==== <code>cmp</code></p>
<h2 id="section-90">====</h2>
<p>.#include <boost/qvm/mat_operations.hpp></p>
<p>namespace boost { namespace qvm { //Only enabled if: // is_mat<A>::value &amp;&amp; is_mat<B>::value &amp;&amp; // mat_traits<A>::rows==mat_traits<B>::rows &amp;&amp; // mat_traits<A>::cols==mat_traits<B>::cols template <class A,class B,class Cmp> bool cmp( A const &amp; a, B const &amp; b, Cmp pred );</p>
<h2 id="section-91">} }</h2>
<p>====</p>
<p>Returns: :: Similar to &lt;<vec_eq,`operator==`>&gt;, except that the individual elements of <code>a</code> and <code>b</code> are passed to the binary predicate <code>pred</code> for comparison.</p>
<p>'''</p>
<p>[[vec_mag_sqr]] ==== <code>mag_sqr</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename vec_traits&lt;A&gt;::scalar_type
    mag_sqr( A const &amp; a );</code></pre>
<h2 id="section-92">} }</h2>
<p>====</p>
<p>Returns: :: The squared magnitude of the vector <code>a</code>.</p>
<p>'''</p>
<p>[[vec_mag]] ==== <code>mag</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename vec_traits&lt;A&gt;::scalar_type
    mag( A const &amp; a );</code></pre>
<h2 id="section-93">} }</h2>
<p>====</p>
<p>Returns: :: The magnitude of the vector <code>a</code>.</p>
<p>'''</p>
<p>[[vec_normalized]] ==== <code>normalized</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    typename deduce_vec&lt;A&gt;::type
    normalized( A const &amp; a );</code></pre>
<h2 id="section-94">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- typename deduce_vec<A>::type tmp; assign(tmp,a); normalize(tmp); return tmp; ----</p>
<p>NOTE: The &lt;<deduce_vec,`deduce_vec`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[vec_normalize]] ==== <code>normalize</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    void normalize( A &amp; a );</code></pre>
<h2 id="section-95">} }</h2>
<p>====</p>
<p>Effects: :: Normalizes <code>a</code>.</p>
<p>Postcondition:</p>
<p><code>mag(a)==&lt;&lt;scalar_traits,scalar_traits&gt;&gt;&lt;typename &lt;&lt;vec_traits,vec_traits&lt;A&gt;::scalar_type&gt;&gt;&gt;::value(1)</code>.</p>
<p>Throws: :: If the magnitude of <code>a</code> is zero, throws &lt;<zero_magnitude_error,`zero_magnitude_error`>&gt;.</p>
<p>'''</p>
<p>[[vec_dot]] ==== <code>dot</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==vec_traits&lt;B&gt;::dim
    template &lt;class A,class B&gt;
    typename deduce_scalar&lt;A,B&gt;::type
    dot( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-96">} }</h2>
<p>====</p>
<p>Returns: :: The dot product of the vectors <code>a</code> and <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_scalar,`deduce_scalar`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[vec_cross]] ==== <code>cross</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
    //  vec_traits&lt;A&gt;::dim==3 &amp;&amp; vec_traits&lt;B&gt;::dim==3
    template &lt;class A,class B&gt;
    typename deduce_vec2&lt;A,B,3&gt;::type
    cross( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-97">} }</h2>
<p>====</p>
<p>Returns: :: The cross product of the vectors <code>a</code> and <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_vec2,`deduce_vec2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[zero_vec]] ==== <code>zero_vec</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    template &lt;class T,int S&gt;
    -unspecified-return-type- zero_vec();</code></pre>
<h2 id="section-98">} }</h2>
<p>====</p>
<p>Returns: :: A read-only vector of unspecified type with &lt;<vec_traits,`scalar_type`>&gt; <code>T</code> and size <code>S</code>, with all elements equal to &lt;<scalar_traits,`scalar_traits<T>::value(0)`&gt;&gt;.</p>
<p>'''</p>
<p>[[vec_set_zero]] ==== <code>set_zero</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if:
    //  is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    void set_zero( A &amp; a );</code></pre>
<h2 id="section-99">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign(a, zero_vec&lt; typename vec_traits<A>::scalar_type, vec_traits<A>::dim&gt;()); ----</p>
<p>'''</p>
<p>[[vec_scalar_cast]] ==== <code>scalar_cast</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class Scalar,class A&gt;
    -unspecified-return_type- scalar_cast( A const &amp; a );</code></pre>
<h2 id="section-100">} }</h2>
<p>====</p>
<p>Returns: :: A read-only &lt;<view_proxy,view proxy>&gt; of <code>a</code> that looks like a vector of the same dimensions as <code>a</code>, but with &lt;<vec_traits,`scalar_type`>&gt; <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
<p>'''</p>
<p>[[vref]] ==== <code>vref</code></p>
<p>==== .#include <boost/qvm/vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>    //Only enabled if: is_vec&lt;A&gt;::value
    template &lt;class A&gt;
    -unspecified-return-type- vref( A &amp; a );</code></pre>
<h2 id="section-101">} }</h2>
<p>====</p>
<p>Returns: :: An identity &lt;<view_proxy,view proxy>&gt; of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
<p>TIP: <code>vref</code> allows calling Boost QVM operations when <code>a</code> is of built-in type, for example a plain old C array.</p>
<p>'''</p>
<p>=== Generic matrix operations</p>
<p>[[mat_assign]] ==== <code>assign</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
A &amp; assign( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-102">} }</h2>
<p>====</p>
<p>Effects: :: Copies all elements of the matrix <code>b</code> to the matrix <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[mat_convert_to]] ==== <code>convert_to</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;R&gt;::value &amp;&amp; is_mat&lt;A&gt;::value &amp;&amp;
//  mat_traits&lt;R&gt;::rows==mat_traits&lt;A&gt;::rows &amp;&amp;
//  mat_traits&lt;R&gt;::cols==mat_traits&lt;A&gt;::cols
template &lt;class R,class A&gt;
R convert_to( A const &amp; a );</code></pre>
<h2 id="section-103">} }</h2>
<p>====</p>
<p>Requirements: :: <code>R</code> must be copyable.</p>
<p>Effects:</p>
<p>As if: <code>R r; &lt;&lt;mat_assign,assign&gt;&gt;(r,a); return r;</code></p>
<p>'''</p>
<p>[[mat_minus_eq_scalar]] ==== <code>operator-=</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
A &amp; operator-=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-104">} }</h2>
<p>====</p>
<p>Effects: :: Subtracts the elements of <code>b</code> from the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[mat_minus_unary]] ==== <code>operator-</code> (unary)</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;class A&gt;
typename deduce_mat&lt;A&gt;::type
operator-( A const &amp; a );</code></pre>
<h2 id="section-105">} }</h2>
<p>====</p>
<p>Returns: :: A matrix of the negated elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_mat,`deduce_mat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[mat_minus]] ==== <code>operator-</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;A&gt;::cols&gt;::type
operator-( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-106">} }</h2>
<p>====</p>
<p>Returns: :: A matrix of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> subtracted from the corresponding elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_mat2,`deduce_mat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[mat_plus_eq_scalar]] ==== <code>operator+=</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
A &amp; operator+=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-107">} }</h2>
<p>====</p>
<p>Effects: :: Adds the elements of <code>b</code> to the corresponding elements of <code>a</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[mat_plus]] ==== <code>operator+</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;A&gt;::cols&gt;::type
operator+( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-108">} }</h2>
<p>====</p>
<p>Returns: :: A matrix of the same size as <code>a</code> and <code>b</code>, with elements the elements of <code>b</code> added to the corresponding elements of <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_mat2,`deduce_mat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[mat_div_eq_scalar]] ==== <code>operator/=</code> (scalar)</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator/=( A &amp; a, B b );</code></pre>
<h2 id="section-109">} }</h2>
<p>====</p>
<p>Effects: :: This operation divides a matrix by a scalar.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[mat_div_scalar]] ==== <code>operator/</code> (scalar)</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_mat&lt;A&gt;::type
operator/( A const &amp; a, B b );</code></pre>
<h2 id="section-110">} }</h2>
<p>====</p>
<p>Returns: :: A matrix that is the result of dividing the matrix <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_mat,`deduce_mat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[mat_mul_eq]] ==== <code>operator*=</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
A &amp; operator*=( A &amp; a, B const &amp; b );</code></pre>
<h2 id="section-111">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- A tmp(a); a = tmp * b; return a; ----</p>
<p>'''</p>
<p>[[mat_mul_eq_scalar]] ==== <code>operator*=</code> (scalar)</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
A &amp; operator*=( A &amp; a, B b );</code></pre>
<h2 id="section-112">} }</h2>
<p>====</p>
<p>Effects: :: This operation multiplies the matrix <code>a</code> matrix by the scalar <code>b</code>.</p>
<p>Returns: :: <code>a</code>.</p>
<p>'''</p>
<p>[[mat_mul]] ==== <code>operator*</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::rows
template &lt;class A,class B&gt;
typename deduce_mat2&lt;A,B,mat_traits&lt;A&gt;::rows,mat_traits&lt;B&gt;::cols&gt;::type
operator*( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-113">} }</h2>
<p>====</p>
<p>Returns: :: The result of https://en.wikipedia.org/wiki/Matrix_multiplication[multiplying] the matrices <code>a</code> and <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_mat2,`deduce_mat2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[mat_mul_scalar]] ==== <code>operator*</code> (scalar)</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
template &lt;class A,class B&gt;
typename deduce_mat&lt;A&gt;::type
operator*( A const &amp; a, B b );

//Only enabled if: is_scalar&lt;B&gt;::value &amp;&amp; is_mat&lt;A&gt;::value
template &lt;class B,class A&gt;
typename deduce_mat&lt;A&gt;::type
operator*( B b, A const &amp; a );</code></pre>
<h2 id="section-114">} }</h2>
<p>====</p>
<p>Returns: :: A matrix that is the result of multiplying the matrix <code>a</code> by the scalar <code>b</code>.</p>
<p>NOTE: The &lt;<deduce_mat,`deduce_mat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[mat_eq]] ==== <code>operator==</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
bool operator==( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-115">} }</h2>
<p>====</p>
<p>Returns: :: <code>true</code> if each element of <code>a</code> compares equal to its corresponding element of <code>b</code>, <code>false</code> otherwise.</p>
<p>'''</p>
<p>[[mat_neq]] ==== <code>operator!=</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B&gt;
bool operator!=( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-116">} }</h2>
<p>====</p>
<p>Returns: :: <code>!( a &lt;&lt;mat_eq,=\=&gt;&gt; b )</code>.</p>
<p>'''</p>
<p>[[mat_cmp]] ==== <code>cmp</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_mat&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;B&gt;::rows &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;B&gt;::cols
template &lt;class A,class B,class Cmp&gt;
bool cmp( A const &amp; a, B const &amp; b, Cmp pred );</code></pre>
<h2 id="section-117">} }</h2>
<p>====</p>
<p>Returns: :: Similar to &lt;<mat_eq,`operator==`>&gt;, except that the individual elements of <code>a</code> and <code>b</code> are passed to the binary predicate <code>pred</code> for comparison.</p>
<p>'''</p>
<p>[[mat_inverse]] ==== <code>inverse</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_scalar&lt;B&gt;::value
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols

template &lt;class A,class B&gt;
typename deduce_mat&lt;A&gt;::type
inverse( A const &amp; a, B det );

template &lt;class A&gt;
typename deduce_mat&lt;A&gt;::type
inverse( A const &amp; a );</code></pre>
<h2 id="section-118">} }</h2>
<p>====</p>
<p>Preconditions: :: <code>det!=&lt;&lt;scalar_traits,scalar_traits&gt;&gt;&lt;typename &lt;&lt;mat_traits,mat_traits&lt;A&gt;::scalar_type&gt;&gt;&gt;::value(0)</code></p>
<p>Returns: :: Both overloads compute the inverse of <code>a</code>. The first overload takes the pre-computed determinant of <code>a</code>.</p>
<p>Throws: :: The second overload computes the determinant automatically and throws &lt;<zero_determinant_error,`zero_determinant_error`>&gt; if the computed determinant is zero.</p>
<p>NOTE: The &lt;<deduce_mat,`deduce_mat`>&gt; template can be specialized to deduce the desired return type from the type <code>A</code>.</p>
<p>'''</p>
<p>[[zero_mat]] ==== <code>zero_mat</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T,int D&gt;
-unspecified-return-type- zero_mat();

template &lt;class T,int R,int C&gt;
-unspecified-return-type- zero_mat();</code></pre>
<h2 id="section-119">} }</h2>
<p>====</p>
<p>Returns: :: A read-only matrix of unspecified type with &lt;<mat_traits,`scalar_type`>&gt; <code>T</code>, <code>R</code> rows and <code>C</code> columns (or <code>D</code> rows and <code>D</code> columns), with all elements equal to &lt;<scalar_traits,`scalar_traits<T>::value(0)`&gt;&gt;.</p>
<p>'''</p>
<p>[[mat_set_zero]] ==== <code>set_zero</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value
template &lt;class A&gt;
void set_zero( A &amp; a );</code></pre>
<h2 id="section-120">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign(a, zero_mat&lt; typename mat_traits<A>::scalar_type, mat_traits<A>::rows, mat_traits<A>::cols&gt;()); ----</p>
<p>'''</p>
<p>[[identity_mat]] ==== <code>identity_mat</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class S,int D&gt;
-unspecified-return-type- identity_mat();</code></pre>
<h2 id="section-121">} }</h2>
<p>====</p>
<p>Returns: :: An identity matrix of size <code>D</code> x <code>D</code> and scalar type <code>S</code>.</p>
<p>'''</p>
<p>[[mat_set_identity]] ==== <code>set_identity</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::cols==mat_traits&lt;A&gt;::rows
template &lt;class A&gt;
void set_identity( A &amp; a );</code></pre>
<h2 id="section-122">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, identity_mat&lt; typename mat_traits<A>::scalar_type, mat_traits<A>::rows, mat_traits<A>::cols&gt;()); ----</p>
<p>'''</p>
<p>[[rot_mat]] ==== <code>rot_mat</code> / Euler angles</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_vec&lt;A&gt;::value &amp;&amp; vec_traits&lt;A&gt;::dim==3
template &lt;int Dim,class A,class Angle&gt;
-unspecified-return-type-
rot_mat( A const &amp; axis, Angle angle );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_xzy( Angle x1, Angle z2, Angle y3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_xyz( Angle x1, Angle y2, Angle z3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_yxz( Angle y1, Angle x2, Angle z3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_yzx( Angle y1, Angle z2, Angle x3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_zyx( Angle z1, Angle y2, Angle x3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_zxy( Angle z1, Angle x2, Angle y3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_xzx( Angle x1, Angle z2, Angle x3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_xyx( Angle x1, Angle y2, Angle x3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_yxy( Angle y1, Angle x2, Angle y3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_yzy( Angle y1, Angle z2, Angle y3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_zyz( Angle z1, Angle y2, Angle z3 );

template &lt;int Dim,class Angle&gt;
-unspecified-return-type-
rot_mat_zxz( Angle z1, Angle y2, Angle z3 );</code></pre>
<h2 id="section-123">} }</h2>
<p>====</p>
<p>Returns: :: A matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns parameter, which performs a rotation around the <code>axis</code> at <code>angle</code> radians, or TaitBryan angles (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z), or proper Euler angles (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y). See https://en.wikipedia.org/wiki/Euler_angles[Euler angles].</p>
<p>Throws: :: In case the axis vector has zero magnitude, throws &lt;<zero_magnitude_error,`zero_magnitude_error`>&gt;.</p>
<p>NOTE: These functions are not view proxies; they return a temp object.</p>
<p>'''</p>
<p>[[mat_set_rot]] ==== <code>set_rot</code> / Euler angles</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
//  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
template &lt;class A&gt;
void set_rot( A &amp; a, B const &amp; axis, typename vec_traits&lt;B&gt;::scalar_type angle );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_xyz( A &amp; a, Angle x1, Angle y2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_yxz( A &amp; a, Angle y1, Angle x2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_yzx( A &amp; a, Angle y1, Angle z2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_zyx( A &amp; a, Angle z1, Angle y2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_zxy( A &amp; a, Angle z1, Angle x2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_xzx( A &amp; a, Angle x1, Angle z2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_xyx( A &amp; a, Angle x1, Angle y2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_yxy( A &amp; a, Angle y1, Angle x2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_yzy( A &amp; a, Angle y1, Angle z2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_zyz( A &amp; a, Angle z1, Angle y2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_zxz( A &amp; a, Angle z1, Angle x2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void set_rot_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );</code></pre>
<h2 id="section-124">} }</h2>
<p>====</p>
<p>Effects: :: Assigns the return value of the corresponding &lt;<rot_mat,`rot_mat`>&gt; function to <code>a</code>.</p>
<p>'''</p>
<p>[[mat_rotate]] ==== <code>rotate</code> / Euler angles</p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp;
//  is_vec&lt;B&gt;::value &amp;&amp; vec_traits&lt;B&gt;::dim==3
template &lt;class A,class B&gt;
void rotate( A &amp; a, B const &amp; axis, typename mat_traits&lt;A&gt;::scalar_type angle );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_xzy( A &amp; a, Angle x1, Angle z2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_xyz( A &amp; a, Angle x1, Angle y2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_yxz( A &amp; a, Angle y1, Angle x2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_yzx( A &amp; a, Angle y1, Angle z2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_zyx( A &amp; a, Angle z1, Angle y2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_zxy( A &amp; a, Angle z1, Angle x2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_xzx( A &amp; a, Angle x1, Angle z2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_xyx( A &amp; a, Angle x1, Angle y2, Angle x3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_yxy( A &amp; a, Angle y1, Angle x2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_yzy( A &amp; a, Angle y1, Angle z2, Angle y3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_zyz( A &amp; a, Angle z1, Angle y2, Angle z3 );

//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A,class Angle&gt;
void rotate_zxz( A &amp; a, Angle z1, Angle x2, Angle z3 );</code></pre>
<h2 id="section-125">} }</h2>
<p>====</p>
<p>Effects: :: Multiplies the matrix <code>a</code> in-place by the return value of the corresponding &lt;<rot_mat,`rot_mat`>&gt; function.</p>
<p>'''</p>
<p>[[rotx_mat]] ==== <code>rotx_mat</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int Dim,class Angle&gt;
-unspecified-return-type- rotx_mat( Angle const &amp; angle );</code></pre>
<h2 id="section-126">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>X</code> axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[mat_set_rotx]] ==== <code>set_rotx</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void set_rotx( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-127">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, rotx_mat<mat_traits<A>::rows&gt;(angle)); ----</p>
<p>'''</p>
<p>[[mat_rotate_x]] ==== <code>rotate_x</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void rotate_x( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-128">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a &lt;&lt;mat_mul_eq,*\=&gt;&gt; &lt;&lt;rotx_mat,rotx_mat&gt;&gt;&lt;&lt;&lt;mat_traits,mat_traits&lt;A&gt;::rows&gt;&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[roty_mat]] ==== <code>roty_mat</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int Dim,class Angle&gt;
-unspecified-return-type- roty_mat( Angle const &amp; angle );</code></pre>
<h2 id="section-129">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>Y</code> axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[mat_set_roty]] ==== <code>set_roty</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void set_roty( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-130">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, roty_mat<mat_traits<A>::rows&gt;(angle)); ----</p>
<p>'''</p>
<p>[[mat_rotate_y]] ==== <code>rotate_y</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void rotate_y( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-131">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a &lt;&lt;mat_mul_eq,*\=&gt;&gt; &lt;&lt;roty_mat,roty_mat&gt;&gt;&lt;&lt;&lt;mat_traits,mat_traits&lt;A&gt;::rows&gt;&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[rotz_mat]] ==== <code>rotz_mat</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int Dim,class Angle&gt;
-unspecified-return-type- rotz_mat( Angle const &amp; angle );</code></pre>
<h2 id="section-132">} }</h2>
<p>====</p>
<p>Returns: :: A &lt;<view_proxy,view proxy>&gt; matrix of unspecified type, of <code>Dim</code> rows and <code>Dim</code> columns and scalar type <code>Angle</code>, which performs a rotation around the <code>Z</code> axis at <code>angle</code> radians.</p>
<p>'''</p>
<p>[[mat_set_rotz]] ==== <code>set_rotz</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void set_rotz( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-133">} }</h2>
<p>====</p>
<p>Effects: :: As if: + [source,c++] ---- assign( a, rotz_mat<mat_traits<A>::rows&gt;(angle)); ----</p>
<p>'''</p>
<p>[[mat_rotate_z]] ==== <code>rotate_z</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3 &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
void rotate_z( A &amp; a, typename mat_traits&lt;A&gt;::scalar_type angle );</code></pre>
<h2 id="section-134">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>a &lt;&lt;mat_mul_eq,*\=&gt;&gt; &lt;&lt;rotz_mat,rotz_mat&gt;&gt;&lt;&lt;&lt;mat_traits,mat_traits&lt;A&gt;::rows&gt;&gt;&gt;(angle)</code>.</p>
<p>'''</p>
<p>[[determinant]] ==== <code>determinant</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols
template &lt;class A&gt;
mat_traits&lt;A&gt;::scalar_type
determinant( A const &amp; a );</code></pre>
<h2 id="section-135">} }</h2>
<p>====</p>
<p>This function computes the https://en.wikipedia.org/wiki/Determinant[determinant] of the square matrix <code>a</code>.</p>
<p>'''</p>
<p>[[perspective_lh]] ==== <code>perspective_lh</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
-unspecified-return-type-
perspective_lh( T fov_y, T aspect, T zn, T zf );</code></pre>
<h2 id="section-136">} }</h2>
<p>====</p>
<p>Returns: :: A 4x4 projection matrix of unspecified type of the following form: + [cols=&quot;<sup>v,</sup>v,<sup>v,</sup>v&quot;,width=&quot;50%&quot;] |==== | <code>xs</code> | 0 | 0 | 0 | 0 | <code>ys</code> | 0 | 0 | 0 | 0 | <code>zf</code>/(<code>zf</code>-<code>zn</code>) | -<code>zn</code>*<code>zf</code>/(<code>zf</code>-<code>zn</code>) | 0 | 0 | 1 | 0 |==== + where <code>ys</code> = cot(<code>fov_y</code>/2) and <code>xs</code> = <code>ys</code>/<code>aspect</code>.</p>
<p>'''</p>
<p>[[perspective_rh]] ==== <code>perspective_rh</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;class T&gt;
-unspecified-return-type-
perspective_rh( T fov_y, T aspect, T zn, T zf );</code></pre>
<h2 id="section-137">} }</h2>
<p>====</p>
<p>Returns: :: A 4x4 projection matrix of unspecified type of the following form: + [cols=&quot;<sup>v,</sup>v,<sup>v,</sup>v&quot;,width=&quot;50%&quot;] |==== | <code>xs</code> | 0 | 0 | 0 | 0 | <code>ys</code> | 0 | 0 | 0 | 0 | <code>zf</code>/(<code>zn</code>-<code>zf</code>) | <code>zn</code>*<code>zf</code>/(<code>zn</code>-<code>zf</code>) | 0 | 0 | -1 | 0 |==== + where <code>ys</code> = cot(<code>fov_y</code>/2), and <code>xs</code> = <code>ys</code>/<code>aspect</code>.</p>
<p>'''</p>
<p>[[mat_scalar_cast]] ==== <code>scalar_cast</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;class Scalar,class A&gt;
-unspecified-return_type- scalar_cast( A const &amp; a );</code></pre>
<h2 id="section-138">} }</h2>
<p>====</p>
<p>Returns: :: A read-only &lt;<view_proxy,view proxy>&gt; of <code>a</code> that looks like a matrix of the same dimensions as <code>a</code>, but with &lt;<mat_traits,`scalar_type`>&gt; <code>Scalar</code> and elements constructed from the corresponding elements of <code>a</code>.</p>
<p>'''</p>
<p>[[mref]] ==== <code>mref</code></p>
<p>==== .#include <boost/qvm/mat_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;class A&gt;
-unspecified-return-type- mref( A &amp; a );</code></pre>
<h2 id="section-139">} }</h2>
<p>====</p>
<p>Returns: :: An identity view proxy of <code>a</code>; that is, it simply accesses the elements of <code>a</code>.</p>
<p>TIP: <code>mref</code> allows calling Boost QVM operations when <code>a</code> is of built-in type, for example a plain old C array.</p>
<p>'''</p>
<p>=== Generic quaternion-vector operations</p>
<p>[[quat_vec_mul]] ==== <code>operator*</code></p>
<p>==== .#include <boost/qvm/quat_vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::cols==vec_traits&lt;B&gt;::dim
template &lt;class A,class B&gt;
typename deduce_vec2&lt;A,B,mat_traits&lt;A&gt;::rows&gt;::type
operator*( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-140">} }</h2>
<p>====</p>
<p>Returns: :: The result of transforming the vector <code>b</code> by the quaternion <code>a</code>.</p>
<p>NOTE: The &lt;<deduce_vec2,`deduce_vec2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>=== Generic matrix-vector operations</p>
<p>[[mat_vec_mul]] ==== <code>operator*</code></p>
<p>==== .#include <boost/qvm/mat_vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::cols==vec_traits&lt;B&gt;::dim
template &lt;class A,class B&gt;
typename deduce_vec2&lt;A,B,mat_traits&lt;A&gt;::rows&gt;::type
operator*( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-141">} }</h2>
<p>====</p>
<p>Returns: :: The result of multiplying the matrix <code>a</code> and the vector <code>b</code>, where <code>b</code> is interpreted as a matrix-column. The resulting matrix-row is returned as a vector type.</p>
<p>NOTE: The &lt;<deduce_vec2,`deduce_vec2`>&gt; template can be specialized to deduce the desired return type, given the types <code>A</code> and <code>B</code>.</p>
<p>'''</p>
<p>[[transform_vector]] ==== <code>transform_vector</code></p>
<p>==== .#include <boost/qvm/mat_vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==4 &amp;&amp; mat_traits&lt;A&gt;::cols==4 &amp;&amp;
//  vec_traits&lt;B&gt;::dim==3
template &lt;class A,class B&gt;
deduce_vec2&lt;A,B,3&gt; &gt;::type
transform_vector( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-142">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>return a &lt;&lt;mat_vec_mul,*&gt;&gt; &lt;&lt;swizzling,XYZ0&gt;&gt;(b)</code>.</p>
<p>'''</p>
<p>[[transform_point]] ==== <code>transform_pointt</code></p>
<p>==== .#include <boost/qvm/mat_vec_operations.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp; is_vec&lt;B&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==4 &amp;&amp; mat_traits&lt;A&gt;::cols==4 &amp;&amp;
//  vec_traits&lt;B&gt;::dim==3
template &lt;class A,class B&gt;
deduce_vec2&lt;A,B,3&gt; &gt;::type
transform_point( A const &amp; a, B const &amp; b );</code></pre>
<h2 id="section-143">} }</h2>
<p>====</p>
<p>Effects: :: As if: <code>return a &lt;&lt;mat_vec_mul,*&gt;&gt; &lt;&lt;swizzling,XYZ1&gt;&gt;(b)</code>.</p>
<p>'''</p>
<p>=== Generic matrix-to-matrix view proxies</p>
<p>[[del_row]] ==== <code>del_row</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int R&gt;
-unspecified-return-type- del_row();</code></pre>
<h2 id="section-144">} }</h2>
<p>====</p>
<p>The expression <code>del_row&lt;R&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with row <code>R</code> deleted.</p>
<p>'''</p>
<p>[[del_col]] ==== <code>del_col</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int C&gt;
-unspecified-return-type- del_col();</code></pre>
<h2 id="section-145">} }</h2>
<p>====</p>
<p>The expression <code>del_col&lt;C&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with column <code>C</code> deleted.</p>
<p>'''</p>
<p>[[del_row_col]] ==== <code>del_row_col</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int R,int C&gt;
-unspecified-return-type- del_row_col();</code></pre>
<h2 id="section-146">} }</h2>
<p>====</p>
<p>The expression <code>del_row_col&lt;R,C&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with row <code>R</code> and column <code>C</code> deleted.</p>
<p>'''</p>
<p>[[neg_row]] ==== <code>neg_row</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int R&gt;
-unspecified-return-type- neg_row();</code></pre>
<h2 id="section-147">} }</h2>
<p>====</p>
<p>The expression <code>neg_row&lt;R&gt;(m)</code> returns a read-only &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with row <code>R</code> negated.</p>
<p>'''</p>
<p>[[neg_col]] ==== <code>neg_col</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int C&gt;
-unspecified-return-type- neg_col();</code></pre>
<h2 id="section-148">} }</h2>
<p>====</p>
<p>The expression <code>neg_col&lt;C&gt;(m)</code> returns a read-only &lt;<view_proxy,`view proxy`>&gt; that looks like the matrix <code>m</code> with column <code>C</code> negated.</p>
<p>'''</p>
<p>[[swap_rows]] ==== <code>swap_rows</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int R1,int R2&gt;
-unspecified-return-type- swap_rows();</code></pre>
<h2 id="section-149">} }</h2>
<p>====</p>
<p>The expression <code>swap_rows&lt;R1,R2&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with rows <code>R1</code> and <code>R2</code> swapped.</p>
<p>'''</p>
<p>[[swap_cols]] ==== <code>swap_cols</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>template &lt;int C1,int C2&gt;
-unspecified-return-type- swap_cols();</code></pre>
<h2 id="section-150">} }</h2>
<p>====</p>
<p>The expression <code>swap_cols&lt;C1,C2&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that looks like the matrix <code>m</code> with columns <code>C1</code> and <code>C2</code> swapped.</p>
<p>'''</p>
<p>[[transposed]] ==== <code>transposed</code></p>
<p>==== .#include <boost/qvm/map_mat_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>-unspecified-return-type- transposed();</code></pre>
<h2 id="section-151">} }</h2>
<p>====</p>
<p>The expression <code>transposed(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that transposes the matrix <code>m</code>.</p>
<p>'''</p>
<p>=== Generic vector-to-matrix view proxies</p>
<p>[[col_mat]] ==== <code>col_mat</code></p>
<p>==== .#include <boost/qvm/map_vec_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_vec&lt;A&gt;::value
template &lt;iclass A&gt;
-unspecified-return-type- col_mat( A &amp; a );</code></pre>
<h2 id="section-152">} }</h2>
<p>====</p>
<p>The expression <code>col_mat(v)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the vector <code>v</code> as a matrix-column.</p>
<p>'''</p>
<p>[[row_mat]] ==== <code>row_mat</code></p>
<p>==== .#include <boost/qvm/map_vec_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_vec&lt;A&gt;::value
template &lt;iclass A&gt;
-unspecified-return-type- row_mat( A &amp; a );</code></pre>
<h2 id="section-153">} }</h2>
<p>====</p>
<p>The expression <code>row_mat(v)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the vector <code>v</code> as a matrix-row.</p>
<p>'''</p>
<p>[[translation_mat]] ==== <code>translation_mat</code></p>
<p>==== .#include <boost/qvm/map_vec_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_vec&lt;A&gt;::value
template &lt;iclass A&gt;
-unspecified-return-type- translation_mat( A &amp; a );</code></pre>
<h2 id="section-154">} }</h2>
<p>====</p>
<p>The expression <code>translation_mat(v)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the vector <code>v</code> as translation matrix of size 1 + &lt;<vec_traits,`vec_traits<A>::dim`&gt;&gt;.</p>
<p>'''</p>
<p>[[diag_mat]] ==== <code>diag_mat</code></p>
<p>==== .#include <boost/qvm/map_vec_mat.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_vec&lt;A&gt;::value
template &lt;iclass A&gt;
-unspecified-return-type- diag_mat( A &amp; a );</code></pre>
<h2 id="section-155">} }</h2>
<p>====</p>
<p>The expression <code>diag_mat(v)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the vector <code>v</code> as a square matrix of the same dimensions in which the elements of <code>v</code> appear as the main diagonal and all other elements are zero.</p>
<p>TIP: If <code>v</code> is a 3D vector, the expression <code>diag_mat(XYZ1(v))</code> can be used as a scaling 4D matrix.</p>
<p>'''</p>
<p>=== Generic matrix-to-vector view proxies</p>
<p>[[col]] ==== <code>col</code></p>
<p>==== .#include <boost/qvm/map_mat_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;int C,class A&gt;
-unspecified-return-type- col( A &amp; a );</code></pre>
<h2 id="section-156">} }</h2>
<p>====</p>
<p>The expression <code>col&lt;C&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses column <code>C</code> of the matrix <code>m</code> as a vector.</p>
<p>'''</p>
<p>[[row]] ==== <code>row</code></p>
<p>==== .#include <boost/qvm/map_mat_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;int C,class A&gt;
-unspecified-return-type- row( A &amp; a );</code></pre>
<h2 id="section-157">} }</h2>
<p>====</p>
<p>The expression <code>row&lt;R&gt;(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses row <code>R</code> of the matrix <code>m</code> as a vector.</p>
<p>'''</p>
<p>[[diag]] ==== <code>diag</code></p>
<p>==== .#include <boost/qvm/map_mat_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if: is_mat&lt;A&gt;::value
template &lt;class A&gt;
-unspecified-return-type- diag( A &amp; a );</code></pre>
<h2 id="section-158">} }</h2>
<p>====</p>
<p>The expression <code>diag(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the main diagonal of the matrix <code>m</code> as a vector.</p>
<p>'''</p>
<p>[[translation]] ==== <code>translation</code></p>
<p>==== .#include <boost/qvm/map_mat_vec.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>//Only enabled if:
//  is_mat&lt;A&gt;::value &amp;&amp;
//  mat_traits&lt;A&gt;::rows==mat_traits&lt;A&gt;::cols &amp;&amp; mat_traits&lt;A&gt;::rows&gt;=3
template &lt;class A&gt;
-unspecified-return-type- translation( A &amp; a );</code></pre>
<h2 id="section-159">} }</h2>
<p>====</p>
<p>The expression <code>translation(m)</code> returns an lvalue &lt;<view_proxy,view proxy>&gt; that accesses the translation component of the square matrix <code>m</code>, which is a vector of size <code>D</code>-1, where <code>D</code> is the size of <code>m</code>.</p>
<p>'''</p>
<p>=== Exceptions</p>
<p>[[error]] ==== <code>error</code></p>
<p>==== .#include <boost/qvm/error.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>struct error: virtual boost::exception, virtual std::exception { };        </code></pre>
<h2 id="section-160">} }</h2>
<p>====</p>
<p>This is the base for all exceptions thorwn by Boost QVM.</p>
<p>'''</p>
<p>[[zero_magnitude_error]] ==== <code>zero_magnitude_error</code></p>
<p>==== .#include <boost/qvm/error.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>struct zero_magnitude_error: virtual error { };        </code></pre>
<h2 id="section-161">} }</h2>
<p>====</p>
<p>This exception indicates that an operation requires a vector or a quaternion with non-zero magnitude, but the computed magnitude is zero.</p>
<p>'''</p>
<p>[[zero_determinant_error]] ==== <code>zero_determinant_error</code></p>
<p>==== .#include <boost/qvm/error.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>struct zero_determinant_error: virtual error { };        </code></pre>
<h2 id="section-162">} }</h2>
<p>====</p>
<p>This exception indicates that an operation requires a matrix with non-zero determinant, but the computed determinant is zero.</p>
<p>'''</p>
<p>=== Macros and configuration: BOOST_QVM_</p>
<p>[[BOOST_QVM_INLINE]] ==== <code>INLINE</code> ===== <code>BOOST_QVM_INLINE</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_INLINE
#define BOOST_QVM_INLINE inline
#endif</code></pre>
<h2 id="section-163">} }</h2>
<p>====</p>
<p>This macro is not used directly by Boost QVM, except as the default value of other macros from <code>&lt;boost/qvm/inline.hpp&gt;</code>. A user-defined <code>BOOST_QVM_INLINE</code> should expand to a value that is valid substitution of the <code>inline</code> keyword in function definitions.</p>
<p>'''</p>
<p>[[BOOST_QVM_FORCE_INLINE]] ==== <code>FORCE_INLINE</code> ===== <code>BOOST_QVM_FORCE_INLINE</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_FORCE_INLINE
#define BOOST_QVM_FORCE_INLINE /*platform-specific*/
#endif</code></pre>
<h2 id="section-164">} }</h2>
<p>====</p>
<p>This macro is not used directly by Boost QVM, except as the default value of other macros from <code>&lt;boost/qvm/inline.hpp&gt;</code>. A user-defined <code>BOOST_QVM_FORCE_INLINE</code> should expand to a value that is valid substitution of the <code>inline</code> keyword in function definitions, to indicate that the compiler must inline the function. Of course, actual inlining may or may not occur.</p>
<p>'''</p>
<p>[[BOOST_QVM_INLINE_TRIVIAL]] ==== <code>INLINE_TRIVIAL</code> ===== <code>BOOST_QVM_INLINE_TRIVIAL</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_INLINE_TRIVIAL
#define BOOST_QVM_INLINE_TRIVIAL BOOST_QVM_FORCE_INLINE
#endif</code></pre>
<h2 id="section-165">} }</h2>
<p>====</p>
<p>Boost QVM uses <code>BOOST_QVM_INLINE_TRIVIAL</code> in definitions of functions that are not critical for the overall performance of the library but are extremely simple (such as one-liners) and therefore should always be inlined.</p>
<p>'''</p>
<p>[[BOOST_QVM_INLINE_CRITICAL]] ==== <code>INLINE_CRITICAL</code> ===== <code>BOOST_QVM_INLINE_CRITICAL</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_INLINE_CRITICAL
#define BOOST_QVM_INLINE_CRITICAL BOOST_QVM_FORCE_INLINE
#endif</code></pre>
<h2 id="section-166">} }</h2>
<p>====</p>
<p>Boost QVM uses <code>BOOST_QVM_INLINE_CRITICAL</code> in definitions of functions that are critical for the overall performance of the library, such as functions that access individual vector and matrix elements.</p>
<p>'''</p>
<p>[[BOOST_QVM_INLINE_OPERATIONS]] ==== <code>INLINE_OPERATIONS</code> ===== <code>BOOST_QVM_INLINE_OPERATIONS</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_INLINE_OPERATIONS
#define BOOST_QVM_INLINE_OPERATIONS BOOST_QVM_INLINE
#endif</code></pre>
<h2 id="section-167">} }</h2>
<p>====</p>
<p>Boost QVM uses <code>BOOST_QVM_INLINE_OPERATIONS</code> in definitions of functions that implement various high-level operations, such as matrix multiplication, computing the magnitude of a vector, etc.</p>
<p>'''</p>
<p>[[BOOST_QVM_INLINE_RECURSION]] ==== <code>INLINE_RECURSION</code> ===== <code>BOOST_QVM_INLINE_RECURSION</code></p>
<p>==== .#include <boost/qvm/inline.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_INLINE_RECURSION
#define BOOST_QVM_INLINE_RECURSION BOOST_QVM_INLINE_OPERATIONS
#endif</code></pre>
<h2 id="section-168">} }</h2>
<p>====</p>
<p>Boost QVM uses <code>BOOST_QVM_INLINE_RECURSION</code> in definitions of recursive functions that are not critical for the overall performance of the library (definitions of all critical functions, including critical recursive functions, use &lt;<BOOST_QVM_INLINE_CRITICAL,`BOOST_QVM_INLINE_CRITICAL`>&gt;).</p>
<p>'''</p>
<p>[[BOOST_QVM_ASSERT]] ==== <code>ASSERT</code> ===== <code>BOOST_QVM_ASSERT</code></p>
<p>==== .#include <boost/qvm/assert.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<h1 id="ifndef-boost_qvm_assert">ifndef BOOST_QVM_ASSERT</h1>
<h1 id="include-3">include <boost/assert.hpp></h1>
<h1 id="define-boost_qvm_assert-boost_assert">define BOOST_QVM_ASSERT BOOST_ASSERT</h1>
<h1 id="endif">endif</h1>
<h2 id="section-169">} }</h2>
<p>====</p>
<p>This is the macro Boost QVM uses to assert on precondition violations and logic errors. A user-defined <code>BOOST_QVM_ASSERT</code> should have the semantics of the standard <code>assert</code>.</p>
<p>'''</p>
<p>[[BOOST_QVM_STATIC_ASSERT]] ==== <code>STATIC_ASSERT</code> ===== <code>BOOST_QVM_STATIC_ASSERT</code></p>
<p>==== .#include <boost/qvm/static_assert.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_STATIC_ASSERT
#include &lt;boost/static_assert.hpp&gt;
#define BOOST_QVM_STATIC_ASSERT BOOST_STATIC_ASSERT
#endif</code></pre>
<h2 id="section-170">} }</h2>
<p>====</p>
<p>All static assertions in Boost QVM use the <code>BOOST_QVM_STATIC_ASSERT</code> macro.</p>
<p>'''</p>
<p>[[BOOST_QVM_THROW_EXCEPTION]] ==== <code>THROW_EXCEPTION</code> ===== <code>BOOST_QVM_THROW_EXCEPTION</code></p>
<p>==== .#include <boost/qvm/throw_exception.hpp> [source,c++] ---- namespace boost { namespace qvm {</p>
<pre><code>#ifndef BOOST_QVM_THROW_EXCEPTION
#include &lt;boost/throw_exception.hpp&gt;
#define BOOST_QVM_THROW_EXCEPTION BOOST_THROW_EXCEPTION
#endif</code></pre>
<h2 id="section-171">} }</h2>
<p>====</p>
<p>This macro is used whenever Boost QVM throws an exception. Users who override the standard <code>BOOST_QVM_THROW_EXCEPTION</code> behavior must ensure that when invoked, the substituted implementation does not return control to the caller. Below is a list of all QVM functions that invoke <code>BOOST_QVM_THROW_EXCEPTION</code>:</p>
<ul>
<li>Quaternion operations: ** &lt;<quat_inverse,`inverse`>&gt; ** &lt;<rot_quat,`rot_quat`>&gt; ** &lt;<quat_normalize,`normalize`>&gt; ** &lt;<quat_normalized,`normalized`>&gt;</li>
<li>Vector operations: ** &lt;<vec_normalize,`normalize`>&gt; ** &lt;<vec_normalized,`normalized`>&gt;</li>
<li>Matrix operations: ** &lt;<mat_inverse,`inverse`>&gt; ** &lt;<rot_mat,`rot_mat`>&gt;</li>
</ul>
<p>== Design rationale</p>
<p>In graphics and simulation applications, there is a need for a library that makes it easy to perform 2D and 3D transformations efficiently. {CPP} makes it possible to define vector and matrix types and to overload various operators to implement the standard algebraic operations. Because this is a relatively straightforward process, there are many such libraries in existence, each with its own types and operator overrloads. Such libraries are typically part of a higher level system, such as a graphics engine or a 3D modeling API. As a result, it is typical for programmers to have to integrate and to translate between several different quaternion, vector and matrix types that come with the various APIs they use.</p>
<p>On the other hand, performance considerations often lead to matrix and vector types becoming coupled with a particular platform, or to (over time) acquire various <code>#ifdefs</code> needed to enable optimizations through platform-specific compiler features that control the physical format or layout of their elements. But such optimizations may interfere with ease of use and portability; for example on some platforms requiring 16-byte alignment for matrix types makes them incompatible with standard containers.</p>
<p>Boost QVM solves both of these issues by decoupling the standard algebraic functions from the types they operate on -- without compromising type safety.</p>
<p>Key design features of Boost QVM:</p>
<ul>
<li><p>Emphasis on 2, 3 and 4-dimensional operations (including quaternions and zero-overhead &lt;<swizzling,swizzling>&gt;) as needed in graphics and simulation applications.</p></li>
<li><p>Zero-overhead &lt;<view_proxy,view proxies>&gt; that can be used to access any object with quaternion, vector or matrix semantics through a read-only or lvalue reference of a different type. For example, <code>&lt;&lt;col,col&gt;&gt;&lt;C&gt;(m)</code> binds the <code>C</code>-th column of a matrix <code>m</code> as a mutable vector type without the overhead of a temporary.</p></li>
<li><p>Integration of various user-defined or 3rd-party quaternion, vector or matrix types into a coherent type-safe system. This enables the user to build algebraic expressions using objects of diverse types that would otherwise be incompatible.</p></li>
<li><p>When users need to implement platform-specific or even project-specific optimizations in a given subsystem, Boost QVM makes it simple to define custom new types that automatically aquire the full set of algebraic operations so they can interface seamlessly with the rest of the program. At the same time, the user can define a limited number of overloads for the new types as needed to implement specific optimizations.</p></li>
</ul>
<p>== Code generator</p>
<p>While Boost QVM defines generic functions that operate on matrix and vector types of arbitrary static dimensions, it also provides a code generator that can be used to create compatible header files that define much simpler specializations of these functions for specific dimensions. This is useful during debugging since the generated code is much easier to read than the template metaprogramming-heavy generic implementations. It is also potentially friendlier to the optimizer.</p>
<p>The code generator is a command-line utility program. Its source code can be found in the <code>boost/libs/qvm/gen</code> directory. It was used to generate the following headers that ship with Boost QVM:</p>
<ul>
<li>2D, 3D and 4D matrix operations: ** <code>boost/qvm/gen/mat_operations2.hpp</code> (matrices of size 2x2, 2x1 and 1x2, included by <code>boost/qvm/mat_operations2.hpp</code>) ** <code>boost/qvm/gen/mat_operations3.hpp</code> (matrices of size 3x3, 3x1 and 1x3, included by <code>boost/qvm/mat_operations3.hpp</code>) ** <code>boost/qvm/gen/mat_operations4.hpp</code> (matrices of size 4x4, 4x1 and 1x4, included by <code>boost/qvm/mat_operations4.hpp</code>)</li>
<li>2D, 3D and 4D vector operations: ** <code>boost/qvm/gen/v2.hpp</code> (included by <code>boost/qvm/vec_operations2.hpp</code>) ** <code>boost/qvm/gen/v3.hpp</code> (included by <code>boost/qvm/vec_operations3.hpp</code>) ** <code>boost/qvm/gen/v4.hpp</code> (included by <code>boost/qvm/vec_operations4.hpp</code>)</li>
<li>2D, 3D and 4D vector-matrix operations: ** <code>boost/qvm/gen/vm2.hpp</code> (included by <code>boost/qvm/vec_mat_operations2.hpp</code>) ** <code>boost/qvm/gen/vm3.hpp</code> (included by <code>boost/qvm/vec_mat_operations3.hpp</code>) ** <code>boost/qvm/gen/vm4.hpp</code> (included by <code>boost/qvm/vec_mat_operations4.hpp</code>)</li>
<li>2D, 3D and 4D vector swizzling operations: ** <code>boost/qvm/gen/sw2.hpp</code> (included by <code>boost/qvm/swizzle2.hpp</code>) ** <code>boost/qvm/gen/sw3.hpp</code> (included by <code>boost/qvm/swizzle3.hpp</code>) ** <code>boost/qvm/gen/sw4.hpp</code> (included by <code>boost/qvm/swizzle4.hpp</code>)</li>
</ul>
<p>Any such generated headers must be included before the corresponding generic header file is included. For example, if one creates a header <code>boost/qvm/gen/m5.hpp</code>, it must be included before <code>boost/qvm/mat_operations.hpp</code> in included. However, the generic headers (<code>boost/qvm/mat_operations.hpp</code>, <code>boost/qvm/vec_operations.hpp</code>, <code>boost/qvm/vec_mat_operations.hpp</code> and <code>boost/qvm/swizzle.hpp</code>) already include the generated headers from the list above, so the generated headers don't need to be included manually.</p>
<p>NOTE: headers under <code>boost/qvm/gen</code> are not part of the public interface of Boost QVM. For example, <code>boost/qvm/gen/mat_operations2.hpp</code> should not be included directly; <code>#include &lt;boost/qvm/mat_operations2.hpp&gt;</code> instead.</p>
<p>== Known quirks and issues</p>
<p>=== Capturing view proxies with <code>auto</code></p>
<p>By design, &lt;<view_proxy,view proxies>&gt; must not return temporary objects. They return reference to an argument they take by (<code>const</code>) reference, cast to reference of unspecified type that is not copyable. Because of this, the return value of a view proxy can not be captured by value with <code>auto</code>:</p>
<h2 id="sourcec-35">[source,c++]</h2>
<h2 id="auto-tr-transposedm-error-the-return-type-of-transposed-can-not-be-copied.">auto tr = transposed(m); //Error: the return type of transposed can not be copied.</h2>
<p>The correct use of auto with view proxies is:</p>
<h2 id="sourcec-36">[source,c++]</h2>
<h2 id="auto-tr-transposedm">auto &amp; tr = transposed(m);</h2>
<p>NOTE: Many view proxies are not read-only, that is, they're lvalues; changes made on the view proxy operate on the original object. This is another reason why they can not be captured by value with <code>auto</code>.</p>
<p>'''</p>
<p>=== Binding QVM overloads from an unrelated namespace</p>
<p>The operator overloads in namespace <code>boost::qvm</code> are designed to work with user-defined types. Typically it is sufficient to make these operators available in the namespace where the operator is used, by <code>using namespace boost::qvm</code>. A problem arises if the scope that uses the operator is not controlled by the user. For example:</p>
<h2 id="sourcec-37">[source,c++]</h2>
<p>namespace ns1 {</p>
<pre><code>struct float2 { float x, y; };</code></pre>
<p>}</p>
<p>namespace ns2 {</p>
<pre><code>using namespace boost::qvm;

void f() {
    ns1::float2 a, b;
    a==b; //OK
    ns1::float2 arr1[2], arr2[2];
    std::equal(arr1,arr1+2,arr2); //Error: operator== is inaccessible from namespace std
}</code></pre>
<h2 id="section-172">}</h2>
<p>In the <code>std::equal</code> expression above, even though <code>boost::qvm::operator==</code> is made visible in namespace <code>ns2</code> by <code>using namespace boost::qvm</code>, the call originates from namespace <code>std</code>. In this case the compiler can't bind <code>boost::qvm::operator==</code> because only namespace <code>ns1</code> is visible through ADL, and it does not contain a suitable declaration. The solution is to declare <code>operator==</code> in namespace ns1, which can be done like this:</p>
<h2 id="sourcec-38">[source,c++]</h2>
<p>namespace ns1 {</p>
<pre><code>using boost::qvm::operator==;</code></pre>
<h2 id="section-173">}</h2>
<p>'''</p>
<p>=== Link errors when calling math functions with int arguments</p>
<p>Boost QVM does not call standard math functions (e.g. sin, cos, etc.) directly. Instead, it calls function templates declared in <code>boost/qvm/math.hpp</code> in namespace <code>boost::qvm</code>. This allows the user to specialize these templates for user-defined scalar types.</p>
<p>Boost QVM itself defines specializations of the math function templates only for <code>float</code> and <code>double</code>, but it does not provide generic definitions. This is done to protect the user from unintentionally writing code that binds standard math functions that take <code>double</code> when passing arguments of lesser types, which would be suboptimal.</p>
<p>Because of this, a call to e.g. <code>&lt;&lt;rot_mat,rot_mat&gt;&gt;(axis,1)</code> will compile successfully but fail to link, since it calls e.g. <code>boost::qvm::sin&lt;int&gt;</code>, which is undefined. Because rotations by integer number of radians are rarely needed, in QVM there is no protection against such errors. In such cases the solution is to use <code>rot_mat(axis,1.0f)</code> instead.</p>
<p>== Q&amp;A</p>
<p>[qanda] What is the motivation behind Boost QVM? Why not just use uBLAS/Eigen/CML/GLM/etc?:: The primary domain of Boost QVM is realtime graphics and simulation applications, so it is not a complete linear algebra library. While (naturally) there is some overlap with such libraries, QVM puts the emphasis on 2, 3 and 4 dimensional zero-overhead operations (hence domain-specific features like Swizzling).</p>
<p>How does the <code>qvm::&lt;&lt;vec,vec&gt;&gt;</code> (or <code>qvm::&lt;&lt;mat,mat&gt;&gt;</code>, or <code>qvm::&lt;&lt;quat,quat&gt;&gt;</code>) template compare to vector types from other libraries?:: The <code>qvm::vec</code> template is not in any way central to the vector operations defined by QVM. The operations are designed to work with any user-defined vector type or with 3rd-party vector types (e.g. <code>D3DVECTOR</code>), while the <code>qvm::vec</code> template is simply a default return type for expressions that use arguments of different types that would be incompatible outside of QVM. For example, if the &lt;<deduce_mat2,`deduce_mat2`>&gt; hasn't been specialized, calling &lt;<cross,`cross`>&gt; with a user-defined type <code>vec3</code> and a user-defined type <code>float3</code> returns a <code>qvm::vec</code>.</p>
<p>Why doesn't QVM use [] or () to access vector and matrix elements?:: Because it's designed to work with user-defined types, and the {CPP} standard requires these operators to be members. Of course if a user-defined type defines <code>operator[]</code> or <code>operator()</code> they are available for use with other QVM functions, but QVM defines its own mechanisms for &lt;<quat_access,accessing quaternion elements>&gt;, &lt;<vec_access,accessing vector elements>&gt; (as well as &lt;<swizzling,swizzling>&gt;), and &lt;<mat_access,accessing matrix elements>&gt;.</p>
<p>'''</p>
<p>[.text-right] (C) 2008-2018 Emil Dotchevski and Reverge Studios, Inc.</p>
