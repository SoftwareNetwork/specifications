<h1 id="rapid-yaml">Rapid YAML</h1>
<p><a href="https://github.com/biojppm/rapidyaml/blob/master/LICENSE.txt"><img src="https://img.shields.io/badge/License-MIT-green.svg" alt="MIT Licensed" /></a> <a href="https://github.com/biojppm/rapidyaml/releases"><img src="https://img.shields.io/github/v/release/biojppm/rapidyaml?color=g&amp;include_prereleases&amp;label=release%20&amp;sort=semver" alt="release" /></a> <a href="https://rapidyaml.docsforge.com/"><img src="https://img.shields.io/badge/docs-docsforge-blue" alt="Docs" /></a> <a href="https://gitter.im/rapidyaml/community"><img src="https://badges.gitter.im/rapidyaml/community.svg" alt="Gitter" /></a></p>
<p><a href="https://github.com/biojppm/rapidyaml/actions=workflow%3Aci"><img src="https://github.com/biojppm/rapidyaml/workflows/ci/badge.svg?branch=master" alt="ci" /></a> <a href="https://coveralls.io/github/biojppm/rapidyaml"><img src="https://coveralls.io/repos/github/biojppm/rapidyaml/badge.svg?branch=master" alt="Coveralls" /></a> <a href="https://codecov.io/gh/biojppm/rapidyaml"><img src="https://codecov.io/gh/biojppm/rapidyaml/branch/master/graph/badge.svg?branch=master" alt="Codecov" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/alerts/"><img src="https://img.shields.io/lgtm/alerts/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Total alerts" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/context:cpp"><img src="https://img.shields.io/lgtm/grade/cpp/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Language grade: C/C++" /></a></p>
<p>Or ryml, for short. ryml is a library to parse and emit YAML, and do it fast.</p>
<p>ryml parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your direct request, after parsing / before emitting. Internally the data tree representation has no knowledge of types (but of course, every node can have a YAML type tag). It is easy and fast to read, write and iterate through the data tree.</p>
<p>ryml can use custom per-tree memory allocators, and is exception-agnostic. Errors are reported via a custom error handler callback. A default error handler implementation using <code>std::abort()</code> is provided, but you can opt out, or provide your exception-throwing callback.</p>
<p>ryml has respect for your compilation times and therefore it is NOT header-only. It uses standard cmake build files, so it is easy to compile and install.</p>
<p>ryml has no dependencies, not even on the STL (although it does use the libc). It provides optional headers that let you serialize/deserialize STL strings and containers (or show you how to do it).</p>
<p>ryml is written in C++11, and is known to compile with: * Visual Studio 2015 and later * clang++ 3.9 and later * g++ 5 and later</p>
<p>ryml is <a href="https://github.com/biojppm/rapidyaml/actions">extensively unit-tested in Linux, Windows and MacOS</a>. The tests include analysing ryml with: * valgrind * clang-tidy * clang sanitizers: * memory * address * undefined behavior * thread * <a href="https://lgtm.com/projects/g/biojppm/rapidyaml">LGTM.com</a></p>
<p>ryml is also partially available in Python, with more languages to follow (see below).</p>
<p>See also <a href="./changelog">the changelog</a> and <a href="./ROADMAP.md">the roadmap</a>.</p>
<hr />
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#is-it-rapid">Is it rapid?</a>
<ul>
<li><a href="#comparison-with-yaml-cpp">Comparison with yaml-cpp</a></li>
<li><a href="#performance-reading-json">Performance reading JSON</a></li>
<li><a href="#performance-emitting">Performance emitting</a></li>
</ul></li>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#using-ryml-in-your-project">Using ryml in your project</a>
<ul>
<li><a href="#building-ryml-as-part-of-your-project">Building ryml as part of your project</a></li>
<li><a href="#install-ryml-first">Install ryml first</a></li>
<li><a href="#cmake-build-settings-for-ryml">cmake build settings for ryml</a></li>
</ul></li>
<li><a href="#other-languages">Other languages</a>
<ul>
<li><a href="#python">Python</a></li>
</ul></li>
<li><a href="#yaml-standard-conformance">YAML standard conformance</a>
<ul>
<li><a href="#test-suite-status">Test suite status</a></li>
</ul></li>
<li><a href="#known-limitations">Known limitations</a></li>
<li><a href="#alternative-libraries">Alternative libraries</a></li>
<li><a href="#license">License</a></li>
</ul>
<hr />
<h2 id="is-it-rapid">Is it rapid?</h2>
<p>You bet! On a i7-6800K CPU <span class="citation" data-cites="3.40GHz">@3.40GHz</span>: * ryml parses YAML at about ~150MB/s on Linux and ~100MB/s on Windows (vs2017). * <strong>ryml parses JSON at about ~450MB/s on Linux</strong>, faster than sajson (didn’t try yet on Windows). * compared against the other existing YAML libraries for C/C++: * ryml is in general between 2 and 3 times faster than <a href="https://github.com/yaml/libyaml">libyaml</a> * ryml is in general between 20 and 70 times faster than <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>, and in some cases as much as 100x and <a href="https://github.com/biojppm/c4core/pull/16#issuecomment-700972614">even 200x</a> faster.</p>
<p><a href="./bm/bm_parse.cpp">Here’s the benchmark</a>. Using different approaches within ryml (in-situ/read-only vs. with/without reuse), a YAML / JSON buffer is repeatedly parsed, and compared against other libraries.</p>
<h3 id="comparison-with-yaml-cpp">Comparison with yaml-cpp</h3>
<p>The first result set is for Windows, and is using a <a href="./bm/cases/appveyor.yml">appveyor.yml config file</a>. A comparison of these results is summarized on the table below:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>appveyor / vs2017 / Release</td>
<td>101.5</td>
<td>5.3</td>
<td>20x / 5.2%</td>
</tr>
<tr class="even">
<td>appveyor / vs2017 / Debug</td>
<td>6.4</td>
<td>0.0844</td>
<td>76x / 1.3%</td>
</tr>
</tbody>
</table>
<p>The next set of results is taken in Linux, comparing g++ 8.2 and clang++ 7.0.1 in parsing a YAML buffer from a <a href="./bm/cases/travis.yml">travis.yml config file</a> or a JSON buffer from a <a href="./bm/cases/compile_commands.json">compile_commands.json file</a>. You can <a href="./bm/results/parse.linux.i7_6800K.md">see the full results here</a>. Summarizing:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>json / clang++ / Release</td>
<td>453.5</td>
<td>15.1</td>
<td>30x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Release</td>
<td>430.5</td>
<td>16.3</td>
<td>26x / 4%</td>
</tr>
<tr class="odd">
<td>json / clang++ / Debug</td>
<td>61.9</td>
<td>1.63</td>
<td>38x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Debug</td>
<td>72.6</td>
<td>1.53</td>
<td>47x / 2%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Release</td>
<td>131.6</td>
<td>8.08</td>
<td>16x / 6%</td>
</tr>
<tr class="even">
<td>travis / g++ / Release</td>
<td>176.4</td>
<td>8.23</td>
<td>21x / 5%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Debug</td>
<td>10.2</td>
<td>1.08</td>
<td>9x / 1%</td>
</tr>
<tr class="even">
<td>travis / g++ / Debug</td>
<td>12.5</td>
<td>1.01</td>
<td>12x / 8%</td>
</tr>
</tbody>
</table>
<p>The 450MB/s read rate for JSON puts ryml squarely in the same ballpark as <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and other fast json readers (<a href="https://lemire.me/blog/2018/05/03/how-fast-can-you-parse-json/">data from here</a>). Even parsing full YAML is at ~150MB/s, which is still in that performance ballpark, albeit at its lower end. This is something to be proud of, as the YAML specification is much more complex than JSON: <a href="https://www.arp242.net/yaml-config.html#its-pretty-complex">23449 vs 1969 words</a>.</p>
<h3 id="performance-reading-json">Performance reading JSON</h3>
<p>So how does ryml compare against other JSON readers? Well, it’s one of the fastest!</p>
<p>The benchmark is the <a href="./bm/parse.cpp">same as above</a>, and it is reading the <a href="./bm/cases/compile_commands.json">compile_commands.json</a>, The <code>_ro</code> suffix notes parsing a read-only buffer (so buffer copies are performed), while the <code>_rw</code> suffix means that the source buffer can be parsed in situ. The <code>_reuse</code> means the data tree and/or parser are reused on each benchmark repeat.</p>
<p>Here’s what we get with g++ 8.2:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Benchmark</th>
<th style="text-align: right;">Release,MB/s</th>
<th style="text-align: right;">Debug,MB/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">rapidjson_ro</td>
<td style="text-align: right;">509.9</td>
<td style="text-align: right;">43.4</td>
</tr>
<tr class="even">
<td style="text-align: left;">rapidjson_rw</td>
<td style="text-align: right;">1329.4</td>
<td style="text-align: right;">68.2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sajson_rw</td>
<td style="text-align: right;">434.2</td>
<td style="text-align: right;">176.5</td>
</tr>
<tr class="even">
<td style="text-align: left;">sajson_ro</td>
<td style="text-align: right;">430.7</td>
<td style="text-align: right;">175.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">jsoncpp_ro</td>
<td style="text-align: right;">183.6</td>
<td style="text-align: right;">187.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">nlohmann_json_ro</td>
<td style="text-align: right;">115.8</td>
<td style="text-align: right;">21.5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">yamlcpp_ro</td>
<td style="text-align: right;">16.6</td>
<td style="text-align: right;">1.6</td>
</tr>
<tr class="even">
<td style="text-align: left;">libyaml_ro</td>
<td style="text-align: right;">113.9</td>
<td style="text-align: right;">35.7</td>
</tr>
<tr class="odd">
<td style="text-align: left;">libyaml_ro_reuse</td>
<td style="text-align: right;">114.6</td>
<td style="text-align: right;">35.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">ryml_ro</td>
<td style="text-align: right;">388.6</td>
<td style="text-align: right;">36.9</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ryml_rw</td>
<td style="text-align: right;">393.7</td>
<td style="text-align: right;">36.9</td>
</tr>
<tr class="even">
<td style="text-align: left;">ryml_ro_reuse</td>
<td style="text-align: right;">446.2</td>
<td style="text-align: right;">74.6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ryml_rw_reuse</td>
<td style="text-align: right;">457.1</td>
<td style="text-align: right;">74.9</td>
</tr>
</tbody>
</table>
<p>You can verify that (at least for this test) ryml beats most json parsers at their own game, with the only exception of <a href="https://github.com/Tencent/rapidjson">rapidjson</a>. And actually, in Debug, <a href="https://github.com/Tencent/rapidjson">rapidjson</a> is slower than ryml, and only <a href="https://github.com/chadaustin/sajson">sajson</a> manages to be faster.</p>
<h3 id="performance-emitting">Performance emitting</h3>
<p>Emitting benchmarks were not created yet, but feedback from some users reports as much as 25x speedup from yaml-cpp <a href="https://github.com/biojppm/rapidyaml/issues/28#issue-553855608">(eg, here)</a>.</p>
<p>If you have data or YAML code for this, please submit a pull request, or just send us the files!</p>
<hr />
<h2 id="quick-start">Quick start</h2>
<p>If you’re wondering whether ryml’s speed comes at a usage cost, you need not. With ryml, you can have your cake and eat it too: being rapid is definitely NOT the same as being unpractical, so ryml was written with easy AND efficient usage in mind, and comes with a two level API for accessing and traversing the data tree.</p>
<p>The following snippet is a quick overview taken from <a href="samples/quickstart.cpp">the quickstart sample</a>. After cloning ryml, you can very easily build and run this executable using any of the build samples, eg the <a href="samples/add_subdirectory/"><code>add_subdirectory()</code> sample</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// Parse YAML code in place, potentially mutating the buffer.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">// It is also possible to:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">//   - parse a read-only buffer</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">//   - reuse an existing tree (advised)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">//   - reuse an existing parser (advised)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="dt">char</span> yml_buf[] = <span class="st">&quot;{foo: 1, bar: [2, 3], john: doe}&quot;</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>ryml::Tree tree = ryml::parse(ryml::substr(yml_buf));</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">// Note: it will always be significantly faster to use mutable</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co">// buffers and reuse tree+parser.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">// Below you will find samples that show how to achieve reuse; but</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co">// please note that for brevity and clarity, many of the examples</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="co">// here are parsing immutable buffers, and not reusing tree or</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">// parser.</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="co">// API overview</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="co">// ryml has a two-level API:</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a><span class="co">// The lower level index API is based on the indices of nodes,</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a><span class="co">// where the node&#39;s id is the node&#39;s position in the tree&#39;s data</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">// array. This API is very efficient, but somewhat difficult to use:</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="dt">size_t</span> root_id = tree.root_id();</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a><span class="dt">size_t</span> bar_id = tree.find_child(root_id, <span class="st">&quot;bar&quot;</span>); <span class="co">// need to get the index right</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>CHECK(tree.is_map(root_id)); <span class="co">// all of the index methods are in the tree</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>CHECK(tree.is_seq(bar_id));  <span class="co">// ... and receive the subject index</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a><span class="co">// The node API is a lightweight abstraction sitting on top of the</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a><span class="co">// index API, but offering a much more convenient interaction:</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>ryml::NodeRef root = tree.rootref();</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>ryml::NodeRef bar = tree[<span class="st">&quot;bar&quot;</span>];</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>CHECK(root.is_map());</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>CHECK(bar.is_seq());</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a><span class="co">// NodeRef is a lightweight handle to the tree and associated id:</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>CHECK(root.tree() == &amp;tree); <span class="co">// NodeRef points at its tree, WITHOUT refcount</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>CHECK(root.id() == root_id); <span class="co">// NodeRef&#39;s id is the index of the node</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>CHECK(bar.id() == bar_id);   <span class="co">// NodeRef&#39;s id is the index of the node</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a><span class="co">// The node API translates very cleanly to the index API, so most</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a><span class="co">// of the code examples below are using the node API.</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a><span class="co">// One significant point of the node API is that it holds a raw</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a><span class="co">// pointer to the tree. Care must be taken to ensure the lifetimes</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a><span class="co">// match, so that a node will never access the tree after the tree</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a><span class="co">// went out of scope.</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a><span class="co">// To read the parsed tree</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a><span class="co">// Node::operator[] does a lookup, is O(num_children[node]).</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a><span class="co">// maps use string keys, seqs use integral keys.</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;foo&quot;</span>].is_keyval());</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;foo&quot;</span>].key() == <span class="st">&quot;foo&quot;</span>);</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;foo&quot;</span>].val() == <span class="st">&quot;1&quot;</span>);</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>].is_seq());</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>].has_key());</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>].key() == <span class="st">&quot;bar&quot;</span>);</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>].val() == <span class="st">&quot;2&quot;</span>);</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>].val() == <span class="st">&quot;3&quot;</span>);</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;john&quot;</span>].val() == <span class="st">&quot;doe&quot;</span>);</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true"></a><span class="co">// An integral key is the position of the child within its parent,</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true"></a><span class="co">// so even maps can also use int keys, if the key position is</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true"></a><span class="co">// known.</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true"></a>CHECK(tree[<span class="dv">0</span>].id() == tree[<span class="st">&quot;foo&quot;</span>].id());</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true"></a>CHECK(tree[<span class="dv">1</span>].id() == tree[<span class="st">&quot;bar&quot;</span>].id());</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true"></a>CHECK(tree[<span class="dv">2</span>].id() == tree[<span class="st">&quot;john&quot;</span>].id());</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true"></a><span class="co">// Tree::operator[](int) searches a root child by its position.</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true"></a>CHECK(tree[<span class="dv">0</span>].id() == tree[<span class="st">&quot;foo&quot;</span>].id());  <span class="co">// 0: first child of root</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true"></a>CHECK(tree[<span class="dv">1</span>].id() == tree[<span class="st">&quot;bar&quot;</span>].id());  <span class="co">// 1: first child of root</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true"></a>CHECK(tree[<span class="dv">2</span>].id() == tree[<span class="st">&quot;john&quot;</span>].id()); <span class="co">// 2: first child of root</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true"></a><span class="co">// NodeRef::operator[](int) searches a node child by its position</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true"></a><span class="co">// on __the node__&#39;s children list:</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true"></a>CHECK(bar[<span class="dv">0</span>].val() == <span class="st">&quot;2&quot;</span>); <span class="co">// 0 means first child of bar</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true"></a>CHECK(bar[<span class="dv">1</span>].val() == <span class="st">&quot;3&quot;</span>); <span class="co">// 1 means second child of bar</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true"></a><span class="co">// NodeRef::operator[](string):</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true"></a><span class="co">// A string key is the key of the node: lookup is by name. So it</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true"></a><span class="co">// is only available for maps, and it is NOT available for seqs,</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true"></a><span class="co">// since seq members do not have keys.</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;foo&quot;</span>].key() == <span class="st">&quot;foo&quot;</span>);</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;bar&quot;</span>].key() == <span class="st">&quot;bar&quot;</span>);</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true"></a>CHECK(tree[<span class="st">&quot;john&quot;</span>].key() == <span class="st">&quot;john&quot;</span>);</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true"></a>CHECK(bar.is_seq());</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true"></a><span class="co">// CHECK(bar[&quot;BOOM!&quot;].is_seed()); // error, seqs do not have key lookup</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true"></a><span class="co">// Note that maps can also use index keys as well as string keys:</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;foo&quot;</span>].id() == root[<span class="dv">0</span>].id());</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>].id() == root[<span class="dv">1</span>].id());</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;john&quot;</span>].id() == root[<span class="dv">2</span>].id());</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true"></a><span class="co">// Please note that since a ryml tree uses indexed linked lists for storing</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true"></a><span class="co">// children, the complexity of `Tree::operator[csubstr]` and</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true"></a><span class="co">// `Tree::operator[size_t]` is linear on the number of root children. If you use</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true"></a><span class="co">// it with a large tree where the root has many children, you may get a</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true"></a><span class="co">// performance hit. To avoid this hit, you can create your own accelerator</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true"></a><span class="co">// structure. For example, before doing a lookup, do a single traverse at the</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true"></a><span class="co">// root level to fill an `std::map&lt;csubstr,size_t&gt;` mapping key names to node</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true"></a><span class="co">// indices; with a node index, a lookup (via `Tree::get()`) is O(1), so this way</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true"></a><span class="co">// you can get O(log n) lookup from a key.</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true"></a><span class="co">// </span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true"></a><span class="co">// As for `NodeRef`, the difference from `NodeRef::operator[]`</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true"></a><span class="co">// to `Tree::operator[]` is that the latter refers to the root node, whereas</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true"></a><span class="co">// the former can be invoked on any node. But the lookup process is the same for</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true"></a><span class="co">// both and their algorithmic complexity is the same: they are both linear in</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true"></a><span class="co">// the number of direct children; but depending on the data, that number may</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true"></a><span class="co">// be very different from one to another.</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true"></a></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true"></a><span class="co">// Hierarchy:</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true"></a></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true"></a>{</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true"></a>    ryml::NodeRef foo = root.first_child();</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true"></a>    ryml::NodeRef john = root.last_child();</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true"></a>    CHECK(tree.size() == <span class="dv">6</span>); <span class="co">// O(1) number of nodes in the tree</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true"></a>    CHECK(root.num_children() == <span class="dv">3</span>); <span class="co">// O(num_children[root])</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true"></a>    CHECK(foo.num_siblings() == <span class="dv">3</span>); <span class="co">// O(num_children[parent(foo)])</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true"></a>    CHECK(foo.parent().id() == root.id()); <span class="co">// parent() is O(1)</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true"></a>    CHECK(root.first_child().id() == root[<span class="st">&quot;foo&quot;</span>].id()); <span class="co">// first_child() is O(1)</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true"></a>    CHECK(root.last_child().id() == root[<span class="st">&quot;john&quot;</span>].id()); <span class="co">// last_child() is O(1)</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true"></a>    CHECK(john.first_sibling().id() == foo.id());</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true"></a>    CHECK(foo.last_sibling().id() == john.id());</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true"></a>    <span class="co">// prev_sibling(), next_sibling(): (both are O(1))</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true"></a>    CHECK(foo.num_siblings() == root.num_children());</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true"></a>    CHECK(foo.prev_sibling().id() == ryml::NONE); <span class="co">// foo is the first_child()</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true"></a>    CHECK(foo.next_sibling().key() == <span class="st">&quot;bar&quot;</span>);</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true"></a>    CHECK(foo.next_sibling().next_sibling().key() == <span class="st">&quot;john&quot;</span>);</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true"></a>    CHECK(foo.next_sibling().next_sibling().next_sibling().id() == ryml::NONE); <span class="co">// john is the last_child()</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true"></a>}</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true"></a></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true"></a><span class="co">// Iterating:</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true"></a>{</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true"></a>    ryml::csubstr expected_keys[] = {<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;john&quot;</span>};</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true"></a>    <span class="co">// iterate children using the high-level node API:</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true"></a>    {</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true"></a>        <span class="dt">size_t</span> count = <span class="dv">0</span>;</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true"></a>        <span class="cf">for</span>(ryml::NodeRef <span class="at">const</span>&amp; child : root.children())</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true"></a>            CHECK(child.key() == expected_keys[count++]);</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true"></a>    }</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true"></a>    <span class="co">// iterate siblings using the high-level node API:</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true"></a>    {</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true"></a>        <span class="dt">size_t</span> count = <span class="dv">0</span>;</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true"></a>        <span class="cf">for</span>(ryml::NodeRef <span class="at">const</span>&amp; child : root[<span class="st">&quot;foo&quot;</span>].siblings())</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true"></a>            CHECK(child.key() == expected_keys[count++]);</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true"></a>    }</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true"></a>    <span class="co">// iterate children using the lower-level tree index API:</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true"></a>    {</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true"></a>        <span class="dt">size_t</span> count = <span class="dv">0</span>;</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true"></a>        <span class="cf">for</span>(<span class="dt">size_t</span> child_id = tree.first_child(root_id); child_id != ryml::NONE; child_id = tree.next_sibling(child_id))</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true"></a>            CHECK(tree.key(child_id) == expected_keys[count++]);</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true"></a>    }</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true"></a>    <span class="co">// iterate siblings using the lower-level tree index API:</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true"></a>    <span class="co">// (notice the only difference from above is in the loop</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true"></a>    <span class="co">// preamble, which calls tree.first_sibling(bar_id) instead of</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true"></a>    <span class="co">// tree.first_child(root_id))</span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true"></a>    {</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true"></a>        <span class="dt">size_t</span> count = <span class="dv">0</span>;</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true"></a>        <span class="cf">for</span>(<span class="dt">size_t</span> child_id = tree.first_sibling(bar_id); child_id != ryml::NONE; child_id = tree.next_sibling(child_id))</span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true"></a>            CHECK(tree.key(child_id) == expected_keys[count++]);</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true"></a>    }</span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true"></a>}</span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true"></a></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true"></a></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true"></a><span class="co">// Gotchas:</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true"></a>CHECK(!tree[<span class="st">&quot;bar&quot;</span>].has_val());          <span class="co">// seq is a container, so no val</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true"></a>CHECK(!tree[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>].has_key());       <span class="co">// belongs to a seq, so no key</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true"></a>CHECK(!tree[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>].has_key());       <span class="co">// belongs to a seq, so no key</span></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true"></a><span class="co">//CHECK(tree[&quot;bar&quot;].val() == BOOM!);    // ... so attempting to get a val is undefined behavior</span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true"></a><span class="co">//CHECK(tree[&quot;bar&quot;][0].key() == BOOM!); // ... so attempting to get a key is undefined behavior</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true"></a><span class="co">//CHECK(tree[&quot;bar&quot;][1].key() == BOOM!); // ... so attempting to get a key is undefined behavior</span></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true"></a></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true"></a><span class="co">// Deserializing: use operator&gt;&gt;</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true"></a>{</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true"></a>    <span class="dt">int</span> foo = <span class="dv">0</span>, bar0 = <span class="dv">0</span>, bar1 = <span class="dv">0</span>;</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true"></a>    <span class="bu">std::</span>string john;</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true"></a>    root[<span class="st">&quot;foo&quot;</span>] &gt;&gt; foo;</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true"></a>    root[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>] &gt;&gt; bar0;</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true"></a>    root[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>] &gt;&gt; bar1;</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true"></a>    root[<span class="st">&quot;john&quot;</span>] &gt;&gt; john; <span class="co">// requires from_chars(std::string). see serialization samples below.</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true"></a>    CHECK(foo == <span class="dv">1</span>);</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true"></a>    CHECK(bar0 == <span class="dv">2</span>);</span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true"></a>    CHECK(bar1 == <span class="dv">3</span>);</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true"></a>    CHECK(john == <span class="st">&quot;doe&quot;</span>);</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true"></a>}</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true"></a></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true"></a></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true"></a><span class="co">// Modifying existing nodes: operator&lt;&lt; vs operator=</span></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true"></a></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true"></a><span class="co">// operator= assigns an existing string to the receiving node.</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true"></a><span class="co">// This pointer will be in effect until the tree goes out of scope</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true"></a><span class="co">// so beware to only assign from strings outliving the tree.</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true"></a>root[<span class="st">&quot;foo&quot;</span>] = <span class="st">&quot;says you&quot;</span>;</span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>] = <span class="st">&quot;-2&quot;</span>;</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>] = <span class="st">&quot;-3&quot;</span>;</span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true"></a>root[<span class="st">&quot;john&quot;</span>] = <span class="st">&quot;ron&quot;</span>;</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true"></a><span class="co">// Now the tree is _pointing_ at the memory of the strings above.</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true"></a><span class="co">// That is OK because those are static strings and will outlive</span></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true"></a><span class="co">// the tree.</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;foo&quot;</span>].val() == <span class="st">&quot;says you&quot;</span>);</span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>].val() == <span class="st">&quot;-2&quot;</span>);</span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>].val() == <span class="st">&quot;-3&quot;</span>);</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;john&quot;</span>].val() == <span class="st">&quot;ron&quot;</span>);</span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true"></a><span class="co">// WATCHOUT: do not assign from temporary objects:</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true"></a><span class="co">// {</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true"></a><span class="co">//     std::string crash(&quot;will dangle&quot;);</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true"></a><span class="co">//     root[&quot;john&quot;] == ryml::to_csubstr(crash);</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true"></a><span class="co">// }</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true"></a><span class="co">// CHECK(root[&quot;john&quot;] == &quot;dangling&quot;); // CRASH! the string was deallocated</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true"></a></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true"></a><span class="co">// operator&lt;&lt; first serializes the input to the tree&#39;s arena, then</span></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true"></a><span class="co">// assigns the serialized string to the receiving node. This avoids</span></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true"></a><span class="co">// constraints with the lifetime, since the arena lives with the tree.</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true"></a>CHECK(tree.arena().empty());</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true"></a>root[<span class="st">&quot;foo&quot;</span>] &lt;&lt; <span class="st">&quot;says who&quot;</span>;  <span class="co">// requires to_chars(). see serialization samples below.</span></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>] &lt;&lt; <span class="dv">20</span>;</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>] &lt;&lt; <span class="dv">30</span>;</span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true"></a>root[<span class="st">&quot;john&quot;</span>] &lt;&lt; <span class="st">&quot;deere&quot;</span>;</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;foo&quot;</span>].val() == <span class="st">&quot;says who&quot;</span>);</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>].val() == <span class="st">&quot;20&quot;</span>);</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>].val() == <span class="st">&quot;30&quot;</span>);</span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;john&quot;</span>].val() == <span class="st">&quot;deere&quot;</span>);</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true"></a>CHECK(tree.arena() == <span class="st">&quot;says who2030deere&quot;</span>); <span class="co">// the result of serializations to the tree arena</span></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true"></a><span class="co">// using operator&lt;&lt; instead of operator=, the crash above is avoided:</span></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true"></a>{</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true"></a>    <span class="bu">std::</span>string ok(<span class="st">&quot;in_scope&quot;</span>);</span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true"></a>    <span class="co">// root[&quot;john&quot;] == ryml::to_csubstr(ok); // don&#39;t, will dangle</span></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true"></a>    root[<span class="st">&quot;john&quot;</span>] &lt;&lt; ryml::to_csubstr(ok); <span class="co">// OK, copy to the tree&#39;s arena</span></span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true"></a>}</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;john&quot;</span>] == <span class="st">&quot;in_scope&quot;</span>); <span class="co">// OK!</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true"></a>CHECK(tree.arena() == <span class="st">&quot;says who2030deerein_scope&quot;</span>); <span class="co">// the result of serializations to the tree arena</span></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true"></a></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true"></a></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true"></a><span class="co">// Adding new nodes:</span></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true"></a></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true"></a><span class="co">// adding a keyval node to a map:</span></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">3</span>);</span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true"></a>root[<span class="st">&quot;newkeyval&quot;</span>] = <span class="st">&quot;shiny and new&quot;</span>; <span class="co">// using these strings</span></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true"></a>root.append_child() &lt;&lt; ryml::key(<span class="st">&quot;newkeyval (serialized)&quot;</span>) &lt;&lt; <span class="st">&quot;shiny and new (serialized)&quot;</span>; <span class="co">// serializes and assigns the serialization</span></span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">5</span>);</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newkeyval&quot;</span>].key() == <span class="st">&quot;newkeyval&quot;</span>);</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newkeyval&quot;</span>].val() == <span class="st">&quot;shiny and new&quot;</span>);</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newkeyval (serialized)&quot;</span>].key() == <span class="st">&quot;newkeyval (serialized)&quot;</span>);</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newkeyval (serialized)&quot;</span>].val() == <span class="st">&quot;shiny and new (serialized)&quot;</span>);</span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true"></a>CHECK( ! root[<span class="st">&quot;newkeyval&quot;</span>].key().is_sub(tree.arena())); <span class="co">// it&#39;s using directly the static string above</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true"></a>CHECK( ! root[<span class="st">&quot;newkeyval&quot;</span>].val().is_sub(tree.arena())); <span class="co">// it&#39;s using directly the static string above</span></span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true"></a>CHECK(   root[<span class="st">&quot;newkeyval (serialized)&quot;</span>].key().is_sub(tree.arena())); <span class="co">// it&#39;s using a serialization of the string above</span></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true"></a>CHECK(   root[<span class="st">&quot;newkeyval (serialized)&quot;</span>].val().is_sub(tree.arena())); <span class="co">// it&#39;s using a serialization of the string above</span></span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true"></a><span class="co">// adding a val node to a seq:</span></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>].num_children() == <span class="dv">2</span>);</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">2</span>] = <span class="st">&quot;oh so nice&quot;</span>;</span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true"></a>root[<span class="st">&quot;bar&quot;</span>][<span class="dv">3</span>] &lt;&lt; <span class="st">&quot;oh so nice (serialized)&quot;</span>;</span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>].num_children() == <span class="dv">4</span>);</span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">2</span>].val() == <span class="st">&quot;oh so nice&quot;</span>);</span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;bar&quot;</span>][<span class="dv">3</span>].val() == <span class="st">&quot;oh so nice (serialized)&quot;</span>);</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true"></a><span class="co">// adding a seq node:</span></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">5</span>);</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true"></a>root[<span class="st">&quot;newseq&quot;</span>] |= ryml::SEQ;</span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true"></a>root.append_child() &lt;&lt; ryml::key(<span class="st">&quot;newseq (serialized)&quot;</span>) |= ryml::SEQ;</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">7</span>);</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newseq&quot;</span>].num_children() == <span class="dv">0</span>);</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newseq (serialized)&quot;</span>].num_children() == <span class="dv">0</span>);</span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true"></a><span class="co">// adding a map node:</span></span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">7</span>);</span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true"></a>root[<span class="st">&quot;newmap&quot;</span>] |= ryml::MAP;</span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true"></a>root.append_child() &lt;&lt; ryml::key(<span class="st">&quot;newmap (serialized)&quot;</span>) |= ryml::SEQ;</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true"></a>CHECK(root.num_children() == <span class="dv">9</span>);</span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newmap&quot;</span>].num_children() == <span class="dv">0</span>);</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;newmap (serialized)&quot;</span>].num_children() == <span class="dv">0</span>);</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true"></a><span class="co">// operator[] does not mutate the tree until the returned node is</span></span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true"></a><span class="co">// written to.</span></span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true"></a><span class="co">// Until such time, the NodeRef object keeps in itself the required</span></span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true"></a><span class="co">// information to write to the proper place in the tree. This is</span></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true"></a><span class="co">// called being in a &quot;seed&quot; state.</span></span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true"></a><span class="co">// This means that passing a key/index which does not exist will</span></span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true"></a><span class="co">// not mutate the tree, but will instead store (in the node) the</span></span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true"></a><span class="co">// proper place of the tree to do so if and when it is required.</span></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true"></a><span class="co">//</span></span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true"></a><span class="co">// This is a significant difference from eg, the behavior of</span></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true"></a><span class="co">// std::map, which mutates the map immediately within the call to</span></span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true"></a><span class="co">// operator[].</span></span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true"></a>CHECK(!root.has_child(<span class="st">&quot;I am nobody&quot;</span>));</span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true"></a>ryml::NodeRef nobody = root[<span class="st">&quot;I am nobody&quot;</span>];</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true"></a>CHECK(nobody.valid());   <span class="co">// points at the tree, and a specific place in the tree</span></span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true"></a>CHECK(nobody.is_seed()); <span class="co">// ... but nothing is there yet.</span></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true"></a>CHECK(!root.has_child(<span class="st">&quot;I am nobody&quot;</span>)); <span class="co">// same as above</span></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true"></a>ryml::NodeRef somebody = root[<span class="st">&quot;I am somebody&quot;</span>];</span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true"></a>CHECK(!root.has_child(<span class="st">&quot;I am somebody&quot;</span>)); <span class="co">// same as above</span></span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true"></a>CHECK(somebody.valid());</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true"></a>CHECK(somebody.is_seed()); <span class="co">// same as above</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true"></a>somebody = <span class="st">&quot;indeed&quot;</span>;  <span class="co">// this will commit to the tree, mutating at the proper place</span></span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true"></a>CHECK(somebody.valid());</span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true"></a>CHECK(!somebody.is_seed()); <span class="co">// now the tree has this node, and it is no longer a seed</span></span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true"></a>CHECK(root.has_child(<span class="st">&quot;I am somebody&quot;</span>));</span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true"></a>CHECK(root[<span class="st">&quot;I am somebody&quot;</span>].val() == <span class="st">&quot;indeed&quot;</span>);</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true"></a></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true"></a><span class="co">//------------------------------------------------------------------</span></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true"></a><span class="co">// Emitting:</span></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true"></a></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true"></a><span class="co">// emit to a FILE*</span></span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true"></a>ryml::<span class="ex">emit</span>(tree, stdout);</span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true"></a><span class="co">// emit to a stream</span></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true"></a><span class="bu">std::</span>stringstream ss;</span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true"></a>ss &lt;&lt; tree;</span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true"></a><span class="bu">std::</span>string stream_result = ss.str();</span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true"></a><span class="co">// emit to a buffer:</span></span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true"></a><span class="bu">std::</span>string str_result = ryml::emitrs&lt;<span class="bu">std::</span>string&gt;(tree);</span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true"></a><span class="co">// can emit to any given buffer:</span></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true"></a><span class="dt">char</span> buf[<span class="dv">1024</span>];</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true"></a>ryml::csubstr buf_result = ryml::<span class="ex">emit</span>(tree, buf);</span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true"></a><span class="co">// now check</span></span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true"></a>ryml::csubstr expected_result = <span class="st">R&quot;(foo: says who</span></span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true"></a><span class="st">bar:</span></span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true"></a><span class="st">- 20</span></span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true"></a><span class="st">- 30</span></span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true"></a><span class="st">- oh so nice</span></span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true"></a><span class="st">- oh so nice (serialized)</span></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true"></a><span class="st">john: in_scope</span></span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true"></a><span class="st">newkeyval: shiny and new</span></span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true"></a><span class="st">newkeyval (serialized): shiny and new (serialized)</span></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true"></a><span class="st">newseq: []</span></span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true"></a><span class="st">newseq (serialized): []</span></span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true"></a><span class="st">newmap: {}</span></span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true"></a><span class="st">newmap (serialized): []</span></span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true"></a><span class="st">I am somebody: indeed</span></span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true"></a><span class="st">)&quot;</span>;</span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true"></a>CHECK(buf_result == expected_result);</span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true"></a>CHECK(str_result == expected_result);</span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true"></a>CHECK(stream_result == expected_result);</span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true"></a><span class="co">// There are many possibilities to emit to buffer;</span></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true"></a><span class="co">// please look at the quickstart sample functions below.</span></span></code></pre></div>
<p>The <a href="./samples/quickstart.cpp">quickstart.cpp sample</a> (from which the above overview was taken) has many more detailed examples, and should be your first port of call to find out any particular point about ryml’s API. It is tested in the CI, and thus has the correct behavior. There you can find the following subjects being addressed:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>sample_substr();               <span class="co">///&lt; about ryml&#39;s string views (from c4core)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>sample_parse_read_only();      <span class="co">///&lt; parse a read-only YAML source buffer</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>sample_parse_in_situ();        <span class="co">///&lt; parse an immutable YAML source buffer</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>sample_parse_reuse_tree();     <span class="co">///&lt; parse into an existing tree, maybe into a node</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>sample_parse_reuse_parser();   <span class="co">///&lt; reuse an existing parser</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>sample_parse_reuse_tree_and_parser(); <span class="co">///&lt; how to reuse existing trees and parsers</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>sample_iterate_trees();        <span class="co">///&lt; visit individual nodes and iterate through trees</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>sample_create_trees();         <span class="co">///&lt; programatically create trees</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>sample_tree_arena();           <span class="co">///&lt; interact with the tree&#39;s serialization arena</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>sample_fundamental_types();    <span class="co">///&lt; serialize/deserialize fundamental types</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>sample_formatting();           <span class="co">///&lt; control formatting when serializing/deserializing</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>sample_base64();               <span class="co">///&lt; encode/decode base64</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>sample_user_scalar_types();    <span class="co">///&lt; serialize/deserialize scalar (leaf/string) types</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>sample_user_container_types(); <span class="co">///&lt; serialize/deserialize container (map or seq) types</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>sample_std_types();            <span class="co">///&lt; serialize/deserialize STL containers</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>sample_emit_to_container();    <span class="co">///&lt; emit to memory, eg a string or vector-like container</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>sample_emit_to_stream();       <span class="co">///&lt; emit to a stream, eg std::ostream</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>sample_emit_to_file();         <span class="co">///&lt; emit to a FILE*</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>sample_emit_nested_node();     <span class="co">///&lt; pick a nested node as the root when emitting</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>sample_json();                 <span class="co">///&lt; notes and constraints: JSON parsing and emitting</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>sample_anchors_and_aliases();  <span class="co">///&lt; deal with YAML anchors and aliases</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>sample_tags();                 <span class="co">///&lt; deal with YAML type tags</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>sample_docs();                 <span class="co">///&lt; deal with YAML docs</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>sample_error_handler();        <span class="co">///&lt; set a custom error handler</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>sample_global_allocator();     <span class="co">///&lt; set a global allocator for ryml</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>sample_per_tree_allocator();   <span class="co">///&lt; set per-tree allocators</span></span></code></pre></div>
<hr />
<h2 id="using-ryml-in-your-project">Using ryml in your project</h2>
<p>As with any other library, you have the option to integrate ryml into your project’s build setup, thereby building ryml together with your project, or – prior to configuring your project – you can have ryml installed either manually or through package managers. Currently <a href="https://cmake.org/">cmake</a> is required; we recommend a recent cmake version, at least 3.13.</p>
<p>These samples show how to build an application using ryml. All the samples use <a href="./samples/quickstart.cpp">the same quickstart executable source</a>, but are built in different ways, and this shows multiple ways to integrate ryml into your project. We also encourage you to refer to the quickstart source itself, which extensively covers most of the functionality that you may want out of ryml.</p>
<p>Each sample brings a <code>run.sh</code> script with the sequence of commands required to successfully build and run the application (this is a bash script and runs in Linux and MacOS, but it is also possible to run in Windows via Git Bash or the WSL). Click on the links below to find out more about each sample:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Sample name</th>
<th>ryml is part of build?</th>
<th style="text-align: left;">cmake file</th>
<th style="text-align: left;">commands</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="./samples/add_subdirectory"><code>add_subdirectory</code></a></td>
<td>yes</td>
<td style="text-align: left;"><a href="./samples/add_subdirectory/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/add_subdirectory/run.sh"><code>run.sh</code></a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="./samples/fetch_content"><code>fetch_content</code></a></td>
<td>yes</td>
<td style="text-align: left;"><a href="./samples/fetch_content/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/fetch_content/run.sh"><code>run.sh</code></a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="./samples/find_package"><code>find_package</code></a></td>
<td>no, needs prior install</td>
<td style="text-align: left;"><a href="./samples/find_package/CMakeLists.txt"><code>CMakeLists.txt</code></a></td>
<td style="text-align: left;"><a href="./samples/find_package/run.sh"><code>run.sh</code></a></td>
</tr>
</tbody>
</table>
<h3 id="building-ryml-as-part-of-your-project">Building ryml as part of your project</h3>
<p>ryml is a small library, so this is the advised way. If you’re using git, we suggest adding ryml as git submodule of your repo. This makes it easy to track any upstream changes in ryml. Otherwise, you will have to start by cloning the repo:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">git</span> clone --recursive https://github.com/biojppm/rapidyaml</span></code></pre></div>
<p>Take care to use the <code>--recursive</code> flag to force git to clone the submodules as well. If you omit <code>--recursive</code>, after cloning you will have to do <code>git submodule init</code> and <code>git submodule update</code> to ensure the submodules are checked out.</p>
<p>Now that you have ryml available, you can add it in cmake either from cmake’s <code>add_subdirectory()</code> subdirectory, or through cmake’s <code>FetchContent</code>. Let’s start first by <code>add_subdirectory()</code>; here’s a self-contained example that adds ryml as a cmake subdirectory:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> 3.13)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">project</span>(quickstart <span class="ot">LANGUAGES</span> <span class="ot">CXX</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">add_subdirectory</span>(<span class="dv">${</span>PATH_TO_RYML<span class="dv">}</span> ryml)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="kw">add_executable</span>(quickstart quickstart.cpp)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">target_link_libraries</span>(quickstart ryml)</span></code></pre></div>
<p>This will build ryml as part of your project, and is the easiest way to integrate, particularly if you add ryml as a submodule of your project. You can find <a href="samples/add_subdirectory">a fully working <code>add_subdirectory()</code> example here</a>.</p>
<p>Alternatively, if you prefer to use cmake’s <code>FetchContent</code>, here’s a self-contained example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> 3.13)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">project</span>(quickstart <span class="ot">LANGUAGES</span> <span class="ot">CXX</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">include</span>(FetchContent)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="fu">FetchContent_Declare</span>(ryml</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    GIT_REPOSITORY https://github.com/biojppm/rapidyaml.git</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    GIT_TAG master     <span class="co"># or the desired branch or tag or commit</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    GIT_SHALLOW false  <span class="co"># ensure ryml&#39;s submodules are checked out</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="fu">FetchContent_MakeAvailable</span>(ryml)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="kw">add_executable</span>(quickstart quickstart.cpp)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="kw">target_link_libraries</span>(quickstart ryml)</span></code></pre></div>
<p>You can <a href="samples/fetch_content">try this sample yourself here</a>.</p>
<h3 id="install-ryml-first">Install ryml first</h3>
<p>You can also build and install ryml in the customary cmake way prior to consuming it in your project via <code>find_package()</code>. This is the traditional way, and a little less practical than above. But first note ryml is now available in some package managers such as <a href="https://vcpkg.io">vcpkg</a>.</p>
<p>We have to start by building ryml. For Visual Studio &amp; multi-configuration CMake generators, this would be:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">cmake</span> -S path/to/rapidyaml -B path/to/ryml/build/dir <span class="kw">\</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>      <span class="ex">-DCMAKE_INSTALL_PREFIX</span>=path/to/ryml/install/dir</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="fu">cmake</span> --build path/to/ryml/build/dir --parallel --config Release</span></code></pre></div>
<p>whereas for single configuration CMake generators (Ninja, Unix Makefiles, etc), this would be:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">cmake</span> -S path/to/rapidyaml -B path/to/ryml/build/dir <span class="kw">\</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>      <span class="ex">-DCMAKE_INSTALL_PREFIX</span>=path/to/ryml/install/dir <span class="kw">\</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>      <span class="ex">-DCMAKE_BUILD_TYPE</span>=Release</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">cmake</span> --build path/to/ryml/build/dir --parallel</span></code></pre></div>
<p>(Note the <code>-S</code> and <code>-B</code> options first appeared in cmake 3.13 and are not available in earlier cmake versions). Now you can install ryml:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="fu">cmake</span> --build path/to/ryml/build/dir --target install</span></code></pre></div>
<p>This will get ryml installed into the directory <code>path/to/ryml/install/dir</code>, together with cmake export files for ryml, which <code>find_package()</code> will need to successfully import ryml to your project.</p>
<p>Now to consume this installed ryml version, do the following:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co"># somewhere in your CMakeLists.txt</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co"># this is the target you wish to link with ryml</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">add_library</span>(foolib a.cpp b.cpp)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="co"># instruct cmake to search for ryml</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="kw">find_package</span>(ryml <span class="ot">REQUIRED</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="kw">target_link_libraries</span>(foolib <span class="ot">PUBLIC</span> ryml::ryml)  <span class="co"># </span><span class="al">NOTE</span><span class="co"> namespace ryml::</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="kw">add_executable</span>(fooexe main.cpp)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="kw">target_link_libraries</span>(fooexe foolib) <span class="co"># brings in ryml</span></span></code></pre></div>
<p>Note a significant difference to the subdirectory approach from the previous section: the installed ryml cmake exports file places the ryml library target in the <code>ryml::</code> namespace.</p>
<p>Now when building your project, you will need to point cmake to the installed ryml. To do this, simply add the ryml install directory to your project’s <code>CMAKE_PREFIX_PATH</code> by doing eg <code>-DCMAKE_PREFIX_PATH=path/to/ryml/install/dir</code> when configuring your project, or by setting this variable in the cmake GUI if that’s what you prefer to use.</p>
<p>You can also set (via command line or GUI) the variable <code>ryml_DIR</code> to the directory where the exports file <code>rymlConfig.cmake</code> was installed (which is different across platforms); search for this file in the ryml install tree, and provide the directory where it is located. For example, in Windows with the example above, this would be <code>-Dryml_DIR=path/to/ryml/install/dir/cmake</code>.</p>
<h3 id="cmake-build-settings-for-ryml">cmake build settings for ryml</h3>
<p>The following cmake variables can be used to control the build behavior of ryml:</p>
<ul>
<li><code>RYML_DEFAULT_CALLBACKS=ON/OFF</code>. Enable/disable ryml’s default implementation of error and allocation callbacks. Defaults to <code>ON</code>.</li>
<li><code>RYML_STANDALONE=ON/OFF</code>. ryml uses <a href="https://github.com/biojppm/c4core">c4core</a>, a C++ library with low-level multi-platform utilities for C++. When <code>RYML_STANDALONE=ON</code>, c4core is incorporated into ryml as if it is the same library. Defaults to <code>ON</code>.</li>
</ul>
<p>If you’re developing ryml or just debugging problems with ryml itself, the following variables can be helpful: * <code>RYML_DEV=ON/OFF</code>: a bool variable which enables development targets such as unit tests, benchmarks, etc. Defaults to <code>OFF</code>. * <code>RYML_DBG=ON/OFF</code>: a bool variable which enables verbose prints from parsing code; can be useful to figure out parsing problems. Defaults to <code>OFF</code>.</p>
<h4 id="forcing-ryml-to-use-a-different-c4core-version">Forcing ryml to use a different c4core version</h4>
<p>ryml is strongly coupled to c4core, and this is reinforced by the fact that c4core is a submodule of the current repo. However, it is still possible to use a c4core version different from the one in the repo (of course, only if there are no incompatibilities between the versions). You can find out how to achieve this by looking at the <a href="samples/custom_c4core"><code>custom_c4core</code> sample</a>.</p>
<hr />
<h2 id="other-languages">Other languages</h2>
<p>One of the aims of ryml is to provide an efficient YAML API for other languages. There’s already a cursory implementation for Python (using only the low-level API). After ironing out the general approach, other languages are likely to follow: probably (in order) JavaScript, C#, Java, Ruby, PHP, Octave and R (all of this is possible because we’re using <a href="http://www.swig.org/">SWIG</a>, which makes it easy to do so).</p>
<h3 id="python">Python</h3>
<p>(Note that this is a work in progress. Additions will be made and things will be changed.) With that said, here’s an example of the Python API:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="im">import</span> ryml</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co"># because ryml does not take ownership of the source buffer</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co"># ryml cannot accept strings; only bytes or bytearrays</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>src <span class="op">=</span> b<span class="st">&quot;{HELLO: a, foo: b, bar: c, baz: d, seq: [0, 1, 2, 3]}&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">def</span> check(tree):</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    <span class="co"># for now, only the index-based low-level API is implemented</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="cf">assert</span> tree.size() <span class="op">==</span> <span class="dv">10</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    <span class="cf">assert</span> tree.root_id() <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="cf">assert</span> tree.first_child(<span class="dv">0</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    <span class="cf">assert</span> tree.next_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>    <span class="cf">assert</span> tree.first_sibling(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    <span class="cf">assert</span> tree.last_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    <span class="co"># use bytes objects for queries</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;foo&quot;</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>    <span class="cf">assert</span> tree.key(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;foo&quot;</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>    <span class="cf">assert</span> tree.val(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;b&quot;</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;seq&quot;</span>) <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>    <span class="cf">assert</span> tree.is_seq(<span class="dv">5</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>    <span class="co"># to loop over children:</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.children(tree, <span class="dv">5</span>)):</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>        <span class="cf">assert</span> tree.val(ch) <span class="op">==</span> [b<span class="st">&quot;0&quot;</span>, b<span class="st">&quot;1&quot;</span>, b<span class="st">&quot;2&quot;</span>, b<span class="st">&quot;3&quot;</span>][i]</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>    <span class="co"># to loop over siblings:</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>    <span class="cf">for</span> i, sib <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.siblings(tree, <span class="dv">5</span>)):</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a>        <span class="cf">assert</span> tree.key(sib) <span class="op">==</span> [b<span class="st">&quot;HELLO&quot;</span>, b<span class="st">&quot;foo&quot;</span>, b<span class="st">&quot;bar&quot;</span>, b<span class="st">&quot;baz&quot;</span>, b<span class="st">&quot;seq&quot;</span>][i]</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>    <span class="co"># to walk over all elements</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> tree.size()</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a>    <span class="cf">for</span> n, indentation_level <span class="kw">in</span> ryml.walk(tree):</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>        <span class="co"># just a dumb emitter</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>        left <span class="op">=</span> <span class="st">&quot;  &quot;</span> <span class="op">*</span> indentation_level</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>        <span class="cf">if</span> tree.is_keyval(n):</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a>           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.key(n), tree.val(n))</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a>        <span class="cf">elif</span> tree.is_val(n):</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a>           <span class="bu">print</span>(<span class="st">&quot;- </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.val(n))</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a>        <span class="cf">elif</span> tree.is_keyseq(n):</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">:&quot;</span>.<span class="bu">format</span>(left, tree.key(n))</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a>        visited[inode] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a>    <span class="cf">assert</span> <span class="va">False</span> <span class="kw">not</span> <span class="kw">in</span> visited</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true"></a>    <span class="co"># </span><span class="al">NOTE</span><span class="co"> about encoding!</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true"></a>    k <span class="op">=</span> tree.get_key(<span class="dv">5</span>)</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true"></a>    <span class="bu">print</span>(k)  <span class="co"># &#39;&lt;memory at 0x7f80d5b93f48&gt;&#39;</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true"></a>    <span class="cf">assert</span> k <span class="op">==</span> b<span class="st">&quot;seq&quot;</span>               <span class="co"># ok, as expected</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true"></a>    <span class="cf">assert</span> k <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>                <span class="co"># not ok - </span><span class="al">NOTE</span><span class="co"> THIS! </span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true"></a>    <span class="cf">assert</span> <span class="bu">str</span>(k) <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>           <span class="co"># not ok</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true"></a>    <span class="cf">assert</span> <span class="bu">str</span>(k, <span class="st">&quot;utf8&quot;</span>) <span class="op">==</span> <span class="st">&quot;seq&quot;</span>   <span class="co"># ok again</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true"></a></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true"></a><span class="co"># parse immutable buffer</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true"></a>tree <span class="op">=</span> ryml.parse(src)</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true"></a>check(tree) <span class="co"># OK</span></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true"></a></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true"></a><span class="co"># also works, but requires bytearrays or</span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true"></a><span class="co"># objects offering writeable memory</span></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true"></a>mutable <span class="op">=</span> <span class="bu">bytearray</span>(src)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true"></a>tree <span class="op">=</span> ryml.parse_in_situ(mutable)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true"></a>check(tree) <span class="co"># OK</span></span></code></pre></div>
<p>As expected, the performance results so far are encouraging. In a <a href="api/python/parse_bm.py">timeit benchmark</a> compared against <a href="https://pyyaml.org/">PyYaml</a> and <a href="https://yaml.readthedocs.io/en/latest/">ruamel.yaml</a>, ryml parses quicker by a factor of 30x-50x:</p>
<pre><code>+-----------------------+-------+----------+---------+----------------+
| case                  | iters | time(ms) | avg(ms) | avg_read(MB/s) |
+-----------------------+-------+----------+---------+----------------+
| parse:RuamelYaml      |    88 | 800.483  |  9.096  |      0.234     |
| parse:PyYaml          |    88 | 541.370  |  6.152  |      0.346     |
| parse:RymlRo          |  3888 | 776.020  |  0.200  |     10.667     |
| parse:RymlRoReuse     |  1888 | 381.558  |  0.202  |     10.535     |
| parse:RymlRw          |  3888 | 775.121  |  0.199  |     10.679     |
| parse:RymlRwReuse     |  3888 | 774.534  |  0.199  |     10.687     |
+-----------------------+-------+----------+---------+----------------+</code></pre>
<p>(Note that the results above are somewhat biased towards ryml, because it does not perform any type conversions: return types are merely <code>memoryviews</code> to the source buffer.)</p>
<hr />
<h2 id="yaml-standard-conformance">YAML standard conformance</h2>
<p>ryml is under active development, but is close to feature complete. The following YAML core features are well covered in the unit tests: * mappings * sequences * complex keys * literal blocks * quoted scalars * tags * anchors and references * UTF8 is expected to mostly work</p>
<p>Of course, there are many dark corners in YAML, and there certainly can appear cases which ryml fails to parse. Your <a href="https://github.com/biojppm/rapidyaml/issues">bug reports or pull requests!</a> are very welcome.</p>
<p>See also <a href="./ROADMAP.md">the roadmap</a> for a list of future work.</p>
<h3 id="test-suite-status">Test suite status</h3>
<p>Integration of the &gt;300 cases in the <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a> is ongoing work. Each of these tests have several subparts: * in-yaml: mildly, plainly or extremely difficult-to-parse yaml * in-json: equivalent json (where possible/meaningful) * out-yaml: equivalent standard yaml * events: equivalent libyaml events allowing to establish correctness of the parsed results</p>
<p>When testing, ryml tries to parse each of the 3 yaml/json parts. If the parsing suceeds, then the ryml test will emit the parsed tree, then parse the emitted result and verify that emission is idempotent, ie that the emitted result is the same as its input without any loss of information. To ensure correctness, this happens over four levels of parse/emission pairs, resulting on ~200 checks per test case.</p>
<p>Please note that in <a href="http://matrix.yaml.io/">their own words</a>, the tests from the YAML test suite <em>contain a lot of edge cases that don’t play such an important role in real world examples</em>. Despite the extreme focus of the test suite, as of May 2020, ryml only fails to parse ~30 out of the <sub>1000=</sub>3x300 cases from the test suite. Out of all other cases, all the ~200 checks per case are 100% successful for consistency over parse/emit pairs — but please note that the events part is not yet read in and used to check for correctness, and therefore that <strong>even though ryml may suceed in parsing, there still exists a minority of cases which may not be correct</strong>. Currently, I would estimate this fraction at somewhere around 5%. These are the suite cases where ryml fails to parse any of its subparts: <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/EXG3.tml">EXG3</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/M7A3.tml">M7A3</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/735Y.tml">735Y</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/82AN.tml">82AN</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/9YRD.tml">9YRD</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/EX5H.tml">EX5H</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/HS5T.tml">HS5T</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/7T8X.tml">7T8X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/RZP5.tml">RZP5</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/FH7J.tml">FH7J</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/PW8X.tml">PW8X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/CN3R.tml">CN3R</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6BCT.tml">6BCT</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/G5U8.tml">G5U8</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/K858.tml">K858</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/NAT4.tml">NAT4</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/9MMW.tml">9MMW</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/DC7X.tml">DC7X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/L94M.tml">L94M</a>,</p>
<p>Except for the known limitations listed next, all other suite cases are expected to work.</p>
<hr />
<h2 id="known-limitations">Known limitations</h2>
<p>ryml makes no effort to follow the standard in the following situations:</p>
<ul>
<li><code>%YAML</code> directives have no effect and are ignored.</li>
<li><code>%TAG</code> directives have no effect and are ignored. All schemas are assumed to be the default YAML 2002 schema.</li>
<li>container elements are not accepted as mapping keys. keys must be simple strings and cannot themselves be mappings or sequences. But mapping values can be any of the above. <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a> cases: <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/4FJ6.tml">4FJ6</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6BFJ.tml">6BFJ</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6PBE.tml">6PBE</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6PBE.tml">6PBE</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/KK5P.tml">KK5P</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/KZN9.tml">KZN9</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/LX3P.tml">LX3P</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/M5DY.tml">M5DY</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/Q9WF.tml">Q9WF</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/SBG9.tml">SBG9</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/X38W.tml">X38W</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/XW4D.tml">XW4D</a>.</li>
</ul>
<hr />
<h2 id="alternative-libraries">Alternative libraries</h2>
<p>Why this library? Because none of the existing libraries was quite what I wanted. There are two C/C++ libraries that I know of:</p>
<ul>
<li><a href="https://github.com/yaml/libyaml">libyaml</a></li>
<li><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></li>
</ul>
<p>The standard <a href="https://github.com/yaml/libyaml">libyaml</a> is a bare C library. It does not create a representation of the data tree, so it can’t qualify as practical. My initial idea was to wrap parsing and emitting around libyaml, but to my surprise I found out it makes heavy use of allocations and string duplications when parsing. I briefly pondered on sending PRs to reduce these allocation needs, but not having a permanent tree to store the parsed data was too much of a downside.</p>
<p><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a> is full of functionality, but is heavy on the use of node-pointer-based structures like <code>std::map</code>, allocations, string copies and slow C++ stream serializations. This is generally a sure way of making your code slower, and strong evidence of this can be seen in the benchmark results above.</p>
<p>When performance and low latency are important, using contiguous structures for better cache behavior and to prevent the library from trampling over the client’s caches, parsing in place and using non-owning strings is of central importance. Hence this Rapid YAML library which, with minimal compromise, bridges the gap from efficiency to usability. This library takes inspiration from <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and <a href="http://rapidxml.sourceforge.net/">RapidXML</a>.</p>
<hr />
<h2 id="license">License</h2>
<p>ryml is permissively licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
