#include <boost/algorithm/string.hpp>

template <class T>
auto &addBoostTarget(Solution &s, const String &name)
{
    static std::map<String, String> commits{
        { "accumulators", "bfcbfe3c58064cd1ffabbce49a95c6c20351c96e" },
        { "algorithm", "5af3e3b174cdd5f06d21fc50e9b5ffa4f953cfe7" },
        { "align", "25b1b0afd8d3fb7963697a0e71fe4316ecab14fb" },
        { "any", "40a0e4b89697cba0b1784867a29773e5f074e55b" },
        { "array", "8f3aea2200fa45ed4c1829b3d3148432867dda87" },
        { "asio", "7c8c58b48849a5dac7b64d3ab664312a3ef051ec" },
        { "assert", "dbe3f8c641151c6c1b33485cd04f6e5285799102" },
        { "assign", "2d5f5f96de4a89367c73576c8ee731bcf020fb0a" },
        { "atomic", "c22cc0812d7c3c615e57d5bd6ddbde4b1457ac57" },
        { "beast", "320037a6bc6e70adb5ec715dc2bdfce9ed0ba41e" },
        { "bimap", "223b2cf3a5d633c5a4f11e07ce242f51bcf61a06" },
        { "bind", "d67200bd2a1f67135a4c677636546ec9615e21ea" },
        { "callable_traits", "04a469afe15cf09ce5ac4b78cd9574e067631c60" },
        { "chrono", "763fae0708aeab9f7a02e2e5b89025a78426dea4" },
        { "circular_buffer", "3dc0e1c56b55ff072bb06d4bb03a236865e92497" },
        { "compatibility", "445fbc1633cbaf49b0c3310db95a642e9c3fe89b" },
        { "compute", "9189a761b79fcd4be2f38158b9cad164bac22fa2" },
        { "concept_check", "7dbaa8541362bb2011f766cf16e6d1f0169af375" },
        { "config", "67102d043643c51104663c5b00e375c2f476cdf5" },
        { "container", "43c0257871e2f4a5d533c059f197a635a58361f2" },
        { "container_hash", "9fbda1a98a32498c52a1c8ebf62311bb36a44ad4" },
        { "context", "bcc3ed785bc2f4f3c82e2ec163abb4d3d2c4b24e" },
        { "contract", "27dba1d8e9b9d7521ef3802ae73a07d5357f1773" },
        { "conversion", "e8d104f34d1dd97c619a01639fe7b56bce5b671d" },
        { "convert", "8b6a8e4e01e9e39395945983c7038de3d2875f3e" },
        { "core", "d60775659b893fc71a8e37df8830067efdbc5c72" },
        { "coroutine", "8df277dc820701e6a62f5ae4018e7b7190490eb8" },
        { "coroutine2", "e1b3ca3179f3daecc5fab6ffeb35ae321e6b138f" },
        { "crc", "28d2df3803fbab1e3799cdfd91296f7006b8a495" },
        { "date_time", "81d60863b6382547cc0cb070cf1f13f82411c386" },
        { "detail", "622c7c4ee6046943164fc7bde49023369969de92" },
        { "disjoint_sets", "4980fe2a87ead3b2e8260aed6e9c8835266cd5d7" },
        { "dll", "b317d6506810eae6abf626dcc91b2de20979501a" },
        { "dynamic_bitset", "a580c496faa497335d589f8426b48deaccc9215a" },
        { "endian", "bde5937912662321c45596367b229ad7298b316c" },
        { "exception", "c87b9c55b1e4d5937b32abe2b84f249171f950ba" },
        { "fiber", "8c1142fe7e4abf62b0cb27210ce4573936ee61d2" },
        { "filesystem", "7dc1712f2df87f28bfd02ab26d3af25c7823eb2c" },
        { "flyweight", "9f8ccdc7fb79545c3d81a55b54684bfc5abf1bad" },
        { "foreach", "4240a1d095cf4a5e04093a1b91b1f0c791a58da9" },
        { "format", "1d347079b1096f4f5a3a6ea85dfcaf5143b42802" },
        { "function", "3f46081c59edd66ea93294d02a962e929c67b03e" },
        { "function_types", "ae4fde2e2ae88291d6d656137169ff4003d184a1" },
        { "functional", "7516442815900430cc9c4a6190354e11bcbe72dd" },
        { "fusion", "62137c0ab7693d781bf7c487363dfc2aeff7b5e9" },
        { "geometry", "292e3df03eb2e9720bfaf1f3ebfe4bb0b309923c" },
        { "gil", "28df5bc4821bd5d17ffc9e77c0f2b3c271e509b2" },
        { "graph", "815268534fc04adf00c9f5bd6803328e20fe14c1" },
        { "graph_parallel", "6d4757c56f8d3d5bb2efa4c5d46119af305ef441" },
        { "hana", "490dbf656d36dc183f492ab973fd2df19c83841d" },
        { "heap", "e4b3a2ea733fcb4bb3b50f362af83e8480e016ae" },
        { "hof", "7e7610854ecec699af8503e44c48383828c44734" },
        { "icl", "adaf950fadf370ed4b8a33153d6510bff242ff06" },
        { "integer", "099cf261b0d73a71ebcaf26e6f8afa6e30ba54cf" },
        { "interprocess", "4e60b89783980bdb6393e66a54f9fe629b996cca" },
        { "intrusive", "247e1824297d84cad9ecfca78779523d24f9604a" },
        { "io", "5fa66f1f76fb9142765692cc0cf6e40af8d08c45" },
        { "iostreams", "29a831798ec6337848d1f2e8595b59e5503e4f21" },
        { "iterator", "3cc4107d01b152bc2417d434b6fa22925a34aecd" },
        { "lambda", "8824e81d52489be9c8cb21d8f8477b03e675ce66" },
        { "lexical_cast", "5cd977133786b58acab162344024e3a12f795034" },
        { "local_function", "9ea3674299e3185ccdacf9dad5060d070ae9d77e" },
        { "locale", "ccb8fbb9a1a0dbdffb1054ffa34e4aba1e425642" },
        { "lockfree", "38f0cfc28d984cba8b368695491f9cc45bca2363" },
        { "log", "b22211073860190985d700c3f30a32a494878436" },
        { "logic", "fd021e5eb747eaa77c94720ef1ea17e7e73911ae" },
        { "math", "dff5644a1198667127d4549ee271288123f54929" },
        { "metaparse", "1cb74cdbe1b989a576b0b8f7fe34151562840797" },
        { "move", "1decc552eb92ebd1e76e1b66cb4bf690c3384432" },
        { "mp11", "dbe0378d65de4aaedab2baca1b64e4d04036861a" },
        { "mpi", "c6b59c05995e2e467c794f5f9673aba662109116" },
        { "mpl", "ac67f5952e6c849e461d7651ffb4fa0e7f380bb0" },
        { "msm", "fc3671a41c583aefd6b40c15673b83589e4f4220" },
        { "multi_array", "804dff44def8a00315a2f096b204e252b325c2e5" },
        { "multi_index", "335252403093efb348e41ae40a004e442082e711" },
        { "multiprecision", "3edbab951ef7f1adfb9d1ef1737d4b7247ba51ec" },
        { "numeric", "36f969a4c5129d11a8913fcbd8d2732ba957315b" },
        { "interval", "aa46846917fb1b3e3df91345d2590f8ef9528bea" },
        { "odeint", "6ff2719b6907b86596c3d43e88c1bcfdf29df560" },
        { "ublas", "e8607b3eea238e590eca93bfe498c21f470155c1" },
        { "optional", "a192204b41bd9744d85f202849f860b66fd1c2bc" },
        { "parameter", "5d3e39325e13a74645b60af33b16e8369f5ee61d" },
        { "parameter_python", "787d8d38d9fd49c34a757b20361f8042dd5ac820" },
        { "phoenix", "d274d83c28b67ca1bde83a547055954a1f2bca6c" },
        { "poly_collection", "78e8a8e64b2d7eb98fe0c7030ca1667ddb7b0b6c" },
        { "polygon", "8738898fc130a12cca349cdac60ca5d659c7cfab" },
        { "pool", "e4b44b276ca6c68ccf9eac4232157340b699453c" },
        { "predef", "aa94d69718a8d4d0a6fd80cb1e62ed62d9b23d83" },
        { "preprocessor", "d135cad759062ba646cb4bc40c163e590d381001" },
        { "process", "c3b707b709995b2ac7c6d419f222deba34868068" },
        { "program_options", "bc0c90a70f0435ee4ce65b97a68d864a7d627e35" },
        { "property_map", "c9b86a852b053b8df3f69a2e98e688a5e6a00f6a" },
        { "property_tree", "bdfe275d172ac30bc5e89a6375a5a64dea20b3c0" },
        { "proto", "d70c74c3a8d2abe746fe017edee564e6e8ae0efc" },
        { "ptr_container", "cc5aefee30dc349360e8030464503c5641840e7b" },
        { "python", "6f72675bff276599ffdccb9681018d8b2e367bc2" },
        { "qvm", "69039e2ec0076846bd9f9a03d15c4f82ba4d5728" },
        { "random", "1559df6b194cbba86653a2e2fefc2ea15e2cecd2" },
        { "range", "9f94c8703b73d7935e4529070ec03e392a97e2a1" },
        { "ratio", "7d40521682bd5367057340c27aade5976d368f32" },
        { "rational", "3fc4192167fa289035878cc4f007208ff6316e1e" },
        { "regex", "866d546fd0d75105be76654a6bb3a1b4cdbb4087" },
        { "safe_numerics", "b75ea6243f605dca1b1e4fc5ccaa4ed1062f1f65" },
        { "scope_exit", "3a2c1d7da44af2bb4bf47a4dc051998a80d3194f" },
        { "serialization", "f01148e421d2072294a6bc5faf70a5f6d4a709c2" },
        { "signals2", "0c51b5dcbf5961054447ce83f467e6e99db16c54" },
        { "smart_ptr", "04f0847af4c1e32d1ad4e785c514b5a49f439acc" },
        { "sort", "62dbaee9779b6f3e84c20e66c20861ecc6d98749" },
        { "spirit", "d59dc0158f742c88210dc7f0dd1cc1168a480d89" },
        { "stacktrace", "39486260ae5c3dfcaf29afe23507cde827f3cb6f" },
        { "statechart", "dc794c0ab2b3b58bc566c0d24239ecef6988eee5" },
        { "static_assert", "feaaf3d14ab42d1f248d2b627a60c446fa9f2600" },
        { "system", "3a4fff686e81320d346304b978f866c4136bd863" },
        { "test", "0003131130d522861e049440342e1763721d6e66" },
        { "thread", "8d0f077ab233a978c869922ef3bd8f26b1c2d451" },
        { "throw_exception", "074bc77efb421388461cfadca751bca7e28ca112" },
        { "timer", "cb59c5cff1d044d875b4c5984a46efcffa6c9df5" },
        { "tokenizer", "c79bd240272e49e7788a41b6df6cba5097689454" },
        { "tti", "31736e3dff24934430b038b85f794432eb949a29" },
        { "tuple", "fb55aa6d4d5e6917f55dbd7aee58afde97879b85" },
        { "type_erasure", "4afdf7ea52018be41e0c41abeab43fc5d2764573" },
        { "type_index", "f3da852bca7dcc4f7768c48183a1894023c0e1fd" },
        { "type_traits", "efc694d679263652520d965b94debbec69a17d85" },
        { "typeof", "e35962f3f07f9eca1efb1e816348bb42794b8a51" },
        { "units", "57389b7374a6f7a4caf87cc44092bb8d0db65ec6" },
        { "unordered", "9abce00f240f4d7b38c335c1f86262e7ea16018d" },
        { "utility", "05dda09fd3b4312594144b5a8617ba6fc694a2d6" },
        { "uuid", "14a90261c790a5ed84fdc97bf21a122f033ad9eb" },
        { "variant", "4a448b2bf7e766f13dd8765514c868ab49fa2c90" },
        { "vmd", "c939f908abe79fcb194c12b782e2fbcc6c0d52e7" },
        { "wave", "ac64abce4a3492a18aee3450d180c1d8ae5b490d" },
        { "winapi", "95884f6932054ca6b7fb0adca444da267268db5d" },
        { "xpressive", "4d4bc69f8b05e63c744e6f477df6a364affbc603" },
        { "yap", "1593ff054b932676cd55f4e8706902597228d896" },
    };

    PackagePath p = "boost";
    p /= name;

    auto &t = s.addTarget<T>(p, "1.69.0");

    String url = p.back();
    if (url == "numeric")
        url = "numeric_conversion";

    t += Git("https://github.com/boostorg/" + url, "", "", commits[p.back()]);

    return t;
}

void addPrivateDefinitions(NativeExecutedTarget &t, const String &N)
{
    DefinitionsType defs;
    defs["BOOST_" + N + "_BUILDING_THE_LIB"];
    defs["BOOST_" + N + "_SOURCE"];
    t.Private += defs;
}

void addStaticDefinitions(NativeExecutedTarget &t, const String &N)
{
    DefinitionsType defs2;
    defs2["BOOST_" + N + "_BUILD_LIB"];
    t.Private << sw::Static << defs2;

    DefinitionsType defs;
    defs["BOOST_" + N + "_USE_LIB"];
    defs["BOOST_" + N + "_STATIC_LINK"];
    t.Public << sw::Static << defs;
}

void addSharedDefinitions(NativeExecutedTarget &t, const String &N)
{
    DefinitionsType defs2;
    defs2["BOOST_" + N + "_BUILD_DLL"];
    t.Private << sw::Shared << defs2;

    DefinitionsType defs;
    defs["BOOST_" + N + "_USE_DLL"];
    defs["BOOST_" + N + "_DYN_LINK"];
    t.Public << sw::Shared << defs;
}

auto &addCompiledBoostTarget(Solution &s, const String &name)
{
    auto &t = addBoostTarget<LibraryTarget>(s, name);
    auto N = boost::to_upper_copy(name);
    addPrivateDefinitions(t, N);
    addSharedDefinitions(t, N);
    addStaticDefinitions(t, N);
    return t;
}

auto &addStaticOnlyCompiledBoostTarget(Solution &s, const String &name)
{
    auto &t = addBoostTarget<StaticLibraryTarget>(s, name);
    auto N = boost::to_upper_copy(name);
    addPrivateDefinitions(t, N);
    addStaticDefinitions(t, N);
    return t;
}

void boost_deps(std::unordered_map<String, NativeExecutedTarget*> &boost_targets);

void build(Solution &s)
{
    std::unordered_map<String, NativeExecutedTarget*> boost_targets;

    auto header_only_target_names = {
        "accumulators",
        "algorithm",
        "align",
        "any",
        "array",
        "asio",
        "assert",
        "assign",
        "beast",
        "bimap",
        "bind",
        "callable_traits",
        "circular_buffer",
        "compatibility",
        "compute",
        "concept_check",
        "config",
        "container_hash",
        "conversion",
        "convert",
        "core",
        "coroutine2",
        "crc",
        "detail",
        "disjoint_sets",
        "dll",
        "dynamic_bitset",
        "endian",
        "flyweight",
        "foreach",
        "format",
        "function",
        "function_types",
        "functional",
        "fusion",
        "geometry",
        "gil",
        "hana",
        "heap",
        "hof",
        "icl",
        "integer",
        "interprocess",
        "intrusive",
        "io",
        "iterator",
        "lambda",
        "lexical_cast",
        "local_function",
        "lockfree",
        "logic",
        "metaparse",
        "move",
        "mp11",
        "mpl",
        "msm",
        "multi_array",
        "multi_index",
        "multiprecision",
        "numeric",
        "interval",
        "odeint",
        "ublas",
        "optional",
        "parameter",
        "phoenix",
        "poly_collection",
        "polygon",
        "pool",
        "predef",
        "preprocessor",
        "process",
        "property_map",
        "property_tree",
        "proto",
        "ptr_container",
        "qvm",
        "range",
        "ratio",
        "rational",
        "safe_numerics",
        "scope_exit",
        "signals2",
        "smart_ptr",
        "sort",
        "spirit",
        "statechart",
        "static_assert",
        "throw_exception",
        "tokenizer",
        "tti",
        "tuple",
        "type_index",
        "type_traits",
        "typeof",
        "units",
        "unordered",
        "utility",
        "uuid",
        "variant",
        "vmd",
        "winapi",
        "xpressive",
        "yap",
    };
    for (auto &t : header_only_target_names)
    {
        auto &tgt = addBoostTarget<LibraryTarget>(s, t);
        tgt.HeaderOnly = true;
        boost_targets[t] = &tgt;
    }

    // some settings
    *boost_targets["function"] += "include/.*\\.hpp"_rr;
    *boost_targets["pool"] += "include/.*\\.[ih]pp"_rr;
    *boost_targets["spirit"] += "include/.*\\.[cih]pp"_rr;

    if (s.Settings.TargetOS.Type == OSType::Windows)
    {
        boost_targets["config"]->Public.Definitions["BOOST_USE_WINDOWS_H"];
        boost_targets["config"]->Public.Definitions["BOOST_USE_INTRIN_H"];
    }

    // compiled
    auto compiled_target_names = {
        "atomic",
        "chrono",
        "container",
        //"context",
        "contract",
        //"coroutine",
        "date_time",
        //"exception", added below
        //"fiber",
        "filesystem",
        "graph",
        //"graph_parallel",
        "iostreams",
        "locale",
        "log",
        "math",
        //"mpi",
        "program_options",
        //"python",
        "random",
        "regex",
        "serialization",
        "stacktrace",
        "system",
        //"test",
        "thread",
        "timer",
        "type_erasure",
        "wave",
    };
    for (auto &t : compiled_target_names)
        boost_targets[t] = &addCompiledBoostTarget(s, t);
    boost_targets["exception"] = &addStaticOnlyCompiledBoostTarget(s, "exception");

    // some settings
    *boost_targets["container"] -= "src/dlmalloc.*\\.c"_rr;
    *boost_targets["iostreams"] += "org.sw.demo.xz_utils.lzma-*"_dep;
    *boost_targets["iostreams"] += "org.sw.demo.bzip2-1"_dep;
    *boost_targets["iostreams"] += "org.sw.demo.madler.zlib-1"_dep;
    *boost_targets["iostreams"] += "org.sw.demo.facebook.zstd.zstd-1"_dep;
    boost_targets["stacktrace"]->HeaderOnly = true;
    if (s.Settings.TargetOS.Type == OSType::Windows)
        boost_targets["random"]->LinkLibraries.insert("Advapi32.lib");

    boost_targets["math"]->Private.IncludeDirectories.insert(boost_targets["math"]->SourceDir / "src/tr1");
    boost_targets["math"]->Private.IncludeDirectories.insert(boost_targets["math"]->SourceDir / "src");
    boost_targets["math"]->Public.IncludeDirectories.insert(boost_targets["math"]->SourceDir / "include");
    ((LibraryTarget*)boost_targets["math"])->Public << sw::Shared << "BOOST_MATH_TR1_DYN_LINK"_d;

    if (s.Settings.TargetOS.Type == OSType::Windows)
    {
        *boost_targets["locale"] -= "src/icu/.*"_rr;
        *boost_targets["locale"] -= "src/posix/.*"_rr;
        boost_targets["locale"]->Public.Definitions["BOOST_LOCALE_NO_POSIX_BACKEND"];
        boost_targets["locale"]->Definitions["NOMINMAX"];
    }
    else
    {
        *boost_targets["locale"] -= "src/win32/.*"_rr;
        boost_targets["locale"]->Public.Definitions["BOOST_LOCALE_NO_WINAPI_BACKEND"];
        boost_targets["locale"]->Public.Definitions["BOOST_LOCALE_WITH_ICONV"];
    }

    *boost_targets["log"] <<
        "include/.*"_rr,
        "src/.*\\.mc"_rr,
        "src/.*\\.hpp"_rr,
        "src/attribute_name.cpp",
        "src/attribute_set.cpp",
        "src/attribute_value_set.cpp",
        "src/code_conversion.cpp",
        "src/core.cpp",
        "src/date_time_format_parser.cpp",
        //"src/debug_output_backend.cpp",
        "src/default_attribute_names.cpp",
        "src/default_sink.cpp",
        "src/dump.cpp",
        "src/event.cpp",
        "src/exceptions.cpp",
        "src/format_parser.cpp",
        "src/global_logger_storage.cpp",
        //"src/light_rw_mutex.cpp",
        "src/named_scope.cpp",
        "src/named_scope_format_parser.cpp",
        "src/once_block.cpp",
        "src/process_id.cpp",
        "src/process_name.cpp",
        "src/record_ostream.cpp",
        "src/severity_level.cpp",
        "src/spirit_encoding.cpp",
        "src/syslog_backend.cpp",
        "src/text_file_backend.cpp",
        "src/text_multifile_backend.cpp",
        "src/text_ostream_backend.cpp",
        "src/thread_id.cpp",
        "src/threadsafe_queue.cpp",
        "src/thread_specific.cpp",
        "src/timer.cpp",
        "src/timestamp.cpp",
        "src/trivial.cpp",
        "src/unhandled_exception_count.cpp"
        ;
    boost_targets["log"]->Public.Definitions["BOOST_LOG_WITHOUT_EVENT_LOG"];
    boost_targets["log"]->Private += sw::Shared, "BOOST_LOG_DLL"_d;
    if (s.Settings.TargetOS.Type == OSType::Windows)
    {
        boost_targets["log"]->Public.Definitions["WIN32_LEAN_AND_MEAN"];
        boost_targets["log"]->Public.Definitions["NOMINMAX"];
    }
    else
        *boost_targets["log"] -= "src/debug_output_backend.cpp", "src/light_rw_mutex.cpp";

    //((LibraryTarget*)boost_targets["fiber"])->Shared.Private.Definitions["BOOST_FIBERS_SOURCE"];
    //boost_targets["fiber"]->Private.Definitions["BOOST_FIBERS_DYN_LINK"];

    //*boost_targets["python"] += "pvt.cppan.demo.python.libcompat";

    *((LibraryTarget*)boost_targets["thread"]) -= "src/pthread/once_atomic.cpp";
    if (s.Settings.TargetOS.Type == OSType::Windows)
    {
        *((LibraryTarget*)boost_targets["thread"]) -= "src/pthread/.*"_rr;
        *((LibraryTarget*)boost_targets["thread"]) >> sw::Shared >> "src/win32/tss_pe.cpp";
        *((LibraryTarget*)boost_targets["thread"]) >> sw::Static >> "src/win32/tss_dll.cpp";
    }
    else
        *((LibraryTarget*)boost_targets["thread"]) -= "src/win32/.*"_rr;
    //*boost_targets["thread"] += *boost_targets["date_time"];

    if (s.Settings.TargetOS.Type == OSType::Windows)
        ((LibraryTarget*)boost_targets["uuid"])->Public += "Bcrypt.lib"_lib;

    boost_deps(boost_targets);

    //
    boost_targets["config"]->fileWriteOnce(boost_targets["config"]->SourceDir / "include/boost/config/auto_link.hpp",
        R"(
#ifdef BOOST_LIB_PREFIX
#  undef BOOST_LIB_PREFIX
#endif
#if defined(BOOST_LIB_NAME)
#  undef BOOST_LIB_NAME
#endif
#if defined(BOOST_LIB_THREAD_OPT)
#  undef BOOST_LIB_THREAD_OPT
#endif
#if defined(BOOST_LIB_RT_OPT)
#  undef BOOST_LIB_RT_OPT
#endif
#if defined(BOOST_LIB_LINK_OPT)
#  undef BOOST_LIB_LINK_OPT
#endif
#if defined(BOOST_LIB_DEBUG_OPT)
#  undef BOOST_LIB_DEBUG_OPT
#endif
#if defined(BOOST_DYN_LINK)
#  undef BOOST_DYN_LINK
#endif
)"
);

    boost_targets["config"]->replaceInFileOnce("include/boost/config/compiler/visualc.hpp",
        "#if (_MSC_VER > 1911)",
        "#if (_MSC_VER > 1912)");
}

void boost_deps(std::unordered_map<String, NativeExecutedTarget*> &boost_targets)
{
    auto add_public_dependency = [&boost_targets](const auto &n1, const auto &n2, bool idir_only = false)
    {
        auto t1 = boost_targets[n1];
        auto t2 = boost_targets[n2];
        if (!t1 || !t2)
            return;
        auto dt = t1->Public + *t2;
        dt->IncludeDirectoriesOnly = idir_only;
    };

    {
        add_public_dependency("accumulators", "algorithm", true);
        add_public_dependency("accumulators", "array", true);
        add_public_dependency("accumulators", "assert", true);
        add_public_dependency("accumulators", "atomic", true);
        add_public_dependency("accumulators", "bind", true);
        add_public_dependency("accumulators", "chrono", true);
        add_public_dependency("accumulators", "circular_buffer", true);
        add_public_dependency("accumulators", "concept_check", true);
        add_public_dependency("accumulators", "config", true);
        add_public_dependency("accumulators", "container", true);
        add_public_dependency("accumulators", "container_hash", true);
        add_public_dependency("accumulators", "conversion", true);
        add_public_dependency("accumulators", "core", true);
        add_public_dependency("accumulators", "date_time", true);
        add_public_dependency("accumulators", "detail", true);
        add_public_dependency("accumulators", "dynamic_bitset", true);
        add_public_dependency("accumulators", "endian", true);
        add_public_dependency("accumulators", "exception", true);
        add_public_dependency("accumulators", "filesystem", true);
        add_public_dependency("accumulators", "foreach", true);
        add_public_dependency("accumulators", "function", true);
        add_public_dependency("accumulators", "function_types", true);
        add_public_dependency("accumulators", "fusion", true);
        add_public_dependency("accumulators", "integer", true);
        add_public_dependency("accumulators", "interval", true);
        add_public_dependency("accumulators", "intrusive", true);
        add_public_dependency("accumulators", "io", true);
        add_public_dependency("accumulators", "iostreams", true);
        add_public_dependency("accumulators", "iterator", true);
        add_public_dependency("accumulators", "lambda", true);
        add_public_dependency("accumulators", "lexical_cast", true);
        add_public_dependency("accumulators", "locale", true);
        add_public_dependency("accumulators", "logic", true);
        add_public_dependency("accumulators", "math", true);
        add_public_dependency("accumulators", "move", true);
        add_public_dependency("accumulators", "mpl", true);
        add_public_dependency("accumulators", "multiprecision", true);
        add_public_dependency("accumulators", "numeric", true);
        add_public_dependency("accumulators", "optional", true);
        add_public_dependency("accumulators", "parameter", true);
        add_public_dependency("accumulators", "phoenix", true);
        add_public_dependency("accumulators", "pool", true);
        add_public_dependency("accumulators", "predef", true);
        add_public_dependency("accumulators", "preprocessor", true);
        add_public_dependency("accumulators", "proto", true);
        add_public_dependency("accumulators", "random", true);
        add_public_dependency("accumulators", "range", true);
        add_public_dependency("accumulators", "ratio", true);
        add_public_dependency("accumulators", "rational", true);
        add_public_dependency("accumulators", "regex", true);
        add_public_dependency("accumulators", "serialization", true);
        add_public_dependency("accumulators", "smart_ptr", true);
        add_public_dependency("accumulators", "spirit", true);
        add_public_dependency("accumulators", "static_assert", true);
        add_public_dependency("accumulators", "system", true);
        add_public_dependency("accumulators", "thread", true);
        add_public_dependency("accumulators", "throw_exception", true);
        add_public_dependency("accumulators", "tokenizer", true);
        add_public_dependency("accumulators", "tti", true);
        add_public_dependency("accumulators", "tuple", true);
        add_public_dependency("accumulators", "type_index", true);
        add_public_dependency("accumulators", "type_traits", true);
        add_public_dependency("accumulators", "typeof", true);
        add_public_dependency("accumulators", "ublas", true);
        add_public_dependency("accumulators", "unordered", true);
        add_public_dependency("accumulators", "utility", true);
        add_public_dependency("accumulators", "variant", true);
        add_public_dependency("accumulators", "winapi", true);
        add_public_dependency("algorithm", "array", true);
        add_public_dependency("algorithm", "assert", true);
        add_public_dependency("algorithm", "bind", true);
        add_public_dependency("algorithm", "concept_check", true);
        add_public_dependency("algorithm", "config", true);
        add_public_dependency("algorithm", "container", true);
        add_public_dependency("algorithm", "container_hash", true);
        add_public_dependency("algorithm", "conversion", true);
        add_public_dependency("algorithm", "core", true);
        add_public_dependency("algorithm", "detail", true);
        add_public_dependency("algorithm", "exception", true);
        add_public_dependency("algorithm", "function", true);
        add_public_dependency("algorithm", "function_types", true);
        add_public_dependency("algorithm", "fusion", true);
        add_public_dependency("algorithm", "integer", true);
        add_public_dependency("algorithm", "intrusive", true);
        add_public_dependency("algorithm", "iterator", true);
        add_public_dependency("algorithm", "move", true);
        add_public_dependency("algorithm", "mpl", true);
        add_public_dependency("algorithm", "numeric", true);
        add_public_dependency("algorithm", "optional", true);
        add_public_dependency("algorithm", "predef", true);
        add_public_dependency("algorithm", "preprocessor", true);
        add_public_dependency("algorithm", "range", true);
        add_public_dependency("algorithm", "regex", true);
        add_public_dependency("algorithm", "smart_ptr", true);
        add_public_dependency("algorithm", "static_assert", true);
        add_public_dependency("algorithm", "throw_exception", true);
        add_public_dependency("algorithm", "tuple", true);
        add_public_dependency("algorithm", "type_index", true);
        add_public_dependency("algorithm", "type_traits", true);
        add_public_dependency("algorithm", "typeof", true);
        add_public_dependency("algorithm", "unordered", true);
        add_public_dependency("algorithm", "utility", true);
        add_public_dependency("align", "assert", true);
        add_public_dependency("align", "config", true);
        add_public_dependency("align", "core", true);
        add_public_dependency("align", "static_assert", true);
        add_public_dependency("align", "throw_exception", true);
        add_public_dependency("any", "assert", true);
        add_public_dependency("any", "config", true);
        add_public_dependency("any", "container_hash", true);
        add_public_dependency("any", "core", true);
        add_public_dependency("any", "detail", true);
        add_public_dependency("any", "integer", true);
        add_public_dependency("any", "move", true);
        add_public_dependency("any", "predef", true);
        add_public_dependency("any", "preprocessor", true);
        add_public_dependency("any", "smart_ptr", true);
        add_public_dependency("any", "static_assert", true);
        add_public_dependency("any", "throw_exception", true);
        add_public_dependency("any", "type_index", true);
        add_public_dependency("any", "type_traits", true);
        add_public_dependency("array", "assert", true);
        add_public_dependency("array", "config", true);
        add_public_dependency("array", "core", true);
        add_public_dependency("array", "static_assert", true);
        add_public_dependency("array", "throw_exception", true);
        add_public_dependency("asio", "algorithm", true);
        add_public_dependency("asio", "array", true);
        add_public_dependency("asio", "assert", true);
        add_public_dependency("asio", "atomic", true);
        add_public_dependency("asio", "bind", true);
        add_public_dependency("asio", "chrono", true);
        add_public_dependency("asio", "concept_check", true);
        add_public_dependency("asio", "config", true);
        add_public_dependency("asio", "container", true);
        add_public_dependency("asio", "container_hash", true);
        add_public_dependency("asio", "context", true);
        add_public_dependency("asio", "conversion", true);
        add_public_dependency("asio", "core", true);
        add_public_dependency("asio", "coroutine", true);
        add_public_dependency("asio", "date_time", true);
        add_public_dependency("asio", "detail", true);
        add_public_dependency("asio", "dynamic_bitset", true);
        add_public_dependency("asio", "endian", true);
        add_public_dependency("asio", "exception", true);
        add_public_dependency("asio", "filesystem", true);
        add_public_dependency("asio", "foreach", true);
        add_public_dependency("asio", "function", true);
        add_public_dependency("asio", "function_types", true);
        add_public_dependency("asio", "fusion", true);
        add_public_dependency("asio", "integer", true);
        add_public_dependency("asio", "intrusive", true);
        add_public_dependency("asio", "io", true);
        add_public_dependency("asio", "iostreams", true);
        add_public_dependency("asio", "iterator", true);
        add_public_dependency("asio", "lambda", true);
        add_public_dependency("asio", "lexical_cast", true);
        add_public_dependency("asio", "locale", true);
        add_public_dependency("asio", "math", true);
        add_public_dependency("asio", "move", true);
        add_public_dependency("asio", "mpl", true);
        add_public_dependency("asio", "multiprecision", true);
        add_public_dependency("asio", "numeric", true);
        add_public_dependency("asio", "optional", true);
        add_public_dependency("asio", "phoenix", true);
        add_public_dependency("asio", "pool", true);
        add_public_dependency("asio", "predef", true);
        add_public_dependency("asio", "preprocessor", true);
        add_public_dependency("asio", "proto", true);
        add_public_dependency("asio", "random", true);
        add_public_dependency("asio", "range", true);
        add_public_dependency("asio", "ratio", true);
        add_public_dependency("asio", "rational", true);
        add_public_dependency("asio", "regex", true);
        add_public_dependency("asio", "serialization", true);
        add_public_dependency("asio", "smart_ptr", true);
        add_public_dependency("asio", "spirit", true);
        add_public_dependency("asio", "static_assert", true);
        add_public_dependency("asio", "system", true);
        add_public_dependency("asio", "thread", true);
        add_public_dependency("asio", "throw_exception", true);
        add_public_dependency("asio", "tokenizer", true);
        add_public_dependency("asio", "tti", true);
        add_public_dependency("asio", "tuple", true);
        add_public_dependency("asio", "type_index", true);
        add_public_dependency("asio", "type_traits", true);
        add_public_dependency("asio", "typeof", true);
        add_public_dependency("asio", "unordered", true);
        add_public_dependency("asio", "utility", true);
        add_public_dependency("asio", "variant", true);
        add_public_dependency("asio", "winapi", true);
        add_public_dependency("assert", "config", true);
        add_public_dependency("assign", "algorithm", true);
        add_public_dependency("assign", "array", true);
        add_public_dependency("assign", "assert", true);
        add_public_dependency("assign", "atomic", true);
        add_public_dependency("assign", "bind", true);
        add_public_dependency("assign", "chrono", true);
        add_public_dependency("assign", "circular_buffer", true);
        add_public_dependency("assign", "concept_check", true);
        add_public_dependency("assign", "config", true);
        add_public_dependency("assign", "container", true);
        add_public_dependency("assign", "container_hash", true);
        add_public_dependency("assign", "conversion", true);
        add_public_dependency("assign", "core", true);
        add_public_dependency("assign", "date_time", true);
        add_public_dependency("assign", "detail", true);
        add_public_dependency("assign", "dynamic_bitset", true);
        add_public_dependency("assign", "endian", true);
        add_public_dependency("assign", "exception", true);
        add_public_dependency("assign", "filesystem", true);
        add_public_dependency("assign", "foreach", true);
        add_public_dependency("assign", "function", true);
        add_public_dependency("assign", "function_types", true);
        add_public_dependency("assign", "fusion", true);
        add_public_dependency("assign", "integer", true);
        add_public_dependency("assign", "intrusive", true);
        add_public_dependency("assign", "io", true);
        add_public_dependency("assign", "iostreams", true);
        add_public_dependency("assign", "iterator", true);
        add_public_dependency("assign", "lambda", true);
        add_public_dependency("assign", "lexical_cast", true);
        add_public_dependency("assign", "locale", true);
        add_public_dependency("assign", "math", true);
        add_public_dependency("assign", "move", true);
        add_public_dependency("assign", "mpl", true);
        add_public_dependency("assign", "multiprecision", true);
        add_public_dependency("assign", "numeric", true);
        add_public_dependency("assign", "optional", true);
        add_public_dependency("assign", "phoenix", true);
        add_public_dependency("assign", "pool", true);
        add_public_dependency("assign", "predef", true);
        add_public_dependency("assign", "preprocessor", true);
        add_public_dependency("assign", "proto", true);
        add_public_dependency("assign", "ptr_container", true);
        add_public_dependency("assign", "random", true);
        add_public_dependency("assign", "range", true);
        add_public_dependency("assign", "ratio", true);
        add_public_dependency("assign", "rational", true);
        add_public_dependency("assign", "regex", true);
        add_public_dependency("assign", "serialization", true);
        add_public_dependency("assign", "smart_ptr", true);
        add_public_dependency("assign", "spirit", true);
        add_public_dependency("assign", "static_assert", true);
        add_public_dependency("assign", "system", true);
        add_public_dependency("assign", "thread", true);
        add_public_dependency("assign", "throw_exception", true);
        add_public_dependency("assign", "tokenizer", true);
        add_public_dependency("assign", "tti", true);
        add_public_dependency("assign", "tuple", true);
        add_public_dependency("assign", "type_index", true);
        add_public_dependency("assign", "type_traits", true);
        add_public_dependency("assign", "typeof", true);
        add_public_dependency("assign", "unordered", true);
        add_public_dependency("assign", "utility", true);
        add_public_dependency("assign", "variant", true);
        add_public_dependency("assign", "winapi", true);
        add_public_dependency("atomic", "assert", true);
        add_public_dependency("atomic", "config", true);
        add_public_dependency("atomic", "preprocessor", true);
        add_public_dependency("atomic", "static_assert", true);
        add_public_dependency("atomic", "type_traits", true);
        add_public_dependency("beast", "algorithm", true);
        add_public_dependency("beast", "align", true);
        add_public_dependency("beast", "array", true);
        add_public_dependency("beast", "asio", true);
        add_public_dependency("beast", "assert", true);
        add_public_dependency("beast", "atomic", true);
        add_public_dependency("beast", "bind", true);
        add_public_dependency("beast", "chrono", true);
        add_public_dependency("beast", "concept_check", true);
        add_public_dependency("beast", "config", true);
        add_public_dependency("beast", "container", true);
        add_public_dependency("beast", "container_hash", true);
        add_public_dependency("beast", "context", true);
        add_public_dependency("beast", "conversion", true);
        add_public_dependency("beast", "core", true);
        add_public_dependency("beast", "coroutine", true);
        add_public_dependency("beast", "date_time", true);
        add_public_dependency("beast", "detail", true);
        add_public_dependency("beast", "dynamic_bitset", true);
        add_public_dependency("beast", "endian", true);
        add_public_dependency("beast", "exception", true);
        add_public_dependency("beast", "filesystem", true);
        add_public_dependency("beast", "foreach", true);
        add_public_dependency("beast", "function", true);
        add_public_dependency("beast", "function_types", true);
        add_public_dependency("beast", "fusion", true);
        add_public_dependency("beast", "integer", true);
        add_public_dependency("beast", "intrusive", true);
        add_public_dependency("beast", "io", true);
        add_public_dependency("beast", "iostreams", true);
        add_public_dependency("beast", "iterator", true);
        add_public_dependency("beast", "lambda", true);
        add_public_dependency("beast", "lexical_cast", true);
        add_public_dependency("beast", "locale", true);
        add_public_dependency("beast", "math", true);
        add_public_dependency("beast", "move", true);
        add_public_dependency("beast", "mpl", true);
        add_public_dependency("beast", "multiprecision", true);
        add_public_dependency("beast", "numeric", true);
        add_public_dependency("beast", "optional", true);
        add_public_dependency("beast", "phoenix", true);
        add_public_dependency("beast", "pool", true);
        add_public_dependency("beast", "predef", true);
        add_public_dependency("beast", "preprocessor", true);
        add_public_dependency("beast", "proto", true);
        add_public_dependency("beast", "random", true);
        add_public_dependency("beast", "range", true);
        add_public_dependency("beast", "ratio", true);
        add_public_dependency("beast", "rational", true);
        add_public_dependency("beast", "regex", true);
        add_public_dependency("beast", "serialization", true);
        add_public_dependency("beast", "smart_ptr", true);
        add_public_dependency("beast", "spirit", true);
        add_public_dependency("beast", "static_assert", true);
        add_public_dependency("beast", "system", true);
        add_public_dependency("beast", "thread", true);
        add_public_dependency("beast", "throw_exception", true);
        add_public_dependency("beast", "tokenizer", true);
        add_public_dependency("beast", "tti", true);
        add_public_dependency("beast", "tuple", true);
        add_public_dependency("beast", "type_index", true);
        add_public_dependency("beast", "type_traits", true);
        add_public_dependency("beast", "typeof", true);
        add_public_dependency("beast", "unordered", true);
        add_public_dependency("beast", "utility", true);
        add_public_dependency("beast", "variant", true);
        add_public_dependency("beast", "winapi", true);
        add_public_dependency("bimap", "algorithm", true);
        add_public_dependency("bimap", "any", true);
        add_public_dependency("bimap", "array", true);
        add_public_dependency("bimap", "assert", true);
        add_public_dependency("bimap", "atomic", true);
        add_public_dependency("bimap", "bind", true);
        add_public_dependency("bimap", "chrono", true);
        add_public_dependency("bimap", "concept_check", true);
        add_public_dependency("bimap", "config", true);
        add_public_dependency("bimap", "container", true);
        add_public_dependency("bimap", "container_hash", true);
        add_public_dependency("bimap", "conversion", true);
        add_public_dependency("bimap", "core", true);
        add_public_dependency("bimap", "date_time", true);
        add_public_dependency("bimap", "detail", true);
        add_public_dependency("bimap", "disjoint_sets", true);
        add_public_dependency("bimap", "dynamic_bitset", true);
        add_public_dependency("bimap", "endian", true);
        add_public_dependency("bimap", "exception", true);
        add_public_dependency("bimap", "filesystem", true);
        add_public_dependency("bimap", "foreach", true);
        add_public_dependency("bimap", "format", true);
        add_public_dependency("bimap", "function", true);
        add_public_dependency("bimap", "function_types", true);
        add_public_dependency("bimap", "fusion", true);
        add_public_dependency("bimap", "graph", true);
        add_public_dependency("bimap", "graph_parallel", true);
        add_public_dependency("bimap", "integer", true);
        add_public_dependency("bimap", "intrusive", true);
        add_public_dependency("bimap", "io", true);
        add_public_dependency("bimap", "iostreams", true);
        add_public_dependency("bimap", "iterator", true);
        add_public_dependency("bimap", "lambda", true);
        add_public_dependency("bimap", "lexical_cast", true);
        add_public_dependency("bimap", "locale", true);
        add_public_dependency("bimap", "math", true);
        add_public_dependency("bimap", "move", true);
        add_public_dependency("bimap", "mpi", true);
        add_public_dependency("bimap", "mpl", true);
        add_public_dependency("bimap", "multi_index", true);
        add_public_dependency("bimap", "multiprecision", true);
        add_public_dependency("bimap", "numeric", true);
        add_public_dependency("bimap", "optional", true);
        add_public_dependency("bimap", "parameter", true);
        add_public_dependency("bimap", "phoenix", true);
        add_public_dependency("bimap", "pool", true);
        add_public_dependency("bimap", "predef", true);
        add_public_dependency("bimap", "preprocessor", true);
        add_public_dependency("bimap", "property_map", true);
        add_public_dependency("bimap", "property_tree", true);
        add_public_dependency("bimap", "proto", true);
        add_public_dependency("bimap", "python", true);
        add_public_dependency("bimap", "random", true);
        add_public_dependency("bimap", "range", true);
        add_public_dependency("bimap", "ratio", true);
        add_public_dependency("bimap", "rational", true);
        add_public_dependency("bimap", "regex", true);
        add_public_dependency("bimap", "serialization", true);
        add_public_dependency("bimap", "smart_ptr", true);
        add_public_dependency("bimap", "spirit", true);
        add_public_dependency("bimap", "static_assert", true);
        add_public_dependency("bimap", "system", true);
        add_public_dependency("bimap", "test", true);
        add_public_dependency("bimap", "thread", true);
        add_public_dependency("bimap", "throw_exception", true);
        add_public_dependency("bimap", "timer", true);
        add_public_dependency("bimap", "tokenizer", true);
        add_public_dependency("bimap", "tti", true);
        add_public_dependency("bimap", "tuple", true);
        add_public_dependency("bimap", "type_index", true);
        add_public_dependency("bimap", "type_traits", true);
        add_public_dependency("bimap", "typeof", true);
        add_public_dependency("bimap", "unordered", true);
        add_public_dependency("bimap", "utility", true);
        add_public_dependency("bimap", "variant", true);
        add_public_dependency("bimap", "winapi", true);
        add_public_dependency("bimap", "xpressive", true);
        add_public_dependency("bind", "assert", true);
        add_public_dependency("bind", "config", true);
        add_public_dependency("bind", "core", true);
        add_public_dependency("chrono", "system", false);
        add_public_dependency("chrono", "assert", true);
        add_public_dependency("chrono", "config", true);
        add_public_dependency("chrono", "container_hash", true);
        add_public_dependency("chrono", "core", true);
        add_public_dependency("chrono", "detail", true);
        add_public_dependency("chrono", "integer", true);
        add_public_dependency("chrono", "move", true);
        add_public_dependency("chrono", "mpl", true);
        add_public_dependency("chrono", "predef", true);
        add_public_dependency("chrono", "preprocessor", true);
        add_public_dependency("chrono", "ratio", true);
        add_public_dependency("chrono", "rational", true);
        add_public_dependency("chrono", "static_assert", true);
        add_public_dependency("chrono", "throw_exception", true);
        add_public_dependency("chrono", "type_traits", true);
        add_public_dependency("chrono", "typeof", true);
        add_public_dependency("chrono", "utility", true);
        add_public_dependency("chrono", "winapi", true);
        add_public_dependency("circular_buffer", "assert", true);
        add_public_dependency("circular_buffer", "concept_check", true);
        add_public_dependency("circular_buffer", "config", true);
        add_public_dependency("circular_buffer", "core", true);
        add_public_dependency("circular_buffer", "move", true);
        add_public_dependency("circular_buffer", "preprocessor", true);
        add_public_dependency("circular_buffer", "static_assert", true);
        add_public_dependency("circular_buffer", "throw_exception", true);
        add_public_dependency("circular_buffer", "type_traits", true);
        add_public_dependency("compute", "algorithm", true);
        add_public_dependency("compute", "any", true);
        add_public_dependency("compute", "array", true);
        add_public_dependency("compute", "assert", true);
        add_public_dependency("compute", "atomic", true);
        add_public_dependency("compute", "bind", true);
        add_public_dependency("compute", "chrono", true);
        add_public_dependency("compute", "concept_check", true);
        add_public_dependency("compute", "config", true);
        add_public_dependency("compute", "container", true);
        add_public_dependency("compute", "container_hash", true);
        add_public_dependency("compute", "conversion", true);
        add_public_dependency("compute", "core", true);
        add_public_dependency("compute", "date_time", true);
        add_public_dependency("compute", "detail", true);
        add_public_dependency("compute", "dynamic_bitset", true);
        add_public_dependency("compute", "endian", true);
        add_public_dependency("compute", "exception", true);
        add_public_dependency("compute", "filesystem", true);
        add_public_dependency("compute", "foreach", true);
        add_public_dependency("compute", "format", true);
        add_public_dependency("compute", "function", true);
        add_public_dependency("compute", "function_types", true);
        add_public_dependency("compute", "fusion", true);
        add_public_dependency("compute", "integer", true);
        add_public_dependency("compute", "intrusive", true);
        add_public_dependency("compute", "io", true);
        add_public_dependency("compute", "iostreams", true);
        add_public_dependency("compute", "iterator", true);
        add_public_dependency("compute", "lambda", true);
        add_public_dependency("compute", "lexical_cast", true);
        add_public_dependency("compute", "locale", true);
        add_public_dependency("compute", "math", true);
        add_public_dependency("compute", "move", true);
        add_public_dependency("compute", "mpl", true);
        add_public_dependency("compute", "multi_index", true);
        add_public_dependency("compute", "multiprecision", true);
        add_public_dependency("compute", "numeric", true);
        add_public_dependency("compute", "optional", true);
        add_public_dependency("compute", "phoenix", true);
        add_public_dependency("compute", "pool", true);
        add_public_dependency("compute", "predef", true);
        add_public_dependency("compute", "preprocessor", true);
        add_public_dependency("compute", "property_tree", true);
        add_public_dependency("compute", "proto", true);
        add_public_dependency("compute", "random", true);
        add_public_dependency("compute", "range", true);
        add_public_dependency("compute", "ratio", true);
        add_public_dependency("compute", "rational", true);
        add_public_dependency("compute", "regex", true);
        add_public_dependency("compute", "serialization", true);
        add_public_dependency("compute", "smart_ptr", true);
        add_public_dependency("compute", "spirit", true);
        add_public_dependency("compute", "static_assert", true);
        add_public_dependency("compute", "system", true);
        add_public_dependency("compute", "thread", true);
        add_public_dependency("compute", "throw_exception", true);
        add_public_dependency("compute", "tokenizer", true);
        add_public_dependency("compute", "tti", true);
        add_public_dependency("compute", "tuple", true);
        add_public_dependency("compute", "type_index", true);
        add_public_dependency("compute", "type_traits", true);
        add_public_dependency("compute", "typeof", true);
        add_public_dependency("compute", "unordered", true);
        add_public_dependency("compute", "utility", true);
        add_public_dependency("compute", "uuid", true);
        add_public_dependency("compute", "variant", true);
        add_public_dependency("compute", "winapi", true);
        add_public_dependency("concept_check", "config", true);
        add_public_dependency("concept_check", "preprocessor", true);
        add_public_dependency("concept_check", "static_assert", true);
        add_public_dependency("concept_check", "type_traits", true);
        add_public_dependency("container", "assert", true);
        add_public_dependency("container", "config", true);
        add_public_dependency("container", "container_hash", true);
        add_public_dependency("container", "core", true);
        add_public_dependency("container", "detail", true);
        add_public_dependency("container", "integer", true);
        add_public_dependency("container", "intrusive", true);
        add_public_dependency("container", "move", true);
        add_public_dependency("container", "preprocessor", true);
        add_public_dependency("container", "static_assert", true);
        add_public_dependency("container", "type_traits", true);
        add_public_dependency("container_hash", "assert", true);
        add_public_dependency("container_hash", "config", true);
        add_public_dependency("container_hash", "core", true);
        add_public_dependency("container_hash", "detail", true);
        add_public_dependency("container_hash", "integer", true);
        add_public_dependency("container_hash", "preprocessor", true);
        add_public_dependency("container_hash", "static_assert", true);
        add_public_dependency("container_hash", "type_traits", true);
        add_public_dependency("context", "thread", false);
        add_public_dependency("context", "algorithm", true);
        add_public_dependency("context", "array", true);
        add_public_dependency("context", "assert", true);
        add_public_dependency("context", "atomic", true);
        add_public_dependency("context", "bind", true);
        add_public_dependency("context", "chrono", true);
        add_public_dependency("context", "concept_check", true);
        add_public_dependency("context", "config", true);
        add_public_dependency("context", "container", true);
        add_public_dependency("context", "container_hash", true);
        add_public_dependency("context", "conversion", true);
        add_public_dependency("context", "core", true);
        add_public_dependency("context", "date_time", true);
        add_public_dependency("context", "detail", true);
        add_public_dependency("context", "dynamic_bitset", true);
        add_public_dependency("context", "endian", true);
        add_public_dependency("context", "exception", true);
        add_public_dependency("context", "filesystem", true);
        add_public_dependency("context", "foreach", true);
        add_public_dependency("context", "function", true);
        add_public_dependency("context", "function_types", true);
        add_public_dependency("context", "fusion", true);
        add_public_dependency("context", "integer", true);
        add_public_dependency("context", "intrusive", true);
        add_public_dependency("context", "io", true);
        add_public_dependency("context", "iostreams", true);
        add_public_dependency("context", "iterator", true);
        add_public_dependency("context", "lambda", true);
        add_public_dependency("context", "lexical_cast", true);
        add_public_dependency("context", "locale", true);
        add_public_dependency("context", "math", true);
        add_public_dependency("context", "move", true);
        add_public_dependency("context", "mpl", true);
        add_public_dependency("context", "multiprecision", true);
        add_public_dependency("context", "numeric", true);
        add_public_dependency("context", "optional", true);
        add_public_dependency("context", "phoenix", true);
        add_public_dependency("context", "pool", true);
        add_public_dependency("context", "predef", true);
        add_public_dependency("context", "preprocessor", true);
        add_public_dependency("context", "proto", true);
        add_public_dependency("context", "random", true);
        add_public_dependency("context", "range", true);
        add_public_dependency("context", "ratio", true);
        add_public_dependency("context", "rational", true);
        add_public_dependency("context", "regex", true);
        add_public_dependency("context", "serialization", true);
        add_public_dependency("context", "smart_ptr", true);
        add_public_dependency("context", "spirit", true);
        add_public_dependency("context", "static_assert", true);
        add_public_dependency("context", "system", true);
        add_public_dependency("context", "throw_exception", true);
        add_public_dependency("context", "tokenizer", true);
        add_public_dependency("context", "tti", true);
        add_public_dependency("context", "tuple", true);
        add_public_dependency("context", "type_index", true);
        add_public_dependency("context", "type_traits", true);
        add_public_dependency("context", "typeof", true);
        add_public_dependency("context", "unordered", true);
        add_public_dependency("context", "utility", true);
        add_public_dependency("context", "variant", true);
        add_public_dependency("context", "winapi", true);
        add_public_dependency("contract", "system", false);
        add_public_dependency("contract", "algorithm", true);
        add_public_dependency("contract", "any", true);
        add_public_dependency("contract", "array", true);
        add_public_dependency("contract", "assert", true);
        add_public_dependency("contract", "atomic", true);
        add_public_dependency("contract", "bind", true);
        add_public_dependency("contract", "chrono", true);
        add_public_dependency("contract", "concept_check", true);
        add_public_dependency("contract", "config", true);
        add_public_dependency("contract", "container", true);
        add_public_dependency("contract", "container_hash", true);
        add_public_dependency("contract", "conversion", true);
        add_public_dependency("contract", "core", true);
        add_public_dependency("contract", "date_time", true);
        add_public_dependency("contract", "detail", true);
        add_public_dependency("contract", "dynamic_bitset", true);
        add_public_dependency("contract", "endian", true);
        add_public_dependency("contract", "exception", true);
        add_public_dependency("contract", "filesystem", true);
        add_public_dependency("contract", "foreach", true);
        add_public_dependency("contract", "function", true);
        add_public_dependency("contract", "function_types", true);
        add_public_dependency("contract", "fusion", true);
        add_public_dependency("contract", "integer", true);
        add_public_dependency("contract", "intrusive", true);
        add_public_dependency("contract", "io", true);
        add_public_dependency("contract", "iostreams", true);
        add_public_dependency("contract", "iterator", true);
        add_public_dependency("contract", "lambda", true);
        add_public_dependency("contract", "lexical_cast", true);
        add_public_dependency("contract", "locale", true);
        add_public_dependency("contract", "math", true);
        add_public_dependency("contract", "move", true);
        add_public_dependency("contract", "mpl", true);
        add_public_dependency("contract", "multiprecision", true);
        add_public_dependency("contract", "numeric", true);
        add_public_dependency("contract", "optional", true);
        add_public_dependency("contract", "phoenix", true);
        add_public_dependency("contract", "pool", true);
        add_public_dependency("contract", "predef", true);
        add_public_dependency("contract", "preprocessor", true);
        add_public_dependency("contract", "proto", true);
        add_public_dependency("contract", "random", true);
        add_public_dependency("contract", "range", true);
        add_public_dependency("contract", "ratio", true);
        add_public_dependency("contract", "rational", true);
        add_public_dependency("contract", "regex", true);
        add_public_dependency("contract", "serialization", true);
        add_public_dependency("contract", "smart_ptr", true);
        add_public_dependency("contract", "spirit", true);
        add_public_dependency("contract", "static_assert", true);
        add_public_dependency("contract", "thread", true);
        add_public_dependency("contract", "throw_exception", true);
        add_public_dependency("contract", "tokenizer", true);
        add_public_dependency("contract", "tti", true);
        add_public_dependency("contract", "tuple", true);
        add_public_dependency("contract", "type_index", true);
        add_public_dependency("contract", "type_traits", true);
        add_public_dependency("contract", "typeof", true);
        add_public_dependency("contract", "unordered", true);
        add_public_dependency("contract", "utility", true);
        add_public_dependency("contract", "variant", true);
        add_public_dependency("contract", "winapi", true);
        add_public_dependency("conversion", "assert", true);
        add_public_dependency("conversion", "config", true);
        add_public_dependency("conversion", "core", true);
        add_public_dependency("conversion", "move", true);
        add_public_dependency("conversion", "predef", true);
        add_public_dependency("conversion", "preprocessor", true);
        add_public_dependency("conversion", "smart_ptr", true);
        add_public_dependency("conversion", "static_assert", true);
        add_public_dependency("conversion", "throw_exception", true);
        add_public_dependency("conversion", "type_traits", true);
        add_public_dependency("conversion", "typeof", true);
        add_public_dependency("convert", "algorithm", true);
        add_public_dependency("convert", "array", true);
        add_public_dependency("convert", "assert", true);
        add_public_dependency("convert", "atomic", true);
        add_public_dependency("convert", "bind", true);
        add_public_dependency("convert", "chrono", true);
        add_public_dependency("convert", "concept_check", true);
        add_public_dependency("convert", "config", true);
        add_public_dependency("convert", "container", true);
        add_public_dependency("convert", "container_hash", true);
        add_public_dependency("convert", "conversion", true);
        add_public_dependency("convert", "core", true);
        add_public_dependency("convert", "date_time", true);
        add_public_dependency("convert", "detail", true);
        add_public_dependency("convert", "dynamic_bitset", true);
        add_public_dependency("convert", "endian", true);
        add_public_dependency("convert", "exception", true);
        add_public_dependency("convert", "filesystem", true);
        add_public_dependency("convert", "foreach", true);
        add_public_dependency("convert", "function", true);
        add_public_dependency("convert", "function_types", true);
        add_public_dependency("convert", "fusion", true);
        add_public_dependency("convert", "integer", true);
        add_public_dependency("convert", "intrusive", true);
        add_public_dependency("convert", "io", true);
        add_public_dependency("convert", "iostreams", true);
        add_public_dependency("convert", "iterator", true);
        add_public_dependency("convert", "lambda", true);
        add_public_dependency("convert", "lexical_cast", true);
        add_public_dependency("convert", "locale", true);
        add_public_dependency("convert", "math", true);
        add_public_dependency("convert", "move", true);
        add_public_dependency("convert", "mpl", true);
        add_public_dependency("convert", "multiprecision", true);
        add_public_dependency("convert", "numeric", true);
        add_public_dependency("convert", "optional", true);
        add_public_dependency("convert", "parameter", true);
        add_public_dependency("convert", "phoenix", true);
        add_public_dependency("convert", "pool", true);
        add_public_dependency("convert", "predef", true);
        add_public_dependency("convert", "preprocessor", true);
        add_public_dependency("convert", "proto", true);
        add_public_dependency("convert", "random", true);
        add_public_dependency("convert", "range", true);
        add_public_dependency("convert", "ratio", true);
        add_public_dependency("convert", "rational", true);
        add_public_dependency("convert", "regex", true);
        add_public_dependency("convert", "serialization", true);
        add_public_dependency("convert", "smart_ptr", true);
        add_public_dependency("convert", "spirit", true);
        add_public_dependency("convert", "static_assert", true);
        add_public_dependency("convert", "system", true);
        add_public_dependency("convert", "thread", true);
        add_public_dependency("convert", "throw_exception", true);
        add_public_dependency("convert", "tokenizer", true);
        add_public_dependency("convert", "tti", true);
        add_public_dependency("convert", "tuple", true);
        add_public_dependency("convert", "type_index", true);
        add_public_dependency("convert", "type_traits", true);
        add_public_dependency("convert", "typeof", true);
        add_public_dependency("convert", "unordered", true);
        add_public_dependency("convert", "utility", true);
        add_public_dependency("convert", "variant", true);
        add_public_dependency("convert", "winapi", true);
        add_public_dependency("core", "assert", true);
        add_public_dependency("core", "config", true);
        add_public_dependency("coroutine", "context", false);
        add_public_dependency("coroutine", "system", false);
        add_public_dependency("coroutine", "thread", false);
        add_public_dependency("coroutine", "algorithm", true);
        add_public_dependency("coroutine", "array", true);
        add_public_dependency("coroutine", "assert", true);
        add_public_dependency("coroutine", "atomic", true);
        add_public_dependency("coroutine", "bind", true);
        add_public_dependency("coroutine", "chrono", true);
        add_public_dependency("coroutine", "concept_check", true);
        add_public_dependency("coroutine", "config", true);
        add_public_dependency("coroutine", "container", true);
        add_public_dependency("coroutine", "container_hash", true);
        add_public_dependency("coroutine", "conversion", true);
        add_public_dependency("coroutine", "core", true);
        add_public_dependency("coroutine", "date_time", true);
        add_public_dependency("coroutine", "detail", true);
        add_public_dependency("coroutine", "dynamic_bitset", true);
        add_public_dependency("coroutine", "endian", true);
        add_public_dependency("coroutine", "exception", true);
        add_public_dependency("coroutine", "filesystem", true);
        add_public_dependency("coroutine", "foreach", true);
        add_public_dependency("coroutine", "function", true);
        add_public_dependency("coroutine", "function_types", true);
        add_public_dependency("coroutine", "fusion", true);
        add_public_dependency("coroutine", "integer", true);
        add_public_dependency("coroutine", "intrusive", true);
        add_public_dependency("coroutine", "io", true);
        add_public_dependency("coroutine", "iostreams", true);
        add_public_dependency("coroutine", "iterator", true);
        add_public_dependency("coroutine", "lambda", true);
        add_public_dependency("coroutine", "lexical_cast", true);
        add_public_dependency("coroutine", "locale", true);
        add_public_dependency("coroutine", "math", true);
        add_public_dependency("coroutine", "move", true);
        add_public_dependency("coroutine", "mpl", true);
        add_public_dependency("coroutine", "multiprecision", true);
        add_public_dependency("coroutine", "numeric", true);
        add_public_dependency("coroutine", "optional", true);
        add_public_dependency("coroutine", "phoenix", true);
        add_public_dependency("coroutine", "pool", true);
        add_public_dependency("coroutine", "predef", true);
        add_public_dependency("coroutine", "preprocessor", true);
        add_public_dependency("coroutine", "proto", true);
        add_public_dependency("coroutine", "random", true);
        add_public_dependency("coroutine", "range", true);
        add_public_dependency("coroutine", "ratio", true);
        add_public_dependency("coroutine", "rational", true);
        add_public_dependency("coroutine", "regex", true);
        add_public_dependency("coroutine", "serialization", true);
        add_public_dependency("coroutine", "smart_ptr", true);
        add_public_dependency("coroutine", "spirit", true);
        add_public_dependency("coroutine", "static_assert", true);
        add_public_dependency("coroutine", "throw_exception", true);
        add_public_dependency("coroutine", "tokenizer", true);
        add_public_dependency("coroutine", "tti", true);
        add_public_dependency("coroutine", "tuple", true);
        add_public_dependency("coroutine", "type_index", true);
        add_public_dependency("coroutine", "type_traits", true);
        add_public_dependency("coroutine", "typeof", true);
        add_public_dependency("coroutine", "unordered", true);
        add_public_dependency("coroutine", "utility", true);
        add_public_dependency("coroutine", "variant", true);
        add_public_dependency("coroutine", "winapi", true);
        add_public_dependency("coroutine2", "algorithm", true);
        add_public_dependency("coroutine2", "array", true);
        add_public_dependency("coroutine2", "assert", true);
        add_public_dependency("coroutine2", "atomic", true);
        add_public_dependency("coroutine2", "bind", true);
        add_public_dependency("coroutine2", "chrono", true);
        add_public_dependency("coroutine2", "concept_check", true);
        add_public_dependency("coroutine2", "config", true);
        add_public_dependency("coroutine2", "container", true);
        add_public_dependency("coroutine2", "container_hash", true);
        add_public_dependency("coroutine2", "context", true);
        add_public_dependency("coroutine2", "conversion", true);
        add_public_dependency("coroutine2", "core", true);
        add_public_dependency("coroutine2", "date_time", true);
        add_public_dependency("coroutine2", "detail", true);
        add_public_dependency("coroutine2", "dynamic_bitset", true);
        add_public_dependency("coroutine2", "endian", true);
        add_public_dependency("coroutine2", "exception", true);
        add_public_dependency("coroutine2", "filesystem", true);
        add_public_dependency("coroutine2", "foreach", true);
        add_public_dependency("coroutine2", "function", true);
        add_public_dependency("coroutine2", "function_types", true);
        add_public_dependency("coroutine2", "fusion", true);
        add_public_dependency("coroutine2", "integer", true);
        add_public_dependency("coroutine2", "intrusive", true);
        add_public_dependency("coroutine2", "io", true);
        add_public_dependency("coroutine2", "iostreams", true);
        add_public_dependency("coroutine2", "iterator", true);
        add_public_dependency("coroutine2", "lambda", true);
        add_public_dependency("coroutine2", "lexical_cast", true);
        add_public_dependency("coroutine2", "locale", true);
        add_public_dependency("coroutine2", "math", true);
        add_public_dependency("coroutine2", "move", true);
        add_public_dependency("coroutine2", "mpl", true);
        add_public_dependency("coroutine2", "multiprecision", true);
        add_public_dependency("coroutine2", "numeric", true);
        add_public_dependency("coroutine2", "optional", true);
        add_public_dependency("coroutine2", "phoenix", true);
        add_public_dependency("coroutine2", "pool", true);
        add_public_dependency("coroutine2", "predef", true);
        add_public_dependency("coroutine2", "preprocessor", true);
        add_public_dependency("coroutine2", "proto", true);
        add_public_dependency("coroutine2", "random", true);
        add_public_dependency("coroutine2", "range", true);
        add_public_dependency("coroutine2", "ratio", true);
        add_public_dependency("coroutine2", "rational", true);
        add_public_dependency("coroutine2", "regex", true);
        add_public_dependency("coroutine2", "serialization", true);
        add_public_dependency("coroutine2", "smart_ptr", true);
        add_public_dependency("coroutine2", "spirit", true);
        add_public_dependency("coroutine2", "static_assert", true);
        add_public_dependency("coroutine2", "system", true);
        add_public_dependency("coroutine2", "thread", true);
        add_public_dependency("coroutine2", "throw_exception", true);
        add_public_dependency("coroutine2", "tokenizer", true);
        add_public_dependency("coroutine2", "tti", true);
        add_public_dependency("coroutine2", "tuple", true);
        add_public_dependency("coroutine2", "type_index", true);
        add_public_dependency("coroutine2", "type_traits", true);
        add_public_dependency("coroutine2", "typeof", true);
        add_public_dependency("coroutine2", "unordered", true);
        add_public_dependency("coroutine2", "utility", true);
        add_public_dependency("coroutine2", "variant", true);
        add_public_dependency("coroutine2", "winapi", true);
        add_public_dependency("crc", "array", true);
        add_public_dependency("crc", "assert", true);
        add_public_dependency("crc", "config", true);
        add_public_dependency("crc", "core", true);
        add_public_dependency("crc", "integer", true);
        add_public_dependency("crc", "preprocessor", true);
        add_public_dependency("crc", "static_assert", true);
        add_public_dependency("crc", "throw_exception", true);
        add_public_dependency("crc", "type_traits", true);
        add_public_dependency("date_time", "algorithm", true);
        add_public_dependency("date_time", "array", true);
        add_public_dependency("date_time", "assert", true);
        add_public_dependency("date_time", "atomic", true);
        add_public_dependency("date_time", "bind", true);
        add_public_dependency("date_time", "chrono", true);
        add_public_dependency("date_time", "concept_check", true);
        add_public_dependency("date_time", "config", true);
        add_public_dependency("date_time", "container", true);
        add_public_dependency("date_time", "container_hash", true);
        add_public_dependency("date_time", "conversion", true);
        add_public_dependency("date_time", "core", true);
        add_public_dependency("date_time", "detail", true);
        add_public_dependency("date_time", "dynamic_bitset", true);
        add_public_dependency("date_time", "endian", true);
        add_public_dependency("date_time", "exception", true);
        add_public_dependency("date_time", "filesystem", true);
        add_public_dependency("date_time", "foreach", true);
        add_public_dependency("date_time", "function", true);
        add_public_dependency("date_time", "function_types", true);
        add_public_dependency("date_time", "fusion", true);
        add_public_dependency("date_time", "integer", true);
        add_public_dependency("date_time", "intrusive", true);
        add_public_dependency("date_time", "io", true);
        add_public_dependency("date_time", "iostreams", true);
        add_public_dependency("date_time", "iterator", true);
        add_public_dependency("date_time", "lambda", true);
        add_public_dependency("date_time", "lexical_cast", true);
        add_public_dependency("date_time", "locale", true);
        add_public_dependency("date_time", "math", true);
        add_public_dependency("date_time", "move", true);
        add_public_dependency("date_time", "mpl", true);
        add_public_dependency("date_time", "multiprecision", true);
        add_public_dependency("date_time", "numeric", true);
        add_public_dependency("date_time", "optional", true);
        add_public_dependency("date_time", "phoenix", true);
        add_public_dependency("date_time", "pool", true);
        add_public_dependency("date_time", "predef", true);
        add_public_dependency("date_time", "preprocessor", true);
        add_public_dependency("date_time", "proto", true);
        add_public_dependency("date_time", "random", true);
        add_public_dependency("date_time", "range", true);
        add_public_dependency("date_time", "ratio", true);
        add_public_dependency("date_time", "rational", true);
        add_public_dependency("date_time", "regex", true);
        add_public_dependency("date_time", "serialization", true);
        add_public_dependency("date_time", "smart_ptr", true);
        add_public_dependency("date_time", "spirit", true);
        add_public_dependency("date_time", "static_assert", true);
        add_public_dependency("date_time", "system", true);
        add_public_dependency("date_time", "thread", true);
        add_public_dependency("date_time", "throw_exception", true);
        add_public_dependency("date_time", "tokenizer", true);
        add_public_dependency("date_time", "tti", true);
        add_public_dependency("date_time", "tuple", true);
        add_public_dependency("date_time", "type_index", true);
        add_public_dependency("date_time", "type_traits", true);
        add_public_dependency("date_time", "typeof", true);
        add_public_dependency("date_time", "unordered", true);
        add_public_dependency("date_time", "utility", true);
        add_public_dependency("date_time", "variant", true);
        add_public_dependency("date_time", "winapi", true);
        add_public_dependency("detail", "assert", true);
        add_public_dependency("detail", "config", true);
        add_public_dependency("detail", "core", true);
        add_public_dependency("detail", "preprocessor", true);
        add_public_dependency("detail", "static_assert", true);
        add_public_dependency("detail", "type_traits", true);
        add_public_dependency("disjoint_sets", "algorithm", true);
        add_public_dependency("disjoint_sets", "any", true);
        add_public_dependency("disjoint_sets", "array", true);
        add_public_dependency("disjoint_sets", "assert", true);
        add_public_dependency("disjoint_sets", "atomic", true);
        add_public_dependency("disjoint_sets", "bimap", true);
        add_public_dependency("disjoint_sets", "bind", true);
        add_public_dependency("disjoint_sets", "chrono", true);
        add_public_dependency("disjoint_sets", "concept_check", true);
        add_public_dependency("disjoint_sets", "config", true);
        add_public_dependency("disjoint_sets", "container", true);
        add_public_dependency("disjoint_sets", "container_hash", true);
        add_public_dependency("disjoint_sets", "conversion", true);
        add_public_dependency("disjoint_sets", "core", true);
        add_public_dependency("disjoint_sets", "date_time", true);
        add_public_dependency("disjoint_sets", "detail", true);
        add_public_dependency("disjoint_sets", "dynamic_bitset", true);
        add_public_dependency("disjoint_sets", "endian", true);
        add_public_dependency("disjoint_sets", "exception", true);
        add_public_dependency("disjoint_sets", "filesystem", true);
        add_public_dependency("disjoint_sets", "foreach", true);
        add_public_dependency("disjoint_sets", "format", true);
        add_public_dependency("disjoint_sets", "function", true);
        add_public_dependency("disjoint_sets", "function_types", true);
        add_public_dependency("disjoint_sets", "fusion", true);
        add_public_dependency("disjoint_sets", "graph", true);
        add_public_dependency("disjoint_sets", "graph_parallel", true);
        add_public_dependency("disjoint_sets", "integer", true);
        add_public_dependency("disjoint_sets", "intrusive", true);
        add_public_dependency("disjoint_sets", "io", true);
        add_public_dependency("disjoint_sets", "iostreams", true);
        add_public_dependency("disjoint_sets", "iterator", true);
        add_public_dependency("disjoint_sets", "lambda", true);
        add_public_dependency("disjoint_sets", "lexical_cast", true);
        add_public_dependency("disjoint_sets", "locale", true);
        add_public_dependency("disjoint_sets", "math", true);
        add_public_dependency("disjoint_sets", "move", true);
        add_public_dependency("disjoint_sets", "mpi", true);
        add_public_dependency("disjoint_sets", "mpl", true);
        add_public_dependency("disjoint_sets", "multi_index", true);
        add_public_dependency("disjoint_sets", "multiprecision", true);
        add_public_dependency("disjoint_sets", "numeric", true);
        add_public_dependency("disjoint_sets", "optional", true);
        add_public_dependency("disjoint_sets", "parameter", true);
        add_public_dependency("disjoint_sets", "phoenix", true);
        add_public_dependency("disjoint_sets", "pool", true);
        add_public_dependency("disjoint_sets", "predef", true);
        add_public_dependency("disjoint_sets", "preprocessor", true);
        add_public_dependency("disjoint_sets", "property_map", true);
        add_public_dependency("disjoint_sets", "property_tree", true);
        add_public_dependency("disjoint_sets", "proto", true);
        add_public_dependency("disjoint_sets", "python", true);
        add_public_dependency("disjoint_sets", "random", true);
        add_public_dependency("disjoint_sets", "range", true);
        add_public_dependency("disjoint_sets", "ratio", true);
        add_public_dependency("disjoint_sets", "rational", true);
        add_public_dependency("disjoint_sets", "regex", true);
        add_public_dependency("disjoint_sets", "serialization", true);
        add_public_dependency("disjoint_sets", "smart_ptr", true);
        add_public_dependency("disjoint_sets", "spirit", true);
        add_public_dependency("disjoint_sets", "static_assert", true);
        add_public_dependency("disjoint_sets", "system", true);
        add_public_dependency("disjoint_sets", "test", true);
        add_public_dependency("disjoint_sets", "thread", true);
        add_public_dependency("disjoint_sets", "throw_exception", true);
        add_public_dependency("disjoint_sets", "timer", true);
        add_public_dependency("disjoint_sets", "tokenizer", true);
        add_public_dependency("disjoint_sets", "tti", true);
        add_public_dependency("disjoint_sets", "tuple", true);
        add_public_dependency("disjoint_sets", "type_index", true);
        add_public_dependency("disjoint_sets", "type_traits", true);
        add_public_dependency("disjoint_sets", "typeof", true);
        add_public_dependency("disjoint_sets", "unordered", true);
        add_public_dependency("disjoint_sets", "utility", true);
        add_public_dependency("disjoint_sets", "variant", true);
        add_public_dependency("disjoint_sets", "winapi", true);
        add_public_dependency("disjoint_sets", "xpressive", true);
        add_public_dependency("dll", "algorithm", true);
        add_public_dependency("dll", "array", true);
        add_public_dependency("dll", "assert", true);
        add_public_dependency("dll", "atomic", true);
        add_public_dependency("dll", "bind", true);
        add_public_dependency("dll", "chrono", true);
        add_public_dependency("dll", "concept_check", true);
        add_public_dependency("dll", "config", true);
        add_public_dependency("dll", "container", true);
        add_public_dependency("dll", "container_hash", true);
        add_public_dependency("dll", "conversion", true);
        add_public_dependency("dll", "core", true);
        add_public_dependency("dll", "date_time", true);
        add_public_dependency("dll", "detail", true);
        add_public_dependency("dll", "dynamic_bitset", true);
        add_public_dependency("dll", "endian", true);
        add_public_dependency("dll", "exception", true);
        add_public_dependency("dll", "filesystem", true);
        add_public_dependency("dll", "foreach", true);
        add_public_dependency("dll", "function", true);
        add_public_dependency("dll", "function_types", true);
        add_public_dependency("dll", "fusion", true);
        add_public_dependency("dll", "integer", true);
        add_public_dependency("dll", "intrusive", true);
        add_public_dependency("dll", "io", true);
        add_public_dependency("dll", "iostreams", true);
        add_public_dependency("dll", "iterator", true);
        add_public_dependency("dll", "lambda", true);
        add_public_dependency("dll", "lexical_cast", true);
        add_public_dependency("dll", "locale", true);
        add_public_dependency("dll", "math", true);
        add_public_dependency("dll", "move", true);
        add_public_dependency("dll", "mpl", true);
        add_public_dependency("dll", "multiprecision", true);
        add_public_dependency("dll", "numeric", true);
        add_public_dependency("dll", "optional", true);
        add_public_dependency("dll", "phoenix", true);
        add_public_dependency("dll", "pool", true);
        add_public_dependency("dll", "predef", true);
        add_public_dependency("dll", "preprocessor", true);
        add_public_dependency("dll", "proto", true);
        add_public_dependency("dll", "random", true);
        add_public_dependency("dll", "range", true);
        add_public_dependency("dll", "ratio", true);
        add_public_dependency("dll", "rational", true);
        add_public_dependency("dll", "regex", true);
        add_public_dependency("dll", "serialization", true);
        add_public_dependency("dll", "smart_ptr", true);
        add_public_dependency("dll", "spirit", true);
        add_public_dependency("dll", "static_assert", true);
        add_public_dependency("dll", "system", true);
        add_public_dependency("dll", "thread", true);
        add_public_dependency("dll", "throw_exception", true);
        add_public_dependency("dll", "tokenizer", true);
        add_public_dependency("dll", "tti", true);
        add_public_dependency("dll", "tuple", true);
        add_public_dependency("dll", "type_index", true);
        add_public_dependency("dll", "type_traits", true);
        add_public_dependency("dll", "typeof", true);
        add_public_dependency("dll", "unordered", true);
        add_public_dependency("dll", "utility", true);
        add_public_dependency("dll", "variant", true);
        add_public_dependency("dll", "winapi", true);
        add_public_dependency("dynamic_bitset", "algorithm", true);
        add_public_dependency("dynamic_bitset", "array", true);
        add_public_dependency("dynamic_bitset", "assert", true);
        add_public_dependency("dynamic_bitset", "atomic", true);
        add_public_dependency("dynamic_bitset", "bind", true);
        add_public_dependency("dynamic_bitset", "chrono", true);
        add_public_dependency("dynamic_bitset", "concept_check", true);
        add_public_dependency("dynamic_bitset", "config", true);
        add_public_dependency("dynamic_bitset", "container", true);
        add_public_dependency("dynamic_bitset", "container_hash", true);
        add_public_dependency("dynamic_bitset", "conversion", true);
        add_public_dependency("dynamic_bitset", "core", true);
        add_public_dependency("dynamic_bitset", "date_time", true);
        add_public_dependency("dynamic_bitset", "detail", true);
        add_public_dependency("dynamic_bitset", "endian", true);
        add_public_dependency("dynamic_bitset", "exception", true);
        add_public_dependency("dynamic_bitset", "filesystem", true);
        add_public_dependency("dynamic_bitset", "foreach", true);
        add_public_dependency("dynamic_bitset", "function", true);
        add_public_dependency("dynamic_bitset", "function_types", true);
        add_public_dependency("dynamic_bitset", "fusion", true);
        add_public_dependency("dynamic_bitset", "integer", true);
        add_public_dependency("dynamic_bitset", "intrusive", true);
        add_public_dependency("dynamic_bitset", "io", true);
        add_public_dependency("dynamic_bitset", "iostreams", true);
        add_public_dependency("dynamic_bitset", "iterator", true);
        add_public_dependency("dynamic_bitset", "lambda", true);
        add_public_dependency("dynamic_bitset", "lexical_cast", true);
        add_public_dependency("dynamic_bitset", "locale", true);
        add_public_dependency("dynamic_bitset", "math", true);
        add_public_dependency("dynamic_bitset", "move", true);
        add_public_dependency("dynamic_bitset", "mpl", true);
        add_public_dependency("dynamic_bitset", "multiprecision", true);
        add_public_dependency("dynamic_bitset", "numeric", true);
        add_public_dependency("dynamic_bitset", "optional", true);
        add_public_dependency("dynamic_bitset", "phoenix", true);
        add_public_dependency("dynamic_bitset", "pool", true);
        add_public_dependency("dynamic_bitset", "predef", true);
        add_public_dependency("dynamic_bitset", "preprocessor", true);
        add_public_dependency("dynamic_bitset", "proto", true);
        add_public_dependency("dynamic_bitset", "random", true);
        add_public_dependency("dynamic_bitset", "range", true);
        add_public_dependency("dynamic_bitset", "ratio", true);
        add_public_dependency("dynamic_bitset", "rational", true);
        add_public_dependency("dynamic_bitset", "regex", true);
        add_public_dependency("dynamic_bitset", "serialization", true);
        add_public_dependency("dynamic_bitset", "smart_ptr", true);
        add_public_dependency("dynamic_bitset", "spirit", true);
        add_public_dependency("dynamic_bitset", "static_assert", true);
        add_public_dependency("dynamic_bitset", "system", true);
        add_public_dependency("dynamic_bitset", "thread", true);
        add_public_dependency("dynamic_bitset", "throw_exception", true);
        add_public_dependency("dynamic_bitset", "tokenizer", true);
        add_public_dependency("dynamic_bitset", "tti", true);
        add_public_dependency("dynamic_bitset", "tuple", true);
        add_public_dependency("dynamic_bitset", "type_index", true);
        add_public_dependency("dynamic_bitset", "type_traits", true);
        add_public_dependency("dynamic_bitset", "typeof", true);
        add_public_dependency("dynamic_bitset", "unordered", true);
        add_public_dependency("dynamic_bitset", "utility", true);
        add_public_dependency("dynamic_bitset", "variant", true);
        add_public_dependency("dynamic_bitset", "winapi", true);
        add_public_dependency("endian", "assert", true);
        add_public_dependency("endian", "config", true);
        add_public_dependency("endian", "container_hash", true);
        add_public_dependency("endian", "core", true);
        add_public_dependency("endian", "detail", true);
        add_public_dependency("endian", "integer", true);
        add_public_dependency("endian", "predef", true);
        add_public_dependency("endian", "preprocessor", true);
        add_public_dependency("endian", "static_assert", true);
        add_public_dependency("endian", "throw_exception", true);
        add_public_dependency("endian", "type_traits", true);
        add_public_dependency("endian", "utility", true);
        add_public_dependency("exception", "assert", true);
        add_public_dependency("exception", "config", true);
        add_public_dependency("exception", "core", true);
        add_public_dependency("exception", "move", true);
        add_public_dependency("exception", "predef", true);
        add_public_dependency("exception", "preprocessor", true);
        add_public_dependency("exception", "smart_ptr", true);
        add_public_dependency("exception", "static_assert", true);
        add_public_dependency("exception", "throw_exception", true);
        add_public_dependency("exception", "tuple", true);
        add_public_dependency("exception", "type_traits", true);
        add_public_dependency("fiber", "context", false);
        add_public_dependency("fiber", "filesystem", false);
        add_public_dependency("fiber", "algorithm", true);
        add_public_dependency("fiber", "array", true);
        add_public_dependency("fiber", "assert", true);
        add_public_dependency("fiber", "atomic", true);
        add_public_dependency("fiber", "bind", true);
        add_public_dependency("fiber", "chrono", true);
        add_public_dependency("fiber", "concept_check", true);
        add_public_dependency("fiber", "config", true);
        add_public_dependency("fiber", "container", true);
        add_public_dependency("fiber", "container_hash", true);
        add_public_dependency("fiber", "conversion", true);
        add_public_dependency("fiber", "core", true);
        add_public_dependency("fiber", "date_time", true);
        add_public_dependency("fiber", "detail", true);
        add_public_dependency("fiber", "dynamic_bitset", true);
        add_public_dependency("fiber", "endian", true);
        add_public_dependency("fiber", "exception", true);
        add_public_dependency("fiber", "foreach", true);
        add_public_dependency("fiber", "format", true);
        add_public_dependency("fiber", "function", true);
        add_public_dependency("fiber", "function_types", true);
        add_public_dependency("fiber", "fusion", true);
        add_public_dependency("fiber", "integer", true);
        add_public_dependency("fiber", "intrusive", true);
        add_public_dependency("fiber", "io", true);
        add_public_dependency("fiber", "iostreams", true);
        add_public_dependency("fiber", "iterator", true);
        add_public_dependency("fiber", "lambda", true);
        add_public_dependency("fiber", "lexical_cast", true);
        add_public_dependency("fiber", "locale", true);
        add_public_dependency("fiber", "math", true);
        add_public_dependency("fiber", "move", true);
        add_public_dependency("fiber", "mpl", true);
        add_public_dependency("fiber", "multiprecision", true);
        add_public_dependency("fiber", "numeric", true);
        add_public_dependency("fiber", "optional", true);
        add_public_dependency("fiber", "phoenix", true);
        add_public_dependency("fiber", "pool", true);
        add_public_dependency("fiber", "predef", true);
        add_public_dependency("fiber", "preprocessor", true);
        add_public_dependency("fiber", "proto", true);
        add_public_dependency("fiber", "random", true);
        add_public_dependency("fiber", "range", true);
        add_public_dependency("fiber", "ratio", true);
        add_public_dependency("fiber", "rational", true);
        add_public_dependency("fiber", "regex", true);
        add_public_dependency("fiber", "serialization", true);
        add_public_dependency("fiber", "smart_ptr", true);
        add_public_dependency("fiber", "spirit", true);
        add_public_dependency("fiber", "static_assert", true);
        add_public_dependency("fiber", "system", true);
        add_public_dependency("fiber", "thread", true);
        add_public_dependency("fiber", "throw_exception", true);
        add_public_dependency("fiber", "tokenizer", true);
        add_public_dependency("fiber", "tti", true);
        add_public_dependency("fiber", "tuple", true);
        add_public_dependency("fiber", "type_index", true);
        add_public_dependency("fiber", "type_traits", true);
        add_public_dependency("fiber", "typeof", true);
        add_public_dependency("fiber", "unordered", true);
        add_public_dependency("fiber", "utility", true);
        add_public_dependency("fiber", "variant", true);
        add_public_dependency("fiber", "winapi", true);
        add_public_dependency("filesystem", "system", false);
        add_public_dependency("filesystem", "assert", true);
        add_public_dependency("filesystem", "concept_check", true);
        add_public_dependency("filesystem", "config", true);
        add_public_dependency("filesystem", "container_hash", true);
        add_public_dependency("filesystem", "conversion", true);
        add_public_dependency("filesystem", "core", true);
        add_public_dependency("filesystem", "detail", true);
        add_public_dependency("filesystem", "function_types", true);
        add_public_dependency("filesystem", "fusion", true);
        add_public_dependency("filesystem", "integer", true);
        add_public_dependency("filesystem", "io", true);
        add_public_dependency("filesystem", "iterator", true);
        add_public_dependency("filesystem", "move", true);
        add_public_dependency("filesystem", "mpl", true);
        add_public_dependency("filesystem", "optional", true);
        add_public_dependency("filesystem", "predef", true);
        add_public_dependency("filesystem", "preprocessor", true);
        add_public_dependency("filesystem", "smart_ptr", true);
        add_public_dependency("filesystem", "static_assert", true);
        add_public_dependency("filesystem", "throw_exception", true);
        add_public_dependency("filesystem", "tuple", true);
        add_public_dependency("filesystem", "type_traits", true);
        add_public_dependency("filesystem", "typeof", true);
        add_public_dependency("filesystem", "utility", true);
        add_public_dependency("filesystem", "winapi", true);
        add_public_dependency("flyweight", "algorithm", true);
        add_public_dependency("flyweight", "array", true);
        add_public_dependency("flyweight", "assert", true);
        add_public_dependency("flyweight", "atomic", true);
        add_public_dependency("flyweight", "bind", true);
        add_public_dependency("flyweight", "chrono", true);
        add_public_dependency("flyweight", "concept_check", true);
        add_public_dependency("flyweight", "config", true);
        add_public_dependency("flyweight", "container", true);
        add_public_dependency("flyweight", "container_hash", true);
        add_public_dependency("flyweight", "conversion", true);
        add_public_dependency("flyweight", "core", true);
        add_public_dependency("flyweight", "date_time", true);
        add_public_dependency("flyweight", "detail", true);
        add_public_dependency("flyweight", "dynamic_bitset", true);
        add_public_dependency("flyweight", "endian", true);
        add_public_dependency("flyweight", "exception", true);
        add_public_dependency("flyweight", "filesystem", true);
        add_public_dependency("flyweight", "foreach", true);
        add_public_dependency("flyweight", "function", true);
        add_public_dependency("flyweight", "function_types", true);
        add_public_dependency("flyweight", "fusion", true);
        add_public_dependency("flyweight", "integer", true);
        add_public_dependency("flyweight", "interprocess", true);
        add_public_dependency("flyweight", "intrusive", true);
        add_public_dependency("flyweight", "io", true);
        add_public_dependency("flyweight", "iostreams", true);
        add_public_dependency("flyweight", "iterator", true);
        add_public_dependency("flyweight", "lambda", true);
        add_public_dependency("flyweight", "lexical_cast", true);
        add_public_dependency("flyweight", "locale", true);
        add_public_dependency("flyweight", "math", true);
        add_public_dependency("flyweight", "move", true);
        add_public_dependency("flyweight", "mpl", true);
        add_public_dependency("flyweight", "multi_index", true);
        add_public_dependency("flyweight", "multiprecision", true);
        add_public_dependency("flyweight", "numeric", true);
        add_public_dependency("flyweight", "optional", true);
        add_public_dependency("flyweight", "parameter", true);
        add_public_dependency("flyweight", "phoenix", true);
        add_public_dependency("flyweight", "pool", true);
        add_public_dependency("flyweight", "predef", true);
        add_public_dependency("flyweight", "preprocessor", true);
        add_public_dependency("flyweight", "proto", true);
        add_public_dependency("flyweight", "random", true);
        add_public_dependency("flyweight", "range", true);
        add_public_dependency("flyweight", "ratio", true);
        add_public_dependency("flyweight", "rational", true);
        add_public_dependency("flyweight", "regex", true);
        add_public_dependency("flyweight", "serialization", true);
        add_public_dependency("flyweight", "smart_ptr", true);
        add_public_dependency("flyweight", "spirit", true);
        add_public_dependency("flyweight", "static_assert", true);
        add_public_dependency("flyweight", "system", true);
        add_public_dependency("flyweight", "thread", true);
        add_public_dependency("flyweight", "throw_exception", true);
        add_public_dependency("flyweight", "tokenizer", true);
        add_public_dependency("flyweight", "tti", true);
        add_public_dependency("flyweight", "tuple", true);
        add_public_dependency("flyweight", "type_index", true);
        add_public_dependency("flyweight", "type_traits", true);
        add_public_dependency("flyweight", "typeof", true);
        add_public_dependency("flyweight", "unordered", true);
        add_public_dependency("flyweight", "utility", true);
        add_public_dependency("flyweight", "variant", true);
        add_public_dependency("flyweight", "winapi", true);
        add_public_dependency("foreach", "algorithm", true);
        add_public_dependency("foreach", "array", true);
        add_public_dependency("foreach", "assert", true);
        add_public_dependency("foreach", "bind", true);
        add_public_dependency("foreach", "concept_check", true);
        add_public_dependency("foreach", "config", true);
        add_public_dependency("foreach", "container", true);
        add_public_dependency("foreach", "container_hash", true);
        add_public_dependency("foreach", "conversion", true);
        add_public_dependency("foreach", "core", true);
        add_public_dependency("foreach", "detail", true);
        add_public_dependency("foreach", "exception", true);
        add_public_dependency("foreach", "function", true);
        add_public_dependency("foreach", "function_types", true);
        add_public_dependency("foreach", "fusion", true);
        add_public_dependency("foreach", "integer", true);
        add_public_dependency("foreach", "intrusive", true);
        add_public_dependency("foreach", "iterator", true);
        add_public_dependency("foreach", "move", true);
        add_public_dependency("foreach", "mpl", true);
        add_public_dependency("foreach", "numeric", true);
        add_public_dependency("foreach", "optional", true);
        add_public_dependency("foreach", "predef", true);
        add_public_dependency("foreach", "preprocessor", true);
        add_public_dependency("foreach", "range", true);
        add_public_dependency("foreach", "regex", true);
        add_public_dependency("foreach", "smart_ptr", true);
        add_public_dependency("foreach", "static_assert", true);
        add_public_dependency("foreach", "throw_exception", true);
        add_public_dependency("foreach", "tuple", true);
        add_public_dependency("foreach", "type_index", true);
        add_public_dependency("foreach", "type_traits", true);
        add_public_dependency("foreach", "typeof", true);
        add_public_dependency("foreach", "unordered", true);
        add_public_dependency("foreach", "utility", true);
        add_public_dependency("format", "assert", true);
        add_public_dependency("format", "config", true);
        add_public_dependency("format", "container_hash", true);
        add_public_dependency("format", "core", true);
        add_public_dependency("format", "detail", true);
        add_public_dependency("format", "integer", true);
        add_public_dependency("format", "move", true);
        add_public_dependency("format", "optional", true);
        add_public_dependency("format", "predef", true);
        add_public_dependency("format", "preprocessor", true);
        add_public_dependency("format", "smart_ptr", true);
        add_public_dependency("format", "static_assert", true);
        add_public_dependency("format", "throw_exception", true);
        add_public_dependency("format", "type_traits", true);
        add_public_dependency("format", "utility", true);
        add_public_dependency("function", "assert", true);
        add_public_dependency("function", "bind", true);
        add_public_dependency("function", "config", true);
        add_public_dependency("function", "container_hash", true);
        add_public_dependency("function", "core", true);
        add_public_dependency("function", "detail", true);
        add_public_dependency("function", "integer", true);
        add_public_dependency("function", "move", true);
        add_public_dependency("function", "predef", true);
        add_public_dependency("function", "preprocessor", true);
        add_public_dependency("function", "smart_ptr", true);
        add_public_dependency("function", "static_assert", true);
        add_public_dependency("function", "throw_exception", true);
        add_public_dependency("function", "type_index", true);
        add_public_dependency("function", "type_traits", true);
        add_public_dependency("function", "typeof", true);
        add_public_dependency("function_types", "assert", true);
        add_public_dependency("function_types", "config", true);
        add_public_dependency("function_types", "container_hash", true);
        add_public_dependency("function_types", "core", true);
        add_public_dependency("function_types", "detail", true);
        add_public_dependency("function_types", "integer", true);
        add_public_dependency("function_types", "mpl", true);
        add_public_dependency("function_types", "predef", true);
        add_public_dependency("function_types", "preprocessor", true);
        add_public_dependency("function_types", "static_assert", true);
        add_public_dependency("function_types", "throw_exception", true);
        add_public_dependency("function_types", "type_traits", true);
        add_public_dependency("function_types", "utility", true);
        add_public_dependency("functional", "assert", true);
        add_public_dependency("functional", "bind", true);
        add_public_dependency("functional", "concept_check", true);
        add_public_dependency("functional", "config", true);
        add_public_dependency("functional", "container_hash", true);
        add_public_dependency("functional", "conversion", true);
        add_public_dependency("functional", "core", true);
        add_public_dependency("functional", "detail", true);
        add_public_dependency("functional", "function", true);
        add_public_dependency("functional", "function_types", true);
        add_public_dependency("functional", "fusion", true);
        add_public_dependency("functional", "integer", true);
        add_public_dependency("functional", "iterator", true);
        add_public_dependency("functional", "move", true);
        add_public_dependency("functional", "mpl", true);
        add_public_dependency("functional", "optional", true);
        add_public_dependency("functional", "predef", true);
        add_public_dependency("functional", "preprocessor", true);
        add_public_dependency("functional", "smart_ptr", true);
        add_public_dependency("functional", "static_assert", true);
        add_public_dependency("functional", "throw_exception", true);
        add_public_dependency("functional", "tuple", true);
        add_public_dependency("functional", "type_index", true);
        add_public_dependency("functional", "type_traits", true);
        add_public_dependency("functional", "typeof", true);
        add_public_dependency("functional", "utility", true);
        add_public_dependency("fusion", "assert", true);
        add_public_dependency("fusion", "config", true);
        add_public_dependency("fusion", "container_hash", true);
        add_public_dependency("fusion", "core", true);
        add_public_dependency("fusion", "detail", true);
        add_public_dependency("fusion", "function_types", true);
        add_public_dependency("fusion", "integer", true);
        add_public_dependency("fusion", "mpl", true);
        add_public_dependency("fusion", "predef", true);
        add_public_dependency("fusion", "preprocessor", true);
        add_public_dependency("fusion", "static_assert", true);
        add_public_dependency("fusion", "throw_exception", true);
        add_public_dependency("fusion", "tuple", true);
        add_public_dependency("fusion", "type_traits", true);
        add_public_dependency("fusion", "typeof", true);
        add_public_dependency("fusion", "utility", true);
        add_public_dependency("geometry", "algorithm", true);
        add_public_dependency("geometry", "array", true);
        add_public_dependency("geometry", "assert", true);
        add_public_dependency("geometry", "atomic", true);
        add_public_dependency("geometry", "bind", true);
        add_public_dependency("geometry", "chrono", true);
        add_public_dependency("geometry", "concept_check", true);
        add_public_dependency("geometry", "config", true);
        add_public_dependency("geometry", "container", true);
        add_public_dependency("geometry", "container_hash", true);
        add_public_dependency("geometry", "conversion", true);
        add_public_dependency("geometry", "core", true);
        add_public_dependency("geometry", "date_time", true);
        add_public_dependency("geometry", "detail", true);
        add_public_dependency("geometry", "dynamic_bitset", true);
        add_public_dependency("geometry", "endian", true);
        add_public_dependency("geometry", "exception", true);
        add_public_dependency("geometry", "filesystem", true);
        add_public_dependency("geometry", "foreach", true);
        add_public_dependency("geometry", "function", true);
        add_public_dependency("geometry", "function_types", true);
        add_public_dependency("geometry", "fusion", true);
        add_public_dependency("geometry", "integer", true);
        add_public_dependency("geometry", "intrusive", true);
        add_public_dependency("geometry", "io", true);
        add_public_dependency("geometry", "iostreams", true);
        add_public_dependency("geometry", "iterator", true);
        add_public_dependency("geometry", "lambda", true);
        add_public_dependency("geometry", "lexical_cast", true);
        add_public_dependency("geometry", "locale", true);
        add_public_dependency("geometry", "math", true);
        add_public_dependency("geometry", "move", true);
        add_public_dependency("geometry", "mpl", true);
        add_public_dependency("geometry", "multiprecision", true);
        add_public_dependency("geometry", "numeric", true);
        add_public_dependency("geometry", "optional", true);
        add_public_dependency("geometry", "phoenix", true);
        add_public_dependency("geometry", "polygon", true);
        add_public_dependency("geometry", "pool", true);
        add_public_dependency("geometry", "predef", true);
        add_public_dependency("geometry", "preprocessor", true);
        add_public_dependency("geometry", "proto", true);
        add_public_dependency("geometry", "qvm", true);
        add_public_dependency("geometry", "random", true);
        add_public_dependency("geometry", "range", true);
        add_public_dependency("geometry", "ratio", true);
        add_public_dependency("geometry", "rational", true);
        add_public_dependency("geometry", "regex", true);
        add_public_dependency("geometry", "serialization", true);
        add_public_dependency("geometry", "smart_ptr", true);
        add_public_dependency("geometry", "spirit", true);
        add_public_dependency("geometry", "static_assert", true);
        add_public_dependency("geometry", "system", true);
        add_public_dependency("geometry", "thread", true);
        add_public_dependency("geometry", "throw_exception", true);
        add_public_dependency("geometry", "tokenizer", true);
        add_public_dependency("geometry", "tti", true);
        add_public_dependency("geometry", "tuple", true);
        add_public_dependency("geometry", "type_index", true);
        add_public_dependency("geometry", "type_traits", true);
        add_public_dependency("geometry", "typeof", true);
        add_public_dependency("geometry", "unordered", true);
        add_public_dependency("geometry", "utility", true);
        add_public_dependency("geometry", "variant", true);
        add_public_dependency("geometry", "winapi", true);
        add_public_dependency("gil", "assert", true);
        add_public_dependency("gil", "bind", true);
        add_public_dependency("gil", "concept_check", true);
        add_public_dependency("gil", "config", true);
        add_public_dependency("gil", "container_hash", true);
        add_public_dependency("gil", "conversion", true);
        add_public_dependency("gil", "core", true);
        add_public_dependency("gil", "detail", true);
        add_public_dependency("gil", "filesystem", true);
        add_public_dependency("gil", "function", true);
        add_public_dependency("gil", "function_types", true);
        add_public_dependency("gil", "fusion", true);
        add_public_dependency("gil", "integer", true);
        add_public_dependency("gil", "io", true);
        add_public_dependency("gil", "iterator", true);
        add_public_dependency("gil", "lambda", true);
        add_public_dependency("gil", "move", true);
        add_public_dependency("gil", "mpl", true);
        add_public_dependency("gil", "numeric", true);
        add_public_dependency("gil", "optional", true);
        add_public_dependency("gil", "predef", true);
        add_public_dependency("gil", "preprocessor", true);
        add_public_dependency("gil", "smart_ptr", true);
        add_public_dependency("gil", "static_assert", true);
        add_public_dependency("gil", "system", true);
        add_public_dependency("gil", "throw_exception", true);
        add_public_dependency("gil", "tuple", true);
        add_public_dependency("gil", "type_index", true);
        add_public_dependency("gil", "type_traits", true);
        add_public_dependency("gil", "typeof", true);
        add_public_dependency("gil", "utility", true);
        add_public_dependency("gil", "winapi", true);
        add_public_dependency("graph", "regex", false);
        add_public_dependency("graph", "algorithm", true);
        add_public_dependency("graph", "any", true);
        add_public_dependency("graph", "array", true);
        add_public_dependency("graph", "assert", true);
        add_public_dependency("graph", "atomic", true);
        add_public_dependency("graph", "bimap", true);
        add_public_dependency("graph", "bind", true);
        add_public_dependency("graph", "chrono", true);
        add_public_dependency("graph", "concept_check", true);
        add_public_dependency("graph", "config", true);
        add_public_dependency("graph", "container", true);
        add_public_dependency("graph", "container_hash", true);
        add_public_dependency("graph", "conversion", true);
        add_public_dependency("graph", "core", true);
        add_public_dependency("graph", "date_time", true);
        add_public_dependency("graph", "detail", true);
        add_public_dependency("graph", "disjoint_sets", true);
        add_public_dependency("graph", "dynamic_bitset", true);
        add_public_dependency("graph", "endian", true);
        add_public_dependency("graph", "exception", true);
        add_public_dependency("graph", "filesystem", true);
        add_public_dependency("graph", "foreach", true);
        add_public_dependency("graph", "format", true);
        add_public_dependency("graph", "function", true);
        add_public_dependency("graph", "function_types", true);
        add_public_dependency("graph", "fusion", true);
        add_public_dependency("graph", "graph_parallel", true);
        add_public_dependency("graph", "integer", true);
        add_public_dependency("graph", "intrusive", true);
        add_public_dependency("graph", "io", true);
        add_public_dependency("graph", "iostreams", true);
        add_public_dependency("graph", "iterator", true);
        add_public_dependency("graph", "lambda", true);
        add_public_dependency("graph", "lexical_cast", true);
        add_public_dependency("graph", "locale", true);
        add_public_dependency("graph", "math", true);
        add_public_dependency("graph", "move", true);
        add_public_dependency("graph", "mpi", true);
        add_public_dependency("graph", "mpl", true);
        add_public_dependency("graph", "multi_index", true);
        add_public_dependency("graph", "multiprecision", true);
        add_public_dependency("graph", "numeric", true);
        add_public_dependency("graph", "optional", true);
        add_public_dependency("graph", "parameter", true);
        add_public_dependency("graph", "phoenix", true);
        add_public_dependency("graph", "pool", true);
        add_public_dependency("graph", "predef", true);
        add_public_dependency("graph", "preprocessor", true);
        add_public_dependency("graph", "property_map", true);
        add_public_dependency("graph", "property_tree", true);
        add_public_dependency("graph", "proto", true);
        add_public_dependency("graph", "python", true);
        add_public_dependency("graph", "random", true);
        add_public_dependency("graph", "range", true);
        add_public_dependency("graph", "ratio", true);
        add_public_dependency("graph", "rational", true);
        add_public_dependency("graph", "serialization", true);
        add_public_dependency("graph", "smart_ptr", true);
        add_public_dependency("graph", "spirit", true);
        add_public_dependency("graph", "static_assert", true);
        add_public_dependency("graph", "system", true);
        add_public_dependency("graph", "test", true);
        add_public_dependency("graph", "thread", true);
        add_public_dependency("graph", "throw_exception", true);
        add_public_dependency("graph", "timer", true);
        add_public_dependency("graph", "tokenizer", true);
        add_public_dependency("graph", "tti", true);
        add_public_dependency("graph", "tuple", true);
        add_public_dependency("graph", "type_index", true);
        add_public_dependency("graph", "type_traits", true);
        add_public_dependency("graph", "typeof", true);
        add_public_dependency("graph", "unordered", true);
        add_public_dependency("graph", "utility", true);
        add_public_dependency("graph", "variant", true);
        add_public_dependency("graph", "winapi", true);
        add_public_dependency("graph", "xpressive", true);
        add_public_dependency("graph_parallel", "mpi", false);
        add_public_dependency("graph_parallel", "algorithm", true);
        add_public_dependency("graph_parallel", "any", true);
        add_public_dependency("graph_parallel", "array", true);
        add_public_dependency("graph_parallel", "assert", true);
        add_public_dependency("graph_parallel", "atomic", true);
        add_public_dependency("graph_parallel", "bimap", true);
        add_public_dependency("graph_parallel", "bind", true);
        add_public_dependency("graph_parallel", "chrono", true);
        add_public_dependency("graph_parallel", "concept_check", true);
        add_public_dependency("graph_parallel", "config", true);
        add_public_dependency("graph_parallel", "container", true);
        add_public_dependency("graph_parallel", "container_hash", true);
        add_public_dependency("graph_parallel", "conversion", true);
        add_public_dependency("graph_parallel", "core", true);
        add_public_dependency("graph_parallel", "date_time", true);
        add_public_dependency("graph_parallel", "detail", true);
        add_public_dependency("graph_parallel", "disjoint_sets", true);
        add_public_dependency("graph_parallel", "dynamic_bitset", true);
        add_public_dependency("graph_parallel", "endian", true);
        add_public_dependency("graph_parallel", "exception", true);
        add_public_dependency("graph_parallel", "filesystem", true);
        add_public_dependency("graph_parallel", "foreach", true);
        add_public_dependency("graph_parallel", "format", true);
        add_public_dependency("graph_parallel", "function", true);
        add_public_dependency("graph_parallel", "function_types", true);
        add_public_dependency("graph_parallel", "fusion", true);
        add_public_dependency("graph_parallel", "graph", true);
        add_public_dependency("graph_parallel", "integer", true);
        add_public_dependency("graph_parallel", "intrusive", true);
        add_public_dependency("graph_parallel", "io", true);
        add_public_dependency("graph_parallel", "iostreams", true);
        add_public_dependency("graph_parallel", "iterator", true);
        add_public_dependency("graph_parallel", "lambda", true);
        add_public_dependency("graph_parallel", "lexical_cast", true);
        add_public_dependency("graph_parallel", "locale", true);
        add_public_dependency("graph_parallel", "math", true);
        add_public_dependency("graph_parallel", "move", true);
        add_public_dependency("graph_parallel", "mpl", true);
        add_public_dependency("graph_parallel", "multi_index", true);
        add_public_dependency("graph_parallel", "multiprecision", true);
        add_public_dependency("graph_parallel", "numeric", true);
        add_public_dependency("graph_parallel", "optional", true);
        add_public_dependency("graph_parallel", "parameter", true);
        add_public_dependency("graph_parallel", "phoenix", true);
        add_public_dependency("graph_parallel", "pool", true);
        add_public_dependency("graph_parallel", "predef", true);
        add_public_dependency("graph_parallel", "preprocessor", true);
        add_public_dependency("graph_parallel", "property_map", true);
        add_public_dependency("graph_parallel", "property_tree", true);
        add_public_dependency("graph_parallel", "proto", true);
        add_public_dependency("graph_parallel", "python", true);
        add_public_dependency("graph_parallel", "random", true);
        add_public_dependency("graph_parallel", "range", true);
        add_public_dependency("graph_parallel", "ratio", true);
        add_public_dependency("graph_parallel", "rational", true);
        add_public_dependency("graph_parallel", "regex", true);
        add_public_dependency("graph_parallel", "serialization", true);
        add_public_dependency("graph_parallel", "smart_ptr", true);
        add_public_dependency("graph_parallel", "spirit", true);
        add_public_dependency("graph_parallel", "static_assert", true);
        add_public_dependency("graph_parallel", "system", true);
        add_public_dependency("graph_parallel", "test", true);
        add_public_dependency("graph_parallel", "thread", true);
        add_public_dependency("graph_parallel", "throw_exception", true);
        add_public_dependency("graph_parallel", "timer", true);
        add_public_dependency("graph_parallel", "tokenizer", true);
        add_public_dependency("graph_parallel", "tti", true);
        add_public_dependency("graph_parallel", "tuple", true);
        add_public_dependency("graph_parallel", "type_index", true);
        add_public_dependency("graph_parallel", "type_traits", true);
        add_public_dependency("graph_parallel", "typeof", true);
        add_public_dependency("graph_parallel", "unordered", true);
        add_public_dependency("graph_parallel", "utility", true);
        add_public_dependency("graph_parallel", "variant", true);
        add_public_dependency("graph_parallel", "winapi", true);
        add_public_dependency("graph_parallel", "xpressive", true);
        add_public_dependency("hana", "assert", true);
        add_public_dependency("hana", "config", true);
        add_public_dependency("hana", "container_hash", true);
        add_public_dependency("hana", "core", true);
        add_public_dependency("hana", "detail", true);
        add_public_dependency("hana", "function_types", true);
        add_public_dependency("hana", "fusion", true);
        add_public_dependency("hana", "integer", true);
        add_public_dependency("hana", "mpl", true);
        add_public_dependency("hana", "predef", true);
        add_public_dependency("hana", "preprocessor", true);
        add_public_dependency("hana", "static_assert", true);
        add_public_dependency("hana", "throw_exception", true);
        add_public_dependency("hana", "tuple", true);
        add_public_dependency("hana", "type_traits", true);
        add_public_dependency("hana", "typeof", true);
        add_public_dependency("hana", "utility", true);
        add_public_dependency("heap", "array", true);
        add_public_dependency("heap", "assert", true);
        add_public_dependency("heap", "bind", true);
        add_public_dependency("heap", "concept_check", true);
        add_public_dependency("heap", "config", true);
        add_public_dependency("heap", "container_hash", true);
        add_public_dependency("heap", "conversion", true);
        add_public_dependency("heap", "core", true);
        add_public_dependency("heap", "detail", true);
        add_public_dependency("heap", "function_types", true);
        add_public_dependency("heap", "fusion", true);
        add_public_dependency("heap", "integer", true);
        add_public_dependency("heap", "intrusive", true);
        add_public_dependency("heap", "iterator", true);
        add_public_dependency("heap", "move", true);
        add_public_dependency("heap", "mpl", true);
        add_public_dependency("heap", "optional", true);
        add_public_dependency("heap", "parameter", true);
        add_public_dependency("heap", "predef", true);
        add_public_dependency("heap", "preprocessor", true);
        add_public_dependency("heap", "smart_ptr", true);
        add_public_dependency("heap", "static_assert", true);
        add_public_dependency("heap", "throw_exception", true);
        add_public_dependency("heap", "tuple", true);
        add_public_dependency("heap", "type_traits", true);
        add_public_dependency("heap", "typeof", true);
        add_public_dependency("heap", "utility", true);
        add_public_dependency("icl", "algorithm", true);
        add_public_dependency("icl", "array", true);
        add_public_dependency("icl", "assert", true);
        add_public_dependency("icl", "atomic", true);
        add_public_dependency("icl", "bind", true);
        add_public_dependency("icl", "chrono", true);
        add_public_dependency("icl", "concept_check", true);
        add_public_dependency("icl", "config", true);
        add_public_dependency("icl", "container", true);
        add_public_dependency("icl", "container_hash", true);
        add_public_dependency("icl", "conversion", true);
        add_public_dependency("icl", "core", true);
        add_public_dependency("icl", "date_time", true);
        add_public_dependency("icl", "detail", true);
        add_public_dependency("icl", "dynamic_bitset", true);
        add_public_dependency("icl", "endian", true);
        add_public_dependency("icl", "exception", true);
        add_public_dependency("icl", "filesystem", true);
        add_public_dependency("icl", "foreach", true);
        add_public_dependency("icl", "function", true);
        add_public_dependency("icl", "function_types", true);
        add_public_dependency("icl", "fusion", true);
        add_public_dependency("icl", "integer", true);
        add_public_dependency("icl", "intrusive", true);
        add_public_dependency("icl", "io", true);
        add_public_dependency("icl", "iostreams", true);
        add_public_dependency("icl", "iterator", true);
        add_public_dependency("icl", "lambda", true);
        add_public_dependency("icl", "lexical_cast", true);
        add_public_dependency("icl", "locale", true);
        add_public_dependency("icl", "math", true);
        add_public_dependency("icl", "move", true);
        add_public_dependency("icl", "mpl", true);
        add_public_dependency("icl", "multiprecision", true);
        add_public_dependency("icl", "numeric", true);
        add_public_dependency("icl", "optional", true);
        add_public_dependency("icl", "phoenix", true);
        add_public_dependency("icl", "pool", true);
        add_public_dependency("icl", "predef", true);
        add_public_dependency("icl", "preprocessor", true);
        add_public_dependency("icl", "proto", true);
        add_public_dependency("icl", "random", true);
        add_public_dependency("icl", "range", true);
        add_public_dependency("icl", "ratio", true);
        add_public_dependency("icl", "rational", true);
        add_public_dependency("icl", "regex", true);
        add_public_dependency("icl", "serialization", true);
        add_public_dependency("icl", "smart_ptr", true);
        add_public_dependency("icl", "spirit", true);
        add_public_dependency("icl", "static_assert", true);
        add_public_dependency("icl", "system", true);
        add_public_dependency("icl", "thread", true);
        add_public_dependency("icl", "throw_exception", true);
        add_public_dependency("icl", "tokenizer", true);
        add_public_dependency("icl", "tti", true);
        add_public_dependency("icl", "tuple", true);
        add_public_dependency("icl", "type_index", true);
        add_public_dependency("icl", "type_traits", true);
        add_public_dependency("icl", "typeof", true);
        add_public_dependency("icl", "unordered", true);
        add_public_dependency("icl", "utility", true);
        add_public_dependency("icl", "variant", true);
        add_public_dependency("icl", "winapi", true);
        add_public_dependency("integer", "assert", true);
        add_public_dependency("integer", "config", true);
        add_public_dependency("integer", "core", true);
        add_public_dependency("integer", "static_assert", true);
        add_public_dependency("interprocess", "algorithm", true);
        add_public_dependency("interprocess", "array", true);
        add_public_dependency("interprocess", "assert", true);
        add_public_dependency("interprocess", "atomic", true);
        add_public_dependency("interprocess", "bind", true);
        add_public_dependency("interprocess", "chrono", true);
        add_public_dependency("interprocess", "concept_check", true);
        add_public_dependency("interprocess", "config", true);
        add_public_dependency("interprocess", "container", true);
        add_public_dependency("interprocess", "container_hash", true);
        add_public_dependency("interprocess", "conversion", true);
        add_public_dependency("interprocess", "core", true);
        add_public_dependency("interprocess", "date_time", true);
        add_public_dependency("interprocess", "detail", true);
        add_public_dependency("interprocess", "dynamic_bitset", true);
        add_public_dependency("interprocess", "endian", true);
        add_public_dependency("interprocess", "exception", true);
        add_public_dependency("interprocess", "filesystem", true);
        add_public_dependency("interprocess", "foreach", true);
        add_public_dependency("interprocess", "function", true);
        add_public_dependency("interprocess", "function_types", true);
        add_public_dependency("interprocess", "fusion", true);
        add_public_dependency("interprocess", "integer", true);
        add_public_dependency("interprocess", "intrusive", true);
        add_public_dependency("interprocess", "io", true);
        add_public_dependency("interprocess", "iostreams", true);
        add_public_dependency("interprocess", "iterator", true);
        add_public_dependency("interprocess", "lambda", true);
        add_public_dependency("interprocess", "lexical_cast", true);
        add_public_dependency("interprocess", "locale", true);
        add_public_dependency("interprocess", "math", true);
        add_public_dependency("interprocess", "move", true);
        add_public_dependency("interprocess", "mpl", true);
        add_public_dependency("interprocess", "multiprecision", true);
        add_public_dependency("interprocess", "numeric", true);
        add_public_dependency("interprocess", "optional", true);
        add_public_dependency("interprocess", "phoenix", true);
        add_public_dependency("interprocess", "pool", true);
        add_public_dependency("interprocess", "predef", true);
        add_public_dependency("interprocess", "preprocessor", true);
        add_public_dependency("interprocess", "proto", true);
        add_public_dependency("interprocess", "random", true);
        add_public_dependency("interprocess", "range", true);
        add_public_dependency("interprocess", "ratio", true);
        add_public_dependency("interprocess", "rational", true);
        add_public_dependency("interprocess", "regex", true);
        add_public_dependency("interprocess", "serialization", true);
        add_public_dependency("interprocess", "smart_ptr", true);
        add_public_dependency("interprocess", "spirit", true);
        add_public_dependency("interprocess", "static_assert", true);
        add_public_dependency("interprocess", "system", true);
        add_public_dependency("interprocess", "thread", true);
        add_public_dependency("interprocess", "throw_exception", true);
        add_public_dependency("interprocess", "tokenizer", true);
        add_public_dependency("interprocess", "tti", true);
        add_public_dependency("interprocess", "tuple", true);
        add_public_dependency("interprocess", "type_index", true);
        add_public_dependency("interprocess", "type_traits", true);
        add_public_dependency("interprocess", "typeof", true);
        add_public_dependency("interprocess", "unordered", true);
        add_public_dependency("interprocess", "utility", true);
        add_public_dependency("interprocess", "variant", true);
        add_public_dependency("interprocess", "winapi", true);
        add_public_dependency("intrusive", "assert", true);
        add_public_dependency("intrusive", "config", true);
        add_public_dependency("intrusive", "container_hash", true);
        add_public_dependency("intrusive", "core", true);
        add_public_dependency("intrusive", "detail", true);
        add_public_dependency("intrusive", "integer", true);
        add_public_dependency("intrusive", "move", true);
        add_public_dependency("intrusive", "preprocessor", true);
        add_public_dependency("intrusive", "static_assert", true);
        add_public_dependency("intrusive", "type_traits", true);
        add_public_dependency("io", "config", true);
        add_public_dependency("iostreams", "algorithm", true);
        add_public_dependency("iostreams", "array", true);
        add_public_dependency("iostreams", "assert", true);
        add_public_dependency("iostreams", "atomic", true);
        add_public_dependency("iostreams", "bind", true);
        add_public_dependency("iostreams", "chrono", true);
        add_public_dependency("iostreams", "concept_check", true);
        add_public_dependency("iostreams", "config", true);
        add_public_dependency("iostreams", "container", true);
        add_public_dependency("iostreams", "container_hash", true);
        add_public_dependency("iostreams", "conversion", true);
        add_public_dependency("iostreams", "core", true);
        add_public_dependency("iostreams", "date_time", true);
        add_public_dependency("iostreams", "detail", true);
        add_public_dependency("iostreams", "dynamic_bitset", true);
        add_public_dependency("iostreams", "endian", true);
        add_public_dependency("iostreams", "exception", true);
        add_public_dependency("iostreams", "filesystem", true);
        add_public_dependency("iostreams", "foreach", true);
        add_public_dependency("iostreams", "function", true);
        add_public_dependency("iostreams", "function_types", true);
        add_public_dependency("iostreams", "fusion", true);
        add_public_dependency("iostreams", "integer", true);
        add_public_dependency("iostreams", "intrusive", true);
        add_public_dependency("iostreams", "io", true);
        add_public_dependency("iostreams", "iterator", true);
        add_public_dependency("iostreams", "lambda", true);
        add_public_dependency("iostreams", "lexical_cast", true);
        add_public_dependency("iostreams", "locale", true);
        add_public_dependency("iostreams", "math", true);
        add_public_dependency("iostreams", "move", true);
        add_public_dependency("iostreams", "mpl", true);
        add_public_dependency("iostreams", "multiprecision", true);
        add_public_dependency("iostreams", "numeric", true);
        add_public_dependency("iostreams", "optional", true);
        add_public_dependency("iostreams", "phoenix", true);
        add_public_dependency("iostreams", "pool", true);
        add_public_dependency("iostreams", "predef", true);
        add_public_dependency("iostreams", "preprocessor", true);
        add_public_dependency("iostreams", "proto", true);
        add_public_dependency("iostreams", "random", true);
        add_public_dependency("iostreams", "range", true);
        add_public_dependency("iostreams", "ratio", true);
        add_public_dependency("iostreams", "rational", true);
        add_public_dependency("iostreams", "regex", true);
        add_public_dependency("iostreams", "serialization", true);
        add_public_dependency("iostreams", "smart_ptr", true);
        add_public_dependency("iostreams", "spirit", true);
        add_public_dependency("iostreams", "static_assert", true);
        add_public_dependency("iostreams", "system", true);
        add_public_dependency("iostreams", "thread", true);
        add_public_dependency("iostreams", "throw_exception", true);
        add_public_dependency("iostreams", "tokenizer", true);
        add_public_dependency("iostreams", "tti", true);
        add_public_dependency("iostreams", "tuple", true);
        add_public_dependency("iostreams", "type_index", true);
        add_public_dependency("iostreams", "type_traits", true);
        add_public_dependency("iostreams", "typeof", true);
        add_public_dependency("iostreams", "unordered", true);
        add_public_dependency("iostreams", "utility", true);
        add_public_dependency("iostreams", "variant", true);
        add_public_dependency("iostreams", "winapi", true);
        add_public_dependency("iterator", "assert", true);
        add_public_dependency("iterator", "concept_check", true);
        add_public_dependency("iterator", "config", true);
        add_public_dependency("iterator", "container_hash", true);
        add_public_dependency("iterator", "conversion", true);
        add_public_dependency("iterator", "core", true);
        add_public_dependency("iterator", "detail", true);
        add_public_dependency("iterator", "function_types", true);
        add_public_dependency("iterator", "fusion", true);
        add_public_dependency("iterator", "integer", true);
        add_public_dependency("iterator", "move", true);
        add_public_dependency("iterator", "mpl", true);
        add_public_dependency("iterator", "optional", true);
        add_public_dependency("iterator", "predef", true);
        add_public_dependency("iterator", "preprocessor", true);
        add_public_dependency("iterator", "smart_ptr", true);
        add_public_dependency("iterator", "static_assert", true);
        add_public_dependency("iterator", "throw_exception", true);
        add_public_dependency("iterator", "tuple", true);
        add_public_dependency("iterator", "type_traits", true);
        add_public_dependency("iterator", "typeof", true);
        add_public_dependency("iterator", "utility", true);
        add_public_dependency("lambda", "assert", true);
        add_public_dependency("lambda", "bind", true);
        add_public_dependency("lambda", "concept_check", true);
        add_public_dependency("lambda", "config", true);
        add_public_dependency("lambda", "container_hash", true);
        add_public_dependency("lambda", "conversion", true);
        add_public_dependency("lambda", "core", true);
        add_public_dependency("lambda", "detail", true);
        add_public_dependency("lambda", "function_types", true);
        add_public_dependency("lambda", "fusion", true);
        add_public_dependency("lambda", "integer", true);
        add_public_dependency("lambda", "iterator", true);
        add_public_dependency("lambda", "move", true);
        add_public_dependency("lambda", "mpl", true);
        add_public_dependency("lambda", "optional", true);
        add_public_dependency("lambda", "predef", true);
        add_public_dependency("lambda", "preprocessor", true);
        add_public_dependency("lambda", "smart_ptr", true);
        add_public_dependency("lambda", "static_assert", true);
        add_public_dependency("lambda", "throw_exception", true);
        add_public_dependency("lambda", "tuple", true);
        add_public_dependency("lambda", "type_traits", true);
        add_public_dependency("lambda", "typeof", true);
        add_public_dependency("lambda", "utility", true);
        add_public_dependency("lexical_cast", "algorithm", true);
        add_public_dependency("lexical_cast", "array", true);
        add_public_dependency("lexical_cast", "assert", true);
        add_public_dependency("lexical_cast", "atomic", true);
        add_public_dependency("lexical_cast", "bind", true);
        add_public_dependency("lexical_cast", "concept_check", true);
        add_public_dependency("lexical_cast", "config", true);
        add_public_dependency("lexical_cast", "container", true);
        add_public_dependency("lexical_cast", "container_hash", true);
        add_public_dependency("lexical_cast", "conversion", true);
        add_public_dependency("lexical_cast", "core", true);
        add_public_dependency("lexical_cast", "detail", true);
        add_public_dependency("lexical_cast", "exception", true);
        add_public_dependency("lexical_cast", "function", true);
        add_public_dependency("lexical_cast", "function_types", true);
        add_public_dependency("lexical_cast", "fusion", true);
        add_public_dependency("lexical_cast", "integer", true);
        add_public_dependency("lexical_cast", "intrusive", true);
        add_public_dependency("lexical_cast", "iterator", true);
        add_public_dependency("lexical_cast", "lambda", true);
        add_public_dependency("lexical_cast", "math", true);
        add_public_dependency("lexical_cast", "move", true);
        add_public_dependency("lexical_cast", "mpl", true);
        add_public_dependency("lexical_cast", "numeric", true);
        add_public_dependency("lexical_cast", "optional", true);
        add_public_dependency("lexical_cast", "predef", true);
        add_public_dependency("lexical_cast", "preprocessor", true);
        add_public_dependency("lexical_cast", "range", true);
        add_public_dependency("lexical_cast", "regex", true);
        add_public_dependency("lexical_cast", "smart_ptr", true);
        add_public_dependency("lexical_cast", "static_assert", true);
        add_public_dependency("lexical_cast", "throw_exception", true);
        add_public_dependency("lexical_cast", "tuple", true);
        add_public_dependency("lexical_cast", "type_index", true);
        add_public_dependency("lexical_cast", "type_traits", true);
        add_public_dependency("lexical_cast", "typeof", true);
        add_public_dependency("lexical_cast", "unordered", true);
        add_public_dependency("lexical_cast", "utility", true);
        add_public_dependency("local_function", "assert", true);
        add_public_dependency("local_function", "bind", true);
        add_public_dependency("local_function", "config", true);
        add_public_dependency("local_function", "container_hash", true);
        add_public_dependency("local_function", "core", true);
        add_public_dependency("local_function", "detail", true);
        add_public_dependency("local_function", "function", true);
        add_public_dependency("local_function", "integer", true);
        add_public_dependency("local_function", "move", true);
        add_public_dependency("local_function", "mpl", true);
        add_public_dependency("local_function", "predef", true);
        add_public_dependency("local_function", "preprocessor", true);
        add_public_dependency("local_function", "scope_exit", true);
        add_public_dependency("local_function", "smart_ptr", true);
        add_public_dependency("local_function", "static_assert", true);
        add_public_dependency("local_function", "throw_exception", true);
        add_public_dependency("local_function", "type_index", true);
        add_public_dependency("local_function", "type_traits", true);
        add_public_dependency("local_function", "typeof", true);
        add_public_dependency("local_function", "utility", true);
        add_public_dependency("locale", "system", false);
        add_public_dependency("locale", "thread", false);
        add_public_dependency("locale", "algorithm", true);
        add_public_dependency("locale", "array", true);
        add_public_dependency("locale", "assert", true);
        add_public_dependency("locale", "atomic", true);
        add_public_dependency("locale", "bind", true);
        add_public_dependency("locale", "chrono", true);
        add_public_dependency("locale", "concept_check", true);
        add_public_dependency("locale", "config", true);
        add_public_dependency("locale", "container", true);
        add_public_dependency("locale", "container_hash", true);
        add_public_dependency("locale", "conversion", true);
        add_public_dependency("locale", "core", true);
        add_public_dependency("locale", "date_time", true);
        add_public_dependency("locale", "detail", true);
        add_public_dependency("locale", "dynamic_bitset", true);
        add_public_dependency("locale", "endian", true);
        add_public_dependency("locale", "exception", true);
        add_public_dependency("locale", "filesystem", true);
        add_public_dependency("locale", "foreach", true);
        add_public_dependency("locale", "function", true);
        add_public_dependency("locale", "function_types", true);
        add_public_dependency("locale", "fusion", true);
        add_public_dependency("locale", "integer", true);
        add_public_dependency("locale", "intrusive", true);
        add_public_dependency("locale", "io", true);
        add_public_dependency("locale", "iostreams", true);
        add_public_dependency("locale", "iterator", true);
        add_public_dependency("locale", "lambda", true);
        add_public_dependency("locale", "lexical_cast", true);
        add_public_dependency("locale", "math", true);
        add_public_dependency("locale", "move", true);
        add_public_dependency("locale", "mpl", true);
        add_public_dependency("locale", "multiprecision", true);
        add_public_dependency("locale", "numeric", true);
        add_public_dependency("locale", "optional", true);
        add_public_dependency("locale", "phoenix", true);
        add_public_dependency("locale", "pool", true);
        add_public_dependency("locale", "predef", true);
        add_public_dependency("locale", "preprocessor", true);
        add_public_dependency("locale", "proto", true);
        add_public_dependency("locale", "random", true);
        add_public_dependency("locale", "range", true);
        add_public_dependency("locale", "ratio", true);
        add_public_dependency("locale", "rational", true);
        add_public_dependency("locale", "regex", true);
        add_public_dependency("locale", "serialization", true);
        add_public_dependency("locale", "smart_ptr", true);
        add_public_dependency("locale", "spirit", true);
        add_public_dependency("locale", "static_assert", true);
        add_public_dependency("locale", "throw_exception", true);
        add_public_dependency("locale", "tokenizer", true);
        add_public_dependency("locale", "tti", true);
        add_public_dependency("locale", "tuple", true);
        add_public_dependency("locale", "type_index", true);
        add_public_dependency("locale", "type_traits", true);
        add_public_dependency("locale", "typeof", true);
        add_public_dependency("locale", "unordered", true);
        add_public_dependency("locale", "utility", true);
        add_public_dependency("locale", "variant", true);
        add_public_dependency("locale", "winapi", true);
        add_public_dependency("lockfree", "align", true);
        add_public_dependency("lockfree", "array", true);
        add_public_dependency("lockfree", "assert", true);
        add_public_dependency("lockfree", "atomic", true);
        add_public_dependency("lockfree", "concept_check", true);
        add_public_dependency("lockfree", "config", true);
        add_public_dependency("lockfree", "container_hash", true);
        add_public_dependency("lockfree", "conversion", true);
        add_public_dependency("lockfree", "core", true);
        add_public_dependency("lockfree", "detail", true);
        add_public_dependency("lockfree", "function_types", true);
        add_public_dependency("lockfree", "fusion", true);
        add_public_dependency("lockfree", "integer", true);
        add_public_dependency("lockfree", "iterator", true);
        add_public_dependency("lockfree", "move", true);
        add_public_dependency("lockfree", "mpl", true);
        add_public_dependency("lockfree", "optional", true);
        add_public_dependency("lockfree", "parameter", true);
        add_public_dependency("lockfree", "predef", true);
        add_public_dependency("lockfree", "preprocessor", true);
        add_public_dependency("lockfree", "smart_ptr", true);
        add_public_dependency("lockfree", "static_assert", true);
        add_public_dependency("lockfree", "throw_exception", true);
        add_public_dependency("lockfree", "tuple", true);
        add_public_dependency("lockfree", "type_traits", true);
        add_public_dependency("lockfree", "typeof", true);
        add_public_dependency("lockfree", "utility", true);
        add_public_dependency("log", "atomic", false);
        add_public_dependency("log", "date_time", false);
        add_public_dependency("log", "filesystem", false);
        add_public_dependency("log", "regex", false);
        add_public_dependency("log", "system", false);
        add_public_dependency("log", "thread", false);
        add_public_dependency("log", "algorithm", true);
        add_public_dependency("log", "align", true);
        add_public_dependency("log", "any", true);
        add_public_dependency("log", "array", true);
        add_public_dependency("log", "asio", true);
        add_public_dependency("log", "assert", true);
        add_public_dependency("log", "bind", true);
        add_public_dependency("log", "chrono", true);
        add_public_dependency("log", "concept_check", true);
        add_public_dependency("log", "config", true);
        add_public_dependency("log", "container", true);
        add_public_dependency("log", "container_hash", true);
        add_public_dependency("log", "context", true);
        add_public_dependency("log", "conversion", true);
        add_public_dependency("log", "core", true);
        add_public_dependency("log", "coroutine", true);
        add_public_dependency("log", "detail", true);
        add_public_dependency("log", "dynamic_bitset", true);
        add_public_dependency("log", "endian", true);
        add_public_dependency("log", "exception", true);
        add_public_dependency("log", "foreach", true);
        add_public_dependency("log", "format", true);
        add_public_dependency("log", "function", true);
        add_public_dependency("log", "function_types", true);
        add_public_dependency("log", "fusion", true);
        add_public_dependency("log", "integer", true);
        add_public_dependency("log", "interprocess", true);
        add_public_dependency("log", "intrusive", true);
        add_public_dependency("log", "io", true);
        add_public_dependency("log", "iostreams", true);
        add_public_dependency("log", "iterator", true);
        add_public_dependency("log", "lambda", true);
        add_public_dependency("log", "lexical_cast", true);
        add_public_dependency("log", "locale", true);
        add_public_dependency("log", "math", true);
        add_public_dependency("log", "move", true);
        add_public_dependency("log", "mpl", true);
        add_public_dependency("log", "multi_index", true);
        add_public_dependency("log", "multiprecision", true);
        add_public_dependency("log", "numeric", true);
        add_public_dependency("log", "optional", true);
        add_public_dependency("log", "parameter", true);
        add_public_dependency("log", "phoenix", true);
        add_public_dependency("log", "pool", true);
        add_public_dependency("log", "predef", true);
        add_public_dependency("log", "preprocessor", true);
        add_public_dependency("log", "property_tree", true);
        add_public_dependency("log", "proto", true);
        add_public_dependency("log", "random", true);
        add_public_dependency("log", "range", true);
        add_public_dependency("log", "ratio", true);
        add_public_dependency("log", "rational", true);
        add_public_dependency("log", "serialization", true);
        add_public_dependency("log", "smart_ptr", true);
        add_public_dependency("log", "spirit", true);
        add_public_dependency("log", "static_assert", true);
        add_public_dependency("log", "throw_exception", true);
        add_public_dependency("log", "tokenizer", true);
        add_public_dependency("log", "tti", true);
        add_public_dependency("log", "tuple", true);
        add_public_dependency("log", "type_index", true);
        add_public_dependency("log", "type_traits", true);
        add_public_dependency("log", "typeof", true);
        add_public_dependency("log", "unordered", true);
        add_public_dependency("log", "utility", true);
        add_public_dependency("log", "variant", true);
        add_public_dependency("log", "winapi", true);
        add_public_dependency("log", "xpressive", true);
        add_public_dependency("logic", "assert", true);
        add_public_dependency("logic", "config", true);
        add_public_dependency("logic", "core", true);
        add_public_dependency("math", "algorithm", true);
        add_public_dependency("math", "array", true);
        add_public_dependency("math", "assert", true);
        add_public_dependency("math", "atomic", true);
        add_public_dependency("math", "bind", true);
        add_public_dependency("math", "concept_check", true);
        add_public_dependency("math", "config", true);
        add_public_dependency("math", "container", true);
        add_public_dependency("math", "container_hash", true);
        add_public_dependency("math", "conversion", true);
        add_public_dependency("math", "core", true);
        add_public_dependency("math", "detail", true);
        add_public_dependency("math", "exception", true);
        add_public_dependency("math", "function", true);
        add_public_dependency("math", "function_types", true);
        add_public_dependency("math", "fusion", true);
        add_public_dependency("math", "integer", true);
        add_public_dependency("math", "intrusive", true);
        add_public_dependency("math", "iterator", true);
        add_public_dependency("math", "lambda", true);
        add_public_dependency("math", "lexical_cast", true);
        add_public_dependency("math", "move", true);
        add_public_dependency("math", "mpl", true);
        add_public_dependency("math", "numeric", true);
        add_public_dependency("math", "optional", true);
        add_public_dependency("math", "predef", true);
        add_public_dependency("math", "preprocessor", true);
        add_public_dependency("math", "range", true);
        add_public_dependency("math", "regex", true);
        add_public_dependency("math", "smart_ptr", true);
        add_public_dependency("math", "static_assert", true);
        add_public_dependency("math", "throw_exception", true);
        add_public_dependency("math", "tuple", true);
        add_public_dependency("math", "type_index", true);
        add_public_dependency("math", "type_traits", true);
        add_public_dependency("math", "typeof", true);
        add_public_dependency("math", "unordered", true);
        add_public_dependency("math", "utility", true);
        add_public_dependency("metaparse", "assert", true);
        add_public_dependency("metaparse", "config", true);
        add_public_dependency("metaparse", "container_hash", true);
        add_public_dependency("metaparse", "core", true);
        add_public_dependency("metaparse", "detail", true);
        add_public_dependency("metaparse", "integer", true);
        add_public_dependency("metaparse", "mpl", true);
        add_public_dependency("metaparse", "predef", true);
        add_public_dependency("metaparse", "preprocessor", true);
        add_public_dependency("metaparse", "static_assert", true);
        add_public_dependency("metaparse", "throw_exception", true);
        add_public_dependency("metaparse", "type_traits", true);
        add_public_dependency("metaparse", "utility", true);
        add_public_dependency("move", "assert", true);
        add_public_dependency("move", "config", true);
        add_public_dependency("move", "core", true);
        add_public_dependency("move", "static_assert", true);
        add_public_dependency("mpi", "python", false);
        add_public_dependency("mpi", "algorithm", true);
        add_public_dependency("mpi", "any", true);
        add_public_dependency("mpi", "array", true);
        add_public_dependency("mpi", "assert", true);
        add_public_dependency("mpi", "atomic", true);
        add_public_dependency("mpi", "bimap", true);
        add_public_dependency("mpi", "bind", true);
        add_public_dependency("mpi", "chrono", true);
        add_public_dependency("mpi", "concept_check", true);
        add_public_dependency("mpi", "config", true);
        add_public_dependency("mpi", "container", true);
        add_public_dependency("mpi", "container_hash", true);
        add_public_dependency("mpi", "conversion", true);
        add_public_dependency("mpi", "core", true);
        add_public_dependency("mpi", "date_time", true);
        add_public_dependency("mpi", "detail", true);
        add_public_dependency("mpi", "disjoint_sets", true);
        add_public_dependency("mpi", "dynamic_bitset", true);
        add_public_dependency("mpi", "endian", true);
        add_public_dependency("mpi", "exception", true);
        add_public_dependency("mpi", "filesystem", true);
        add_public_dependency("mpi", "foreach", true);
        add_public_dependency("mpi", "format", true);
        add_public_dependency("mpi", "function", true);
        add_public_dependency("mpi", "function_types", true);
        add_public_dependency("mpi", "fusion", true);
        add_public_dependency("mpi", "graph", true);
        add_public_dependency("mpi", "graph_parallel", true);
        add_public_dependency("mpi", "integer", true);
        add_public_dependency("mpi", "intrusive", true);
        add_public_dependency("mpi", "io", true);
        add_public_dependency("mpi", "iostreams", true);
        add_public_dependency("mpi", "iterator", true);
        add_public_dependency("mpi", "lambda", true);
        add_public_dependency("mpi", "lexical_cast", true);
        add_public_dependency("mpi", "locale", true);
        add_public_dependency("mpi", "math", true);
        add_public_dependency("mpi", "move", true);
        add_public_dependency("mpi", "mpl", true);
        add_public_dependency("mpi", "multi_index", true);
        add_public_dependency("mpi", "multiprecision", true);
        add_public_dependency("mpi", "numeric", true);
        add_public_dependency("mpi", "optional", true);
        add_public_dependency("mpi", "parameter", true);
        add_public_dependency("mpi", "phoenix", true);
        add_public_dependency("mpi", "pool", true);
        add_public_dependency("mpi", "predef", true);
        add_public_dependency("mpi", "preprocessor", true);
        add_public_dependency("mpi", "property_map", true);
        add_public_dependency("mpi", "property_tree", true);
        add_public_dependency("mpi", "proto", true);
        add_public_dependency("mpi", "random", true);
        add_public_dependency("mpi", "range", true);
        add_public_dependency("mpi", "ratio", true);
        add_public_dependency("mpi", "rational", true);
        add_public_dependency("mpi", "regex", true);
        add_public_dependency("mpi", "serialization", true);
        add_public_dependency("mpi", "smart_ptr", true);
        add_public_dependency("mpi", "spirit", true);
        add_public_dependency("mpi", "static_assert", true);
        add_public_dependency("mpi", "system", true);
        add_public_dependency("mpi", "test", true);
        add_public_dependency("mpi", "thread", true);
        add_public_dependency("mpi", "throw_exception", true);
        add_public_dependency("mpi", "timer", true);
        add_public_dependency("mpi", "tokenizer", true);
        add_public_dependency("mpi", "tti", true);
        add_public_dependency("mpi", "tuple", true);
        add_public_dependency("mpi", "type_index", true);
        add_public_dependency("mpi", "type_traits", true);
        add_public_dependency("mpi", "typeof", true);
        add_public_dependency("mpi", "unordered", true);
        add_public_dependency("mpi", "utility", true);
        add_public_dependency("mpi", "variant", true);
        add_public_dependency("mpi", "winapi", true);
        add_public_dependency("mpi", "xpressive", true);
        add_public_dependency("mpl", "assert", true);
        add_public_dependency("mpl", "config", true);
        add_public_dependency("mpl", "container_hash", true);
        add_public_dependency("mpl", "core", true);
        add_public_dependency("mpl", "detail", true);
        add_public_dependency("mpl", "integer", true);
        add_public_dependency("mpl", "predef", true);
        add_public_dependency("mpl", "preprocessor", true);
        add_public_dependency("mpl", "static_assert", true);
        add_public_dependency("mpl", "throw_exception", true);
        add_public_dependency("mpl", "type_traits", true);
        add_public_dependency("mpl", "utility", true);
        add_public_dependency("msm", "algorithm", true);
        add_public_dependency("msm", "any", true);
        add_public_dependency("msm", "array", true);
        add_public_dependency("msm", "assert", true);
        add_public_dependency("msm", "atomic", true);
        add_public_dependency("msm", "bind", true);
        add_public_dependency("msm", "chrono", true);
        add_public_dependency("msm", "circular_buffer", true);
        add_public_dependency("msm", "concept_check", true);
        add_public_dependency("msm", "config", true);
        add_public_dependency("msm", "container", true);
        add_public_dependency("msm", "container_hash", true);
        add_public_dependency("msm", "conversion", true);
        add_public_dependency("msm", "core", true);
        add_public_dependency("msm", "date_time", true);
        add_public_dependency("msm", "detail", true);
        add_public_dependency("msm", "dynamic_bitset", true);
        add_public_dependency("msm", "endian", true);
        add_public_dependency("msm", "exception", true);
        add_public_dependency("msm", "filesystem", true);
        add_public_dependency("msm", "foreach", true);
        add_public_dependency("msm", "function", true);
        add_public_dependency("msm", "function_types", true);
        add_public_dependency("msm", "fusion", true);
        add_public_dependency("msm", "integer", true);
        add_public_dependency("msm", "intrusive", true);
        add_public_dependency("msm", "io", true);
        add_public_dependency("msm", "iostreams", true);
        add_public_dependency("msm", "iterator", true);
        add_public_dependency("msm", "lambda", true);
        add_public_dependency("msm", "lexical_cast", true);
        add_public_dependency("msm", "locale", true);
        add_public_dependency("msm", "math", true);
        add_public_dependency("msm", "move", true);
        add_public_dependency("msm", "mpl", true);
        add_public_dependency("msm", "multiprecision", true);
        add_public_dependency("msm", "numeric", true);
        add_public_dependency("msm", "optional", true);
        add_public_dependency("msm", "parameter", true);
        add_public_dependency("msm", "phoenix", true);
        add_public_dependency("msm", "pool", true);
        add_public_dependency("msm", "predef", true);
        add_public_dependency("msm", "preprocessor", true);
        add_public_dependency("msm", "proto", true);
        add_public_dependency("msm", "random", true);
        add_public_dependency("msm", "range", true);
        add_public_dependency("msm", "ratio", true);
        add_public_dependency("msm", "rational", true);
        add_public_dependency("msm", "regex", true);
        add_public_dependency("msm", "serialization", true);
        add_public_dependency("msm", "smart_ptr", true);
        add_public_dependency("msm", "spirit", true);
        add_public_dependency("msm", "static_assert", true);
        add_public_dependency("msm", "system", true);
        add_public_dependency("msm", "thread", true);
        add_public_dependency("msm", "throw_exception", true);
        add_public_dependency("msm", "tokenizer", true);
        add_public_dependency("msm", "tti", true);
        add_public_dependency("msm", "tuple", true);
        add_public_dependency("msm", "type_index", true);
        add_public_dependency("msm", "type_traits", true);
        add_public_dependency("msm", "typeof", true);
        add_public_dependency("msm", "unordered", true);
        add_public_dependency("msm", "utility", true);
        add_public_dependency("msm", "variant", true);
        add_public_dependency("msm", "winapi", true);
        add_public_dependency("multi_array", "array", true);
        add_public_dependency("multi_array", "assert", true);
        add_public_dependency("multi_array", "bind", true);
        add_public_dependency("multi_array", "concept_check", true);
        add_public_dependency("multi_array", "config", true);
        add_public_dependency("multi_array", "container_hash", true);
        add_public_dependency("multi_array", "conversion", true);
        add_public_dependency("multi_array", "core", true);
        add_public_dependency("multi_array", "detail", true);
        add_public_dependency("multi_array", "function", true);
        add_public_dependency("multi_array", "function_types", true);
        add_public_dependency("multi_array", "functional", true);
        add_public_dependency("multi_array", "fusion", true);
        add_public_dependency("multi_array", "integer", true);
        add_public_dependency("multi_array", "iterator", true);
        add_public_dependency("multi_array", "move", true);
        add_public_dependency("multi_array", "mpl", true);
        add_public_dependency("multi_array", "optional", true);
        add_public_dependency("multi_array", "predef", true);
        add_public_dependency("multi_array", "preprocessor", true);
        add_public_dependency("multi_array", "smart_ptr", true);
        add_public_dependency("multi_array", "static_assert", true);
        add_public_dependency("multi_array", "throw_exception", true);
        add_public_dependency("multi_array", "tuple", true);
        add_public_dependency("multi_array", "type_index", true);
        add_public_dependency("multi_array", "type_traits", true);
        add_public_dependency("multi_array", "typeof", true);
        add_public_dependency("multi_array", "utility", true);
        add_public_dependency("multi_index", "algorithm", true);
        add_public_dependency("multi_index", "array", true);
        add_public_dependency("multi_index", "assert", true);
        add_public_dependency("multi_index", "atomic", true);
        add_public_dependency("multi_index", "bind", true);
        add_public_dependency("multi_index", "chrono", true);
        add_public_dependency("multi_index", "concept_check", true);
        add_public_dependency("multi_index", "config", true);
        add_public_dependency("multi_index", "container", true);
        add_public_dependency("multi_index", "container_hash", true);
        add_public_dependency("multi_index", "conversion", true);
        add_public_dependency("multi_index", "core", true);
        add_public_dependency("multi_index", "date_time", true);
        add_public_dependency("multi_index", "detail", true);
        add_public_dependency("multi_index", "dynamic_bitset", true);
        add_public_dependency("multi_index", "endian", true);
        add_public_dependency("multi_index", "exception", true);
        add_public_dependency("multi_index", "filesystem", true);
        add_public_dependency("multi_index", "foreach", true);
        add_public_dependency("multi_index", "function", true);
        add_public_dependency("multi_index", "function_types", true);
        add_public_dependency("multi_index", "fusion", true);
        add_public_dependency("multi_index", "integer", true);
        add_public_dependency("multi_index", "intrusive", true);
        add_public_dependency("multi_index", "io", true);
        add_public_dependency("multi_index", "iostreams", true);
        add_public_dependency("multi_index", "iterator", true);
        add_public_dependency("multi_index", "lambda", true);
        add_public_dependency("multi_index", "lexical_cast", true);
        add_public_dependency("multi_index", "locale", true);
        add_public_dependency("multi_index", "math", true);
        add_public_dependency("multi_index", "move", true);
        add_public_dependency("multi_index", "mpl", true);
        add_public_dependency("multi_index", "multiprecision", true);
        add_public_dependency("multi_index", "numeric", true);
        add_public_dependency("multi_index", "optional", true);
        add_public_dependency("multi_index", "phoenix", true);
        add_public_dependency("multi_index", "pool", true);
        add_public_dependency("multi_index", "predef", true);
        add_public_dependency("multi_index", "preprocessor", true);
        add_public_dependency("multi_index", "proto", true);
        add_public_dependency("multi_index", "random", true);
        add_public_dependency("multi_index", "range", true);
        add_public_dependency("multi_index", "ratio", true);
        add_public_dependency("multi_index", "rational", true);
        add_public_dependency("multi_index", "regex", true);
        add_public_dependency("multi_index", "serialization", true);
        add_public_dependency("multi_index", "smart_ptr", true);
        add_public_dependency("multi_index", "spirit", true);
        add_public_dependency("multi_index", "static_assert", true);
        add_public_dependency("multi_index", "system", true);
        add_public_dependency("multi_index", "thread", true);
        add_public_dependency("multi_index", "throw_exception", true);
        add_public_dependency("multi_index", "tokenizer", true);
        add_public_dependency("multi_index", "tti", true);
        add_public_dependency("multi_index", "tuple", true);
        add_public_dependency("multi_index", "type_index", true);
        add_public_dependency("multi_index", "type_traits", true);
        add_public_dependency("multi_index", "typeof", true);
        add_public_dependency("multi_index", "unordered", true);
        add_public_dependency("multi_index", "utility", true);
        add_public_dependency("multi_index", "variant", true);
        add_public_dependency("multi_index", "winapi", true);
        add_public_dependency("multiprecision", "algorithm", true);
        add_public_dependency("multiprecision", "array", true);
        add_public_dependency("multiprecision", "assert", true);
        add_public_dependency("multiprecision", "atomic", true);
        add_public_dependency("multiprecision", "bind", true);
        add_public_dependency("multiprecision", "chrono", true);
        add_public_dependency("multiprecision", "concept_check", true);
        add_public_dependency("multiprecision", "config", true);
        add_public_dependency("multiprecision", "container", true);
        add_public_dependency("multiprecision", "container_hash", true);
        add_public_dependency("multiprecision", "conversion", true);
        add_public_dependency("multiprecision", "core", true);
        add_public_dependency("multiprecision", "date_time", true);
        add_public_dependency("multiprecision", "detail", true);
        add_public_dependency("multiprecision", "dynamic_bitset", true);
        add_public_dependency("multiprecision", "endian", true);
        add_public_dependency("multiprecision", "exception", true);
        add_public_dependency("multiprecision", "filesystem", true);
        add_public_dependency("multiprecision", "foreach", true);
        add_public_dependency("multiprecision", "function", true);
        add_public_dependency("multiprecision", "function_types", true);
        add_public_dependency("multiprecision", "fusion", true);
        add_public_dependency("multiprecision", "integer", true);
        add_public_dependency("multiprecision", "intrusive", true);
        add_public_dependency("multiprecision", "io", true);
        add_public_dependency("multiprecision", "iostreams", true);
        add_public_dependency("multiprecision", "iterator", true);
        add_public_dependency("multiprecision", "lambda", true);
        add_public_dependency("multiprecision", "lexical_cast", true);
        add_public_dependency("multiprecision", "locale", true);
        add_public_dependency("multiprecision", "math", true);
        add_public_dependency("multiprecision", "move", true);
        add_public_dependency("multiprecision", "mpl", true);
        add_public_dependency("multiprecision", "numeric", true);
        add_public_dependency("multiprecision", "optional", true);
        add_public_dependency("multiprecision", "phoenix", true);
        add_public_dependency("multiprecision", "pool", true);
        add_public_dependency("multiprecision", "predef", true);
        add_public_dependency("multiprecision", "preprocessor", true);
        add_public_dependency("multiprecision", "proto", true);
        add_public_dependency("multiprecision", "random", true);
        add_public_dependency("multiprecision", "range", true);
        add_public_dependency("multiprecision", "ratio", true);
        add_public_dependency("multiprecision", "rational", true);
        add_public_dependency("multiprecision", "regex", true);
        add_public_dependency("multiprecision", "serialization", true);
        add_public_dependency("multiprecision", "smart_ptr", true);
        add_public_dependency("multiprecision", "spirit", true);
        add_public_dependency("multiprecision", "static_assert", true);
        add_public_dependency("multiprecision", "system", true);
        add_public_dependency("multiprecision", "thread", true);
        add_public_dependency("multiprecision", "throw_exception", true);
        add_public_dependency("multiprecision", "tokenizer", true);
        add_public_dependency("multiprecision", "tti", true);
        add_public_dependency("multiprecision", "tuple", true);
        add_public_dependency("multiprecision", "type_index", true);
        add_public_dependency("multiprecision", "type_traits", true);
        add_public_dependency("multiprecision", "typeof", true);
        add_public_dependency("multiprecision", "unordered", true);
        add_public_dependency("multiprecision", "utility", true);
        add_public_dependency("multiprecision", "variant", true);
        add_public_dependency("multiprecision", "winapi", true);
        add_public_dependency("numeric", "assert", true);
        add_public_dependency("numeric", "config", true);
        add_public_dependency("numeric", "container_hash", true);
        add_public_dependency("numeric", "conversion", true);
        add_public_dependency("numeric", "core", true);
        add_public_dependency("numeric", "detail", true);
        add_public_dependency("numeric", "integer", true);
        add_public_dependency("numeric", "move", true);
        add_public_dependency("numeric", "mpl", true);
        add_public_dependency("numeric", "predef", true);
        add_public_dependency("numeric", "preprocessor", true);
        add_public_dependency("numeric", "smart_ptr", true);
        add_public_dependency("numeric", "static_assert", true);
        add_public_dependency("numeric", "throw_exception", true);
        add_public_dependency("numeric", "type_traits", true);
        add_public_dependency("numeric", "typeof", true);
        add_public_dependency("numeric", "utility", true);
        add_public_dependency("interval", "assert", true);
        add_public_dependency("interval", "config", true);
        add_public_dependency("interval", "core", true);
        add_public_dependency("interval", "detail", true);
        add_public_dependency("interval", "logic", true);
        add_public_dependency("interval", "preprocessor", true);
        add_public_dependency("interval", "static_assert", true);
        add_public_dependency("interval", "type_traits", true);
        add_public_dependency("odeint", "algorithm", true);
        add_public_dependency("odeint", "any", true);
        add_public_dependency("odeint", "array", true);
        add_public_dependency("odeint", "assert", true);
        add_public_dependency("odeint", "atomic", true);
        add_public_dependency("odeint", "bimap", true);
        add_public_dependency("odeint", "bind", true);
        add_public_dependency("odeint", "chrono", true);
        add_public_dependency("odeint", "compute", true);
        add_public_dependency("odeint", "concept_check", true);
        add_public_dependency("odeint", "config", true);
        add_public_dependency("odeint", "container", true);
        add_public_dependency("odeint", "container_hash", true);
        add_public_dependency("odeint", "conversion", true);
        add_public_dependency("odeint", "core", true);
        add_public_dependency("odeint", "date_time", true);
        add_public_dependency("odeint", "detail", true);
        add_public_dependency("odeint", "disjoint_sets", true);
        add_public_dependency("odeint", "dynamic_bitset", true);
        add_public_dependency("odeint", "endian", true);
        add_public_dependency("odeint", "exception", true);
        add_public_dependency("odeint", "filesystem", true);
        add_public_dependency("odeint", "foreach", true);
        add_public_dependency("odeint", "format", true);
        add_public_dependency("odeint", "function", true);
        add_public_dependency("odeint", "function_types", true);
        add_public_dependency("odeint", "functional", true);
        add_public_dependency("odeint", "fusion", true);
        add_public_dependency("odeint", "graph", true);
        add_public_dependency("odeint", "graph_parallel", true);
        add_public_dependency("odeint", "integer", true);
        add_public_dependency("odeint", "interval", true);
        add_public_dependency("odeint", "intrusive", true);
        add_public_dependency("odeint", "io", true);
        add_public_dependency("odeint", "iostreams", true);
        add_public_dependency("odeint", "iterator", true);
        add_public_dependency("odeint", "lambda", true);
        add_public_dependency("odeint", "lexical_cast", true);
        add_public_dependency("odeint", "locale", true);
        add_public_dependency("odeint", "logic", true);
        add_public_dependency("odeint", "math", true);
        add_public_dependency("odeint", "move", true);
        add_public_dependency("odeint", "mpi", true);
        add_public_dependency("odeint", "mpl", true);
        add_public_dependency("odeint", "multi_array", true);
        add_public_dependency("odeint", "multi_index", true);
        add_public_dependency("odeint", "multiprecision", true);
        add_public_dependency("odeint", "numeric", true);
        add_public_dependency("odeint", "optional", true);
        add_public_dependency("odeint", "parameter", true);
        add_public_dependency("odeint", "phoenix", true);
        add_public_dependency("odeint", "pool", true);
        add_public_dependency("odeint", "predef", true);
        add_public_dependency("odeint", "preprocessor", true);
        add_public_dependency("odeint", "property_map", true);
        add_public_dependency("odeint", "property_tree", true);
        add_public_dependency("odeint", "proto", true);
        add_public_dependency("odeint", "python", true);
        add_public_dependency("odeint", "random", true);
        add_public_dependency("odeint", "range", true);
        add_public_dependency("odeint", "ratio", true);
        add_public_dependency("odeint", "rational", true);
        add_public_dependency("odeint", "regex", true);
        add_public_dependency("odeint", "serialization", true);
        add_public_dependency("odeint", "smart_ptr", true);
        add_public_dependency("odeint", "spirit", true);
        add_public_dependency("odeint", "static_assert", true);
        add_public_dependency("odeint", "system", true);
        add_public_dependency("odeint", "test", true);
        add_public_dependency("odeint", "thread", true);
        add_public_dependency("odeint", "throw_exception", true);
        add_public_dependency("odeint", "timer", true);
        add_public_dependency("odeint", "tokenizer", true);
        add_public_dependency("odeint", "tti", true);
        add_public_dependency("odeint", "tuple", true);
        add_public_dependency("odeint", "type_index", true);
        add_public_dependency("odeint", "type_traits", true);
        add_public_dependency("odeint", "typeof", true);
        add_public_dependency("odeint", "ublas", true);
        add_public_dependency("odeint", "units", true);
        add_public_dependency("odeint", "unordered", true);
        add_public_dependency("odeint", "utility", true);
        add_public_dependency("odeint", "uuid", true);
        add_public_dependency("odeint", "variant", true);
        add_public_dependency("odeint", "winapi", true);
        add_public_dependency("odeint", "xpressive", true);
        add_public_dependency("ublas", "algorithm", true);
        add_public_dependency("ublas", "array", true);
        add_public_dependency("ublas", "assert", true);
        add_public_dependency("ublas", "atomic", true);
        add_public_dependency("ublas", "bind", true);
        add_public_dependency("ublas", "chrono", true);
        add_public_dependency("ublas", "concept_check", true);
        add_public_dependency("ublas", "config", true);
        add_public_dependency("ublas", "container", true);
        add_public_dependency("ublas", "container_hash", true);
        add_public_dependency("ublas", "conversion", true);
        add_public_dependency("ublas", "core", true);
        add_public_dependency("ublas", "date_time", true);
        add_public_dependency("ublas", "detail", true);
        add_public_dependency("ublas", "dynamic_bitset", true);
        add_public_dependency("ublas", "endian", true);
        add_public_dependency("ublas", "exception", true);
        add_public_dependency("ublas", "filesystem", true);
        add_public_dependency("ublas", "foreach", true);
        add_public_dependency("ublas", "function", true);
        add_public_dependency("ublas", "function_types", true);
        add_public_dependency("ublas", "fusion", true);
        add_public_dependency("ublas", "integer", true);
        add_public_dependency("ublas", "interval", true);
        add_public_dependency("ublas", "intrusive", true);
        add_public_dependency("ublas", "io", true);
        add_public_dependency("ublas", "iostreams", true);
        add_public_dependency("ublas", "iterator", true);
        add_public_dependency("ublas", "lambda", true);
        add_public_dependency("ublas", "lexical_cast", true);
        add_public_dependency("ublas", "locale", true);
        add_public_dependency("ublas", "logic", true);
        add_public_dependency("ublas", "math", true);
        add_public_dependency("ublas", "move", true);
        add_public_dependency("ublas", "mpl", true);
        add_public_dependency("ublas", "multiprecision", true);
        add_public_dependency("ublas", "numeric", true);
        add_public_dependency("ublas", "optional", true);
        add_public_dependency("ublas", "phoenix", true);
        add_public_dependency("ublas", "pool", true);
        add_public_dependency("ublas", "predef", true);
        add_public_dependency("ublas", "preprocessor", true);
        add_public_dependency("ublas", "proto", true);
        add_public_dependency("ublas", "random", true);
        add_public_dependency("ublas", "range", true);
        add_public_dependency("ublas", "ratio", true);
        add_public_dependency("ublas", "rational", true);
        add_public_dependency("ublas", "regex", true);
        add_public_dependency("ublas", "serialization", true);
        add_public_dependency("ublas", "smart_ptr", true);
        add_public_dependency("ublas", "spirit", true);
        add_public_dependency("ublas", "static_assert", true);
        add_public_dependency("ublas", "system", true);
        add_public_dependency("ublas", "thread", true);
        add_public_dependency("ublas", "throw_exception", true);
        add_public_dependency("ublas", "tokenizer", true);
        add_public_dependency("ublas", "tti", true);
        add_public_dependency("ublas", "tuple", true);
        add_public_dependency("ublas", "type_index", true);
        add_public_dependency("ublas", "type_traits", true);
        add_public_dependency("ublas", "typeof", true);
        add_public_dependency("ublas", "unordered", true);
        add_public_dependency("ublas", "utility", true);
        add_public_dependency("ublas", "variant", true);
        add_public_dependency("ublas", "winapi", true);
        add_public_dependency("optional", "assert", true);
        add_public_dependency("optional", "config", true);
        add_public_dependency("optional", "container_hash", true);
        add_public_dependency("optional", "core", true);
        add_public_dependency("optional", "detail", true);
        add_public_dependency("optional", "integer", true);
        add_public_dependency("optional", "move", true);
        add_public_dependency("optional", "predef", true);
        add_public_dependency("optional", "preprocessor", true);
        add_public_dependency("optional", "static_assert", true);
        add_public_dependency("optional", "throw_exception", true);
        add_public_dependency("optional", "type_traits", true);
        add_public_dependency("optional", "utility", true);
        add_public_dependency("parameter", "assert", true);
        add_public_dependency("parameter", "config", true);
        add_public_dependency("parameter", "container_hash", true);
        add_public_dependency("parameter", "core", true);
        add_public_dependency("parameter", "detail", true);
        add_public_dependency("parameter", "integer", true);
        add_public_dependency("parameter", "move", true);
        add_public_dependency("parameter", "mpl", true);
        add_public_dependency("parameter", "optional", true);
        add_public_dependency("parameter", "predef", true);
        add_public_dependency("parameter", "preprocessor", true);
        add_public_dependency("parameter", "static_assert", true);
        add_public_dependency("parameter", "throw_exception", true);
        add_public_dependency("parameter", "type_traits", true);
        add_public_dependency("parameter", "utility", true);
        add_public_dependency("parameter_python", "algorithm", true);
        add_public_dependency("parameter_python", "any", true);
        add_public_dependency("parameter_python", "array", true);
        add_public_dependency("parameter_python", "assert", true);
        add_public_dependency("parameter_python", "atomic", true);
        add_public_dependency("parameter_python", "bimap", true);
        add_public_dependency("parameter_python", "bind", true);
        add_public_dependency("parameter_python", "chrono", true);
        add_public_dependency("parameter_python", "concept_check", true);
        add_public_dependency("parameter_python", "config", true);
        add_public_dependency("parameter_python", "container", true);
        add_public_dependency("parameter_python", "container_hash", true);
        add_public_dependency("parameter_python", "conversion", true);
        add_public_dependency("parameter_python", "core", true);
        add_public_dependency("parameter_python", "date_time", true);
        add_public_dependency("parameter_python", "detail", true);
        add_public_dependency("parameter_python", "disjoint_sets", true);
        add_public_dependency("parameter_python", "dynamic_bitset", true);
        add_public_dependency("parameter_python", "endian", true);
        add_public_dependency("parameter_python", "exception", true);
        add_public_dependency("parameter_python", "filesystem", true);
        add_public_dependency("parameter_python", "foreach", true);
        add_public_dependency("parameter_python", "format", true);
        add_public_dependency("parameter_python", "function", true);
        add_public_dependency("parameter_python", "function_types", true);
        add_public_dependency("parameter_python", "fusion", true);
        add_public_dependency("parameter_python", "graph", true);
        add_public_dependency("parameter_python", "graph_parallel", true);
        add_public_dependency("parameter_python", "integer", true);
        add_public_dependency("parameter_python", "intrusive", true);
        add_public_dependency("parameter_python", "io", true);
        add_public_dependency("parameter_python", "iostreams", true);
        add_public_dependency("parameter_python", "iterator", true);
        add_public_dependency("parameter_python", "lambda", true);
        add_public_dependency("parameter_python", "lexical_cast", true);
        add_public_dependency("parameter_python", "locale", true);
        add_public_dependency("parameter_python", "math", true);
        add_public_dependency("parameter_python", "move", true);
        add_public_dependency("parameter_python", "mpi", true);
        add_public_dependency("parameter_python", "mpl", true);
        add_public_dependency("parameter_python", "multi_index", true);
        add_public_dependency("parameter_python", "multiprecision", true);
        add_public_dependency("parameter_python", "numeric", true);
        add_public_dependency("parameter_python", "optional", true);
        add_public_dependency("parameter_python", "parameter", true);
        add_public_dependency("parameter_python", "phoenix", true);
        add_public_dependency("parameter_python", "pool", true);
        add_public_dependency("parameter_python", "predef", true);
        add_public_dependency("parameter_python", "preprocessor", true);
        add_public_dependency("parameter_python", "property_map", true);
        add_public_dependency("parameter_python", "property_tree", true);
        add_public_dependency("parameter_python", "proto", true);
        add_public_dependency("parameter_python", "python", true);
        add_public_dependency("parameter_python", "random", true);
        add_public_dependency("parameter_python", "range", true);
        add_public_dependency("parameter_python", "ratio", true);
        add_public_dependency("parameter_python", "rational", true);
        add_public_dependency("parameter_python", "regex", true);
        add_public_dependency("parameter_python", "serialization", true);
        add_public_dependency("parameter_python", "smart_ptr", true);
        add_public_dependency("parameter_python", "spirit", true);
        add_public_dependency("parameter_python", "static_assert", true);
        add_public_dependency("parameter_python", "system", true);
        add_public_dependency("parameter_python", "test", true);
        add_public_dependency("parameter_python", "thread", true);
        add_public_dependency("parameter_python", "throw_exception", true);
        add_public_dependency("parameter_python", "timer", true);
        add_public_dependency("parameter_python", "tokenizer", true);
        add_public_dependency("parameter_python", "tti", true);
        add_public_dependency("parameter_python", "tuple", true);
        add_public_dependency("parameter_python", "type_index", true);
        add_public_dependency("parameter_python", "type_traits", true);
        add_public_dependency("parameter_python", "typeof", true);
        add_public_dependency("parameter_python", "unordered", true);
        add_public_dependency("parameter_python", "utility", true);
        add_public_dependency("parameter_python", "variant", true);
        add_public_dependency("parameter_python", "winapi", true);
        add_public_dependency("parameter_python", "xpressive", true);
        add_public_dependency("phoenix", "algorithm", true);
        add_public_dependency("phoenix", "array", true);
        add_public_dependency("phoenix", "assert", true);
        add_public_dependency("phoenix", "bind", true);
        add_public_dependency("phoenix", "concept_check", true);
        add_public_dependency("phoenix", "config", true);
        add_public_dependency("phoenix", "container", true);
        add_public_dependency("phoenix", "container_hash", true);
        add_public_dependency("phoenix", "conversion", true);
        add_public_dependency("phoenix", "core", true);
        add_public_dependency("phoenix", "detail", true);
        add_public_dependency("phoenix", "exception", true);
        add_public_dependency("phoenix", "function", true);
        add_public_dependency("phoenix", "function_types", true);
        add_public_dependency("phoenix", "fusion", true);
        add_public_dependency("phoenix", "integer", true);
        add_public_dependency("phoenix", "intrusive", true);
        add_public_dependency("phoenix", "iterator", true);
        add_public_dependency("phoenix", "move", true);
        add_public_dependency("phoenix", "mpl", true);
        add_public_dependency("phoenix", "numeric", true);
        add_public_dependency("phoenix", "optional", true);
        add_public_dependency("phoenix", "predef", true);
        add_public_dependency("phoenix", "preprocessor", true);
        add_public_dependency("phoenix", "proto", true);
        add_public_dependency("phoenix", "range", true);
        add_public_dependency("phoenix", "regex", true);
        add_public_dependency("phoenix", "smart_ptr", true);
        add_public_dependency("phoenix", "static_assert", true);
        add_public_dependency("phoenix", "throw_exception", true);
        add_public_dependency("phoenix", "tuple", true);
        add_public_dependency("phoenix", "type_index", true);
        add_public_dependency("phoenix", "type_traits", true);
        add_public_dependency("phoenix", "typeof", true);
        add_public_dependency("phoenix", "unordered", true);
        add_public_dependency("phoenix", "utility", true);
        add_public_dependency("poly_collection", "algorithm", true);
        add_public_dependency("poly_collection", "array", true);
        add_public_dependency("poly_collection", "assert", true);
        add_public_dependency("poly_collection", "atomic", true);
        add_public_dependency("poly_collection", "bind", true);
        add_public_dependency("poly_collection", "chrono", true);
        add_public_dependency("poly_collection", "concept_check", true);
        add_public_dependency("poly_collection", "config", true);
        add_public_dependency("poly_collection", "container", true);
        add_public_dependency("poly_collection", "container_hash", true);
        add_public_dependency("poly_collection", "conversion", true);
        add_public_dependency("poly_collection", "core", true);
        add_public_dependency("poly_collection", "date_time", true);
        add_public_dependency("poly_collection", "detail", true);
        add_public_dependency("poly_collection", "dynamic_bitset", true);
        add_public_dependency("poly_collection", "endian", true);
        add_public_dependency("poly_collection", "exception", true);
        add_public_dependency("poly_collection", "filesystem", true);
        add_public_dependency("poly_collection", "foreach", true);
        add_public_dependency("poly_collection", "function", true);
        add_public_dependency("poly_collection", "function_types", true);
        add_public_dependency("poly_collection", "fusion", true);
        add_public_dependency("poly_collection", "integer", true);
        add_public_dependency("poly_collection", "intrusive", true);
        add_public_dependency("poly_collection", "io", true);
        add_public_dependency("poly_collection", "iostreams", true);
        add_public_dependency("poly_collection", "iterator", true);
        add_public_dependency("poly_collection", "lambda", true);
        add_public_dependency("poly_collection", "lexical_cast", true);
        add_public_dependency("poly_collection", "locale", true);
        add_public_dependency("poly_collection", "math", true);
        add_public_dependency("poly_collection", "move", true);
        add_public_dependency("poly_collection", "mp11", true);
        add_public_dependency("poly_collection", "mpl", true);
        add_public_dependency("poly_collection", "multiprecision", true);
        add_public_dependency("poly_collection", "numeric", true);
        add_public_dependency("poly_collection", "optional", true);
        add_public_dependency("poly_collection", "phoenix", true);
        add_public_dependency("poly_collection", "pool", true);
        add_public_dependency("poly_collection", "predef", true);
        add_public_dependency("poly_collection", "preprocessor", true);
        add_public_dependency("poly_collection", "proto", true);
        add_public_dependency("poly_collection", "random", true);
        add_public_dependency("poly_collection", "range", true);
        add_public_dependency("poly_collection", "ratio", true);
        add_public_dependency("poly_collection", "rational", true);
        add_public_dependency("poly_collection", "regex", true);
        add_public_dependency("poly_collection", "serialization", true);
        add_public_dependency("poly_collection", "smart_ptr", true);
        add_public_dependency("poly_collection", "spirit", true);
        add_public_dependency("poly_collection", "static_assert", true);
        add_public_dependency("poly_collection", "system", true);
        add_public_dependency("poly_collection", "thread", true);
        add_public_dependency("poly_collection", "throw_exception", true);
        add_public_dependency("poly_collection", "tokenizer", true);
        add_public_dependency("poly_collection", "tti", true);
        add_public_dependency("poly_collection", "tuple", true);
        add_public_dependency("poly_collection", "type_erasure", true);
        add_public_dependency("poly_collection", "type_index", true);
        add_public_dependency("poly_collection", "type_traits", true);
        add_public_dependency("poly_collection", "typeof", true);
        add_public_dependency("poly_collection", "unordered", true);
        add_public_dependency("poly_collection", "utility", true);
        add_public_dependency("poly_collection", "variant", true);
        add_public_dependency("poly_collection", "vmd", true);
        add_public_dependency("poly_collection", "winapi", true);
        add_public_dependency("polygon", "config", true);
        add_public_dependency("pool", "assert", true);
        add_public_dependency("pool", "config", true);
        add_public_dependency("pool", "core", true);
        add_public_dependency("pool", "integer", true);
        add_public_dependency("pool", "predef", true);
        add_public_dependency("pool", "preprocessor", true);
        add_public_dependency("pool", "static_assert", true);
        add_public_dependency("pool", "throw_exception", true);
        add_public_dependency("pool", "type_traits", true);
        add_public_dependency("pool", "winapi", true);
        add_public_dependency("process", "algorithm", true);
        add_public_dependency("process", "array", true);
        add_public_dependency("process", "asio", true);
        add_public_dependency("process", "assert", true);
        add_public_dependency("process", "atomic", true);
        add_public_dependency("process", "bind", true);
        add_public_dependency("process", "chrono", true);
        add_public_dependency("process", "concept_check", true);
        add_public_dependency("process", "config", true);
        add_public_dependency("process", "container", true);
        add_public_dependency("process", "container_hash", true);
        add_public_dependency("process", "context", true);
        add_public_dependency("process", "conversion", true);
        add_public_dependency("process", "core", true);
        add_public_dependency("process", "coroutine", true);
        add_public_dependency("process", "date_time", true);
        add_public_dependency("process", "detail", true);
        add_public_dependency("process", "dynamic_bitset", true);
        add_public_dependency("process", "endian", true);
        add_public_dependency("process", "exception", true);
        add_public_dependency("process", "filesystem", true);
        add_public_dependency("process", "foreach", true);
        add_public_dependency("process", "function", true);
        add_public_dependency("process", "function_types", true);
        add_public_dependency("process", "fusion", true);
        add_public_dependency("process", "integer", true);
        add_public_dependency("process", "intrusive", true);
        add_public_dependency("process", "io", true);
        add_public_dependency("process", "iostreams", true);
        add_public_dependency("process", "iterator", true);
        add_public_dependency("process", "lambda", true);
        add_public_dependency("process", "lexical_cast", true);
        add_public_dependency("process", "locale", true);
        add_public_dependency("process", "math", true);
        add_public_dependency("process", "move", true);
        add_public_dependency("process", "mpl", true);
        add_public_dependency("process", "multiprecision", true);
        add_public_dependency("process", "numeric", true);
        add_public_dependency("process", "optional", true);
        add_public_dependency("process", "phoenix", true);
        add_public_dependency("process", "pool", true);
        add_public_dependency("process", "predef", true);
        add_public_dependency("process", "preprocessor", true);
        add_public_dependency("process", "proto", true);
        add_public_dependency("process", "random", true);
        add_public_dependency("process", "range", true);
        add_public_dependency("process", "ratio", true);
        add_public_dependency("process", "rational", true);
        add_public_dependency("process", "regex", true);
        add_public_dependency("process", "serialization", true);
        add_public_dependency("process", "smart_ptr", true);
        add_public_dependency("process", "spirit", true);
        add_public_dependency("process", "static_assert", true);
        add_public_dependency("process", "system", true);
        add_public_dependency("process", "thread", true);
        add_public_dependency("process", "throw_exception", true);
        add_public_dependency("process", "tokenizer", true);
        add_public_dependency("process", "tti", true);
        add_public_dependency("process", "tuple", true);
        add_public_dependency("process", "type_index", true);
        add_public_dependency("process", "type_traits", true);
        add_public_dependency("process", "typeof", true);
        add_public_dependency("process", "unordered", true);
        add_public_dependency("process", "utility", true);
        add_public_dependency("process", "variant", true);
        add_public_dependency("process", "winapi", true);
        add_public_dependency("program_options", "algorithm", true);
        add_public_dependency("program_options", "any", true);
        add_public_dependency("program_options", "array", true);
        add_public_dependency("program_options", "assert", true);
        add_public_dependency("program_options", "atomic", true);
        add_public_dependency("program_options", "bind", true);
        add_public_dependency("program_options", "concept_check", true);
        add_public_dependency("program_options", "config", true);
        add_public_dependency("program_options", "container", true);
        add_public_dependency("program_options", "container_hash", true);
        add_public_dependency("program_options", "conversion", true);
        add_public_dependency("program_options", "core", true);
        add_public_dependency("program_options", "detail", true);
        add_public_dependency("program_options", "exception", true);
        add_public_dependency("program_options", "function", true);
        add_public_dependency("program_options", "function_types", true);
        add_public_dependency("program_options", "fusion", true);
        add_public_dependency("program_options", "integer", true);
        add_public_dependency("program_options", "intrusive", true);
        add_public_dependency("program_options", "iterator", true);
        add_public_dependency("program_options", "lambda", true);
        add_public_dependency("program_options", "lexical_cast", true);
        add_public_dependency("program_options", "math", true);
        add_public_dependency("program_options", "move", true);
        add_public_dependency("program_options", "mpl", true);
        add_public_dependency("program_options", "numeric", true);
        add_public_dependency("program_options", "optional", true);
        add_public_dependency("program_options", "predef", true);
        add_public_dependency("program_options", "preprocessor", true);
        add_public_dependency("program_options", "range", true);
        add_public_dependency("program_options", "regex", true);
        add_public_dependency("program_options", "smart_ptr", true);
        add_public_dependency("program_options", "static_assert", true);
        add_public_dependency("program_options", "throw_exception", true);
        add_public_dependency("program_options", "tokenizer", true);
        add_public_dependency("program_options", "tuple", true);
        add_public_dependency("program_options", "type_index", true);
        add_public_dependency("program_options", "type_traits", true);
        add_public_dependency("program_options", "typeof", true);
        add_public_dependency("program_options", "unordered", true);
        add_public_dependency("program_options", "utility", true);
        add_public_dependency("property_map", "algorithm", true);
        add_public_dependency("property_map", "any", true);
        add_public_dependency("property_map", "array", true);
        add_public_dependency("property_map", "assert", true);
        add_public_dependency("property_map", "atomic", true);
        add_public_dependency("property_map", "bimap", true);
        add_public_dependency("property_map", "bind", true);
        add_public_dependency("property_map", "chrono", true);
        add_public_dependency("property_map", "concept_check", true);
        add_public_dependency("property_map", "config", true);
        add_public_dependency("property_map", "container", true);
        add_public_dependency("property_map", "container_hash", true);
        add_public_dependency("property_map", "conversion", true);
        add_public_dependency("property_map", "core", true);
        add_public_dependency("property_map", "date_time", true);
        add_public_dependency("property_map", "detail", true);
        add_public_dependency("property_map", "disjoint_sets", true);
        add_public_dependency("property_map", "dynamic_bitset", true);
        add_public_dependency("property_map", "endian", true);
        add_public_dependency("property_map", "exception", true);
        add_public_dependency("property_map", "filesystem", true);
        add_public_dependency("property_map", "foreach", true);
        add_public_dependency("property_map", "format", true);
        add_public_dependency("property_map", "function", true);
        add_public_dependency("property_map", "function_types", true);
        add_public_dependency("property_map", "fusion", true);
        add_public_dependency("property_map", "graph", true);
        add_public_dependency("property_map", "graph_parallel", true);
        add_public_dependency("property_map", "integer", true);
        add_public_dependency("property_map", "intrusive", true);
        add_public_dependency("property_map", "io", true);
        add_public_dependency("property_map", "iostreams", true);
        add_public_dependency("property_map", "iterator", true);
        add_public_dependency("property_map", "lambda", true);
        add_public_dependency("property_map", "lexical_cast", true);
        add_public_dependency("property_map", "locale", true);
        add_public_dependency("property_map", "math", true);
        add_public_dependency("property_map", "move", true);
        add_public_dependency("property_map", "mpi", true);
        add_public_dependency("property_map", "mpl", true);
        add_public_dependency("property_map", "multi_index", true);
        add_public_dependency("property_map", "multiprecision", true);
        add_public_dependency("property_map", "numeric", true);
        add_public_dependency("property_map", "optional", true);
        add_public_dependency("property_map", "parameter", true);
        add_public_dependency("property_map", "phoenix", true);
        add_public_dependency("property_map", "pool", true);
        add_public_dependency("property_map", "predef", true);
        add_public_dependency("property_map", "preprocessor", true);
        add_public_dependency("property_map", "property_tree", true);
        add_public_dependency("property_map", "proto", true);
        add_public_dependency("property_map", "python", true);
        add_public_dependency("property_map", "random", true);
        add_public_dependency("property_map", "range", true);
        add_public_dependency("property_map", "ratio", true);
        add_public_dependency("property_map", "rational", true);
        add_public_dependency("property_map", "regex", true);
        add_public_dependency("property_map", "serialization", true);
        add_public_dependency("property_map", "smart_ptr", true);
        add_public_dependency("property_map", "spirit", true);
        add_public_dependency("property_map", "static_assert", true);
        add_public_dependency("property_map", "system", true);
        add_public_dependency("property_map", "test", true);
        add_public_dependency("property_map", "thread", true);
        add_public_dependency("property_map", "throw_exception", true);
        add_public_dependency("property_map", "timer", true);
        add_public_dependency("property_map", "tokenizer", true);
        add_public_dependency("property_map", "tti", true);
        add_public_dependency("property_map", "tuple", true);
        add_public_dependency("property_map", "type_index", true);
        add_public_dependency("property_map", "type_traits", true);
        add_public_dependency("property_map", "typeof", true);
        add_public_dependency("property_map", "unordered", true);
        add_public_dependency("property_map", "utility", true);
        add_public_dependency("property_map", "variant", true);
        add_public_dependency("property_map", "winapi", true);
        add_public_dependency("property_map", "xpressive", true);
        add_public_dependency("property_tree", "algorithm", true);
        add_public_dependency("property_tree", "any", true);
        add_public_dependency("property_tree", "array", true);
        add_public_dependency("property_tree", "assert", true);
        add_public_dependency("property_tree", "atomic", true);
        add_public_dependency("property_tree", "bind", true);
        add_public_dependency("property_tree", "chrono", true);
        add_public_dependency("property_tree", "concept_check", true);
        add_public_dependency("property_tree", "config", true);
        add_public_dependency("property_tree", "container", true);
        add_public_dependency("property_tree", "container_hash", true);
        add_public_dependency("property_tree", "conversion", true);
        add_public_dependency("property_tree", "core", true);
        add_public_dependency("property_tree", "date_time", true);
        add_public_dependency("property_tree", "detail", true);
        add_public_dependency("property_tree", "dynamic_bitset", true);
        add_public_dependency("property_tree", "endian", true);
        add_public_dependency("property_tree", "exception", true);
        add_public_dependency("property_tree", "filesystem", true);
        add_public_dependency("property_tree", "foreach", true);
        add_public_dependency("property_tree", "format", true);
        add_public_dependency("property_tree", "function", true);
        add_public_dependency("property_tree", "function_types", true);
        add_public_dependency("property_tree", "fusion", true);
        add_public_dependency("property_tree", "integer", true);
        add_public_dependency("property_tree", "intrusive", true);
        add_public_dependency("property_tree", "io", true);
        add_public_dependency("property_tree", "iostreams", true);
        add_public_dependency("property_tree", "iterator", true);
        add_public_dependency("property_tree", "lambda", true);
        add_public_dependency("property_tree", "lexical_cast", true);
        add_public_dependency("property_tree", "locale", true);
        add_public_dependency("property_tree", "math", true);
        add_public_dependency("property_tree", "move", true);
        add_public_dependency("property_tree", "mpl", true);
        add_public_dependency("property_tree", "multi_index", true);
        add_public_dependency("property_tree", "multiprecision", true);
        add_public_dependency("property_tree", "numeric", true);
        add_public_dependency("property_tree", "optional", true);
        add_public_dependency("property_tree", "phoenix", true);
        add_public_dependency("property_tree", "pool", true);
        add_public_dependency("property_tree", "predef", true);
        add_public_dependency("property_tree", "preprocessor", true);
        add_public_dependency("property_tree", "proto", true);
        add_public_dependency("property_tree", "random", true);
        add_public_dependency("property_tree", "range", true);
        add_public_dependency("property_tree", "ratio", true);
        add_public_dependency("property_tree", "rational", true);
        add_public_dependency("property_tree", "regex", true);
        add_public_dependency("property_tree", "serialization", true);
        add_public_dependency("property_tree", "smart_ptr", true);
        add_public_dependency("property_tree", "spirit", true);
        add_public_dependency("property_tree", "static_assert", true);
        add_public_dependency("property_tree", "system", true);
        add_public_dependency("property_tree", "thread", true);
        add_public_dependency("property_tree", "throw_exception", true);
        add_public_dependency("property_tree", "tokenizer", true);
        add_public_dependency("property_tree", "tti", true);
        add_public_dependency("property_tree", "tuple", true);
        add_public_dependency("property_tree", "type_index", true);
        add_public_dependency("property_tree", "type_traits", true);
        add_public_dependency("property_tree", "typeof", true);
        add_public_dependency("property_tree", "unordered", true);
        add_public_dependency("property_tree", "utility", true);
        add_public_dependency("property_tree", "variant", true);
        add_public_dependency("property_tree", "winapi", true);
        add_public_dependency("proto", "algorithm", true);
        add_public_dependency("proto", "array", true);
        add_public_dependency("proto", "assert", true);
        add_public_dependency("proto", "bind", true);
        add_public_dependency("proto", "concept_check", true);
        add_public_dependency("proto", "config", true);
        add_public_dependency("proto", "container", true);
        add_public_dependency("proto", "container_hash", true);
        add_public_dependency("proto", "conversion", true);
        add_public_dependency("proto", "core", true);
        add_public_dependency("proto", "detail", true);
        add_public_dependency("proto", "exception", true);
        add_public_dependency("proto", "function", true);
        add_public_dependency("proto", "function_types", true);
        add_public_dependency("proto", "fusion", true);
        add_public_dependency("proto", "integer", true);
        add_public_dependency("proto", "intrusive", true);
        add_public_dependency("proto", "iterator", true);
        add_public_dependency("proto", "move", true);
        add_public_dependency("proto", "mpl", true);
        add_public_dependency("proto", "numeric", true);
        add_public_dependency("proto", "optional", true);
        add_public_dependency("proto", "predef", true);
        add_public_dependency("proto", "preprocessor", true);
        add_public_dependency("proto", "range", true);
        add_public_dependency("proto", "regex", true);
        add_public_dependency("proto", "smart_ptr", true);
        add_public_dependency("proto", "static_assert", true);
        add_public_dependency("proto", "throw_exception", true);
        add_public_dependency("proto", "tuple", true);
        add_public_dependency("proto", "type_index", true);
        add_public_dependency("proto", "type_traits", true);
        add_public_dependency("proto", "typeof", true);
        add_public_dependency("proto", "unordered", true);
        add_public_dependency("proto", "utility", true);
        add_public_dependency("ptr_container", "algorithm", true);
        add_public_dependency("ptr_container", "array", true);
        add_public_dependency("ptr_container", "assert", true);
        add_public_dependency("ptr_container", "atomic", true);
        add_public_dependency("ptr_container", "bind", true);
        add_public_dependency("ptr_container", "chrono", true);
        add_public_dependency("ptr_container", "circular_buffer", true);
        add_public_dependency("ptr_container", "concept_check", true);
        add_public_dependency("ptr_container", "config", true);
        add_public_dependency("ptr_container", "container", true);
        add_public_dependency("ptr_container", "container_hash", true);
        add_public_dependency("ptr_container", "conversion", true);
        add_public_dependency("ptr_container", "core", true);
        add_public_dependency("ptr_container", "date_time", true);
        add_public_dependency("ptr_container", "detail", true);
        add_public_dependency("ptr_container", "dynamic_bitset", true);
        add_public_dependency("ptr_container", "endian", true);
        add_public_dependency("ptr_container", "exception", true);
        add_public_dependency("ptr_container", "filesystem", true);
        add_public_dependency("ptr_container", "foreach", true);
        add_public_dependency("ptr_container", "function", true);
        add_public_dependency("ptr_container", "function_types", true);
        add_public_dependency("ptr_container", "fusion", true);
        add_public_dependency("ptr_container", "integer", true);
        add_public_dependency("ptr_container", "intrusive", true);
        add_public_dependency("ptr_container", "io", true);
        add_public_dependency("ptr_container", "iostreams", true);
        add_public_dependency("ptr_container", "iterator", true);
        add_public_dependency("ptr_container", "lambda", true);
        add_public_dependency("ptr_container", "lexical_cast", true);
        add_public_dependency("ptr_container", "locale", true);
        add_public_dependency("ptr_container", "math", true);
        add_public_dependency("ptr_container", "move", true);
        add_public_dependency("ptr_container", "mpl", true);
        add_public_dependency("ptr_container", "multiprecision", true);
        add_public_dependency("ptr_container", "numeric", true);
        add_public_dependency("ptr_container", "optional", true);
        add_public_dependency("ptr_container", "phoenix", true);
        add_public_dependency("ptr_container", "pool", true);
        add_public_dependency("ptr_container", "predef", true);
        add_public_dependency("ptr_container", "preprocessor", true);
        add_public_dependency("ptr_container", "proto", true);
        add_public_dependency("ptr_container", "random", true);
        add_public_dependency("ptr_container", "range", true);
        add_public_dependency("ptr_container", "ratio", true);
        add_public_dependency("ptr_container", "rational", true);
        add_public_dependency("ptr_container", "regex", true);
        add_public_dependency("ptr_container", "serialization", true);
        add_public_dependency("ptr_container", "smart_ptr", true);
        add_public_dependency("ptr_container", "spirit", true);
        add_public_dependency("ptr_container", "static_assert", true);
        add_public_dependency("ptr_container", "system", true);
        add_public_dependency("ptr_container", "thread", true);
        add_public_dependency("ptr_container", "throw_exception", true);
        add_public_dependency("ptr_container", "tokenizer", true);
        add_public_dependency("ptr_container", "tti", true);
        add_public_dependency("ptr_container", "tuple", true);
        add_public_dependency("ptr_container", "type_index", true);
        add_public_dependency("ptr_container", "type_traits", true);
        add_public_dependency("ptr_container", "typeof", true);
        add_public_dependency("ptr_container", "unordered", true);
        add_public_dependency("ptr_container", "utility", true);
        add_public_dependency("ptr_container", "variant", true);
        add_public_dependency("ptr_container", "winapi", true);
        add_public_dependency("python", "algorithm", true);
        add_public_dependency("python", "any", true);
        add_public_dependency("python", "array", true);
        add_public_dependency("python", "assert", true);
        add_public_dependency("python", "atomic", true);
        add_public_dependency("python", "bimap", true);
        add_public_dependency("python", "bind", true);
        add_public_dependency("python", "chrono", true);
        add_public_dependency("python", "concept_check", true);
        add_public_dependency("python", "config", true);
        add_public_dependency("python", "container", true);
        add_public_dependency("python", "container_hash", true);
        add_public_dependency("python", "conversion", true);
        add_public_dependency("python", "core", true);
        add_public_dependency("python", "date_time", true);
        add_public_dependency("python", "detail", true);
        add_public_dependency("python", "disjoint_sets", true);
        add_public_dependency("python", "dynamic_bitset", true);
        add_public_dependency("python", "endian", true);
        add_public_dependency("python", "exception", true);
        add_public_dependency("python", "filesystem", true);
        add_public_dependency("python", "foreach", true);
        add_public_dependency("python", "format", true);
        add_public_dependency("python", "function", true);
        add_public_dependency("python", "function_types", true);
        add_public_dependency("python", "fusion", true);
        add_public_dependency("python", "graph", true);
        add_public_dependency("python", "graph_parallel", true);
        add_public_dependency("python", "integer", true);
        add_public_dependency("python", "intrusive", true);
        add_public_dependency("python", "io", true);
        add_public_dependency("python", "iostreams", true);
        add_public_dependency("python", "iterator", true);
        add_public_dependency("python", "lambda", true);
        add_public_dependency("python", "lexical_cast", true);
        add_public_dependency("python", "locale", true);
        add_public_dependency("python", "math", true);
        add_public_dependency("python", "move", true);
        add_public_dependency("python", "mpi", true);
        add_public_dependency("python", "mpl", true);
        add_public_dependency("python", "multi_index", true);
        add_public_dependency("python", "multiprecision", true);
        add_public_dependency("python", "numeric", true);
        add_public_dependency("python", "optional", true);
        add_public_dependency("python", "parameter", true);
        add_public_dependency("python", "phoenix", true);
        add_public_dependency("python", "pool", true);
        add_public_dependency("python", "predef", true);
        add_public_dependency("python", "preprocessor", true);
        add_public_dependency("python", "property_map", true);
        add_public_dependency("python", "property_tree", true);
        add_public_dependency("python", "proto", true);
        add_public_dependency("python", "random", true);
        add_public_dependency("python", "range", true);
        add_public_dependency("python", "ratio", true);
        add_public_dependency("python", "rational", true);
        add_public_dependency("python", "regex", true);
        add_public_dependency("python", "serialization", true);
        add_public_dependency("python", "smart_ptr", true);
        add_public_dependency("python", "spirit", true);
        add_public_dependency("python", "static_assert", true);
        add_public_dependency("python", "system", true);
        add_public_dependency("python", "test", true);
        add_public_dependency("python", "thread", true);
        add_public_dependency("python", "throw_exception", true);
        add_public_dependency("python", "timer", true);
        add_public_dependency("python", "tokenizer", true);
        add_public_dependency("python", "tti", true);
        add_public_dependency("python", "tuple", true);
        add_public_dependency("python", "type_index", true);
        add_public_dependency("python", "type_traits", true);
        add_public_dependency("python", "typeof", true);
        add_public_dependency("python", "unordered", true);
        add_public_dependency("python", "utility", true);
        add_public_dependency("python", "variant", true);
        add_public_dependency("python", "winapi", true);
        add_public_dependency("python", "xpressive", true);
        add_public_dependency("qvm", "assert", true);
        add_public_dependency("qvm", "config", true);
        add_public_dependency("qvm", "core", true);
        add_public_dependency("qvm", "exception", true);
        add_public_dependency("qvm", "move", true);
        add_public_dependency("qvm", "predef", true);
        add_public_dependency("qvm", "preprocessor", true);
        add_public_dependency("qvm", "smart_ptr", true);
        add_public_dependency("qvm", "static_assert", true);
        add_public_dependency("qvm", "throw_exception", true);
        add_public_dependency("qvm", "tuple", true);
        add_public_dependency("qvm", "type_traits", true);
        add_public_dependency("random", "system", false);
        add_public_dependency("random", "algorithm", true);
        add_public_dependency("random", "array", true);
        add_public_dependency("random", "assert", true);
        add_public_dependency("random", "atomic", true);
        add_public_dependency("random", "bind", true);
        add_public_dependency("random", "chrono", true);
        add_public_dependency("random", "concept_check", true);
        add_public_dependency("random", "config", true);
        add_public_dependency("random", "container", true);
        add_public_dependency("random", "container_hash", true);
        add_public_dependency("random", "conversion", true);
        add_public_dependency("random", "core", true);
        add_public_dependency("random", "date_time", true);
        add_public_dependency("random", "detail", true);
        add_public_dependency("random", "dynamic_bitset", true);
        add_public_dependency("random", "endian", true);
        add_public_dependency("random", "exception", true);
        add_public_dependency("random", "filesystem", true);
        add_public_dependency("random", "foreach", true);
        add_public_dependency("random", "function", true);
        add_public_dependency("random", "function_types", true);
        add_public_dependency("random", "fusion", true);
        add_public_dependency("random", "integer", true);
        add_public_dependency("random", "intrusive", true);
        add_public_dependency("random", "io", true);
        add_public_dependency("random", "iostreams", true);
        add_public_dependency("random", "iterator", true);
        add_public_dependency("random", "lambda", true);
        add_public_dependency("random", "lexical_cast", true);
        add_public_dependency("random", "locale", true);
        add_public_dependency("random", "math", true);
        add_public_dependency("random", "move", true);
        add_public_dependency("random", "mpl", true);
        add_public_dependency("random", "multiprecision", true);
        add_public_dependency("random", "numeric", true);
        add_public_dependency("random", "optional", true);
        add_public_dependency("random", "phoenix", true);
        add_public_dependency("random", "pool", true);
        add_public_dependency("random", "predef", true);
        add_public_dependency("random", "preprocessor", true);
        add_public_dependency("random", "proto", true);
        add_public_dependency("random", "range", true);
        add_public_dependency("random", "ratio", true);
        add_public_dependency("random", "rational", true);
        add_public_dependency("random", "regex", true);
        add_public_dependency("random", "serialization", true);
        add_public_dependency("random", "smart_ptr", true);
        add_public_dependency("random", "spirit", true);
        add_public_dependency("random", "static_assert", true);
        add_public_dependency("random", "thread", true);
        add_public_dependency("random", "throw_exception", true);
        add_public_dependency("random", "tokenizer", true);
        add_public_dependency("random", "tti", true);
        add_public_dependency("random", "tuple", true);
        add_public_dependency("random", "type_index", true);
        add_public_dependency("random", "type_traits", true);
        add_public_dependency("random", "typeof", true);
        add_public_dependency("random", "unordered", true);
        add_public_dependency("random", "utility", true);
        add_public_dependency("random", "variant", true);
        add_public_dependency("random", "winapi", true);
        add_public_dependency("range", "algorithm", true);
        add_public_dependency("range", "array", true);
        add_public_dependency("range", "assert", true);
        add_public_dependency("range", "bind", true);
        add_public_dependency("range", "concept_check", true);
        add_public_dependency("range", "config", true);
        add_public_dependency("range", "container", true);
        add_public_dependency("range", "container_hash", true);
        add_public_dependency("range", "conversion", true);
        add_public_dependency("range", "core", true);
        add_public_dependency("range", "detail", true);
        add_public_dependency("range", "exception", true);
        add_public_dependency("range", "function", true);
        add_public_dependency("range", "function_types", true);
        add_public_dependency("range", "fusion", true);
        add_public_dependency("range", "integer", true);
        add_public_dependency("range", "intrusive", true);
        add_public_dependency("range", "iterator", true);
        add_public_dependency("range", "move", true);
        add_public_dependency("range", "mpl", true);
        add_public_dependency("range", "numeric", true);
        add_public_dependency("range", "optional", true);
        add_public_dependency("range", "predef", true);
        add_public_dependency("range", "preprocessor", true);
        add_public_dependency("range", "regex", true);
        add_public_dependency("range", "smart_ptr", true);
        add_public_dependency("range", "static_assert", true);
        add_public_dependency("range", "throw_exception", true);
        add_public_dependency("range", "tuple", true);
        add_public_dependency("range", "type_index", true);
        add_public_dependency("range", "type_traits", true);
        add_public_dependency("range", "typeof", true);
        add_public_dependency("range", "unordered", true);
        add_public_dependency("range", "utility", true);
        add_public_dependency("ratio", "assert", true);
        add_public_dependency("ratio", "config", true);
        add_public_dependency("ratio", "container_hash", true);
        add_public_dependency("ratio", "core", true);
        add_public_dependency("ratio", "detail", true);
        add_public_dependency("ratio", "integer", true);
        add_public_dependency("ratio", "mpl", true);
        add_public_dependency("ratio", "predef", true);
        add_public_dependency("ratio", "preprocessor", true);
        add_public_dependency("ratio", "rational", true);
        add_public_dependency("ratio", "static_assert", true);
        add_public_dependency("ratio", "throw_exception", true);
        add_public_dependency("ratio", "type_traits", true);
        add_public_dependency("ratio", "utility", true);
        add_public_dependency("rational", "assert", true);
        add_public_dependency("rational", "config", true);
        add_public_dependency("rational", "container_hash", true);
        add_public_dependency("rational", "core", true);
        add_public_dependency("rational", "detail", true);
        add_public_dependency("rational", "integer", true);
        add_public_dependency("rational", "preprocessor", true);
        add_public_dependency("rational", "static_assert", true);
        add_public_dependency("rational", "throw_exception", true);
        add_public_dependency("rational", "type_traits", true);
        add_public_dependency("rational", "utility", true);
        add_public_dependency("regex", "assert", true);
        add_public_dependency("regex", "concept_check", true);
        add_public_dependency("regex", "config", true);
        add_public_dependency("regex", "container_hash", true);
        add_public_dependency("regex", "conversion", true);
        add_public_dependency("regex", "core", true);
        add_public_dependency("regex", "detail", true);
        add_public_dependency("regex", "function_types", true);
        add_public_dependency("regex", "fusion", true);
        add_public_dependency("regex", "integer", true);
        add_public_dependency("regex", "iterator", true);
        add_public_dependency("regex", "move", true);
        add_public_dependency("regex", "mpl", true);
        add_public_dependency("regex", "optional", true);
        add_public_dependency("regex", "predef", true);
        add_public_dependency("regex", "preprocessor", true);
        add_public_dependency("regex", "smart_ptr", true);
        add_public_dependency("regex", "static_assert", true);
        add_public_dependency("regex", "throw_exception", true);
        add_public_dependency("regex", "tuple", true);
        add_public_dependency("regex", "type_traits", true);
        add_public_dependency("regex", "typeof", true);
        add_public_dependency("regex", "utility", true);
        add_public_dependency("safe_numerics", "assert", true);
        add_public_dependency("safe_numerics", "concept_check", true);
        add_public_dependency("safe_numerics", "config", true);
        add_public_dependency("safe_numerics", "container_hash", true);
        add_public_dependency("safe_numerics", "core", true);
        add_public_dependency("safe_numerics", "detail", true);
        add_public_dependency("safe_numerics", "integer", true);
        add_public_dependency("safe_numerics", "logic", true);
        add_public_dependency("safe_numerics", "mp11", true);
        add_public_dependency("safe_numerics", "mpl", true);
        add_public_dependency("safe_numerics", "predef", true);
        add_public_dependency("safe_numerics", "preprocessor", true);
        add_public_dependency("safe_numerics", "static_assert", true);
        add_public_dependency("safe_numerics", "throw_exception", true);
        add_public_dependency("safe_numerics", "type_traits", true);
        add_public_dependency("safe_numerics", "utility", true);
        add_public_dependency("scope_exit", "assert", true);
        add_public_dependency("scope_exit", "bind", true);
        add_public_dependency("scope_exit", "config", true);
        add_public_dependency("scope_exit", "container_hash", true);
        add_public_dependency("scope_exit", "core", true);
        add_public_dependency("scope_exit", "detail", true);
        add_public_dependency("scope_exit", "function", true);
        add_public_dependency("scope_exit", "integer", true);
        add_public_dependency("scope_exit", "move", true);
        add_public_dependency("scope_exit", "predef", true);
        add_public_dependency("scope_exit", "preprocessor", true);
        add_public_dependency("scope_exit", "smart_ptr", true);
        add_public_dependency("scope_exit", "static_assert", true);
        add_public_dependency("scope_exit", "throw_exception", true);
        add_public_dependency("scope_exit", "type_index", true);
        add_public_dependency("scope_exit", "type_traits", true);
        add_public_dependency("scope_exit", "typeof", true);
        add_public_dependency("serialization", "algorithm", true);
        add_public_dependency("serialization", "array", true);
        add_public_dependency("serialization", "assert", true);
        add_public_dependency("serialization", "atomic", true);
        add_public_dependency("serialization", "bind", true);
        add_public_dependency("serialization", "chrono", true);
        add_public_dependency("serialization", "concept_check", true);
        add_public_dependency("serialization", "config", true);
        add_public_dependency("serialization", "container", true);
        add_public_dependency("serialization", "container_hash", true);
        add_public_dependency("serialization", "conversion", true);
        add_public_dependency("serialization", "core", true);
        add_public_dependency("serialization", "date_time", true);
        add_public_dependency("serialization", "detail", true);
        add_public_dependency("serialization", "dynamic_bitset", true);
        add_public_dependency("serialization", "endian", true);
        add_public_dependency("serialization", "exception", true);
        add_public_dependency("serialization", "filesystem", true);
        add_public_dependency("serialization", "foreach", true);
        add_public_dependency("serialization", "function", true);
        add_public_dependency("serialization", "function_types", true);
        add_public_dependency("serialization", "fusion", true);
        add_public_dependency("serialization", "integer", true);
        add_public_dependency("serialization", "intrusive", true);
        add_public_dependency("serialization", "io", true);
        add_public_dependency("serialization", "iostreams", true);
        add_public_dependency("serialization", "iterator", true);
        add_public_dependency("serialization", "lambda", true);
        add_public_dependency("serialization", "lexical_cast", true);
        add_public_dependency("serialization", "locale", true);
        add_public_dependency("serialization", "math", true);
        add_public_dependency("serialization", "move", true);
        add_public_dependency("serialization", "mpl", true);
        add_public_dependency("serialization", "multiprecision", true);
        add_public_dependency("serialization", "numeric", true);
        add_public_dependency("serialization", "optional", true);
        add_public_dependency("serialization", "phoenix", true);
        add_public_dependency("serialization", "pool", true);
        add_public_dependency("serialization", "predef", true);
        add_public_dependency("serialization", "preprocessor", true);
        add_public_dependency("serialization", "proto", true);
        add_public_dependency("serialization", "random", true);
        add_public_dependency("serialization", "range", true);
        add_public_dependency("serialization", "ratio", true);
        add_public_dependency("serialization", "rational", true);
        add_public_dependency("serialization", "regex", true);
        add_public_dependency("serialization", "smart_ptr", true);
        add_public_dependency("serialization", "spirit", true);
        add_public_dependency("serialization", "static_assert", true);
        add_public_dependency("serialization", "system", true);
        add_public_dependency("serialization", "thread", true);
        add_public_dependency("serialization", "throw_exception", true);
        add_public_dependency("serialization", "tokenizer", true);
        add_public_dependency("serialization", "tti", true);
        add_public_dependency("serialization", "tuple", true);
        add_public_dependency("serialization", "type_index", true);
        add_public_dependency("serialization", "type_traits", true);
        add_public_dependency("serialization", "typeof", true);
        add_public_dependency("serialization", "unordered", true);
        add_public_dependency("serialization", "utility", true);
        add_public_dependency("serialization", "variant", true);
        add_public_dependency("serialization", "winapi", true);
        add_public_dependency("signals2", "algorithm", true);
        add_public_dependency("signals2", "array", true);
        add_public_dependency("signals2", "assert", true);
        add_public_dependency("signals2", "atomic", true);
        add_public_dependency("signals2", "bind", true);
        add_public_dependency("signals2", "chrono", true);
        add_public_dependency("signals2", "concept_check", true);
        add_public_dependency("signals2", "config", true);
        add_public_dependency("signals2", "container", true);
        add_public_dependency("signals2", "container_hash", true);
        add_public_dependency("signals2", "conversion", true);
        add_public_dependency("signals2", "core", true);
        add_public_dependency("signals2", "date_time", true);
        add_public_dependency("signals2", "detail", true);
        add_public_dependency("signals2", "dynamic_bitset", true);
        add_public_dependency("signals2", "endian", true);
        add_public_dependency("signals2", "exception", true);
        add_public_dependency("signals2", "filesystem", true);
        add_public_dependency("signals2", "foreach", true);
        add_public_dependency("signals2", "function", true);
        add_public_dependency("signals2", "function_types", true);
        add_public_dependency("signals2", "fusion", true);
        add_public_dependency("signals2", "integer", true);
        add_public_dependency("signals2", "intrusive", true);
        add_public_dependency("signals2", "io", true);
        add_public_dependency("signals2", "iostreams", true);
        add_public_dependency("signals2", "iterator", true);
        add_public_dependency("signals2", "lambda", true);
        add_public_dependency("signals2", "lexical_cast", true);
        add_public_dependency("signals2", "locale", true);
        add_public_dependency("signals2", "math", true);
        add_public_dependency("signals2", "move", true);
        add_public_dependency("signals2", "mpl", true);
        add_public_dependency("signals2", "multi_index", true);
        add_public_dependency("signals2", "multiprecision", true);
        add_public_dependency("signals2", "numeric", true);
        add_public_dependency("signals2", "optional", true);
        add_public_dependency("signals2", "parameter", true);
        add_public_dependency("signals2", "phoenix", true);
        add_public_dependency("signals2", "pool", true);
        add_public_dependency("signals2", "predef", true);
        add_public_dependency("signals2", "preprocessor", true);
        add_public_dependency("signals2", "proto", true);
        add_public_dependency("signals2", "random", true);
        add_public_dependency("signals2", "range", true);
        add_public_dependency("signals2", "ratio", true);
        add_public_dependency("signals2", "rational", true);
        add_public_dependency("signals2", "regex", true);
        add_public_dependency("signals2", "serialization", true);
        add_public_dependency("signals2", "smart_ptr", true);
        add_public_dependency("signals2", "spirit", true);
        add_public_dependency("signals2", "static_assert", true);
        add_public_dependency("signals2", "system", true);
        add_public_dependency("signals2", "thread", true);
        add_public_dependency("signals2", "throw_exception", true);
        add_public_dependency("signals2", "tokenizer", true);
        add_public_dependency("signals2", "tti", true);
        add_public_dependency("signals2", "tuple", true);
        add_public_dependency("signals2", "type_index", true);
        add_public_dependency("signals2", "type_traits", true);
        add_public_dependency("signals2", "typeof", true);
        add_public_dependency("signals2", "unordered", true);
        add_public_dependency("signals2", "utility", true);
        add_public_dependency("signals2", "variant", true);
        add_public_dependency("signals2", "winapi", true);
        add_public_dependency("smart_ptr", "assert", true);
        add_public_dependency("smart_ptr", "config", true);
        add_public_dependency("smart_ptr", "core", true);
        add_public_dependency("smart_ptr", "move", true);
        add_public_dependency("smart_ptr", "predef", true);
        add_public_dependency("smart_ptr", "preprocessor", true);
        add_public_dependency("smart_ptr", "static_assert", true);
        add_public_dependency("smart_ptr", "throw_exception", true);
        add_public_dependency("smart_ptr", "type_traits", true);
        add_public_dependency("sort", "algorithm", true);
        add_public_dependency("sort", "array", true);
        add_public_dependency("sort", "assert", true);
        add_public_dependency("sort", "atomic", true);
        add_public_dependency("sort", "bind", true);
        add_public_dependency("sort", "chrono", true);
        add_public_dependency("sort", "concept_check", true);
        add_public_dependency("sort", "config", true);
        add_public_dependency("sort", "container", true);
        add_public_dependency("sort", "container_hash", true);
        add_public_dependency("sort", "conversion", true);
        add_public_dependency("sort", "core", true);
        add_public_dependency("sort", "date_time", true);
        add_public_dependency("sort", "detail", true);
        add_public_dependency("sort", "dynamic_bitset", true);
        add_public_dependency("sort", "endian", true);
        add_public_dependency("sort", "exception", true);
        add_public_dependency("sort", "filesystem", true);
        add_public_dependency("sort", "foreach", true);
        add_public_dependency("sort", "function", true);
        add_public_dependency("sort", "function_types", true);
        add_public_dependency("sort", "fusion", true);
        add_public_dependency("sort", "integer", true);
        add_public_dependency("sort", "intrusive", true);
        add_public_dependency("sort", "io", true);
        add_public_dependency("sort", "iostreams", true);
        add_public_dependency("sort", "iterator", true);
        add_public_dependency("sort", "lambda", true);
        add_public_dependency("sort", "lexical_cast", true);
        add_public_dependency("sort", "locale", true);
        add_public_dependency("sort", "math", true);
        add_public_dependency("sort", "move", true);
        add_public_dependency("sort", "mpl", true);
        add_public_dependency("sort", "multiprecision", true);
        add_public_dependency("sort", "numeric", true);
        add_public_dependency("sort", "optional", true);
        add_public_dependency("sort", "phoenix", true);
        add_public_dependency("sort", "pool", true);
        add_public_dependency("sort", "predef", true);
        add_public_dependency("sort", "preprocessor", true);
        add_public_dependency("sort", "proto", true);
        add_public_dependency("sort", "random", true);
        add_public_dependency("sort", "range", true);
        add_public_dependency("sort", "ratio", true);
        add_public_dependency("sort", "rational", true);
        add_public_dependency("sort", "regex", true);
        add_public_dependency("sort", "serialization", true);
        add_public_dependency("sort", "smart_ptr", true);
        add_public_dependency("sort", "spirit", true);
        add_public_dependency("sort", "static_assert", true);
        add_public_dependency("sort", "system", true);
        add_public_dependency("sort", "thread", true);
        add_public_dependency("sort", "throw_exception", true);
        add_public_dependency("sort", "tokenizer", true);
        add_public_dependency("sort", "tti", true);
        add_public_dependency("sort", "tuple", true);
        add_public_dependency("sort", "type_index", true);
        add_public_dependency("sort", "type_traits", true);
        add_public_dependency("sort", "typeof", true);
        add_public_dependency("sort", "unordered", true);
        add_public_dependency("sort", "utility", true);
        add_public_dependency("sort", "variant", true);
        add_public_dependency("sort", "winapi", true);
        add_public_dependency("spirit", "algorithm", true);
        add_public_dependency("spirit", "array", true);
        add_public_dependency("spirit", "assert", true);
        add_public_dependency("spirit", "atomic", true);
        add_public_dependency("spirit", "bind", true);
        add_public_dependency("spirit", "chrono", true);
        add_public_dependency("spirit", "concept_check", true);
        add_public_dependency("spirit", "config", true);
        add_public_dependency("spirit", "container", true);
        add_public_dependency("spirit", "container_hash", true);
        add_public_dependency("spirit", "conversion", true);
        add_public_dependency("spirit", "core", true);
        add_public_dependency("spirit", "date_time", true);
        add_public_dependency("spirit", "detail", true);
        add_public_dependency("spirit", "dynamic_bitset", true);
        add_public_dependency("spirit", "endian", true);
        add_public_dependency("spirit", "exception", true);
        add_public_dependency("spirit", "filesystem", true);
        add_public_dependency("spirit", "foreach", true);
        add_public_dependency("spirit", "function", true);
        add_public_dependency("spirit", "function_types", true);
        add_public_dependency("spirit", "fusion", true);
        add_public_dependency("spirit", "integer", true);
        add_public_dependency("spirit", "intrusive", true);
        add_public_dependency("spirit", "io", true);
        add_public_dependency("spirit", "iostreams", true);
        add_public_dependency("spirit", "iterator", true);
        add_public_dependency("spirit", "lambda", true);
        add_public_dependency("spirit", "lexical_cast", true);
        add_public_dependency("spirit", "locale", true);
        add_public_dependency("spirit", "math", true);
        add_public_dependency("spirit", "move", true);
        add_public_dependency("spirit", "mpl", true);
        add_public_dependency("spirit", "multiprecision", true);
        add_public_dependency("spirit", "numeric", true);
        add_public_dependency("spirit", "optional", true);
        add_public_dependency("spirit", "phoenix", true);
        add_public_dependency("spirit", "pool", true);
        add_public_dependency("spirit", "predef", true);
        add_public_dependency("spirit", "preprocessor", true);
        add_public_dependency("spirit", "proto", true);
        add_public_dependency("spirit", "random", true);
        add_public_dependency("spirit", "range", true);
        add_public_dependency("spirit", "ratio", true);
        add_public_dependency("spirit", "rational", true);
        add_public_dependency("spirit", "regex", true);
        add_public_dependency("spirit", "serialization", true);
        add_public_dependency("spirit", "smart_ptr", true);
        add_public_dependency("spirit", "static_assert", true);
        add_public_dependency("spirit", "system", true);
        add_public_dependency("spirit", "thread", true);
        add_public_dependency("spirit", "throw_exception", true);
        add_public_dependency("spirit", "tokenizer", true);
        add_public_dependency("spirit", "tti", true);
        add_public_dependency("spirit", "tuple", true);
        add_public_dependency("spirit", "type_index", true);
        add_public_dependency("spirit", "type_traits", true);
        add_public_dependency("spirit", "typeof", true);
        add_public_dependency("spirit", "unordered", true);
        add_public_dependency("spirit", "utility", true);
        add_public_dependency("spirit", "variant", true);
        add_public_dependency("spirit", "winapi", true);
        add_public_dependency("stacktrace", "array", true);
        add_public_dependency("stacktrace", "assert", true);
        add_public_dependency("stacktrace", "config", true);
        add_public_dependency("stacktrace", "container_hash", true);
        add_public_dependency("stacktrace", "core", true);
        add_public_dependency("stacktrace", "detail", true);
        add_public_dependency("stacktrace", "integer", true);
        add_public_dependency("stacktrace", "predef", true);
        add_public_dependency("stacktrace", "preprocessor", true);
        add_public_dependency("stacktrace", "static_assert", true);
        add_public_dependency("stacktrace", "throw_exception", true);
        add_public_dependency("stacktrace", "type_traits", true);
        add_public_dependency("stacktrace", "winapi", true);
        add_public_dependency("statechart", "algorithm", true);
        add_public_dependency("statechart", "array", true);
        add_public_dependency("statechart", "assert", true);
        add_public_dependency("statechart", "atomic", true);
        add_public_dependency("statechart", "bind", true);
        add_public_dependency("statechart", "chrono", true);
        add_public_dependency("statechart", "concept_check", true);
        add_public_dependency("statechart", "config", true);
        add_public_dependency("statechart", "container", true);
        add_public_dependency("statechart", "container_hash", true);
        add_public_dependency("statechart", "conversion", true);
        add_public_dependency("statechart", "core", true);
        add_public_dependency("statechart", "date_time", true);
        add_public_dependency("statechart", "detail", true);
        add_public_dependency("statechart", "dynamic_bitset", true);
        add_public_dependency("statechart", "endian", true);
        add_public_dependency("statechart", "exception", true);
        add_public_dependency("statechart", "filesystem", true);
        add_public_dependency("statechart", "foreach", true);
        add_public_dependency("statechart", "function", true);
        add_public_dependency("statechart", "function_types", true);
        add_public_dependency("statechart", "fusion", true);
        add_public_dependency("statechart", "integer", true);
        add_public_dependency("statechart", "intrusive", true);
        add_public_dependency("statechart", "io", true);
        add_public_dependency("statechart", "iostreams", true);
        add_public_dependency("statechart", "iterator", true);
        add_public_dependency("statechart", "lambda", true);
        add_public_dependency("statechart", "lexical_cast", true);
        add_public_dependency("statechart", "locale", true);
        add_public_dependency("statechart", "math", true);
        add_public_dependency("statechart", "move", true);
        add_public_dependency("statechart", "mpl", true);
        add_public_dependency("statechart", "multiprecision", true);
        add_public_dependency("statechart", "numeric", true);
        add_public_dependency("statechart", "optional", true);
        add_public_dependency("statechart", "phoenix", true);
        add_public_dependency("statechart", "pool", true);
        add_public_dependency("statechart", "predef", true);
        add_public_dependency("statechart", "preprocessor", true);
        add_public_dependency("statechart", "proto", true);
        add_public_dependency("statechart", "random", true);
        add_public_dependency("statechart", "range", true);
        add_public_dependency("statechart", "ratio", true);
        add_public_dependency("statechart", "rational", true);
        add_public_dependency("statechart", "regex", true);
        add_public_dependency("statechart", "serialization", true);
        add_public_dependency("statechart", "smart_ptr", true);
        add_public_dependency("statechart", "spirit", true);
        add_public_dependency("statechart", "static_assert", true);
        add_public_dependency("statechart", "system", true);
        add_public_dependency("statechart", "thread", true);
        add_public_dependency("statechart", "throw_exception", true);
        add_public_dependency("statechart", "tokenizer", true);
        add_public_dependency("statechart", "tti", true);
        add_public_dependency("statechart", "tuple", true);
        add_public_dependency("statechart", "type_index", true);
        add_public_dependency("statechart", "type_traits", true);
        add_public_dependency("statechart", "typeof", true);
        add_public_dependency("statechart", "unordered", true);
        add_public_dependency("statechart", "utility", true);
        add_public_dependency("statechart", "variant", true);
        add_public_dependency("statechart", "winapi", true);
        add_public_dependency("static_assert", "config", true);
        add_public_dependency("system", "config", true);
        add_public_dependency("system", "predef", true);
        add_public_dependency("system", "winapi", true);
        add_public_dependency("test", "timer", false);
        add_public_dependency("test", "algorithm", true);
        add_public_dependency("test", "array", true);
        add_public_dependency("test", "assert", true);
        add_public_dependency("test", "bind", true);
        add_public_dependency("test", "chrono", true);
        add_public_dependency("test", "concept_check", true);
        add_public_dependency("test", "config", true);
        add_public_dependency("test", "container", true);
        add_public_dependency("test", "container_hash", true);
        add_public_dependency("test", "conversion", true);
        add_public_dependency("test", "core", true);
        add_public_dependency("test", "detail", true);
        add_public_dependency("test", "exception", true);
        add_public_dependency("test", "function", true);
        add_public_dependency("test", "function_types", true);
        add_public_dependency("test", "fusion", true);
        add_public_dependency("test", "integer", true);
        add_public_dependency("test", "intrusive", true);
        add_public_dependency("test", "io", true);
        add_public_dependency("test", "iterator", true);
        add_public_dependency("test", "move", true);
        add_public_dependency("test", "mpl", true);
        add_public_dependency("test", "numeric", true);
        add_public_dependency("test", "optional", true);
        add_public_dependency("test", "predef", true);
        add_public_dependency("test", "preprocessor", true);
        add_public_dependency("test", "range", true);
        add_public_dependency("test", "ratio", true);
        add_public_dependency("test", "rational", true);
        add_public_dependency("test", "regex", true);
        add_public_dependency("test", "smart_ptr", true);
        add_public_dependency("test", "static_assert", true);
        add_public_dependency("test", "system", true);
        add_public_dependency("test", "throw_exception", true);
        add_public_dependency("test", "tuple", true);
        add_public_dependency("test", "type_index", true);
        add_public_dependency("test", "type_traits", true);
        add_public_dependency("test", "typeof", true);
        add_public_dependency("test", "unordered", true);
        add_public_dependency("test", "utility", true);
        add_public_dependency("test", "winapi", true);
        add_public_dependency("thread", "atomic", false);
        add_public_dependency("thread", "chrono", false);
        add_public_dependency("thread", "date_time", false);
        add_public_dependency("thread", "system", false);
        add_public_dependency("thread", "algorithm", true);
        add_public_dependency("thread", "array", true);
        add_public_dependency("thread", "assert", true);
        add_public_dependency("thread", "bind", true);
        add_public_dependency("thread", "concept_check", true);
        add_public_dependency("thread", "config", true);
        add_public_dependency("thread", "container", true);
        add_public_dependency("thread", "container_hash", true);
        add_public_dependency("thread", "conversion", true);
        add_public_dependency("thread", "core", true);
        add_public_dependency("thread", "detail", true);
        add_public_dependency("thread", "dynamic_bitset", true);
        add_public_dependency("thread", "endian", true);
        add_public_dependency("thread", "exception", true);
        add_public_dependency("thread", "filesystem", true);
        add_public_dependency("thread", "foreach", true);
        add_public_dependency("thread", "function", true);
        add_public_dependency("thread", "function_types", true);
        add_public_dependency("thread", "fusion", true);
        add_public_dependency("thread", "integer", true);
        add_public_dependency("thread", "intrusive", true);
        add_public_dependency("thread", "io", true);
        add_public_dependency("thread", "iostreams", true);
        add_public_dependency("thread", "iterator", true);
        add_public_dependency("thread", "lambda", true);
        add_public_dependency("thread", "lexical_cast", true);
        add_public_dependency("thread", "locale", true);
        add_public_dependency("thread", "math", true);
        add_public_dependency("thread", "move", true);
        add_public_dependency("thread", "mpl", true);
        add_public_dependency("thread", "multiprecision", true);
        add_public_dependency("thread", "numeric", true);
        add_public_dependency("thread", "optional", true);
        add_public_dependency("thread", "phoenix", true);
        add_public_dependency("thread", "pool", true);
        add_public_dependency("thread", "predef", true);
        add_public_dependency("thread", "preprocessor", true);
        add_public_dependency("thread", "proto", true);
        add_public_dependency("thread", "random", true);
        add_public_dependency("thread", "range", true);
        add_public_dependency("thread", "ratio", true);
        add_public_dependency("thread", "rational", true);
        add_public_dependency("thread", "regex", true);
        add_public_dependency("thread", "serialization", true);
        add_public_dependency("thread", "smart_ptr", true);
        add_public_dependency("thread", "spirit", true);
        add_public_dependency("thread", "static_assert", true);
        add_public_dependency("thread", "throw_exception", true);
        add_public_dependency("thread", "tokenizer", true);
        add_public_dependency("thread", "tti", true);
        add_public_dependency("thread", "tuple", true);
        add_public_dependency("thread", "type_index", true);
        add_public_dependency("thread", "type_traits", true);
        add_public_dependency("thread", "typeof", true);
        add_public_dependency("thread", "unordered", true);
        add_public_dependency("thread", "utility", true);
        add_public_dependency("thread", "variant", true);
        add_public_dependency("thread", "winapi", true);
        add_public_dependency("throw_exception", "assert", true);
        add_public_dependency("throw_exception", "config", true);
        add_public_dependency("timer", "chrono", false);
        add_public_dependency("timer", "system", false);
        add_public_dependency("timer", "assert", true);
        add_public_dependency("timer", "config", true);
        add_public_dependency("timer", "container_hash", true);
        add_public_dependency("timer", "core", true);
        add_public_dependency("timer", "detail", true);
        add_public_dependency("timer", "integer", true);
        add_public_dependency("timer", "io", true);
        add_public_dependency("timer", "move", true);
        add_public_dependency("timer", "mpl", true);
        add_public_dependency("timer", "predef", true);
        add_public_dependency("timer", "preprocessor", true);
        add_public_dependency("timer", "ratio", true);
        add_public_dependency("timer", "rational", true);
        add_public_dependency("timer", "static_assert", true);
        add_public_dependency("timer", "throw_exception", true);
        add_public_dependency("timer", "type_traits", true);
        add_public_dependency("timer", "typeof", true);
        add_public_dependency("timer", "utility", true);
        add_public_dependency("timer", "winapi", true);
        add_public_dependency("tokenizer", "assert", true);
        add_public_dependency("tokenizer", "concept_check", true);
        add_public_dependency("tokenizer", "config", true);
        add_public_dependency("tokenizer", "container_hash", true);
        add_public_dependency("tokenizer", "conversion", true);
        add_public_dependency("tokenizer", "core", true);
        add_public_dependency("tokenizer", "detail", true);
        add_public_dependency("tokenizer", "function_types", true);
        add_public_dependency("tokenizer", "fusion", true);
        add_public_dependency("tokenizer", "integer", true);
        add_public_dependency("tokenizer", "iterator", true);
        add_public_dependency("tokenizer", "move", true);
        add_public_dependency("tokenizer", "mpl", true);
        add_public_dependency("tokenizer", "optional", true);
        add_public_dependency("tokenizer", "predef", true);
        add_public_dependency("tokenizer", "preprocessor", true);
        add_public_dependency("tokenizer", "smart_ptr", true);
        add_public_dependency("tokenizer", "static_assert", true);
        add_public_dependency("tokenizer", "throw_exception", true);
        add_public_dependency("tokenizer", "tuple", true);
        add_public_dependency("tokenizer", "type_traits", true);
        add_public_dependency("tokenizer", "typeof", true);
        add_public_dependency("tokenizer", "utility", true);
        add_public_dependency("tti", "assert", true);
        add_public_dependency("tti", "config", true);
        add_public_dependency("tti", "container_hash", true);
        add_public_dependency("tti", "core", true);
        add_public_dependency("tti", "detail", true);
        add_public_dependency("tti", "function_types", true);
        add_public_dependency("tti", "integer", true);
        add_public_dependency("tti", "mpl", true);
        add_public_dependency("tti", "predef", true);
        add_public_dependency("tti", "preprocessor", true);
        add_public_dependency("tti", "static_assert", true);
        add_public_dependency("tti", "throw_exception", true);
        add_public_dependency("tti", "type_traits", true);
        add_public_dependency("tti", "utility", true);
        add_public_dependency("tuple", "assert", true);
        add_public_dependency("tuple", "config", true);
        add_public_dependency("tuple", "core", true);
        add_public_dependency("tuple", "preprocessor", true);
        add_public_dependency("tuple", "static_assert", true);
        add_public_dependency("tuple", "type_traits", true);
        add_public_dependency("type_erasure", "system", false);
        add_public_dependency("type_erasure", "thread", false);
        add_public_dependency("type_erasure", "algorithm", true);
        add_public_dependency("type_erasure", "array", true);
        add_public_dependency("type_erasure", "assert", true);
        add_public_dependency("type_erasure", "atomic", true);
        add_public_dependency("type_erasure", "bind", true);
        add_public_dependency("type_erasure", "chrono", true);
        add_public_dependency("type_erasure", "concept_check", true);
        add_public_dependency("type_erasure", "config", true);
        add_public_dependency("type_erasure", "container", true);
        add_public_dependency("type_erasure", "container_hash", true);
        add_public_dependency("type_erasure", "conversion", true);
        add_public_dependency("type_erasure", "core", true);
        add_public_dependency("type_erasure", "date_time", true);
        add_public_dependency("type_erasure", "detail", true);
        add_public_dependency("type_erasure", "dynamic_bitset", true);
        add_public_dependency("type_erasure", "endian", true);
        add_public_dependency("type_erasure", "exception", true);
        add_public_dependency("type_erasure", "filesystem", true);
        add_public_dependency("type_erasure", "foreach", true);
        add_public_dependency("type_erasure", "function", true);
        add_public_dependency("type_erasure", "function_types", true);
        add_public_dependency("type_erasure", "fusion", true);
        add_public_dependency("type_erasure", "integer", true);
        add_public_dependency("type_erasure", "intrusive", true);
        add_public_dependency("type_erasure", "io", true);
        add_public_dependency("type_erasure", "iostreams", true);
        add_public_dependency("type_erasure", "iterator", true);
        add_public_dependency("type_erasure", "lambda", true);
        add_public_dependency("type_erasure", "lexical_cast", true);
        add_public_dependency("type_erasure", "locale", true);
        add_public_dependency("type_erasure", "math", true);
        add_public_dependency("type_erasure", "move", true);
        add_public_dependency("type_erasure", "mp11", true);
        add_public_dependency("type_erasure", "mpl", true);
        add_public_dependency("type_erasure", "multiprecision", true);
        add_public_dependency("type_erasure", "numeric", true);
        add_public_dependency("type_erasure", "optional", true);
        add_public_dependency("type_erasure", "phoenix", true);
        add_public_dependency("type_erasure", "pool", true);
        add_public_dependency("type_erasure", "predef", true);
        add_public_dependency("type_erasure", "preprocessor", true);
        add_public_dependency("type_erasure", "proto", true);
        add_public_dependency("type_erasure", "random", true);
        add_public_dependency("type_erasure", "range", true);
        add_public_dependency("type_erasure", "ratio", true);
        add_public_dependency("type_erasure", "rational", true);
        add_public_dependency("type_erasure", "regex", true);
        add_public_dependency("type_erasure", "serialization", true);
        add_public_dependency("type_erasure", "smart_ptr", true);
        add_public_dependency("type_erasure", "spirit", true);
        add_public_dependency("type_erasure", "static_assert", true);
        add_public_dependency("type_erasure", "throw_exception", true);
        add_public_dependency("type_erasure", "tokenizer", true);
        add_public_dependency("type_erasure", "tti", true);
        add_public_dependency("type_erasure", "tuple", true);
        add_public_dependency("type_erasure", "type_index", true);
        add_public_dependency("type_erasure", "type_traits", true);
        add_public_dependency("type_erasure", "typeof", true);
        add_public_dependency("type_erasure", "unordered", true);
        add_public_dependency("type_erasure", "utility", true);
        add_public_dependency("type_erasure", "variant", true);
        add_public_dependency("type_erasure", "vmd", true);
        add_public_dependency("type_erasure", "winapi", true);
        add_public_dependency("type_index", "assert", true);
        add_public_dependency("type_index", "config", true);
        add_public_dependency("type_index", "container_hash", true);
        add_public_dependency("type_index", "core", true);
        add_public_dependency("type_index", "detail", true);
        add_public_dependency("type_index", "integer", true);
        add_public_dependency("type_index", "move", true);
        add_public_dependency("type_index", "predef", true);
        add_public_dependency("type_index", "preprocessor", true);
        add_public_dependency("type_index", "smart_ptr", true);
        add_public_dependency("type_index", "static_assert", true);
        add_public_dependency("type_index", "throw_exception", true);
        add_public_dependency("type_index", "type_traits", true);
        add_public_dependency("type_traits", "config", true);
        add_public_dependency("type_traits", "preprocessor", true);
        add_public_dependency("type_traits", "static_assert", true);
        add_public_dependency("typeof", "config", true);
        add_public_dependency("typeof", "preprocessor", true);
        add_public_dependency("typeof", "static_assert", true);
        add_public_dependency("typeof", "type_traits", true);
        add_public_dependency("units", "algorithm", true);
        add_public_dependency("units", "array", true);
        add_public_dependency("units", "assert", true);
        add_public_dependency("units", "atomic", true);
        add_public_dependency("units", "bind", true);
        add_public_dependency("units", "chrono", true);
        add_public_dependency("units", "concept_check", true);
        add_public_dependency("units", "config", true);
        add_public_dependency("units", "container", true);
        add_public_dependency("units", "container_hash", true);
        add_public_dependency("units", "conversion", true);
        add_public_dependency("units", "core", true);
        add_public_dependency("units", "date_time", true);
        add_public_dependency("units", "detail", true);
        add_public_dependency("units", "dynamic_bitset", true);
        add_public_dependency("units", "endian", true);
        add_public_dependency("units", "exception", true);
        add_public_dependency("units", "filesystem", true);
        add_public_dependency("units", "foreach", true);
        add_public_dependency("units", "function", true);
        add_public_dependency("units", "function_types", true);
        add_public_dependency("units", "fusion", true);
        add_public_dependency("units", "integer", true);
        add_public_dependency("units", "intrusive", true);
        add_public_dependency("units", "io", true);
        add_public_dependency("units", "iostreams", true);
        add_public_dependency("units", "iterator", true);
        add_public_dependency("units", "lambda", true);
        add_public_dependency("units", "lexical_cast", true);
        add_public_dependency("units", "locale", true);
        add_public_dependency("units", "math", true);
        add_public_dependency("units", "move", true);
        add_public_dependency("units", "mpl", true);
        add_public_dependency("units", "multiprecision", true);
        add_public_dependency("units", "numeric", true);
        add_public_dependency("units", "optional", true);
        add_public_dependency("units", "phoenix", true);
        add_public_dependency("units", "pool", true);
        add_public_dependency("units", "predef", true);
        add_public_dependency("units", "preprocessor", true);
        add_public_dependency("units", "proto", true);
        add_public_dependency("units", "random", true);
        add_public_dependency("units", "range", true);
        add_public_dependency("units", "ratio", true);
        add_public_dependency("units", "rational", true);
        add_public_dependency("units", "regex", true);
        add_public_dependency("units", "serialization", true);
        add_public_dependency("units", "smart_ptr", true);
        add_public_dependency("units", "spirit", true);
        add_public_dependency("units", "static_assert", true);
        add_public_dependency("units", "system", true);
        add_public_dependency("units", "thread", true);
        add_public_dependency("units", "throw_exception", true);
        add_public_dependency("units", "tokenizer", true);
        add_public_dependency("units", "tti", true);
        add_public_dependency("units", "tuple", true);
        add_public_dependency("units", "type_index", true);
        add_public_dependency("units", "type_traits", true);
        add_public_dependency("units", "typeof", true);
        add_public_dependency("units", "unordered", true);
        add_public_dependency("units", "utility", true);
        add_public_dependency("units", "variant", true);
        add_public_dependency("units", "winapi", true);
        add_public_dependency("unordered", "assert", true);
        add_public_dependency("unordered", "config", true);
        add_public_dependency("unordered", "container", true);
        add_public_dependency("unordered", "container_hash", true);
        add_public_dependency("unordered", "core", true);
        add_public_dependency("unordered", "detail", true);
        add_public_dependency("unordered", "integer", true);
        add_public_dependency("unordered", "intrusive", true);
        add_public_dependency("unordered", "move", true);
        add_public_dependency("unordered", "predef", true);
        add_public_dependency("unordered", "preprocessor", true);
        add_public_dependency("unordered", "smart_ptr", true);
        add_public_dependency("unordered", "static_assert", true);
        add_public_dependency("unordered", "throw_exception", true);
        add_public_dependency("unordered", "tuple", true);
        add_public_dependency("unordered", "type_traits", true);
        add_public_dependency("utility", "assert", true);
        add_public_dependency("utility", "config", true);
        add_public_dependency("utility", "container_hash", true);
        add_public_dependency("utility", "core", true);
        add_public_dependency("utility", "detail", true);
        add_public_dependency("utility", "integer", true);
        add_public_dependency("utility", "preprocessor", true);
        add_public_dependency("utility", "static_assert", true);
        add_public_dependency("utility", "throw_exception", true);
        add_public_dependency("utility", "type_traits", true);
        add_public_dependency("uuid", "algorithm", true);
        add_public_dependency("uuid", "array", true);
        add_public_dependency("uuid", "assert", true);
        add_public_dependency("uuid", "atomic", true);
        add_public_dependency("uuid", "bind", true);
        add_public_dependency("uuid", "chrono", true);
        add_public_dependency("uuid", "concept_check", true);
        add_public_dependency("uuid", "config", true);
        add_public_dependency("uuid", "container", true);
        add_public_dependency("uuid", "container_hash", true);
        add_public_dependency("uuid", "conversion", true);
        add_public_dependency("uuid", "core", true);
        add_public_dependency("uuid", "date_time", true);
        add_public_dependency("uuid", "detail", true);
        add_public_dependency("uuid", "dynamic_bitset", true);
        add_public_dependency("uuid", "endian", true);
        add_public_dependency("uuid", "exception", true);
        add_public_dependency("uuid", "filesystem", true);
        add_public_dependency("uuid", "foreach", true);
        add_public_dependency("uuid", "function", true);
        add_public_dependency("uuid", "function_types", true);
        add_public_dependency("uuid", "fusion", true);
        add_public_dependency("uuid", "integer", true);
        add_public_dependency("uuid", "intrusive", true);
        add_public_dependency("uuid", "io", true);
        add_public_dependency("uuid", "iostreams", true);
        add_public_dependency("uuid", "iterator", true);
        add_public_dependency("uuid", "lambda", true);
        add_public_dependency("uuid", "lexical_cast", true);
        add_public_dependency("uuid", "locale", true);
        add_public_dependency("uuid", "math", true);
        add_public_dependency("uuid", "move", true);
        add_public_dependency("uuid", "mpl", true);
        add_public_dependency("uuid", "multiprecision", true);
        add_public_dependency("uuid", "numeric", true);
        add_public_dependency("uuid", "optional", true);
        add_public_dependency("uuid", "phoenix", true);
        add_public_dependency("uuid", "pool", true);
        add_public_dependency("uuid", "predef", true);
        add_public_dependency("uuid", "preprocessor", true);
        add_public_dependency("uuid", "proto", true);
        add_public_dependency("uuid", "random", true);
        add_public_dependency("uuid", "range", true);
        add_public_dependency("uuid", "ratio", true);
        add_public_dependency("uuid", "rational", true);
        add_public_dependency("uuid", "regex", true);
        add_public_dependency("uuid", "serialization", true);
        add_public_dependency("uuid", "smart_ptr", true);
        add_public_dependency("uuid", "spirit", true);
        add_public_dependency("uuid", "static_assert", true);
        add_public_dependency("uuid", "system", true);
        add_public_dependency("uuid", "thread", true);
        add_public_dependency("uuid", "throw_exception", true);
        add_public_dependency("uuid", "tokenizer", true);
        add_public_dependency("uuid", "tti", true);
        add_public_dependency("uuid", "tuple", true);
        add_public_dependency("uuid", "type_index", true);
        add_public_dependency("uuid", "type_traits", true);
        add_public_dependency("uuid", "typeof", true);
        add_public_dependency("uuid", "unordered", true);
        add_public_dependency("uuid", "utility", true);
        add_public_dependency("uuid", "variant", true);
        add_public_dependency("uuid", "winapi", true);
        add_public_dependency("variant", "assert", true);
        add_public_dependency("variant", "bind", true);
        add_public_dependency("variant", "config", true);
        add_public_dependency("variant", "container_hash", true);
        add_public_dependency("variant", "core", true);
        add_public_dependency("variant", "detail", true);
        add_public_dependency("variant", "integer", true);
        add_public_dependency("variant", "move", true);
        add_public_dependency("variant", "mpl", true);
        add_public_dependency("variant", "predef", true);
        add_public_dependency("variant", "preprocessor", true);
        add_public_dependency("variant", "smart_ptr", true);
        add_public_dependency("variant", "static_assert", true);
        add_public_dependency("variant", "throw_exception", true);
        add_public_dependency("variant", "type_index", true);
        add_public_dependency("variant", "type_traits", true);
        add_public_dependency("variant", "utility", true);
        add_public_dependency("vmd", "preprocessor", true);
        add_public_dependency("wave", "date_time", false);
        add_public_dependency("wave", "filesystem", false);
        add_public_dependency("wave", "thread", false);
        add_public_dependency("wave", "algorithm", true);
        add_public_dependency("wave", "array", true);
        add_public_dependency("wave", "assert", true);
        add_public_dependency("wave", "atomic", true);
        add_public_dependency("wave", "bind", true);
        add_public_dependency("wave", "chrono", true);
        add_public_dependency("wave", "concept_check", true);
        add_public_dependency("wave", "config", true);
        add_public_dependency("wave", "container", true);
        add_public_dependency("wave", "container_hash", true);
        add_public_dependency("wave", "conversion", true);
        add_public_dependency("wave", "core", true);
        add_public_dependency("wave", "detail", true);
        add_public_dependency("wave", "dynamic_bitset", true);
        add_public_dependency("wave", "endian", true);
        add_public_dependency("wave", "exception", true);
        add_public_dependency("wave", "foreach", true);
        add_public_dependency("wave", "function", true);
        add_public_dependency("wave", "function_types", true);
        add_public_dependency("wave", "fusion", true);
        add_public_dependency("wave", "integer", true);
        add_public_dependency("wave", "intrusive", true);
        add_public_dependency("wave", "io", true);
        add_public_dependency("wave", "iostreams", true);
        add_public_dependency("wave", "iterator", true);
        add_public_dependency("wave", "lambda", true);
        add_public_dependency("wave", "lexical_cast", true);
        add_public_dependency("wave", "locale", true);
        add_public_dependency("wave", "math", true);
        add_public_dependency("wave", "move", true);
        add_public_dependency("wave", "mpl", true);
        add_public_dependency("wave", "multi_index", true);
        add_public_dependency("wave", "multiprecision", true);
        add_public_dependency("wave", "numeric", true);
        add_public_dependency("wave", "optional", true);
        add_public_dependency("wave", "phoenix", true);
        add_public_dependency("wave", "pool", true);
        add_public_dependency("wave", "predef", true);
        add_public_dependency("wave", "preprocessor", true);
        add_public_dependency("wave", "proto", true);
        add_public_dependency("wave", "random", true);
        add_public_dependency("wave", "range", true);
        add_public_dependency("wave", "ratio", true);
        add_public_dependency("wave", "rational", true);
        add_public_dependency("wave", "regex", true);
        add_public_dependency("wave", "serialization", true);
        add_public_dependency("wave", "smart_ptr", true);
        add_public_dependency("wave", "spirit", true);
        add_public_dependency("wave", "static_assert", true);
        add_public_dependency("wave", "system", true);
        add_public_dependency("wave", "throw_exception", true);
        add_public_dependency("wave", "tokenizer", true);
        add_public_dependency("wave", "tti", true);
        add_public_dependency("wave", "tuple", true);
        add_public_dependency("wave", "type_index", true);
        add_public_dependency("wave", "type_traits", true);
        add_public_dependency("wave", "typeof", true);
        add_public_dependency("wave", "unordered", true);
        add_public_dependency("wave", "utility", true);
        add_public_dependency("wave", "variant", true);
        add_public_dependency("wave", "winapi", true);
        add_public_dependency("winapi", "config", true);
        add_public_dependency("winapi", "predef", true);
        add_public_dependency("xpressive", "algorithm", true);
        add_public_dependency("xpressive", "array", true);
        add_public_dependency("xpressive", "assert", true);
        add_public_dependency("xpressive", "atomic", true);
        add_public_dependency("xpressive", "bind", true);
        add_public_dependency("xpressive", "concept_check", true);
        add_public_dependency("xpressive", "config", true);
        add_public_dependency("xpressive", "container", true);
        add_public_dependency("xpressive", "container_hash", true);
        add_public_dependency("xpressive", "conversion", true);
        add_public_dependency("xpressive", "core", true);
        add_public_dependency("xpressive", "detail", true);
        add_public_dependency("xpressive", "exception", true);
        add_public_dependency("xpressive", "function", true);
        add_public_dependency("xpressive", "function_types", true);
        add_public_dependency("xpressive", "fusion", true);
        add_public_dependency("xpressive", "integer", true);
        add_public_dependency("xpressive", "intrusive", true);
        add_public_dependency("xpressive", "iterator", true);
        add_public_dependency("xpressive", "lambda", true);
        add_public_dependency("xpressive", "lexical_cast", true);
        add_public_dependency("xpressive", "math", true);
        add_public_dependency("xpressive", "move", true);
        add_public_dependency("xpressive", "mpl", true);
        add_public_dependency("xpressive", "numeric", true);
        add_public_dependency("xpressive", "optional", true);
        add_public_dependency("xpressive", "predef", true);
        add_public_dependency("xpressive", "preprocessor", true);
        add_public_dependency("xpressive", "proto", true);
        add_public_dependency("xpressive", "range", true);
        add_public_dependency("xpressive", "regex", true);
        add_public_dependency("xpressive", "smart_ptr", true);
        add_public_dependency("xpressive", "static_assert", true);
        add_public_dependency("xpressive", "throw_exception", true);
        add_public_dependency("xpressive", "tuple", true);
        add_public_dependency("xpressive", "type_index", true);
        add_public_dependency("xpressive", "type_traits", true);
        add_public_dependency("xpressive", "typeof", true);
        add_public_dependency("xpressive", "unordered", true);
        add_public_dependency("xpressive", "utility", true);
        add_public_dependency("yap", "assert", true);
        add_public_dependency("yap", "config", true);
        add_public_dependency("yap", "container_hash", true);
        add_public_dependency("yap", "core", true);
        add_public_dependency("yap", "detail", true);
        add_public_dependency("yap", "function_types", true);
        add_public_dependency("yap", "fusion", true);
        add_public_dependency("yap", "hana", true);
        add_public_dependency("yap", "integer", true);
        add_public_dependency("yap", "move", true);
        add_public_dependency("yap", "mpl", true);
        add_public_dependency("yap", "predef", true);
        add_public_dependency("yap", "preprocessor", true);
        add_public_dependency("yap", "smart_ptr", true);
        add_public_dependency("yap", "static_assert", true);
        add_public_dependency("yap", "throw_exception", true);
        add_public_dependency("yap", "tuple", true);
        add_public_dependency("yap", "type_index", true);
        add_public_dependency("yap", "type_traits", true);
        add_public_dependency("yap", "typeof", true);
        add_public_dependency("yap", "utility", true);
    }
}
