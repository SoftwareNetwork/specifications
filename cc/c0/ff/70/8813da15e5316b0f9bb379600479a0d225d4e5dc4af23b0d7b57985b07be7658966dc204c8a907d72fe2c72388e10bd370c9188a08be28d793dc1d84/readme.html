<h1 id="taskflow">Taskflow <img align="right" width="10%" src="image/taskflow_logo.png"></h1>
<p><a href="https://app.codacy.com/gh/taskflow/taskflow?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=taskflow/taskflow&amp;utm_campaign=Badge_Grade_Dashboard"><img src="https://api.codacy.com/project/badge/Grade/3bbdc89f9a7a41eaa17559fab8a64cde" alt="Codacy Badge" /></a> <a href="https://travis-ci.com/taskflow/taskflow"><img src="https://travis-ci.com/taskflow/taskflow.svg?branch=master" alt="Linux Build Status" /></a> <a href="https://ci.appveyor.com/project/tsung-wei-huang/taskflow"><img src="https://ci.appveyor.com/api/projects/status/rbjl16i6c9ahxr16?svg=true" alt="Windows Build status" /></a> <a href="https://taskflow.github.io/taskflow/index.html"><img src="image/api-doc.svg" alt="Wiki" /></a> <a href="https://taskflow.github.io/tfprof/"><img src="image/tfprof.svg" alt="TFProf" /></a> <a href="https://arxiv.org/abs/2004.10908v2"><img src="image/cite-arXiv.svg" alt="Cite" /></a></p>
<p>Taskflow helps you quickly write parallel tasks programs in modern C++</p>
<h1 id="why-taskflow">Why Taskflow?</h1>
<p>Taskflow is faster, more expressive, and easier for drop-in integration than many of existing task programming frameworks in handling complex parallel workloads.</p>
<div class="figure">
<img src="image/performance.png" />

</div>
<p>Taskflow lets you quickly implement task decomposition strategies that incorporate both regular and irregular compute patterns, together with an efficient <em>work-stealing</em> scheduler to optimize your multithreaded performance.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="#get-started-with-taskflow">Static Tasking</a></th>
<th align="center"><a href="#dynamic-tasking">Dynamic Tasking</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/static_graph.svg" /></td>
<td align="center"><img align="right" src="image/dynamic_graph.svg" width="100%"></td>
</tr>
</tbody>
</table>
<p>Taskflow supports conditional tasking for you to make rapid control-flow decisions across dependent tasks to implement cycles and conditions that were otherwise difficult to do with existing tools.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="#conditional-tasking">Conditional Tasking</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/condition.svg" /></td>
</tr>
</tbody>
</table>
<p>Taskflow is composable. You can create large parallel graphs through composition of modular and reusable blocks that are easier to optimize at an individual scope.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="#composable-tasking">Taskflow Composition</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/framework.svg" /></td>
</tr>
</tbody>
</table>
<p>Taskflow supports heterogeneous tasking for you to accelerate a wide range of scientific computing applications by harnessing the power of CPU-GPU collaborative computing.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="#concurrent-cpu-gpu-tasking">Concurrent CPU-GPU Tasking</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/cudaflow.svg" /></td>
</tr>
</tbody>
</table>
<p>Taskflow provides visualization and tooling needed for profiling Taskflow programs.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="https://taskflow.github.io/tfprof">Taskflow Profiler</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/tfprof.png" /></td>
</tr>
</tbody>
</table>
<p>We are committed to support trustworthy developments for both academic and industrial research projects in parallel computing. Check out <a href="#who-is-using-taskflow">Who is Using Taskflow</a> and what our users say:</p>
<ul>
<li><em>&quot;Taskflow is the cleanest Task API I've ever seen.&quot; <span class="citation">[Damien Hocking @Corelium Inc]</span>(http://coreliuminc.com)</em></li>
<li><em>&quot;Taskflow has a very simple and elegant tasking interface. The performance also scales very well.&quot; <a href="https://github.com/totalgee">Glen Fraser</a></em></li>
<li><em>&quot;Taskflow lets me handle parallel processing in a smart way.&quot; <span class="citation">[Hayabusa @Learning]</span>(https://cpp-learning.com/cpp-taskflow/)</em></li>
<li><em>&quot;Taskflow improves the throughput of our graph engine in just a few hours of coding.&quot; <span class="citation">[Jean-Michaël @KDAB]</span>(https://ossia.io/)</em></li>
<li><em>&quot;Best poster award for open-source parallel programming library.&quot; <a href="https://github.com/CppCon/CppCon2018">Cpp Conference 2018</a></em></li>
<li><em>&quot;Second Prize of Open-source Software Competition.&quot; <a href="https://tsung-wei-huang.github.io/img/mm19-ossc-award.jpg">ACM Multimedia Conference 2019</a></em></li>
</ul>
<p>See a quick <a href="https://taskflow.github.io/">presentation</a> and visit the <a href="https://taskflow.github.io/taskflow/index.html">documentation</a> to learn more about Taskflow. Technical details can be referred to our <a href="https://arxiv.org/abs/2004.10908v2">arXiv paper</a>.</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#get-started-with-taskflow">Get Started with Taskflow</a></li>
<li><a href="#create-a-taskflow-application">Create a Taskflow Application</a></li>
<li><a href="#step-1-create-a-taskflow">Step 1: Create a Taskflow</a></li>
<li><a href="#step-2-define-task-dependencies">Step 2: Define Task Dependencies</a></li>
<li><a href="#step-3-execute-a-taskflow">Step 3: Execute a Taskflow</a></li>
<li><a href="#dynamic-tasking">Dynamic Tasking</a></li>
<li><a href="#conditional-tasking">Conditional Tasking</a></li>
<li><a href="#composable-tasking">Composable Tasking</a></li>
<li><a href="#concurrent-cpu-gpu-tasking">Concurrent CPU-GPU Tasking</a></li>
<li><a href="#step-1-create-a-cudaflow">Step 1: Create a cudaFlow</a></li>
<li><a href="#step-2-compile-and-execute-a-cudaflow">Step 2: Compile and Execute a cudaFlow</a></li>
<li><a href="#visualize-a-taskflow-graph">Visualize a Taskflow Graph</a></li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#system-requirements">System Requirements</a></li>
<li><a href="#compile-unit-tests-examples-and-benchmarks">Compile Unit Tests, Examples, and Benchmarks</a></li>
<li><a href="#who-is-using-taskflow">Who is Using Taskflow?</a></li>
</ul>
<h1 id="get-started-with-taskflow">Get Started with Taskflow</h1>
<p>The following example <a href="./examples/simple.cpp">simple.cpp</a> shows the basic Taskflow API you need in most applications.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;taskflow/taskflow.hpp&gt;</span><span class="pp">  </span><span class="co">// Taskflow is header-only</span>

<span class="dt">int</span> main(){
  
  tf::Executor executor;
  tf::Taskflow taskflow;

  <span class="kw">auto</span> [A, B, C, D] = taskflow.emplace(
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskA</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">//  task dependency graph</span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskB</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">// </span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskC</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">//          +---+          </span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskD</span><span class="sc">\n</span><span class="st">&quot;</span>; }                <span class="co">//    +----&gt;| B |-----+   </span>
  );                                                 <span class="co">//    |     +---+     |</span>
                                                     <span class="co">//  +---+           +-v-+ </span>
  A.precede(B);  <span class="co">// A runs before B                  //  | A |           | D | </span>
  A.precede(C);  <span class="co">// A runs before C                  //  +---+           +-^-+ </span>
  B.precede(D);  <span class="co">// B runs before D                  //    |     +---+     |    </span>
  C.precede(D);  <span class="co">// C runs before D                  //    +----&gt;| C |-----+    </span>
                                                     <span class="co">//          +---+          </span>
  executor.run(taskflow).wait();

  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Compile and run the code with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="ex">g++</span> simple.cpp -I path/to/include/taskflow/ -std=c++17 -O2 -lpthread -o simple
<span class="ex">~</span>$ <span class="ex">./simple</span>
<span class="ex">TaskA</span>
<span class="ex">TaskC</span>  <span class="op">&lt;</span>-- concurrent with TaskB
<span class="ex">TaskB</span>  <span class="op">&lt;</span>-- concurrent with TaskC
<span class="ex">TaskD</span></code></pre></div>
<h1 id="create-a-taskflow-application">Create a Taskflow Application</h1>
<p>Taskflow defines a very expressive API to create task dependency graphs. Most applications are developed through the following three steps:</p>
<h2 id="step-1-create-a-taskflow">Step 1: Create a Taskflow</h2>
<p>Create a taskflow object to build a task dependency graph:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow taskflow;</code></pre></div>
<p>A task is a callable object for which <a href="https://en.cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> is applicable. Use the method <code>emplace</code> to create a task:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = taskflow.emplace([](){ <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task A</span><span class="sc">\n</span><span class="st">&quot;</span>; });</code></pre></div>
<h2 id="step-2-define-task-dependencies">Step 2: Define Task Dependencies</h2>
<p>You can add dependency links between tasks to enforce one task to run before or after another.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.precede(B);  <span class="co">// A runs before B.</span></code></pre></div>
<h2 id="step-3-execute-a-taskflow">Step 3: Execute a Taskflow</h2>
<p>To execute a taskflow, you need to create an <em>executor</em>. An executor manages a set of worker threads to execute a taskflow through an efficient <em>work-stealing</em> algorithm.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Executor executor;</code></pre></div>
<p>The executor provides a rich set of methods to run a taskflow. You can run a taskflow multiple times, or until a stopping criteria is met. These methods are non-blocking with a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> return to let you query the execution status. Executor is <em>thread-safe</em>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.run(taskflow);       <span class="co">// runs the taskflow once</span>
executor.run_n(taskflow, <span class="dv">4</span>);  <span class="co">// runs the taskflow four times</span>

<span class="co">// keeps running the taskflow until the predicate becomes true</span>
executor.run_until(taskflow, [counter=<span class="dv">4</span>](){ <span class="cf">return</span> --counter == <span class="dv">0</span>; } );</code></pre></div>
<p>You can call <code>wait_for_all</code> to block the executor until all associated taskflows complete.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.wait_for_all();  <span class="co">// block until all associated tasks finish</span></code></pre></div>
<p>Notice that the executor does not own any taskflow. It is your responsibility to keep a taskflow alive during its execution, or it can result in undefined behavior. In most applications, you need only one executor to run multiple taskflows each representing a specific part of your parallel decomposition.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="dynamic-tasking">Dynamic Tasking</h1>
<p>Another powerful feature of Taskflow is <em>dynamic</em> tasking. Dynamic tasks are those tasks created during the execution of a taskflow. These tasks are spawned by a parent task and are grouped together to a <em>subflow</em> graph. To create a subflow for dynamic tasking, emplace a callable with one argument of type <code>tf::Subflow</code>.</p>
<p><img align="right" src="image/subflow_join.svg" width="30%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create three regular tasks</span>
tf::Task A = tf.emplace([](){}).name(<span class="st">&quot;A&quot;</span>);
tf::Task C = tf.emplace([](){}).name(<span class="st">&quot;C&quot;</span>);
tf::Task D = tf.emplace([](){}).name(<span class="st">&quot;D&quot;</span>);

<span class="co">// create a subflow graph (dynamic tasking)</span>
tf::Task B = tf.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  tf::Task B3 = subflow.emplace([](){}).name(<span class="st">&quot;B3&quot;</span>);
  B1.precede(B3);
  B2.precede(B3);
}).name(<span class="st">&quot;B&quot;</span>);
            
A.precede(B);  <span class="co">// B runs after A </span>
A.precede(C);  <span class="co">// C runs after A </span>
B.precede(D);  <span class="co">// D runs after B </span>
C.precede(D);  <span class="co">// D runs after C </span></code></pre></div>
<p>By default, a subflow graph joins its parent node. This ensures a subflow graph finishes before the successors of its parent task. You can disable this feature by calling <code>subflow.detach()</code>. For example, detaching the above subflow will result in the following execution flow:</p>
<p><img align="right" src="image/subflow_detach.svg" width="35%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create a &quot;detached&quot; subflow graph (dynamic tasking)</span>
tf::Task B = tf.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  tf::Task B3 = subflow.emplace([](){}).name(<span class="st">&quot;B3&quot;</span>);

  B1.precede(B3);
  B2.precede(B3);

  <span class="co">// detach the subflow to form a parallel execution line</span>
  subflow.detach();
}).name(<span class="st">&quot;B&quot;</span>);</code></pre></div>
<p>A subflow can be nested or recursive. You can create another subflow from the execution of a subflow and so on.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="conditional-tasking">Conditional Tasking</h1>
<p>Taskflow supports <em>conditional tasking</em> for users to implement <em>general</em> control flow with cycles and conditionals. A <em>condition task</em> evalutes a set of instructions and returns an integer index of the next immediate successor to execute. The index is defined with respect to the order of its successor construction.</p>
<p><img align="right" src="image/condition-2.svg" width="20%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task init = tf.emplace([](){ }).name(<span class="st">&quot;init&quot;</span>);
tf::Task stop = tf.emplace([](){ }).name(<span class="st">&quot;stop&quot;</span>);

<span class="co">// creates a condition task that returns 0 or 1</span>
tf::Task cond = tf.emplace([](){
  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;flipping a coin</span><span class="sc">\n</span><span class="st">&quot;</span>;
  <span class="cf">return</span> rand() % <span class="dv">2</span>;
}).name(<span class="st">&quot;cond&quot;</span>);

<span class="co">// creates a feedback loop</span>
init.precede(cond);
cond.precede(cond, stop);  <span class="co">// cond--0--&gt;cond, cond--1--&gt;stop</span>

executor.run(tf).wait();</code></pre></div>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="composable-tasking">Composable Tasking</h1>
<p>A powerful feature of <code>tf::Taskflow</code> is composability. You can create multiple task graphs from different parts of your workload and use them to compose a large graph through the <code>composed_of</code> method.</p>
<p><img align="right" src="image/composition.svg" width="50%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow f1, f2;

<span class="kw">auto</span> [f1A, f1B] = f1.emplace( 
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f1A</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f1B</span><span class="sc">\n</span><span class="st">&quot;</span>; }
);
<span class="kw">auto</span> [f2A, f2B, f2C] = f2.emplace( 
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2A</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2B</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2C</span><span class="sc">\n</span><span class="st">&quot;</span>; }
);
<span class="kw">auto</span> f1_module_task = f2.composed_of(f1);

f1_module_task.succeed(f2A, f2B)
              .precede(f2C);</code></pre></div>
<p>Similarly, <code>composed_of</code> returns a task handle and you can use <code>precede</code> to create dependencies. You can compose a taskflow from multiple taskflows and use the result to compose a larger taskflow and so on.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="concurrent-cpu-gpu-tasking">Concurrent CPU-GPU Tasking</h1>
<p>Taskflow enables concurrent CPU-GPU tasking by leveraging <a href="https://developer.nvidia.com/cuda-toolkit">Nvidia CUDA Toolkit</a>. You can harness the power of CPU-GPU collaborative computing to implement heterogeneous decomposition algorithms.</p>
<h2 id="step-1-create-a-cudaflow">Step 1: Create a cudaFlow</h2>
<p>A <code>tf::cudaFlow</code> is a graph object created at runtime similar to dynamic tasking. It manages a task node in a taskflow and associates it with a <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html">CUDA Graph</a>. To create a cudaFlow, emplace a callable with an argument of type <code>tf::cudaFlow</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow taskflow;
tf::Executor executor;

<span class="at">const</span> <span class="dt">unsigned</span> N = <span class="dv">1</span>&lt;&lt;<span class="dv">20</span>;                            <span class="co">// size of the vector</span>
<span class="bu">std::</span>vector&lt;<span class="dt">float</span>&gt; hx(N, <span class="fl">1.0f</span>), hy(N, <span class="fl">2.0f</span>);         <span class="co">// x and y vectors at host</span>
<span class="dt">float</span> *dx{<span class="kw">nullptr</span>}, *dy{<span class="kw">nullptr</span>};                    <span class="co">// x and y vectors at device</span>

tf::Task allocate_x = taskflow.emplace([&amp;](){ cudaMalloc(&amp;dx, N*<span class="kw">sizeof</span>(<span class="dt">float</span>));});
tf::Task allocate_y = taskflow.emplace([&amp;](){ cudaMalloc(&amp;dy, N*<span class="kw">sizeof</span>(<span class="dt">float</span>));});
tf::Task cudaflow = taskflow.emplace([&amp;](tf::cudaFlow&amp; cf) {
  tf::cudaTask h2d_x = cf.copy(dx, hx.data(), N);    <span class="co">// host-to-device x data transfer</span>
  tf::cudaTask h2d_y = cf.copy(dy, hy.data(), N);    <span class="co">// host-to-device y data transfer</span>
  tf::cudaTask d2h_x = cf.copy(hx.data(), dx, N);    <span class="co">// device-to-host x data transfer</span>
  tf::cudaTask d2h_y = cf.copy(hy.data(), dy, N);    <span class="co">// device-to-host y data transfer</span>
  <span class="co">// launch saxpy&lt;&lt;&lt;(N+255)/256, 256, 0&gt;&gt;&gt;(N, 2.0f, dx, dy)</span>
  tf::cudaTask kernel = cf.kernel((N<span class="dv">+255</span>)/<span class="dv">256</span>, <span class="dv">256</span>, <span class="dv">0</span>, saxpy, N, <span class="fl">2.0f</span>, dx, dy);
  kernel.succeed(h2d_x, h2d_y)
        .precede(d2h_x, d2h_y);
});
cudaflow.succeed(allocate_x, allocate_y);            <span class="co">// overlap data allocations</span>

executor.run(taskflow).wait();</code></pre></div>
<p>Assume our kernel implements the canonical saxpy operation (single-precision A·X Plus Y) using the CUDA syntax.</p>
<p><img align="right" src="image/saxpy.svg" width="50%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// saxpy (single-precision A·X Plus Y) kernel</span>
__global__ <span class="dt">void</span> saxpy(
  <span class="dt">int</span> n, <span class="dt">float</span> a, <span class="dt">float</span> *x, <span class="dt">float</span> *y
) {
  <span class="co">// get the thread index</span>
  <span class="dt">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;

  <span class="cf">if</span> (i &lt; n) {
    y[i] = a*x[i] + y[i];
  }
}</code></pre></div>
<h2 id="step-2-compile-and-execute-a-cudaflow">Step 2: Compile and Execute a cudaFlow</h2>
<p>Name you source with the extension <code>.cu</code>, let's say <code>saxpy.cu</code>, and compile it through <a href="https://developer.nvidia.com/cuda-llvm-compiler">nvcc</a>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="ex">nvcc</span> saxpy.cu -I path/to/include/taskflow -O2 -o saxpy
<span class="ex">~</span>$ <span class="ex">./saxpy</span></code></pre></div>
<p>Our source autonomously enables cudaFlow for compilers that support CUDA.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="visualize-a-taskflow-graph">Visualize a Taskflow Graph</h1>
<p>You can dump a taskflow through a <code>std::ostream</code> in <a href="https://www.graphviz.org/">GraphViz</a> format using the method <code>dump</code>. There are a number of free <a href="https://dreampuf.github.io/GraphvizOnline/">GraphViz tools</a> you could find online to visualize your Taskflow graph.</p>
<p><img align="right" src="image/graphviz.svg" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow taskflow;
tf::Task A = taskflow.emplace([] () {}).name(<span class="st">&quot;A&quot;</span>);
tf::Task B = taskflow.emplace([] () {}).name(<span class="st">&quot;B&quot;</span>);
tf::Task C = taskflow.emplace([] () {}).name(<span class="st">&quot;C&quot;</span>);
tf::Task D = taskflow.emplace([] () {}).name(<span class="st">&quot;D&quot;</span>);
tf::Task E = taskflow.emplace([] () {}).name(<span class="st">&quot;E&quot;</span>);
A.precede(B, C, E); 
C.precede(D);
B.precede(D, E); 

taskflow.dump(<span class="bu">std::</span>cout);  <span class="co">// dump the graph in DOT to std::cout</span></code></pre></div>
<p>When you have tasks that are created at runtime (e.g., subflow, cudaFlow), you need to execute the graph first to spawn these tasks and dump the entire graph.</p>
<p><img align="right" src="image/debug_subflow.svg" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Executor executor;
tf::Taskflow taskflow;

tf::Task A = taskflow.emplace([](){}).name(<span class="st">&quot;A&quot;</span>);

<span class="co">// create a subflow of two tasks B1-&gt;B2</span>
tf::Task B = taskflow.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  B1.precede(B2);
}).name(<span class="st">&quot;B&quot;</span>);

A.precede(B);

executor.run(tf).wait();  <span class="co">// run the taskflow to spawn subflows</span>
tf.dump(<span class="bu">std::</span>cout);       <span class="co">// dump the graph including dynamic tasks</span></code></pre></div>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="api-reference">API Reference</h1>
<p>The official <a href="https://taskflow.github.io/taskflow/index.html">documentation</a> explains a complete list of Taskflow API. Here, we highlight commonly used methods.</p>
<h2 id="taskflow-api">Taskflow API</h2>
<p>The class <code>tf::Taskflow</code> is the main place to create a task dependency graph.</p>
<h3 id="emplaceplaceholder"><em>emplace/placeholder</em></h3>
<p>You can use <code>emplace</code> to create a task from a target callable.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task task = taskflow.emplace([] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;my task</span><span class="sc">\n</span><span class="st">&quot;</span>; });</code></pre></div>
<p>When a task cannot be determined beforehand, you can create a placeholder and assign the callable later.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = taskflow.emplace([](){});
tf::Task B = taskflow.placeholder();
A.precede(B);
B.work([](){ <span class="co">/* do something */</span> });</code></pre></div>
<h3 id="for_eachfor_each_index"><em>for_each/for_each_index</em></h3>
<p>The method <code>for_each</code> creates a subflow to perform parallel iterations over a range of elements specified by <code>[beg, end)</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> v = {<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>};
<span class="kw">auto</span> t = taskflow.for_each(v.begin(), v.end(),
  [] (<span class="dt">char</span> i) { 
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;parallel iteration on character &quot;</span> &lt;&lt; i &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
  }
);</code></pre></div>
<p>You can also specify an <em>index-based</em> range with the given step size.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [0, 11) with a step size of 2, i.e., 0, 2, 4, 6, 8, 10</span>
<span class="kw">auto</span> t = taskflow.for_each_index(<span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">2</span>, 
  [] (<span class="dt">int</span> i) {
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;parallel iteration on index &quot;</span> &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;
  } 
);</code></pre></div>
<h2 id="task-api">Task API</h2>
<p>Each time you create a task, the taskflow object adds a node to the present task dependency graph and return a <em>task handle</em> to you. You can access or modify the attributes of the associated task node.</p>
<h3 id="name"><em>name</em></h3>
<p>The method <code>name</code> lets you assign a human-readable string to a task.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.name(<span class="st">&quot;my name is A&quot;</span>);</code></pre></div>
<h3 id="work"><em>work</em></h3>
<p>The method <code>work</code> lets you assign a callable to a task.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.work([] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello world!&quot;</span>; });</code></pre></div>
<h3 id="precedesucceed"><em>precede/succeed</em></h3>
<p>The method <code>precede/succedd</code> lets you add a preceding/succeeding link between tasks.</p>
<p><img align="right" width="30%" src="image/broadcast.svg"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// A runs before B, C, D, and E</span>
A.precede(B, C, D, E);</code></pre></div>
<p>The method <code>succeed</code> is similar to <code>precede</code> but operates in the opposite direction.</p>
<h3 id="emptyhas_work"><em>empty/has_work</em></h3>
<p>A task is empty if it is not associated with any graph node.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task task;  <span class="co">// assert(task.empty());</span></code></pre></div>
<p>A placeholder task is associated with a graph node but has no work assigned yet.</p>
<pre><code>tf::Task task = taskflow.placeholder();  // assert(!task.has_work());</code></pre>
<h2 id="executor-api">Executor API</h2>
<p>The class <code>tf::Executor</code> is used for executing one or multiple taskflow objects.</p>
<h3 id="runrun_nrun_until"><em>run/run_n/run_until</em></h3>
<p>The run series are <em>thread-safe</em> and <em>non-blocking</em> calls to execute a taskflow. Issuing multiple runs on the same taskflow will automatically synchronize to a sequential chain of executions.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.run(taskflow);                 <span class="co">// runs a graph once</span>
executor.run_n(taskflow, <span class="dv">5</span>);            <span class="co">// runs a graph five times</span>
executor.run_until(taskflow, my_pred);  <span class="co">// keeps running until the my_pred becomes true</span>
executor.wait_for_all();                <span class="co">// blocks until all tasks finish</span></code></pre></div>
The first run finishes before the second run, and the second run finishes before the third run.
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="system-requirements">System Requirements</h1>
<p>To use the latest <a href="https://github.com/taskflow/taskflow/archive/master.zip">Taskflow</a>, you only need a <a href="https://en.wikipedia.org/wiki/C%2B%2B14">C++14</a> compiler.</p>
<ul>
<li>GNU C++ Compiler at least v5.0 with -std=c++14</li>
<li>Clang C++ Compiler at least v4.0 with -std=c++14</li>
<li>Microsoft Visual Studio at least v15.7 (MSVC++ 19.14); see <a href="https://github.com/taskflow/taskflow/issues/143">vcpkg guide</a></li>
<li>AppleClang Xode Version at least v8</li>
<li>Nvidia CUDA Toolkit and Compiler (<a href="https://developer.nvidia.com/cuda-llvm-compiler">nvcc</a>) at least v10.0 with -std=c++14</li>
</ul>
<p>Taskflow works on Linux, Windows, and Mac OS X. See the <a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a> status.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="compile-unit-tests-examples-and-benchmarks">Compile Unit Tests, Examples, and Benchmarks</h1>
<p>Taskflow uses <a href="https://cmake.org/">CMake</a> to build examples and unit tests. We recommend using out-of-source build.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="fu">cmake</span> --version   # must be at least 3.9 or higher
<span class="ex">~</span>$ <span class="fu">mkdir</span> build
<span class="ex">~</span>$ <span class="bu">cd</span> build
<span class="ex">~</span>$ <span class="fu">cmake</span> ../ 
<span class="ex">~</span>$ <span class="fu">make</span> <span class="kw">&amp;</span> <span class="fu">make</span> test  # run all unit tests</code></pre></div>
<h2 id="examples">Examples</h2>
<p>The folder <code>examples/</code> contains several examples and is a great place to learn to use Taskflow.</p>
<table style="width:28%;">
<colgroup>
<col width="11%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="./examples/simple.cpp">simple.cpp</a></td>
<td>uses basic task building blocks to create a trivial taskflow graph</td>
</tr>
<tr class="even">
<td><a href="./examples/visualization.cpp">visualization.cpp</a></td>
<td>inspects a taskflow through the dump method</td>
</tr>
<tr class="odd">
<td><a href="./examples/parallel_for.cpp">parallel_for.cpp</a></td>
<td>parallelizes a for loop with unbalanced workload</td>
</tr>
<tr class="even">
<td><a href="./examples/subflow.cpp">subflow.cpp</a></td>
<td>demonstrates how to create a subflow graph that spawns three dynamic tasks</td>
</tr>
<tr class="odd">
<td><a href="./examples/run_variants.cpp">run_variants.cpp</a></td>
<td>shows multiple ways to run a taskflow graph</td>
</tr>
<tr class="even">
<td><a href="./examples/composition.cpp">composition.cpp</a></td>
<td>demonstrates the decomposable interface of taskflow</td>
</tr>
<tr class="odd">
<td><a href="./examples/observer.cpp">observer.cpp</a></td>
<td>demonstrates how to monitor the thread activities in scheduling and running tasks</td>
</tr>
<tr class="even">
<td><a href="./examples/condition.cpp">condition.cpp</a></td>
<td>creates a conditional tasking graph with a feedback loop control flow</td>
</tr>
<tr class="odd">
<td><a href="./examples/cuda/saxpy.cu">cuda/saxpy.cu</a></td>
<td>uses cudaFlow to create a saxpy (single-precision A·X Plus Y) task graph</td>
</tr>
<tr class="even">
<td><a href="./examples/cuda/matmul.cu">cuda/matmul.cu</a></td>
<td>uses cudaFlow to create a matrix multiplication workload and compares it with a CPU basline</td>
</tr>
</tbody>
</table>
<h2 id="benchmarks">Benchmarks</h2>
<p>Please visit <a href="benchmarks/benchmarks.md">benchmarks</a> to learn to compile the benchmarks.</p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="who-is-using-taskflow">Who is Using Taskflow?</h1>
<p>Taskflow is being used in both industry and academic projects to scale up existing workloads that incorporate complex task dependencies.</p>
<ul>
<li><a href="https://github.com/OpenTimer/OpenTimer">OpenTimer</a>: A High-performance Timing Analysis Tool for Very Large Scale Integration (VLSI) Systems</li>
<li><a href="https://github.com/novuscore/NovusCore">NovusCore</a>: An emulating project for World of Warraft (Wrath of the Lich King 3.3.5a 12340 client build)</li>
<li><a href="https://github.com/choltz95/SA-PCB">SA-PCB</a>: Annealing-based Printed Circuit Board (PCB) Placement Tool</li>
<li><a href="https://github.com/LPMP/LPMP">LPMP</a>: A C++ framework for developing scalable Lagrangian decomposition solvers for discrete optimization problems</li>
<li><a href="https://github.com/The-OpenROAD-Project/OpenPhySyn">OpenPhySyn</a>: A plugin-based physical synthesis optimization kit as part of the OpenRoad flow</li>
<li><a href="https://ossia.io/">OSSIA</a>: Open-source Software System for Interactive Applications</li>
<li><a href="https://github.com/dealii/dealii">deal.II</a>: A C++ software library to support the creation of finite element code</li>
<li><a href="https://github.com/Intsights/PyRepScan">PyRepScan</a>: A Git Repository Leaks Scanner Python Library written in C++</li>
<li><a href="https://www.mydatamodels.com/">MyDataModels</a>: An online platform for self-service machine learning fro small data</li>
<li><a href="http://www.revealtech.ai/">revealtech.ai</a>: Mobile application that provides focused, intelligent analytics on the edge</li>
</ul>
<p><a href="https://github.com/search?q=taskflow&amp;type=Code">More...</a></p>
<div align="right">
<b><a href="#table-of-contents">[↑]</a></b>
</div>
<h1 id="contributors">Contributors</h1>
<p>Taskflow is being actively developed and contributed by the <a href="https://github.com/taskflow/taskflow/graphs/contributors">these people</a>. Meanwhile, we appreciate the support from many organizations for our developments.</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="https://www.utah.edu/"><img src="image/utah.png" width="100px"></a></th>
<th align="center"><a href="https://illinois.edu/"><img src="image/uiuc.png" width="100px"></a></th>
<th align="center"><a href="https://csl.illinois.edu/"><img src="image/csl.png" width="100px"></a></th>
<th align="center"><a href="https://www.nsf.gov/"><img src="image/nsf.png" width="100px"></a></th>
<th align="center"><a href="https://www.darpa.mil/news-events/2017-09-13"><img src="image/darpa.png" width="100px"></a></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h1 id="license">License</h1>
<p>Taskflow is licensed under the <a href="./LICENSE">MIT License</a>.</p>
<hr />
