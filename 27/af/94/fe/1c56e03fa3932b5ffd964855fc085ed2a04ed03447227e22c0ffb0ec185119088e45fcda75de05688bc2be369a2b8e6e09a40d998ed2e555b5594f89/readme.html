<h1 id="boost.redis">Boost.Redis</h1>
<p>Boost.Redis is a high-level <a href="https://redis.io/">Redis</a>
client library built on top of <a
href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a>
that implements the Redis protocol <a
href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>.
The requirements for using Boost.Redis are:</p>
<ul>
<li>Boost. The library is included in Boost distributions starting with
1.84.</li>
<li>C++17 or higher.</li>
<li>Redis 6 or higher (must support RESP3).</li>
<li>Gcc (10, 11, 12), Clang (11, 13, 14) and Visual Studio (16 2019, 17
2022).</li>
<li>Have basic-level knowledge about <a
href="https://redis.io/docs/">Redis</a> and <a
href="https://www.boost.org/doc/libs/1_82_0/doc/html/boost_asio/overview.html">Boost.Asio</a>.</li>
</ul>
<p>The latest release can be downloaded on
https://github.com/boostorg/redis/releases. The library headers can be
found in the <code>include</code> subdirectory and a compilation of the
source</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/redis/src.hpp&gt;</span></span></code></pre></div>
<p>is required. The simplest way to do it is to included this header in
no more than one source file in your applications. To build the examples
and tests cmake is supported, for example</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp"># </span><span class="er">Linux</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="er">$</span> <span class="ex">BOOST_</span>ROOT<span class="op">=/</span>opt<span class="op">/</span>boost_1_84_0 cmake <span class="op">--</span>preset g<span class="op">++-</span><span class="dv">11</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="pp"># </span><span class="er">Windows </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="er">$</span> cmake <span class="op">-</span>G <span class="st">&quot;Visual Studio 17 2022&quot;</span> <span class="op">-</span>A x64 <span class="op">-</span>B bin64 <span class="op">-</span>DCMAKE_TOOLCHAIN_FILE<span class="op">=</span>C<span class="op">:/</span>vcpkg<span class="op">/</span>scripts<span class="op">/</span>buildsystems<span class="op">/</span>vcpkg<span class="op">.</span>cmake</span></code></pre></div>
<p><a name="connection"></a> ## Connection</p>
<p>Let us start with a simple application that uses a short-lived
connection to send a <a href="https://redis.io/commands/ping/">ping</a>
command to Redis</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> co_main<span class="op">(</span>config <span class="at">const</span><span class="op">&amp;</span> cfg<span class="op">)</span> <span class="op">-&gt;</span> net<span class="op">::</span>awaitable<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> conn <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>connection<span class="op">&gt;(</span><span class="cf">co_await</span> net<span class="op">::</span>this_coro<span class="op">::</span>executor<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>   conn<span class="op">-&gt;</span>async_run<span class="op">(</span>cfg<span class="op">,</span> <span class="op">{},</span> net<span class="op">::</span>consign<span class="op">(</span>net<span class="op">::</span>detached<span class="op">,</span> conn<span class="op">));</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// A request containing only a ping command.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>   request req<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>   req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;PING&quot;</span><span class="op">,</span> <span class="st">&quot;Hello world&quot;</span><span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Response where the PONG response will be stored.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>   response<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> resp<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Executes the request.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> resp<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>   conn<span class="op">-&gt;</span>cancel<span class="op">();</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;PING: &quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>resp<span class="op">).</span>value<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The roles played by the <code>async_run</code> and
<code>async_exec</code> functions are</p>
<ul>
<li><code>async_exec</code>: Execute the commands contained in the
request and store the individual responses in the <code>resp</code>
object. Can be called from multiple places in your code
concurrently.</li>
<li><code>async_run</code>: Resolve, connect, ssl-handshake,
resp3-handshake, health-checks, reconnection and coordinate low-level
read and write operations (among other things).</li>
</ul>
<h3 id="server-pushes">Server pushes</h3>
<p>Redis servers can also send a variety of pushes to the client, some
of them are</p>
<ul>
<li><a href="https://redis.io/docs/manual/pubsub/">Pubsub</a></li>
<li><a
href="https://redis.io/docs/manual/keyspace-notifications/">Keyspace
notification</a></li>
<li><a
href="https://redis.io/docs/manual/client-side-caching/">Client-side
caching</a></li>
</ul>
<p>The connection class supports server pushes by means of the
<code>boost::redis::connection::async_receive</code> function, which can
be called in the same connection that is being used to execute commands.
The coroutine below shows how to used it</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>receiver<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>connection<span class="op">&gt;</span> conn<span class="op">)</span> <span class="op">-&gt;</span> net<span class="op">::</span>awaitable<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>   request req<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;SUBSCRIBE&quot;</span><span class="op">,</span> <span class="st">&quot;channel&quot;</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>   generic_response resp<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   conn<span class="op">-&gt;</span>set_receive_response<span class="op">(</span>resp<span class="op">);</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Loop while reconnection is enabled</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>conn<span class="op">-&gt;</span>will_reconnect<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Reconnect to channels.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> ignore<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Loop reading Redis pushes.</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>         error_code ec<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>         <span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_receive<span class="op">(</span>resp<span class="op">,</span> net<span class="op">::</span>redirect_error<span class="op">(</span>net<span class="op">::</span>use_awaitable<span class="op">,</span> ec<span class="op">));</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">(</span>ec<span class="op">)</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span> <span class="co">// Connection lost, break so we can reconnect to channels.</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>         <span class="co">// Use the response resp in some way and then clear it.</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>         <span class="op">...</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>         consume_one<span class="op">(</span>resp<span class="op">);</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><a name="requests"></a> ## Requests</p>
<p>Redis requests are composed of one or more commands (in the Redis
documentation they are called <a
href="https://redis.io/topics/pipelining">pipelines</a>). For
example</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Some example containers.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>list<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> list <span class="op">{...};</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> mystruct<span class="op">&gt;</span> map <span class="op">{</span> <span class="op">...};</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// The request can contain multiple commands.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>request req<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Command with variable length of arguments.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;SET&quot;</span><span class="op">,</span> <span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;some value&quot;</span><span class="op">,</span> <span class="st">&quot;EX&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Pushes a list.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push_range<span class="op">(</span><span class="st">&quot;SUBSCRIBE&quot;</span><span class="op">,</span> list<span class="op">);</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Same as above but as an iterator range.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push_range<span class="op">(</span><span class="st">&quot;SUBSCRIBE&quot;</span><span class="op">,</span> <span class="bu">std::</span>cbegin<span class="op">(</span>list<span class="op">),</span> <span class="bu">std::</span>cend<span class="op">(</span>list<span class="op">));</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Pushes a map.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push_range<span class="op">(</span><span class="st">&quot;HSET&quot;</span><span class="op">,</span> <span class="st">&quot;key&quot;</span><span class="op">,</span> map<span class="op">);</span></span></code></pre></div>
<p>Sending a request to Redis is performed with
<code>boost::redis::connection::async_exec</code> as already stated.</p>
<h3 id="config-flags">Config flags</h3>
<p>The <code>boost::redis::request::config</code> object inside the
request dictates how the <code>boost::redis::connection</code> should
handle the request in some important situations. The reader is advised
to read it carefully.</p>
<p><a name="responses"></a> ## Responses</p>
<p>Boost.Redis uses the following strategy to support Redis
responses</p>
<ul>
<li><code>boost::redis::request</code> is used for requests whose number
of commands are not dynamic.</li>
<li><strong>Dynamic</strong>: Otherwise use
<code>boost::redis::generic_response</code>.</li>
</ul>
<p>For example, the request below has three commands</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>request req<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;PING&quot;</span><span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;INCR&quot;</span><span class="op">,</span> <span class="st">&quot;key&quot;</span><span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;QUIT&quot;</span><span class="op">);</span></span></code></pre></div>
<p>and its response also has three comamnds and can be read in the
following response object</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>response<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span></span></code></pre></div>
<p>The response behaves as a tuple and must have as many elements as the
request has commands (exceptions below). It is also necessary that each
tuple element is capable of storing the response to the command it
refers to, otherwise an error will occur. To ignore responses to
individual commands in the request use the tag
<code>boost::redis::ignore_t</code>, for example</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Ignore the second and last responses.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>response<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="ex">boost::</span>redis::ignore_t<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="ex">boost::</span>redis::ignore_t<span class="op">&gt;</span></span></code></pre></div>
<p>The following table provides the resp3-types returned by some Redis
commands</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 61%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>RESP3 type</th>
<th>Documentation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lpush</td>
<td>Number</td>
<td>https://redis.io/commands/lpush</td>
</tr>
<tr class="even">
<td>lrange</td>
<td>Array</td>
<td>https://redis.io/commands/lrange</td>
</tr>
<tr class="odd">
<td>set</td>
<td>Simple-string, null or blob-string</td>
<td>https://redis.io/commands/set</td>
</tr>
<tr class="even">
<td>get</td>
<td>Blob-string</td>
<td>https://redis.io/commands/get</td>
</tr>
<tr class="odd">
<td>smembers</td>
<td>Set</td>
<td>https://redis.io/commands/smembers</td>
</tr>
<tr class="even">
<td>hgetall</td>
<td>Map</td>
<td>https://redis.io/commands/hgetall</td>
</tr>
</tbody>
</table>
<p>To map these RESP3 types into a C++ data structure use the table
below</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 65%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>RESP3 type</th>
<th>Possible C++ type</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple-string</td>
<td><code>std::string</code></td>
<td>Simple</td>
</tr>
<tr class="even">
<td>Simple-error</td>
<td><code>std::string</code></td>
<td>Simple</td>
</tr>
<tr class="odd">
<td>Blob-string</td>
<td><code>std::string</code>, <code>std::vector</code></td>
<td>Simple</td>
</tr>
<tr class="even">
<td>Blob-error</td>
<td><code>std::string</code>, <code>std::vector</code></td>
<td>Simple</td>
</tr>
<tr class="odd">
<td>Number</td>
<td><code>long long</code>, <code>int</code>, <code>std::size_t</code>,
<code>std::string</code></td>
<td>Simple</td>
</tr>
<tr class="even">
<td>Double</td>
<td><code>double</code>, <code>std::string</code></td>
<td>Simple</td>
</tr>
<tr class="odd">
<td>Null</td>
<td><code>std::optional&lt;T&gt;</code></td>
<td>Simple</td>
</tr>
<tr class="even">
<td>Array</td>
<td><code>std::vector</code>, <code>std::list</code>,
<code>std::array</code>, <code>std::deque</code></td>
<td>Aggregate</td>
</tr>
<tr class="odd">
<td>Map</td>
<td><code>std::vector</code>, <code>std::map</code>,
<code>std::unordered_map</code></td>
<td>Aggregate</td>
</tr>
<tr class="even">
<td>Set</td>
<td><code>std::vector</code>, <code>std::set</code>,
<code>std::unordered_set</code></td>
<td>Aggregate</td>
</tr>
<tr class="odd">
<td>Push</td>
<td><code>std::vector</code>, <code>std::map</code>,
<code>std::unordered_map</code></td>
<td>Aggregate</td>
</tr>
</tbody>
</table>
<p>For example, the response to the request</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>request req<span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;HELLO&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push_range<span class="op">(</span><span class="st">&quot;RPUSH&quot;</span><span class="op">,</span> <span class="st">&quot;key1&quot;</span><span class="op">,</span> vec<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push_range<span class="op">(</span><span class="st">&quot;HSET&quot;</span><span class="op">,</span> <span class="st">&quot;key2&quot;</span><span class="op">,</span> map<span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;LRANGE&quot;</span><span class="op">,</span> <span class="st">&quot;key3&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;HGETALL&quot;</span><span class="op">,</span> <span class="st">&quot;key4&quot;</span><span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;QUIT&quot;</span><span class="op">);</span></span></code></pre></div>
<p>can be read in the tuple below</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>response<span class="op">&lt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   redis<span class="op">::</span><span class="dt">ignore_t</span><span class="op">,</span>  <span class="co">// hello</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span><span class="op">,</span>              <span class="co">// rpush</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span><span class="op">,</span>              <span class="co">// hset</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;,</span>   <span class="co">// lrange</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>map<span class="op">&lt;</span>U<span class="op">,</span> V<span class="op">&gt;,</span>   <span class="co">// hgetall</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>string       <span class="co">// quit</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> resp<span class="op">;</span></span></code></pre></div>
<p>Where both are passed to <code>async_exec</code> as showed
elsewhere</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> resp<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span></code></pre></div>
<p>If the intention is to ignore responses altogether use
<code>ignore</code></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Ignores the response</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> ignore<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span></code></pre></div>
<p>Responses that contain nested aggregates or heterogeneous data types
will be given special treatment later in <a href="#the-general-case">The
general case</a>. As of this writing, not all RESP3 types are used by
the Redis server, which means in practice users will be concerned with a
reduced subset of the RESP3 specification.</p>
<h3 id="pushes">Pushes</h3>
<p>Commands that have no response like</p>
<ul>
<li><code>"SUBSCRIBE"</code></li>
<li><code>"PSUBSCRIBE"</code></li>
<li><code>"UNSUBSCRIBE"</code></li>
</ul>
<p>must <strong>NOT</strong> be included in the response tuple. For
example, the request below</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>request req<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;PING&quot;</span><span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;SUBSCRIBE&quot;</span><span class="op">,</span> <span class="st">&quot;channel&quot;</span><span class="op">);</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;QUIT&quot;</span><span class="op">);</span></span></code></pre></div>
<p>must be read in this tuple
<code>response&lt;std::string, std::string&gt;</code>, that has static
size two.</p>
<h3 id="null">Null</h3>
<p>It is not uncommon for apps to access keys that do not exist or that
have already expired in the Redis server, to deal with these cases
Boost.Redis provides support for <code>std::optional</code>. To use it,
wrap your type around <code>std::optional</code> like this</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>response<span class="op">&lt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>optional<span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>optional<span class="op">&lt;</span>B<span class="op">&gt;,</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">...</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">&gt;</span> resp<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> resp<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span></code></pre></div>
<p>Everything else stays pretty much the same.</p>
<h3 id="transactions">Transactions</h3>
<p>To read responses to transactions we must first observe that Redis
will queue the transaction commands and send their individual responses
as elements of an array, the array is itself the response to the
<code>EXEC</code> command. For example, to read the response to this
request</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;MULTI&quot;</span><span class="op">);</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;GET&quot;</span><span class="op">,</span> <span class="st">&quot;key1&quot;</span><span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;LRANGE&quot;</span><span class="op">,</span> <span class="st">&quot;key2&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;HGETALL&quot;</span><span class="op">,</span> <span class="st">&quot;key3&quot;</span><span class="op">);</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span>push<span class="op">(</span><span class="st">&quot;EXEC&quot;</span><span class="op">);</span></span></code></pre></div>
<p>use the following response type</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="ex">boost::</span>redis::ignore<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">exec_resp_type</span> <span class="op">=</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>   response<span class="op">&lt;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;,</span> <span class="co">// get</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;,</span> <span class="co">// lrange</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;&gt;</span> <span class="co">// hgetall</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">&gt;;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>response<span class="op">&lt;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>   <span class="ex">boost::</span>redis::ignore_t<span class="op">,</span>  <span class="co">// multi</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>   <span class="ex">boost::</span>redis::ignore_t<span class="op">,</span>  <span class="co">// get</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>   <span class="ex">boost::</span>redis::ignore_t<span class="op">,</span>  <span class="co">// lrange</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>   <span class="ex">boost::</span>redis::ignore_t<span class="op">,</span>  <span class="co">// hgetall</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>   <span class="dt">exec_resp_type</span><span class="op">,</span>        <span class="co">// exec</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> resp<span class="op">;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> resp<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span></code></pre></div>
<p>For a complete example see cpp20_containers.cpp.</p>
<p><a name="the-general-case"></a></p>
<h3 id="the-general-case">The general case</h3>
<p>There are cases where responses to Redis commands won’t fit in the
model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don’t have a fixed
RESP3 type. Expecting an <code>int</code> and receiving a blob-string
will result in error.</li>
<li>RESP3 aggregates that contain nested aggregates can’t be read in STL
containers.</li>
<li>Transactions with a dynamic number of commands can’t be read in a
<code>response</code>.</li>
</ul>
<p>To deal with these cases Boost.Redis provides the
<code>boost::redis::resp3::node</code> type abstraction, that is the
most general form of an element in a response, be it a simple RESP3 type
or the element of an aggregate. It is defined like this</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> String<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> basic_node <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>   <span class="co">// The RESP3 type of the data in this node.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>   type <span class="dt">data_type</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// The number of elements of an aggregate (or 1 for simple data).</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>size_t aggregate_size<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>   <span class="co">// The depth of this node in the response tree.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>size_t depth<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>   <span class="co">// The actual data. For aggregate types this is always empty.</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>   String value<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Any response to a Redis command can be received in a
<code>boost::redis::generic_response</code>. The vector can be seen as a
pre-order view of the response tree. Using it is not different than
using other types</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Receives any RESP3 simple or aggregate data type.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ex">boost::</span>redis::generic_response resp<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="cf">co_await</span> conn<span class="op">-&gt;</span>async_exec<span class="op">(</span>req<span class="op">,</span> resp<span class="op">,</span> net<span class="op">::</span>deferred<span class="op">);</span></span></code></pre></div>
<p>For example, suppose we want to retrieve a hash data structure from
Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code>boost::redis::generic_response</code>: Works always.</li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all
elements as string.</li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if
you need the data as a <code>std::map</code>.</li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing
serialized data. Avoids temporaries and requires
<code>boost_redis_from_bulk</code> for <code>U</code> and
<code>V</code>.</li>
</ul>
<p>In addition to the above users can also use unordered versions of the
containers. The same reasoning applies to sets
e.g. <code>SMEMBERS</code> and other data structures in general.</p>
<p><a name="serialization"></a> ## Serialization</p>
<p>Boost.Redis supports serialization of user defined types by means of
the following customization points</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Serialize.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> boost_redis_to_bulk<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;</span> to<span class="op">,</span> mystruct <span class="at">const</span><span class="op">&amp;</span> obj<span class="op">);</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Deserialize</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> boost_redis_from_bulk<span class="op">(</span>mystruct<span class="op">&amp;</span> obj<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> p<span class="op">,</span> <span class="bu">std::</span>size_t size<span class="op">,</span> <span class="ex">boost::</span>system::error_code<span class="op">&amp;</span> ec<span class="op">)</span></span></code></pre></div>
<p>These functions are accessed over ADL and therefore they must be
imported in the global namespace by the user. In the <a
href="#examples">Examples</a> section the reader can find examples
showing how to serialize using json and <a
href="https://protobuf.dev/">protobuf</a>.</p>
<p><a name="examples"></a> ## Examples</p>
<p>The examples below show how to use the features discussed so far</p>
<ul>
<li>cpp20_intro.cpp: Does not use awaitable operators.</li>
<li>cpp20_intro_tls.cpp: Communicates over TLS.</li>
<li>cpp20_containers.cpp: Shows how to send and receive STL containers
and how to use transactions.</li>
<li>cpp20_json.cpp: Shows how to serialize types using Boost.Json.</li>
<li>cpp20_protobuf.cpp: Shows how to serialize types using
protobuf.</li>
<li>cpp20_resolve_with_sentinel.cpp: Shows how to resolve a master
address using sentinels.</li>
<li>cpp20_subscriber.cpp: Shows how to implement pubsub with
reconnection re-subscription.</li>
<li>cpp20_echo_server.cpp: A simple TCP echo server.</li>
<li>cpp20_chat_room.cpp: A command line chat built on Redis pubsub.</li>
<li>cpp17_intro.cpp: Uses callbacks and requires C++17.</li>
<li>cpp17_intro_sync.cpp: Runs <code>async_run</code> in a separate
thread and performs synchronous calls to <code>async_exec</code>.</li>
</ul>
<p>The main function used in some async examples has been factored out
in the main.cpp file.</p>
<h2 id="echo-server-benchmark">Echo server benchmark</h2>
<p>This document benchmarks the performance of TCP echo servers I
implemented in different languages using different Redis clients. The
main motivations for choosing an echo server are</p>
<ul>
<li>Simple to implement and does not require expertise level in most
languages.</li>
<li>I/O bound: Echo servers have very low CPU consumption in general and
therefore are excelent to measure how a program handles concurrent
requests.</li>
<li>It simulates very well a typical backend in regard to
concurrency.</li>
</ul>
<p>I also imposed some constraints on the implementations</p>
<ul>
<li>It should be simple enough and not require writing too much
code.</li>
<li>Favor the use standard idioms and avoid optimizations that require
expert level.</li>
<li>Avoid the use of complex things like connection and thread
pool.</li>
</ul>
<p>To reproduce these results run one of the echo-server programs in one
terminal and the <a
href="https://github.com/boostorg/redis/blob/42880e788bec6020dd018194075a211ad9f339e8/benchmarks/cpp/asio/echo_server_client.cpp">echo-server-client</a>
in another.</p>
<h3 id="without-redis">Without Redis</h3>
<p>First I tested a pure TCP echo server, i.e. one that sends the
messages directly to the client without interacting with Redis. The
result can be seen below</p>
<p><img
src="https://boostorg.github.io/redis/tcp-echo-direct.png" /></p>
<p>The tests were performed with a 1000 concurrent TCP connections on
the localhost where latency is 0.07ms on average on my machine. On
higher latency networks the difference among libraries is expected to
decrease.</p>
<ul>
<li>I expected Libuv to have similar performance to Asio and Tokio.</li>
<li>I did expect nodejs to come a little behind given it is is
javascript code. Otherwise I did expect it to have similar performance
to libuv since it is the framework behind it.</li>
<li>Go did surprise me: faster than nodejs and libuv!</li>
</ul>
<p>The code used in the benchmarks can be found at</p>
<ul>
<li><a
href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/cpp/asio/echo_server_direct.cpp">Asio</a>:
A variation of <a
href="https://github.com/chriskohlhoff/asio/blob/4915cfd8a1653c157a1480162ae5601318553eb8/asio/src/examples/cpp20/coroutines/echo_server.cpp">this</a>
Asio example.</li>
<li><a
href="https://github.com/boostorg/redis/tree/835a1decf477b09317f391eddd0727213cdbe12b/benchmarks/c/libuv">Libuv</a>:
Taken from <a
href="https://github.com/libuv/libuv/blob/06948c6ee502862524f233af4e2c3e4ca876f5f6/docs/code/tcp-echo-server/main.c">here</a>
Libuv example .</li>
<li><a
href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/rust/echo_server_direct">Tokio</a>:
Taken from <a href="https://docs.rs/tokio/latest/tokio/">here</a>.</li>
<li><a
href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_direct">Nodejs</a></li>
<li><a
href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_direct.go">Go</a></li>
</ul>
<h3 id="with-redis">With Redis</h3>
<p>This is similar to the echo server described above but messages are
echoed by Redis and not by the echo-server itself, which acts as a proxy
between the client and the Redis server. The results can be seen
below</p>
<p><img
src="https://boostorg.github.io/redis/tcp-echo-over-redis.png" /></p>
<p>The tests were performed on a network where latency is 35ms on
average, otherwise it uses the same number of TCP connections as the
previous example.</p>
<p>As the reader can see, the Libuv and the Rust test are not depicted
in the graph, the reasons are</p>
<ul>
<li><p><a href="https://github.com/redis-rs/redis-rs">redis-rs</a>: This
client comes so far behind that it can’t even be represented together
with the other benchmarks without making them look insignificant. I
don’t know for sure why it is so slow, I suppose it has something to do
with its lack of automatic <a
href="https://redis.io/docs/manual/pipelining/">pipelining</a> support.
In fact, the more TCP connections I lauch the worse its performance
gets.</p></li>
<li><p>Libuv: I left it out because it would require me writing to much
c code. More specifically, I would have to use hiredis and implement
support for pipelines manually.</p></li>
</ul>
<p>The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/boostorg/redis">Boost.Redis</a>: <a
href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/examples/echo_server.cpp">code</a></li>
<li><a href="https://github.com/redis/node-redis">node-redis</a>: <a
href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_over_redis">code</a></li>
<li><a href="https://github.com/go-redis/redis">go-redis</a>: <a
href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_over_redis.go">code</a></li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>Redis clients have to support automatic pipelining to have
competitive performance. For updates to this document follow
https://github.com/boostorg/redis.</p>
<h2 id="comparison">Comparison</h2>
<p>The main reason for why I started writing Boost.Redis was to have a
client compatible with the Asio asynchronous model. As I made progresses
I could also address what I considered weaknesses in other libraries.
Due to time constraints I won’t be able to give a detailed comparison
with each client listed in the <a
href="https://redis.io/docs/clients/#cpp">official</a> list, instead I
will focus on the most popular C++ client on github in number of stars,
namely</p>
<ul>
<li>https://github.com/sewenew/redis-plus-plus</li>
</ul>
<h3 id="boost.redis-vs-redis-plus-plus">Boost.Redis vs
Redis-plus-plus</h3>
<p>Before we start it is important to mention some of the things
redis-plus-plus does not support</p>
<ul>
<li>The latest version of the communication protocol RESP3. Without that
it is impossible to support some important Redis features like client
side caching, among other things.</li>
<li>Coroutines.</li>
<li>Reading responses directly in user data structures to avoid creating
temporaries.</li>
<li>Error handling with support for error-code.</li>
<li>Cancellation.</li>
</ul>
<p>The remaining points will be addressed individually. Let us first
have a look at what sending a command a pipeline and a transaction look
like</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> redis <span class="op">=</span> Redis<span class="op">(</span><span class="st">&quot;tcp://127.0.0.1:6379&quot;</span><span class="op">);</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Send commands</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>redis<span class="op">.</span>set<span class="op">(</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;val&quot;</span><span class="op">);</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> val <span class="op">=</span> redis<span class="op">.</span>get<span class="op">(</span><span class="st">&quot;key&quot;</span><span class="op">);</span> <span class="co">// val is of type OptionalString.</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>val<span class="op">)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">*</span>val <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending pipelines</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipe <span class="op">=</span> redis<span class="op">.</span>pipeline<span class="op">();</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipe_replies <span class="op">=</span> pipe<span class="op">.</span>set<span class="op">(</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;value&quot;</span><span class="op">)</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>get<span class="op">(</span><span class="st">&quot;key&quot;</span><span class="op">)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>rename<span class="op">(</span><span class="st">&quot;key&quot;</span><span class="op">,</span> <span class="st">&quot;new-key&quot;</span><span class="op">)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>rpush<span class="op">(</span><span class="st">&quot;list&quot;</span><span class="op">,</span> <span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">})</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>lrange<span class="op">(</span><span class="st">&quot;list&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>exec<span class="op">();</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Parse reply with reply type and index.</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> set_cmd_result <span class="op">=</span> pipe_replies<span class="op">.</span>get<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending a transaction</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> tx <span class="op">=</span> redis<span class="op">.</span>transaction<span class="op">();</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> tx_replies <span class="op">=</span> tx<span class="op">.</span>incr<span class="op">(</span><span class="st">&quot;num0&quot;</span><span class="op">)</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>incr<span class="op">(</span><span class="st">&quot;num1&quot;</span><span class="op">)</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>mget<span class="op">({</span><span class="st">&quot;num0&quot;</span><span class="op">,</span> <span class="st">&quot;num1&quot;</span><span class="op">})</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>exec<span class="op">();</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> incr_result0 <span class="op">=</span> tx_replies<span class="op">.</span>get<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This
makes auto-pipelining impossible.</li>
<li>Any Api that sends individual commands has a very restricted scope
of usability and should be avoided for performance reasons.</li>
<li>The API imposes exceptions on users, no error-code overload is
provided.</li>
<li>No way to reuse the buffer for new calls to e.g. redis.get in order
to avoid further dynamic memory allocations.</li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p>According to the documentation, pipelines in redis-plus-plus have the
following characteristics</p>
<blockquote>
<p>NOTE: By default, creating a Pipeline object is NOT cheap, since it
creates a new connection.</p>
</blockquote>
<p>This is clearly a downside in the API as pipelines should be the
default way of communicating and not an exception, paying such a high
price for each pipeline imposes a severe cost in performance.
Transactions also suffer from the very same problem.</p>
<blockquote>
<p>NOTE: Creating a Transaction object is NOT cheap, since it creates a
new connection.</p>
</blockquote>
<p>In Boost.Redis there is no difference between sending one command, a
pipeline or a transaction because requests are decoupled from the IO
objects.</p>
<blockquote>
<p>redis-plus-plus also supports async interface, however, async support
for Transaction and Subscriber is still on the way.</p>
<p>The async interface depends on third-party event library, and so far,
only libuv is supported.</p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> async_redis <span class="op">=</span> AsyncRedis<span class="op">(</span>opts<span class="op">,</span> pool_opts<span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>Future<span class="op">&lt;</span>string<span class="op">&gt;</span> ping_res <span class="op">=</span> async_redis<span class="op">.</span>ping<span class="op">();</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> ping_res<span class="op">.</span>get<span class="op">()</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span></code></pre></div>
<p>As the reader can see, the async interface is based on futures which
is also known to have a bad performance. The biggest problem however
with this async design is that it makes it impossible to write
asynchronous programs correctly since it starts an async operation on
every command sent instead of enqueueing a message and triggering a
write when it can be sent. It is also not clear how are pipelines
realised with this design (if at all).</p>
<p><a name="api-reference"></a> ## Reference</p>
<p>The <a href="#high-level-api">High-Level</a> page documents all
public types.</p>
<h2 id="acknowledgement">Acknowledgement</h2>
<p>Acknowledgement to people that helped shape Boost.Redis</p>
<ul>
<li>Richard Hodges (<a
href="https://github.com/madmongo1">madmongo1</a>): For very helpful
support with Asio, the design of asynchronous programs, etc.</li>
<li>Vinícius dos Santos Oliveira (<a
href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful
discussion about how Boost.Redis consumes buffers in the read
operation.</li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>):
For helping me understand how the <code>AUTH</code> and
<code>HELLO</code> command can influence each other.</li>
<li>Mohammad Nejati (<a href="https://github.com/ashtum">ashtum</a>):
For pointing out scenarios where calls to <code>async_exec</code> should
fail when the connection is lost.</li>
<li>Klemens Morgenstern (<a
href="https://github.com/klemens-morgenstern">klemens-morgenstern</a>):
For useful discussion about timeouts, cancellation, synchronous
interfaces and general help with Asio.</li>
<li>Vinnie Falco (<a
href="https://github.com/vinniefalco">vinniefalco</a>): For general
suggestions about how to improve the code and the documentation.</li>
<li>Bram Veldhoen (<a
href="https://github.com/bveldhoen">bveldhoen</a>): For contributing a
Redis-streams example.</li>
</ul>
<p>Also many thanks to all individuals that participated in the Boost
review</p>
<ul>
<li>Zach Laine:
https://lists.boost.org/Archives/boost/2023/01/253883.php</li>
<li>Vinnie Falco:
https://lists.boost.org/Archives/boost/2023/01/253886.php</li>
<li>Christian Mazakas:
https://lists.boost.org/Archives/boost/2023/01/253900.php</li>
<li>Ruben Perez:
https://lists.boost.org/Archives/boost/2023/01/253915.php</li>
<li>Dmitry Arkhipov:
https://lists.boost.org/Archives/boost/2023/01/253925.php</li>
<li>Alan de Freitas:
https://lists.boost.org/Archives/boost/2023/01/253927.php</li>
<li>Mohammad Nejati:
https://lists.boost.org/Archives/boost/2023/01/253929.php</li>
<li>Sam Hartsfield:
https://lists.boost.org/Archives/boost/2023/01/253931.php</li>
<li>Miguel Portilla:
https://lists.boost.org/Archives/boost/2023/01/253935.php</li>
<li>Robert A.H. Leahy:
https://lists.boost.org/Archives/boost/2023/01/253928.php</li>
</ul>
<p>The Reviews can be found at:
https://lists.boost.org/Archives/boost/2023/01/date.php. The thread with
the ACCEPT from the review manager can be found here:
https://lists.boost.org/Archives/boost/2023/01/253944.php.</p>
<h2 id="changelog">Changelog</h2>
<h3 id="boost-1.85">Boost 1.85</h3>
<ul>
<li><p>(<a href="https://github.com/boostorg/redis/issues/170">Issue
170</a>) Under load and on low-latency networks it is possible to start
receiving responses before the write operation completed and while the
request is still marked as staged and not written. This messes up with
the heuristics that classifies responses as unsolicied or not.</p></li>
<li><p>(<a href="https://github.com/boostorg/redis/issues/168">Issue
168</a>). Provides a way of passing a custom SSL context to the
connection. The design here differs from that of Boost.Beast and
Boost.MySql since in Boost.Redis the connection owns the context instead
of only storing a reference to a user provided one. This is ok so
because apps need only one connection for their entire application,
which makes the overhead of one ssl-context per connection
negligible.</p></li>
<li><p>(<a href="https://github.com/boostorg/redis/issues/181">Issue
181</a>). See a detailed description of this bug in <a
href="https://github.com/boostorg/redis/issues/181#issuecomment-1913346983">this</a>
comment.</p></li>
<li><p>(<a href="https://github.com/boostorg/redis/issues/182">Issue
182</a>). Sets <code>"default"</code> as the default value of
<code>config::username</code>. This makes it simpler to use the
<code>requirepass</code> configuration in Redis.</p></li>
<li><p>(<a href="https://github.com/boostorg/redis/issues/189">Issue
189</a>). Fixes narrowing convertion by using <code>std::size_t</code>
instead of <code>std::uint64_t</code> for the sizes of bulks and
aggregates. The code relies now on <code>std::from_chars</code>
returning an error if a value greater than 32 is received on platforms
on which the size of<code>std::size_t</code> is 32.</p></li>
</ul>
<h3 id="boost-1.84-first-release-in-boost">Boost 1.84 (First release in
Boost)</h3>
<ul>
<li><p>Deprecates the <code>async_receive</code> overload that takes a
response. Users should now first call <code>set_receive_response</code>
to avoid constantly and unnecessarily setting the same
response.</p></li>
<li><p>Uses <code>std::function</code> to type erase the response
adapter. This change should not influence users in any way but allowed
important simplification in the connections internals. This resulted in
massive performance improvement.</p></li>
<li><p>The connection has a new member <code>get_usage()</code> that
returns the connection usage information, such as number of bytes
written, received etc.</p></li>
<li><p>There are massive performance improvements in the consuming of
server pushes which are now communicated with an
<code>asio::channel</code> and therefore can be buffered which avoids
blocking the socket read-loop. Batch reads are also supported by means
of <code>channel.try_send</code> and buffered messages can be consumed
synchronously with <code>connection::receive</code>. The function
<code>boost::redis::cancel_one</code> has been added to simplify
processing multiple server pushes contained in the same
<code>generic_response</code>. <em>IMPORTANT</em>: These changes may
result in more than one push in the response when
<code>connection::async_receive</code> resumes. The user must therefore
be careful when calling <code>resp.clear()</code>: either ensure that
all message have been processed or just use
<code>consume_one</code>.</p></li>
</ul>
<h3
id="v1.4.2-incorporates-changes-to-conform-the-boost-review-and-more">v1.4.2
(incorporates changes to conform the boost review and more)</h3>
<ul>
<li><p>Adds <code>boost::redis::config::database_index</code> to make it
possible to choose a database before starting running commands
e.g. after an automatic reconnection.</p></li>
<li><p>Massive performance improvement. One of my tests went from 140k
req/s to 390k/s. This was possible after a parser simplification that
reduced the number of reschedules and buffer rotations.</p></li>
<li><p>Adds Redis stream example.</p></li>
<li><p>Renames the project to Boost.Redis and moves the code into
namespace <code>boost::redis</code>.</p></li>
<li><p>As pointed out in the reviews the <code>to_bulk</code> and
<code>from_bulk</code> names were too generic for ADL customization
points. They gained the prefix <code>boost_redis_</code>.</p></li>
<li><p>Moves <code>boost::redis::resp3::request</code> to
<code>boost::redis::request</code>.</p></li>
<li><p>Adds new typedef <code>boost::redis::response</code> that should
be used instead of <code>std::tuple</code>.</p></li>
<li><p>Adds new typedef <code>boost::redis::generic_response</code> that
should be used instead of
<code>std::vector&lt;resp3::node&lt;std::string&gt;&gt;</code>.</p></li>
<li><p>Renames <code>redis::ignore</code> to
<code>redis::ignore_t</code>.</p></li>
<li><p>Changes <code>async_exec</code> to receive a
<code>redis::response</code> instead of an adapter, namely, instead of
passing <code>adapt(resp)</code> users should pass <code>resp</code>
directly.</p></li>
<li><p>Introduces <code>boost::redis::adapter::result</code> to store
responses to commands including possible resp3 errors without losing the
error diagnostic part. To access values now use
<code>std::get&lt;N&gt;(resp).value()</code> instead of
<code>std::get&lt;N&gt;(resp)</code>.</p></li>
<li><p>Implements full-duplex communication. Before these changes the
connection would wait for a response to arrive before sending the next
one. Now requests are continuously coalesced and written to the socket.
<code>request::coalesce</code> became unnecessary and was removed. I
could measure significative performance gains with theses
changes.</p></li>
<li><p>Improves serialization examples using Boost.Describe to serialize
to JSON and protobuf. See cpp20_json.cpp and cpp20_protobuf.cpp for more
details.</p></li>
<li><p>Upgrades to Boost 1.81.0.</p></li>
<li><p>Fixes build with libc++.</p></li>
<li><p>Adds high-level functionality to the connection classes. For
example, <code>boost::redis::connection::async_run</code> will
automatically resolve, connect, reconnect and perform health
checks.</p></li>
</ul>
<h3 id="v1.4.0-1">v1.4.0-1</h3>
<ul>
<li>Renames <code>retry_on_connection_lost</code> to
<code>cancel_if_unresponded</code>. (v1.4.1)</li>
<li>Removes dependency on Boost.Hana, <code>boost::string_view</code>,
Boost.Variant2 and Boost.Spirit.</li>
<li>Fixes build and setup CI on windows.</li>
</ul>
<h3 id="v1.3.0-1">v1.3.0-1</h3>
<ul>
<li><p>Upgrades to Boost 1.80.0</p></li>
<li><p>Removes automatic sending of the <code>HELLO</code> command. This
can’t be implemented properly without bloating the connection class. It
is now a user responsibility to send HELLO. Requests that contain it
have priority over other requests and will be moved to the front of the
queue, see <code>aedis::request::config</code></p></li>
<li><p>Automatic name resolving and connecting have been removed from
<code>aedis::connection::async_run</code>. Users have to do this step
manually now. The reason for this change is that having them built-in
doesn’t offer enough flexibility that is need for boost users.</p></li>
<li><p>Removes healthy checks and idle timeout. This functionality must
now be implemented by users, see the examples. This is part of making
Aedis useful to a larger audience and suitable for the Boost review
process.</p></li>
<li><p>The <code>aedis::connection</code> is now using a typeddef to a
<code>net::ip::tcp::socket</code> and
<code>aedis::ssl::connection</code> to
<code>net::ssl::stream&lt;net::ip::tcp::socket&gt;</code>. Users that
need to use other stream type must now specialize
<code>aedis::basic_connection</code>.</p></li>
<li><p>Adds a low level example of async code.</p></li>
</ul>
<h3 id="v1.2.0">v1.2.0</h3>
<ul>
<li><p><code>aedis::adapt</code> supports now tuples created with
<code>std::tie</code>. <code>aedis::ignore</code> is now an alias to the
type of <code>std::ignore</code>.</p></li>
<li><p>Provides allocator support for the internal queue used in the
<code>aedis::connection</code> class.</p></li>
<li><p>Changes the behaviour of <code>async_run</code> to complete with
success if asio::error::eof is received. This makes it easier to write
composed operations with awaitable operators.</p></li>
<li><p>Adds allocator support in the <code>aedis::request</code> (a
contribution from Klemens Morgenstern).</p></li>
<li><p>Renames <code>aedis::request::push_range2</code> to
<code>push_range</code>. The suffix 2 was used for disambiguation.
Klemens fixed it with SFINAE.</p></li>
<li><p>Renames <code>fail_on_connection_lost</code> to
<code>aedis::request::config::cancel_on_connection_lost</code>. Now, it
will only cause connections to be canceled when <code>async_run</code>
completes.</p></li>
<li><p>Introduces
<code>aedis::request::config::cancel_if_not_connected</code> which will
cause a request to be canceled if <code>async_exec</code> is called
before a connection has been established.</p></li>
<li><p>Introduces new request flag
<code>aedis::request::config::retry</code> that if set to true will
cause the request to not be canceled when it was sent to Redis but
remained unresponded after <code>async_run</code> completed. It provides
a way to avoid executing commands twice.</p></li>
<li><p>Removes the <code>aedis::connection::async_run</code> overload
that takes request and adapter as parameters.</p></li>
<li><p>Changes the way <code>aedis::adapt()</code> behaves with
<code>std::vector&lt;aedis::resp3::node&lt;T&gt;&gt;</code>. Receiving
RESP3 simple errors, blob errors or null won’t causes an error but will
be treated as normal response. It is the user responsibility to check
the content in the vector.</p></li>
<li><p>Fixes a bug in <code>connection::cancel(operation::exec)</code>.
Now this call will only cancel non-written requests.</p></li>
<li><p>Implements per-operation implicit cancellation support for
<code>aedis::connection::async_exec</code>. The following call will
<code>co_await (conn.async_exec(...) || timer.async_wait(...))</code>
will cancel the request as long as it has not been written.</p></li>
<li><p>Changes <code>aedis::connection::async_run</code> completion
signature to <code>f(error_code)</code>. This is how is was in the past,
the second parameter was not helpful.</p></li>
<li><p>Renames <code>operation::receive_push</code> to
<code>aedis::operation::receive</code>.</p></li>
</ul>
<h3 id="v1.1.0-1">v1.1.0-1</h3>
<ul>
<li><p>Removes <code>coalesce_requests</code> from the
<code>aedis::connection::config</code>, it became a request property
now, see <code>aedis::request::config::coalesce</code>.</p></li>
<li><p>Removes <code>max_read_size</code> from the
<code>aedis::connection::config</code>. The maximum read size can be
specified now as a parameter of the <code>aedis::adapt()</code>
function.</p></li>
<li><p>Removes <code>aedis::sync</code> class, see intro_sync.cpp for
how to perform synchronous and thread safe calls. This is possible in
Boost. 1.80 only as it requires
<code>boost::asio::deferred</code>.</p></li>
<li><p>Moves from <code>boost::optional</code> to
<code>std::optional</code>. This is part of moving to C++17.</p></li>
<li><p>Changes the behaviour of the second
<code>aedis::connection::async_run</code> overload so that it always
returns an error when the connection is lost.</p></li>
<li><p>Adds TLS support, see intro_tls.cpp.</p></li>
<li><p>Adds an example that shows how to resolve addresses over
sentinels, see subscriber_sentinel.cpp.</p></li>
<li><p>Adds a
<code>aedis::connection::timeouts::resp3_handshake_timeout</code>. This
is timeout used to send the <code>HELLO</code> command.</p></li>
<li><p>Adds <code>aedis::endpoint</code> where in addition to host and
port, users can optionally provide username, password and the expected
server role (see
<code>aedis::error::unexpected_server_role</code>).</p></li>
<li><p><code>aedis::connection::async_run</code> checks whether the
server role received in the hello command is equal to the expected
server role specified in <code>aedis::endpoint</code>. To skip this
check let the role variable empty.</p></li>
<li><p>Removes reconnect functionality from
<code>aedis::connection</code>. It is possible in simple reconnection
strategies but bloats the class in more complex scenarios, for example,
with sentinel, authentication and TLS. This is trivial to implement in a
separate coroutine. As a result the <code>enum event</code> and
<code>async_receive_event</code> have been removed from the class
too.</p></li>
<li><p>Fixes a bug in <code>connection::async_receive_push</code> that
prevented passing any response adapter other that
<code>adapt(std::vector&lt;node&gt;)</code>.</p></li>
<li><p>Changes the behaviour of <code>aedis::adapt()</code> that caused
RESP3 errors to be ignored. One consequence of it is that
<code>connection::async_run</code> would not exit with failure in
servers that required authentication.</p></li>
<li><p>Changes the behaviour of <code>connection::async_run</code> that
would cause it to complete with success when an error in the
<code>connection::async_exec</code> occurred.</p></li>
<li><p>Ports the buildsystem from autotools to CMake.</p></li>
</ul>
<h3 id="v1.0.0">v1.0.0</h3>
<ul>
<li><p>Adds experimental cmake support for windows users.</p></li>
<li><p>Adds new class <code>aedis::sync</code> that wraps an
<code>aedis::connection</code> in a thread-safe and synchronous API. All
free functions from the <code>sync.hpp</code> are now member functions
of <code>aedis::sync</code>.</p></li>
<li><p>Split <code>aedis::connection::async_receive_event</code> in two
functions, one to receive events and another for server side pushes, see
<code>aedis::connection::async_receive_push</code>.</p></li>
<li><p>Removes collision between <code>aedis::adapter::adapt</code> and
<code>aedis::adapt</code>.</p></li>
<li><p>Adds <code>connection::operation</code> enum to replace
<code>cancel_*</code> member functions with a single cancel function
that gets the operations that should be cancelled as argument.</p></li>
<li><p>Bugfix: a bug on reconnect from a state where the
<code>connection</code> object had unsent commands. It could cause
<code>async_exec</code> to never complete under certain
conditions.</p></li>
<li><p>Bugfix: Documentation of <code>adapt()</code> functions were
missing from Doxygen.</p></li>
</ul>
<h3 id="v0.3.0">v0.3.0</h3>
<ul>
<li><p>Adds <code>experimental::exec</code> and
<code>receive_event</code> functions to offer a thread safe and
synchronous way of executing requests across threads. See
<code>intro_sync.cpp</code> and <code>subscriber_sync.cpp</code> for
examples.</p></li>
<li><p><code>connection::async_read_push</code> was renamed to
<code>async_receive_event</code>.</p></li>
<li><p><code>connection::async_receive_event</code> is now being used to
communicate internal events to the user, such as resolve, connect, push
etc. For examples see cpp20_subscriber.cpp and
<code>connection::event</code>.</p></li>
<li><p>The <code>aedis</code> directory has been moved to
<code>include</code> to look more similar to Boost libraries. Users
should now replace <code>-I/aedis-path</code> with
<code>-I/aedis-path/include</code> in the compiler flags.</p></li>
<li><p>The <code>AUTH</code> and <code>HELLO</code> commands are now
sent automatically. This change was necessary to implement reconnection.
The username and password used in <code>AUTH</code> should be provided
by the user on <code>connection::config</code>.</p></li>
<li><p>Adds support for reconnection. See
<code>connection::enable_reconnect</code>.</p></li>
<li><p>Fixes a bug in the <code>connection::async_run(host, port)</code>
overload that was causing crashes on reconnection.</p></li>
<li><p>Fixes the executor usage in the connection class. Before theses
changes it was imposing <code>any_io_executor</code> on users.</p></li>
<li><p><code>connection::async_receiver_event</code> is not cancelled
anymore when <code>connection::async_run</code> exits. This change makes
user code simpler.</p></li>
<li><p><code>connection::async_exec</code> with host and port overload
has been removed. Use the other <code>connection::async_run</code>
overload.</p></li>
<li><p>The host and port parameters from
<code>connection::async_run</code> have been move to
<code>connection::config</code> to better support authentication and
failover.</p></li>
<li><p>Many simplifications in the <code>chat_room</code>
example.</p></li>
<li><p>Fixes build in clang the compilers and makes some improvements in
the documentation.</p></li>
</ul>
<h3 id="v0.2.0-1">v0.2.0-1</h3>
<ul>
<li>Fixes a bug that happens on very high load. (v0.2.1)</li>
<li>Major rewrite of the high-level API. There is no more need to use
the low-level API anymore.</li>
<li>No more callbacks: Sending requests follows the ASIO asynchronous
model.</li>
<li>Support for reconnection: Pending requests are not canceled when a
connection is lost and are re-sent when a new one is established.</li>
<li>The library is not sending HELLO-3 on user behalf anymore. This is
important to support AUTH properly.</li>
</ul>
<h3 id="v0.1.0-2">v0.1.0-2</h3>
<ul>
<li>Adds reconnect coroutine in the <code>echo_server</code> example.
(v0.1.2)</li>
<li>Corrects <code>client::async_wait_for_data</code> with
<code>make_parallel_group</code> to launch operation. (v0.1.2)</li>
<li>Improvements in the documentation. (v0.1.2)</li>
<li>Avoids dynamic memory allocation in the client class after
reconnection. (v0.1.2)</li>
<li>Improves the documentation and adds some features to the high-level
client. (v.0.1.1)</li>
<li>Improvements in the design and documentation.</li>
</ul>
<h3 id="v0.0.1">v0.0.1</h3>
<ul>
<li>First release to collect design feedback.</li>
</ul>
