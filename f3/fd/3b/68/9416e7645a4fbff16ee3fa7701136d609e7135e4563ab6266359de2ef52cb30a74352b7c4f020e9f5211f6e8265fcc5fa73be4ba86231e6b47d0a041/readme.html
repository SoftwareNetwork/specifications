<h1 id="xtensor"><img src="docs/source/xtensor.svg" alt="xtensor" /></h1>
<p><a href="https://travis-ci.org/QuantStack/xtensor"><img src="https://travis-ci.org/QuantStack/xtensor.svg?branch=master" alt="Travis" /></a> <a href="https://ci.appveyor.com/project/QuantStack/xtensor"><img src="https://ci.appveyor.com/api/projects/status/quf1hllkedr0rxbk?svg=true" alt="Appveyor" /></a> <a href="https://xtensor.readthedocs.io/en/latest/?badge=latest"><img src="http://readthedocs.org/projects/xtensor/badge/?version=latest" alt="Documentation" /></a> <a href="https://mybinder.org/v2/gh/QuantStack/xtensor/stable?filepath=notebooks/xtensor.ipynb"><img src="https://img.shields.io/badge/launch-binder-brightgreen.svg" alt="Binder" /></a> <a href="https://gitter.im/QuantStack/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the Gitter Chat" /></a></p>
<p>Multi-dimensional arrays with broadcasting and lazy computing.</p>
<h2 id="introduction">Introduction</h2>
<p><code>xtensor</code> is a C++ library meant for numerical analysis with multi-dimensional array expressions.</p>
<p><code>xtensor</code> provides</p>
<ul>
<li>an extensible expression system enabling <strong>lazy broadcasting</strong>.</li>
<li>an API following the idioms of the <strong>C++ standard library</strong>.</li>
<li>tools to manipulate array expressions and build upon <code>xtensor</code>.</li>
</ul>
<p>Containers of <code>xtensor</code> are inspired by <a href="http://www.numpy.org">NumPy</a>, the Python array programming library. <strong>Adaptors</strong> for existing data structures to be plugged into our expression system can easily be written.</p>
<p>In fact, <code>xtensor</code> can be used to <strong>process NumPy data structures inplace</strong> using Python's <a href="https://docs.python.org/3/c-api/buffer.html">buffer protocol</a>. Similarly, we can operate on Julia and R arrays. For more details on the NumPy, Julia and R bindings, check out the <a href="https://github.com/QuantStack/xtensor-python">xtensor-python</a>, <a href="https://github.com/QuantStack/Xtensor.jl">xtensor-julia</a> and <a href="https://github.com/QuantStack/xtensor-r">xtensor-r</a> projects respectively.</p>
<p><code>xtensor</code> requires a modern C++ compiler supporting C++14. The following C++ compilers are supported:</p>
<ul>
<li>On Windows platforms, Visual C++ 2015 Update 2, or more recent</li>
<li>On Unix platforms, gcc 4.9 or a recent version of Clang</li>
</ul>
<h2 id="installation">Installation</h2>
<p><code>xtensor</code> is a header-only library. We provide a package for the conda package manager.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">conda</span> install -c conda-forge xtensor</code></pre></div>
<p>Or you can directly install it from the sources:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">cmake</span> -DCMAKE_INSTALL_PREFIX=your_install_prefix
<span class="fu">make</span> install</code></pre></div>
<h2 id="trying-it-online">Trying it online</h2>
<p>To try out xtensor interactively in your web browser, just click on the binder link:</p>
<p><a href="https://mybinder.org/v2/gh/QuantStack/xtensor/stable?filepath=notebooks/xtensor.ipynb"><img src="docs/source/binder-logo.svg" alt="Binder" /></a></p>
<h2 id="documentation">Documentation</h2>
<p>To get started with using <code>xtensor</code>, check out the full documentation</p>
<p>http://xtensor.readthedocs.io/</p>
<h2 id="dependencies">Dependencies</h2>
<p><code>xtensor</code> depends on the <a href="https://github.com/QuantStack/xtl">xtl</a> library and has an optional dependency on the <a href="https://github.com/QuantStack/xsimd">xsimd</a> library:</p>
<table>
<thead>
<tr class="header">
<th><code>xtensor</code></th>
<th><code>xtl</code></th>
<th><code>xsimd</code> (optional)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>master</td>
<td>^0.5.3</td>
<td>^7.0.0</td>
</tr>
<tr class="even">
<td>0.19.4</td>
<td>^0.5.3</td>
<td>^7.0.0</td>
</tr>
<tr class="odd">
<td>0.19.3</td>
<td>^0.5.3</td>
<td>^7.0.0</td>
</tr>
<tr class="even">
<td>0.19.2</td>
<td>^0.5.3</td>
<td>^7.0.0</td>
</tr>
<tr class="odd">
<td>0.19.1</td>
<td>^0.5.1</td>
<td>^7.0.0</td>
</tr>
<tr class="even">
<td>0.19.0</td>
<td>^0.5.1</td>
<td>^7.0.0</td>
</tr>
<tr class="odd">
<td>0.18.2</td>
<td>^0.4.16</td>
<td>^7.0.0</td>
</tr>
<tr class="even">
<td>0.18.1</td>
<td>^0.4.16</td>
<td>^7.0.0</td>
</tr>
<tr class="odd">
<td>0.18.0</td>
<td>^0.4.16</td>
<td>^7.0.0</td>
</tr>
<tr class="even">
<td>0.17.4</td>
<td>^0.4.16</td>
<td>^6.1.4</td>
</tr>
<tr class="odd">
<td>0.17.3</td>
<td>^0.4.15</td>
<td>^6.1.4</td>
</tr>
<tr class="even">
<td>0.17.2</td>
<td>^0.4.15</td>
<td>^6.1.4</td>
</tr>
<tr class="odd">
<td>0.17.1</td>
<td>^0.4.14</td>
<td>^6.1.4</td>
</tr>
<tr class="even">
<td>0.17.0</td>
<td>^0.4.13</td>
<td>^6.1.4</td>
</tr>
</tbody>
</table>
<p>The dependency on <code>xsimd</code> is required if you want to enable SIMD acceleration in <code>xtensor</code>. This can be done by defining the macro <code>XTENSOR_USE_XSIMD</code> <em>before</em> including any header of <code>xtensor</code>.</p>
<h2 id="usage">Usage</h2>
<h3 id="basic-usage">Basic usage</h3>
<p><strong>Initialize a 2-D array and compute the sum of one of its rows and a 1-D array.</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xarray.hpp&quot;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xio.hpp&quot;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xview.hpp&quot;</span>

xt::xarray&lt;<span class="dt">double</span>&gt; arr<span class="dv">1</span>
  {{<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>},
   {<span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">7.0</span>},
   {<span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">7.0</span>}};

xt::xarray&lt;<span class="dt">double</span>&gt; arr<span class="dv">2</span>
  {<span class="fl">5.0</span>, <span class="fl">6.0</span>, <span class="fl">7.0</span>};

xt::xarray&lt;<span class="dt">double</span>&gt; res = xt::view(arr1, <span class="dv">1</span>) + arr2;

<span class="bu">std::</span>cout &lt;&lt; res;</code></pre></div>
<p>Outputs:</p>
<pre><code>{7, 11, 14}</code></pre>
<p><strong>Initialize a 1-D array and reshape it inplace.</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xarray.hpp&quot;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xio.hpp&quot;</span>

xt::xarray&lt;<span class="dt">int</span>&gt; arr
  {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};

arr.reshape({<span class="dv">3</span>, <span class="dv">3</span>});

<span class="bu">std::</span>cout &lt;&lt; arr;</code></pre></div>
<p>Outputs:</p>
<pre><code>{{1, 2, 3},
 {4, 5, 6},
 {7, 8, 9}}</code></pre>
<p><strong>Index Access</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xarray.hpp&quot;</span>
<span class="pp">#include </span><span class="im">&quot;xtensor/xio.hpp&quot;</span>

xt::xarray&lt;<span class="dt">double</span>&gt; arr<span class="dv">1</span>
  {{<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>},
   {<span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">7.0</span>},
   {<span class="fl">2.0</span>, <span class="fl">5.0</span>, <span class="fl">7.0</span>}};

<span class="bu">std::</span>cout &lt;&lt; arr1(<span class="dv">0</span>, <span class="dv">0</span>) &lt;&lt; <span class="bu">std::</span>endl;

xt::xarray&lt;<span class="dt">int</span>&gt; arr<span class="dv">2</span>
  {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};

<span class="bu">std::</span>cout &lt;&lt; arr2(<span class="dv">0</span>);</code></pre></div>
<p>Outputs:</p>
<pre><code>1.0
1</code></pre>
<h3 id="the-numpy-to-xtensor-cheat-sheet">The NumPy to xtensor cheat sheet</h3>
<p>If you are familiar with NumPy APIs, and you are interested in xtensor, you can check out the <a href="https://xtensor.readthedocs.io/en/latest/numpy.html">NumPy to xtensor cheat sheet</a> provided in the documentation.</p>
<h3 id="lazy-broadcasting-with-xtensor">Lazy broadcasting with <code>xtensor</code></h3>
<p>Xtensor can operate on arrays of different shapes of dimensions in an element-wise fashion. Broadcasting rules of xtensor are similar to those of <a href="http://www.numpy.org">NumPy</a> and <a href="http://libdynd.org">libdynd</a>.</p>
<h3 id="broadcasting-rules">Broadcasting rules</h3>
<p>In an operation involving two arrays of different dimensions, the array with the lesser dimensions is broadcast across the leading dimensions of the other.</p>
<p>For example, if <code>A</code> has shape <code>(2, 3)</code>, and <code>B</code> has shape <code>(4, 2, 3)</code>, the result of a broadcasted operation with <code>A</code> and <code>B</code> has shape <code>(4, 2, 3)</code>.</p>
<pre><code>   (2, 3) # A
(4, 2, 3) # B
---------
(4, 2, 3) # Result</code></pre>
<p>The same rule holds for scalars, which are handled as 0-D expressions. If <code>A</code> is a scalar, the equation becomes:</p>
<pre><code>       () # A
(4, 2, 3) # B
---------
(4, 2, 3) # Result</code></pre>
<p>If matched up dimensions of two input arrays are different, and one of them has size <code>1</code>, it is broadcast to match the size of the other. Let's say B has the shape <code>(4, 2, 1)</code> in the previous example, so the broadcasting happens as follows:</p>
<pre><code>   (2, 3) # A
(4, 2, 1) # B
---------
(4, 2, 3) # Result</code></pre>
<h3 id="universal-functions-laziness-and-vectorization">Universal functions, laziness and vectorization</h3>
<p>With <code>xtensor</code>, if <code>x</code>, <code>y</code> and <code>z</code> are arrays of <em>broadcastable shapes</em>, the return type of an expression such as <code>x + y * sin(z)</code> is <strong>not an array</strong>. It is an <code>xexpression</code> object offering the same interface as an N-dimensional array, which does not hold the result. <strong>Values are only computed upon access or when the expression is assigned to an xarray object</strong>. This allows to operate symbolically on very large arrays and only compute the result for the indices of interest.</p>
<p>We provide utilities to <strong>vectorize any scalar function</strong> (taking multiple scalar arguments) into a function that will perform on <code>xexpression</code>s, applying the lazy broadcasting rules which we just described. These functions are called <em>xfunction</em>s. They are <code>xtensor</code>'s counterpart to NumPy's universal functions.</p>
<p>In <code>xtensor</code>, arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and all special functions are <em>xfunction</em>s.</p>
<h3 id="iterating-over-xexpressions-and-broadcasting-iterators">Iterating over <code>xexpression</code>s and broadcasting Iterators</h3>
<p>All <code>xexpression</code>s offer two sets of functions to retrieve iterator pairs (and their <code>const</code> counterpart).</p>
<ul>
<li><code>begin()</code> and <code>end()</code> provide instances of <code>xiterator</code>s which can be used to iterate over all the elements of the expression. The order in which elements are listed is <code>row-major</code> in that the index of last dimension is incremented first.</li>
<li><code>begin(shape)</code> and <code>end(shape)</code> are similar but take a <em>broadcasting shape</em> as an argument. Elements are iterated upon in a row-major way, but certain dimensions are repeated to match the provided shape as per the rules described above. For an expression <code>e</code>, <code>e.begin(e.shape())</code> and <code>e.begin()</code> are equivalent.</li>
</ul>
<h3 id="runtime-vs-compile-time-dimensionality">Runtime vs compile-time dimensionality</h3>
<p>Two container classes implementing multi-dimensional arrays are provided: <code>xarray</code> and <code>xtensor</code>.</p>
<ul>
<li><code>xarray</code> can be reshaped dynamically to any number of dimensions. It is the container that is the most similar to NumPy arrays.</li>
<li><code>xtensor</code> has a dimension set at compilation time, which enables many optimizations. For example, shapes and strides of <code>xtensor</code> instances are allocated on the stack instead of the heap.</li>
</ul>
<p><code>xarray</code> and <code>xtensor</code> container are both <code>xexpression</code>s and can be involved and mixed in universal functions, assigned to each other etc...</p>
<p>Besides, two access operators are provided:</p>
<ul>
<li>The variadic template <code>operator()</code> which can take multiple integral arguments or none.</li>
<li>And the <code>operator[]</code> which takes a single multi-index argument, which can be of size determined at runtime. <code>operator[]</code> also supports access with braced initializers.</li>
</ul>
<h2 id="performances">Performances</h2>
<p>Xtensor operations make use of SIMD acceleration depending on what instruction sets are available on the platform at hand (SSE, AVX, AVX512, Neon).</p>
<h3 id="xsimd"><a href="https://github.com/QuantStack/xsimd"><img src="docs/source/xsimd-small.svg" alt="xsimd" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xsimd">xsimd</a> project underlies the detection of the available instruction sets, and provides generic high-level wrappers and memory allocators for client libraries such as xtensor.</p>
<h3 id="continuous-benchmarking">Continuous benchmarking</h3>
<p>Xtensor operations are continuously benchmarked, and are significantly improved at each new version. Current performances on statically dimensioned tensors match those of the Eigen library. Dynamically dimension tensors for which the shape is heap allocated come at a small additional cost.</p>
<h3 id="stack-allocation-for-shapes-and-strides">Stack allocation for shapes and strides</h3>
<p>More generally, the library implement a <code>promote_shape</code> mechanism at build time to determine the optimal sequence type to hold the shape of an expression. The shape type of a broadcasting expression whose members have a dimensionality determined at compile time will have a stack allocated sequence type. If at least one note of a broadcasting expression has a dynamic dimension (for example an <code>xarray</code>), it bubbles up to the entire broadcasting expression which will have a heap allocated shape. The same hold for views, broadcast expressions, etc...</p>
<p>Therefore, when building an application with xtensor, we recommend using statically-dimensioned containers whenever possible to improve the overall performance of the application.</p>
<h2 id="language-bindings">Language bindings</h2>
<h3 id="xtensor-python"><a href="https://github.com/QuantStack/xtensor-python"><img src="docs/source/xtensor-python-small.svg" alt="xtensor-python" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xtensor-python">xtensor-python</a> project provides the implementation of two <code>xtensor</code> containers, <code>pyarray</code> and <code>pytensor</code> which effectively wrap NumPy arrays, allowing inplace modification, including reshapes.</p>
<p>Utilities to automatically generate NumPy-style universal functions, exposed to Python from scalar functions are also provided.</p>
<h3 id="xtensor-julia"><a href="https://github.com/QuantStack/xtensor-julia"><img src="docs/source/xtensor-julia-small.svg" alt="xtensor-julia" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xtensor-julia">xtensor-julia</a> project provides the implementation of two <code>xtensor</code> containers, <code>jlarray</code> and <code>jltensor</code> which effectively wrap julia arrays, allowing inplace modification, including reshapes.</p>
<p>Like in the Python case, utilities to generate NumPy-style universal functions are provided.</p>
<h3 id="xtensor-r"><a href="https://github.com/QuantStack/xtensor-r"><img src="docs/source/xtensor-r-small.svg" alt="xtensor-r" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xtensor-r">xtensor-r</a> project provides the implementation of two <code>xtensor</code> containers, <code>rarray</code> and <code>rtensor</code> which effectively wrap R arrays, allowing inplace modification, including reshapes.</p>
<p>Like for the Python and Julia bindings, utilities to generate NumPy-style universal functions are provided.</p>
<h2 id="library-bindings">Library bindings</h2>
<h3 id="xtensor-blas"><a href="https://github.com/QuantStack/xtensor-blas"><img src="docs/source/xtensor-blas-small.svg" alt="xtensor-blas" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xtensor-blas">xtensor-blas</a> project provides bindings to BLAS libraries, enabling linear-algebra operations on xtensor expressions.</p>
<h3 id="xtensor-io"><a href="https://github.com/QuantStack/xtensor-io"><img src="docs/source/xtensor-io-small.svg" alt="xtensor-io" /></a></h3>
<p>The <a href="https://github.com/QuantStack/xtensor-io">xtensor-io</a> project enables the loading of a variety of file formats into xtensor expressions, such as image files, sound files, HDF5 files, as well as NumPy npy and npz files.</p>
<h2 id="building-and-running-the-tests">Building and running the tests</h2>
<p>Building the tests requires the <a href="https://github.com/google/googletest">GTest</a> testing framework and <a href="https://cmake.org">cmake</a>.</p>
<p>gtest and cmake are available as packages for most Linux distributions. Besides, they can also be installed with the <code>conda</code> package manager (even on windows):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">conda</span> install -c conda-forge gtest cmake</code></pre></div>
<p>Once <code>gtest</code> and <code>cmake</code> are installed, you can build and run the tests:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">mkdir</span> build
<span class="bu">cd</span> build
<span class="fu">cmake</span> -DBUILD_TESTS=ON ../
<span class="fu">make</span> xtest</code></pre></div>
<p>You can also use CMake to download the source of <code>gtest</code>, build it, and use the generated libraries:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">mkdir</span> build
<span class="bu">cd</span> build
<span class="fu">cmake</span> -DBUILD_TESTS=ON -DDOWNLOAD_GTEST=ON ../
<span class="fu">make</span> xtest</code></pre></div>
<h2 id="building-the-html-documentation">Building the HTML documentation</h2>
<p>xtensor's documentation is built with three tools</p>
<ul>
<li><a href="http://www.doxygen.org">doxygen</a></li>
<li><a href="http://www.sphinx-doc.org">sphinx</a></li>
<li><a href="https://breathe.readthedocs.io">breathe</a></li>
</ul>
<p>While doxygen must be installed separately, you can install breathe by typing</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">pip</span> install breathe sphinx_rtd_theme</code></pre></div>
<p>Breathe can also be installed with <code>conda</code></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">conda</span> install -c conda-forge breathe</code></pre></div>
<p>Finally, go to <code>docs</code> subdirectory and build the documentation with the following command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">make</span> html</code></pre></div>
<h2 id="license">License</h2>
<p>We use a shared copyright model that enables all contributors to maintain the copyright on their contributions.</p>
<p>This software is licensed under the BSD-3-Clause license. See the <a href="LICENSE" class="uri">LICENSE</a> file for details.</p>
