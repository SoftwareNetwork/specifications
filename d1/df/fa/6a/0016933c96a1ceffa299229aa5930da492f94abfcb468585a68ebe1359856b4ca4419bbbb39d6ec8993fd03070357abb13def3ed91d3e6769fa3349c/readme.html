<h1 id="rapid-yaml">Rapid YAML</h1>
<p><a href="https://github.com/biojppm/rapidyaml/blob/master/LICENSE.txt"><img src="https://img.shields.io/badge/License-MIT-green.svg" alt="MIT Licensed" /></a> <a href="https://github.com/biojppm/rapidyaml/actions?query=workflow%3Arun_tests"><img src="https://github.com/biojppm/rapidyaml/workflows/run_tests/badge.svg?branch=master" alt="run_tests" /></a> <a href="https://coveralls.io/github/biojppm/rapidyaml"><img src="https://coveralls.io/repos/github/biojppm/rapidyaml/badge.svg?branch=master" alt="Coverage: coveralls" /></a> <a href="https://codecov.io/gh/biojppm/rapidyaml"><img src="https://codecov.io/gh/biojppm/rapidyaml/branch/master/graph/badge.svg?branch=master" alt="Coverage: codecov" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/alerts/"><img src="https://img.shields.io/lgtm/alerts/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Total alerts" /></a> <a href="https://lgtm.com/projects/g/biojppm/rapidyaml/context:cpp"><img src="https://img.shields.io/lgtm/grade/cpp/g/biojppm/rapidyaml.svg?logo=lgtm&amp;logoWidth=18" alt="Language grade: C/C++" /></a> <a href="https://gitter.im/rapidyaml/community"><img src="https://badges.gitter.im/rapidyaml/community.svg" alt="Gitter" /></a></p>
<p>Or ryml, for short. ryml is a library to parse and emit YAML, and do it fast.</p>
<p>ryml parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your direct request, after parsing / before emitting. Internally the data tree representation has no knowledge of types (but of course, every node can have a YAML type tag). It is easy and fast to read, write and iterate through the data tree.</p>
<p>ryml can use custom per-tree memory allocators, and is exception-agnostic. Errors are reported via a custom error handler callback. A default error handler implementation using <code>std::abort()</code> is provided, but you can opt out, or provide your exception-throwing callback.</p>
<p>ryml has respect for your compilation times and therefore it is NOT header-only. It uses standard cmake build files, so it is easy to compile and install.</p>
<p>ryml has no dependencies, not even on the STL (although it does use the libc). It provides optional headers that let you serialize/deserialize STL strings and containers (or show you how to do it).</p>
<p>ryml is written in C++11, and is known to compile with: * Visual Studio 2015 and later * clang++ 3.9 and later * g++ 5 and later</p>
<p>ryml is <a href="https://github.com/biojppm/rapidyaml/actions?query=workflow%3Arun_tests">extensively unit-tested in Linux, Windows and MacOS</a>. The tests include analysing ryml with: * valgrind * clang-tidy * clang sanitizers: * memory * address * undefined behavior * thread * <a href="https://lgtm.com/projects/g/biojppm/rapidyaml">LGTM.com</a></p>
<p>ryml is also partially available in Python, with more languages to follow (see below).</p>
<p>See also <a href="./CHANGELOG.md">the changelog</a> and <a href="./ROADMAP.md">the roadmap</a>.</p>
<hr />
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#is-it-rapid">Is it rapid?</a></li>
<li><a href="#comparison-with-yaml-cpp">Comparison with yaml-cpp</a></li>
<li><a href="#performance-reading-json">Performance reading JSON</a></li>
<li><a href="#performance-emitting">Performance emitting</a></li>
<li><a href="#installing-and-using">Installing and using</a></li>
<li><a href="#using-ryml-as-cmake-subproject">Using ryml as cmake subproject</a></li>
<li><a href="#the-traditional-way-using-an-installed-version">The traditional way: using an installed version</a></li>
<li><a href="#cmake-build-settings-for-ryml">cmake build settings for ryml</a></li>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#references-anchors-and-aliases">References: anchors and aliases</a></li>
<li><a href="#traversing-the-tree">Traversing the tree</a></li>
<li><a href="#creating-a-tree">Creating a tree</a></li>
<li><a href="#low-level-api">Low-level API</a></li>
<li><a href="#custom-types">Custom types</a>
<ul>
<li><a href="#leaf-types">Leaf types</a></li>
<li><a href="#container-types">Container types</a></li>
</ul></li>
<li><a href="#stl-interoperation">STL interoperation</a></li>
<li><a href="#custom-formatting-for-intrinsic-types">Custom formatting for intrinsic types</a></li>
<li><a href="#custom-allocators-and-error-handlers">Custom allocators and error handlers</a></li>
<li><a href="#using-ryml-to-parse-json-and-preprocessing-functions">Using ryml to parse JSON, and preprocessing functions</a></li>
<li><a href="#other-languages">Other languages</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#yaml-standard-conformance">YAML standard conformance</a></li>
<li><a href="#known-limitations">Known limitations</a></li>
<li><a href="#alternative-libraries">Alternative libraries</a></li>
<li><a href="#license">License</a></li>
</ul>
<hr />
<h2 id="is-it-rapid">Is it rapid?</h2>
<p>You bet!</p>
<p>(The results presented below are a bit scattered; and they need to be sistematized.) On a i7-6800K CPU <span class="citation">@3.40GHz</span>: * ryml parses YAML at about ~150MB/s on Linux and ~100MB/s on Windows (vs2017). * <strong>ryml parses JSON at about ~450MB/s on Linux</strong>, faster than sajson (didn't try yet on Windows). * compared against the other existing YAML libraries for C/C++: * ryml is in general between 2 and 3 times faster than <a href="https://github.com/yaml/libyaml">libyaml</a> * ryml is in general between 20 and 70 times faster than <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>, and in some cases as much as 100x and <a href="https://github.com/biojppm/c4core/pull/16#issuecomment-700972614">even 200x</a> faster.</p>
<p><a href="./bm/bm_parse.cpp">Here's the benchmark</a>. Using different approaches within ryml (in-situ/read-only vs. with/without reuse), a YAML / JSON buffer is repeatedly parsed, and compared against other libraries.</p>
<h3 id="comparison-with-yaml-cpp">Comparison with yaml-cpp</h3>
<p>The first result set is for Windows, and is using a <a href="./bm/cases/appveyor.yml">appveyor.yml config file</a>. A comparison of these results is summarized on the table below:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>appveyor / vs2017 / Release</td>
<td>101.5</td>
<td>5.3</td>
<td>20x / 5.2%</td>
</tr>
<tr class="even">
<td>appveyor / vs2017 / Debug</td>
<td>6.4</td>
<td>0.0844</td>
<td>76x / 1.3%</td>
</tr>
</tbody>
</table>
<p>The next set of results is taken in Linux, comparing g++ 8.2 and clang++ 7.0.1 in parsing a YAML buffer from a <a href="./bm/cases/travis.yml">travis.yml config file</a> or a JSON buffer from a <a href="./bm/cases/compile_commands.json">compile_commands.json file</a>. You can <a href="./bm/results/parse.linux.i7_6800K.md">see the full results here</a>. Summarizing:</p>
<table>
<thead>
<tr class="header">
<th>Read rates (MB/s)</th>
<th>ryml</th>
<th>yamlcpp</th>
<th>compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>json / clang++ / Release</td>
<td>453.5</td>
<td>15.1</td>
<td>30x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Release</td>
<td>430.5</td>
<td>16.3</td>
<td>26x / 4%</td>
</tr>
<tr class="odd">
<td>json / clang++ / Debug</td>
<td>61.9</td>
<td>1.63</td>
<td>38x / 3%</td>
</tr>
<tr class="even">
<td>json / g++ / Debug</td>
<td>72.6</td>
<td>1.53</td>
<td>47x / 2%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Release</td>
<td>131.6</td>
<td>8.08</td>
<td>16x / 6%</td>
</tr>
<tr class="even">
<td>travis / g++ / Release</td>
<td>176.4</td>
<td>8.23</td>
<td>21x / 5%</td>
</tr>
<tr class="odd">
<td>travis / clang++ / Debug</td>
<td>10.2</td>
<td>1.08</td>
<td>9x / 1%</td>
</tr>
<tr class="even">
<td>travis / g++ / Debug</td>
<td>12.5</td>
<td>1.01</td>
<td>12x / 8%</td>
</tr>
</tbody>
</table>
<p>The 450MB/s read rate for JSON puts ryml squarely in the same ballpark as <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and other fast json readers (<a href="https://lemire.me/blog/2018/05/03/how-fast-can-you-parse-json/">data from here</a>). Even parsing full YAML is at ~150MB/s, which is still in that performance ballpark, albeit at its lower end. This is something to be proud of, as the YAML specification is much more complex than JSON: <a href="https://www.arp242.net/yaml-config.html#its-pretty-complex">23449 vs 1969 words</a>.</p>
<h3 id="performance-reading-json">Performance reading JSON</h3>
<p>So how does ryml compare against other JSON readers? Well, it's one of the fastest!</p>
<p>The benchmark is the <a href="./bm/parse.cpp">same as above</a>, and it is reading the <a href="./bm/cases/compile_commands.json">compile_commands.json</a>, The <code>_ro</code> suffix notes parsing a read-only buffer (so buffer copies are performed), while the <code>_rw</code> suffix means that the source buffer can be parsed in situ. The <code>_reuse</code> means the data tree and/or parser are reused on each benchmark repeat.</p>
<p>Here's what we get with g++ 8.2:</p>
<pre><code>|------------------|-------------------------------|-------------------------------
|                  |           Release             |           Debug               
| Benchmark        |  Iterations    Bytes/sec      |  Iterations    Bytes/sec      
|------------------|-------------------------------|-------------------------------
| rapidjson_ro     |        7941    509.855M/s     |         633    43.3632M/s     
| rapidjson_rw     |       21400    1.32937G/s     |        1067    68.171M/s     
| sajson_rw        |        6808    434.245M/s     |        2770    176.478M/s     
| sajson_ro        |        6726    430.723M/s     |        2748    175.613M/s     
| jsoncpp_ro       |        2871    183.616M/s     |        2941    187.937M/s     
| nlohmann_json_ro |        1807    115.801M/s     |         337    21.5237M/s     
| yamlcpp_ro       |         261    16.6322M/s     |          25    1.58178M/s     
| libyaml_ro       |        1786    113.909M/s     |         560    35.6599M/s     
| libyaml_ro_reuse |        1797    114.594M/s     |         561    35.8531M/s     
| ryml_ro          |        6088    388.585M/s     |         576    36.8634M/s     
| ryml_rw          |        6179    393.658M/s     |         577    36.8474M/s     
| ryml_ro_reuse    |        6986    446.248M/s     |        1164    74.636M/s      
| ryml_rw_reuse    |        7157    457.076M/s     |        1175    74.8721M/s     
|------------------|-------------------------------|-------------------------------</code></pre>
<p>You can verify that (at least for this test) ryml beats most json parsers at their own game, with the notable exception of <a href="https://github.com/Tencent/rapidjson">rapidjson</a> --- <em>but this occurs only in Release mode</em>. When in Debug mode, <a href="https://github.com/Tencent/rapidjson">rapidjson</a> is actually slower than ryml, and only <a href="https://github.com/chadaustin/sajson">sajson</a> manages to be faster.</p>
<p>More json comparison benchmarks will be added, but seem unlikely to significantly alter these results.</p>
<h3 id="performance-emitting">Performance emitting</h3>
<p>Emitting benchmarks were not created yet, but feedback from some users reports as much as 25x speedup from yaml-cpp <a href="https://github.com/biojppm/rapidyaml/issues/28#issue-553855608">(eg, here)</a>.</p>
<p>If you have data or YAML code for this, please submit a merge request, or just send us the files!</p>
<hr />
<h2 id="installing-and-using">Installing and using</h2>
<p>First, clone the repo:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone --recursive https://github.com/biojppm/rapidyaml</code></pre></div>
<p>Take care to use the <code>--recursive</code> flag to force git to clone the submodules as well. If you omit <code>--recursive</code>, after cloning you will have to do <code>git submodule init</code> and <code>submodule update</code> to ensure the submodules are checked out.</p>
<p>Next, you can either use ryml as a cmake subdirectory or build and install to a directory of your choice. Currently <a href="https://cmake.org/">cmake</a> is required for using ryml; we recommend a recent cmake version, at least 3.13.</p>
<h3 id="using-ryml-as-cmake-subproject">Using ryml as cmake subproject</h3>
<p>ryml is a small library, so this is the advised way.</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="co"># somewhere in your CMakeLists.txt</span>

<span class="co"># this is the target you wish to link with ryml</span>
<span class="kw">add_library</span>(foolib a.cpp b.cpp)

<span class="co"># make ryml a subproject of your project</span>
<span class="kw">add_subdirectory</span>(path/to/rapidyaml ryml)
<span class="kw">target_link_libraries</span>(foolib <span class="ot">PUBLIC</span> ryml)  <span class="co"># that&#39;s it!</span>

<span class="kw">add_executable</span>(fooexe main.cpp)
<span class="kw">target_link_libraries</span>(fooexe foolib) <span class="co"># brings in ryml</span></code></pre></div>
<p>If you're using git, we also suggest you add ryml as git submodule of your repo. This makes it easy to track any upstream changes in ryml.</p>
<h3 id="the-traditional-way-using-an-installed-version">The traditional way: using an installed version</h3>
<p>You can also use ryml in the customary cmake way, by first building and installing it, and then consuming it in your project via <code>find_package()</code>.</p>
<p>First, build ryml. For Visual Studio &amp; multi-configuration CMake generators, this would be:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">cmake</span> -S path/to/rapidyaml -B path/to/ryml/build/dir \
      -DCMAKE_INSTALL_PREFIX=path/to/ryml/install/dir
<span class="fu">cmake</span> --build path/to/ryml/build/dir --parallel --config Release</code></pre></div>
<p>whereas for single configuration CMake generators (Unix Makefiles, etc), this would be:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">cmake</span> -S path/to/rapidyaml -B path/to/ryml/build/dir \
      -DCMAKE_INSTALL_PREFIX=path/to/ryml/install/dir \
      -DCMAKE_BUILD_TYPE=Release
<span class="fu">cmake</span> --build path/to/ryml/build/dir --parallel</code></pre></div>
<p>(Note the <code>-S</code> and <code>-B</code> options first appeared in cmake 3.13 and are not available in earlier cmake versions). Now you can install ryml:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">cmake</span> --build path/to/ryml/build/dir --target install</code></pre></div>
<p>This will get ryml installed into the directory <code>path/to/ryml/install/dir</code>, together with cmake export files for ryml, which <code>find_package()</code> will need to successfully import ryml to your project.</p>
<p>Now to consume this installed ryml version, do the following:</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="co"># somewhere in your CMakeLists.txt</span>

<span class="co"># this is the target you wish to link with ryml</span>
<span class="kw">add_library</span>(foolib a.cpp b.cpp)

<span class="co"># instruct cmake to search for ryml</span>
<span class="kw">find_package</span>(ryml <span class="ot">REQUIRED</span>)
<span class="kw">target_link_libraries</span>(foolib <span class="ot">PUBLIC</span> ryml::ryml)  <span class="co"># </span><span class="al">NOTE</span><span class="co"> namespace ryml::</span>

<span class="kw">add_executable</span>(fooexe main.cpp)
<span class="kw">target_link_libraries</span>(fooexe foolib) <span class="co"># brings in ryml</span></code></pre></div>
<p>Note a significant difference to the subdirectory approach from the previous section: the installed ryml cmake exports file places the ryml library target in the <code>ryml::</code> namespace.</p>
<p>Now when building your project, you will need to point cmake to the installed ryml. To do this, simply add the ryml install directory to your project's <code>CMAKE_PREFIX_PATH</code> by doing eg <code>-DCMAKE_PREFIX_PATH=path/to/ryml/install/dir</code> when configuring your project, or by setting this variable in the cmake GUI if that's what you prefer to use.</p>
<p>You can also set (via command line or GUI) the variable <code>ryml_DIR</code> to the directory where the exports file <code>rymlConfig.cmake</code> was installed (which is different across platforms); search for this file in the ryml install tree, and provide the directory where it is located. For example, in Windows with the example above, this would be <code>-Dryml_DIR=path/to/ryml/install/dir/cmake</code>.</p>
<h3 id="cmake-build-settings-for-ryml">cmake build settings for ryml</h3>
<p>The following cmake variables can be used to control the build behavior of ryml:</p>
<ul>
<li><code>RYML_DEFAULT_CALLBACKS=ON/OFF</code>. Enable/disable ryml's default implementation of error and allocation callbacks. Defaults to <code>ON</code>.</li>
<li><code>RYML_STANDALONE=ON/OFF</code>. ryml uses <a href="https://github.com/biojppm/c4core">c4core</a>, a C++ library with low-level multi-platform utilities for C++. When <code>RYML_STANDALONE=ON</code>, c4core is incorporated into ryml as if it is the same library. Defaults to <code>ON</code>.</li>
</ul>
<p>If you're developing ryml or just debugging problems with ryml itself, the following variables can be helpful: * <code>RYML_DEV=ON/OFF</code>: a bool variable which enables development targets such as unit tests, benchmarks, etc. Defaults to <code>OFF</code>. * <code>RYML_DBG=ON/OFF</code>: a bool variable which enables verbose prints from parsing code; can be useful to figure out parsing problems. Defaults to <code>OFF</code>.</p>
<hr />
<h2 id="quick-start">Quick start</h2>
<p>If you're wondering whether ryml's speed comes at a usage cost, you need not. With ryml, you can have your cake and eat it too: being rapid is definitely NOT the same as being unpractical! ryml was written with easy AND efficient usage in mind, and comes with a two level API for accessing and traversing the data tree.</p>
<p>The low-level interface is an index-based API available through the <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> class (see examples below). This class is essentially a contiguous array of <code>NodeData</code> elements; these are linked to parent, children and siblings via indices.</p>
<p>On top of this index-based API, there is a thin abstraction <a href="src/c4/yml/node.hpp"><code>ryml::NodeRef</code></a> which is essentially a non-owning pointer to a <code>NodeData</code> element. It provides convenient methods for accessing the <code>NodeData</code> properties wrapping it via a class allowing for a more object-oriented use.</p>
<h3 id="parsing">Parsing</h3>
<p>A parser takes a source buffer and fills a <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ryml.hpp&gt;</span>

<span class="co">// not needed by ryml, just for these examples (and below)</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="co">// convenience functions to print a node</span>
<span class="dt">void</span> show_keyval(ryml::NodeRef n)
{
    assert(n.has_keyval());
    <span class="bu">std::</span>cout &lt;&lt; n.key() &lt;&lt; <span class="st">&quot;: &quot;</span> &lt;&lt; n.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}
<span class="dt">void</span> show_val(ryml::NodeRef n)
{
    assert(n.has_val());
    <span class="bu">std::</span>cout &lt;&lt; n.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}
    
<span class="dt">int</span> main()
{
    <span class="co">// ryml can parse in situ (and read-only buffers too):</span>
    <span class="dt">char</span> src[] = <span class="st">&quot;{foo: 1, bar: [2, 3]}&quot;</span>;
    ryml::substr srcview = <span class="va">src_</span>; <span class="co">// a mutable view to the source buffer</span>
    <span class="co">// there are also overloads for reusing the tree and parser</span>
    ryml::Tree tree = ryml::parse(srcview);

    <span class="co">// get a reference to the &quot;foo&quot; node</span>
    ryml::NodeRef node = tree[<span class="st">&quot;foo&quot;</span>];

    show_keyval(node);  <span class="co">// &quot;foo: 1&quot;</span>
    show_val(node[<span class="st">&quot;bar&quot;</span>][<span class="dv">0</span>]);  <span class="co">// &quot;2&quot;</span>
    show_val(node[<span class="st">&quot;bar&quot;</span>][<span class="dv">1</span>]);  <span class="co">// &quot;3&quot;</span>

    <span class="co">// deserializing:</span>
    <span class="dt">int</span> foo;
    node &gt;&gt; foo; <span class="co">// now foo == 1</span>
}</code></pre></div>
<p>It is also possible to parse read-only buffers, but note these will be copied over to an arena buffer in the tree object, and that buffer copy will be the one to be parsed:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &quot;{foo: 1}&quot; is a const char[], so a read-only buffer; it will be</span>
<span class="co">// copied to the tree&#39;s arena before parsing</span>
ryml::Tree tree = ryml::parse(<span class="st">&quot;{foo: 1}&quot;</span>);</code></pre></div>
<p>When parsing, you can reuse the existing trees and parsers. You can also parse into particular tree nodes, so that you can parse an entire file into a node which is deep in the hierarchy of an existing tree. To see the various parse overloads, consult the <a href="src/c4/yml/parse.hpp">c4/yml/parse.hpp header</a>. The free-standing <code>parse()</code> functions (towards the end of the file) are just convenience wrappers for calling the several <code>Parser::parse()</code> overloads.</p>
<h3 id="references-anchors-and-aliases">References: anchors and aliases</h3>
<p>Note that dereferencing is opt-in; after parsing, you have to call <code>Tree::resolve()</code> explicitly if you want resolved references in the tree. This method will resolve all references and substitute the anchored values in place of the reference.</p>
<p>The <code>Tree::resolve()</code> method first does a full traversal of the tree to gather all anchors and references in a separate collection, then it goes through that collection to locate the names, which it does by obeying the YAML standard diktat that</p>
<pre><code>an alias node refers to the most recent node in the serialization having the specified anchor</code></pre>
<p>So, depending on the number of anchor/alias nodes, this is a potentially expensive operation, with a best-case linear complexity (from the initial traversal) and a worst-case quadratic complexity (if every node has an alias/anchor). This potential cost is the reason for requiring an explicit call to <code>Tree::resolve()</code>.</p>
<h3 id="traversing-the-tree">Traversing the tree</h3>
<p>The data tree is an index-linked array of <code>NodeData</code> elements. These are defined roughly as (browse the <a href="src/c4/yml/tree.hpp">c4/yml/tree.hpp header</a>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// (inside namespace c4::yml)</span>

<span class="kw">typedef</span> <span class="kw">enum</span> : <span class="dt">int</span> <span class="co">// bitflags for marking node features</span>
{
   KEY=<span class="dv">1</span>&lt;&lt;<span class="dv">0</span>,
   VAL=<span class="dv">1</span>&lt;&lt;<span class="dv">1</span>,
   MAP=<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>,
   SEQ=<span class="dv">1</span>&lt;&lt;<span class="dv">4</span>,
   DOC=<span class="dv">1</span>&lt;&lt;<span class="dv">5</span>,
   TAG=...,
   REF=...,
   ANCHOR=..., <span class="co">// etc </span>
} NodeType_e;
<span class="kw">struct</span> NodeType
{
   NodeType_e <span class="va">m_flags</span>;
   <span class="co">// ... predicate methods such as</span>
   <span class="co">// has_key(), is_map(), is_seq(), etc</span>
};
<span class="kw">struct</span> NodeScalar <span class="co">// this is both for keys and vals</span>
{
    csubstr tag;
    csubstr scalar;
    csubstr anchor;
    <span class="co">// csubstr is a constant substring:</span>
    <span class="co">// a non-owning read-only string view</span>
    <span class="co">// consisting of a pointer and a length</span>
}
<span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">size_t</span> NONE = (<span class="dt">size_t</span>)<span class="dv">-1</span>;
<span class="kw">struct</span> NodeData
{
    NodeType   type;
    NodeScalar key; <span class="co">// data for the key (if applicable)</span>
    NodeScalar val; <span class="co">// data for the value</span>
    
    <span class="dt">size_t</span>     parent;      <span class="co">// NONE when this is the root node</span>
    <span class="dt">size_t</span>     first_child; <span class="co">// NONE if this is a leaf node</span>
    <span class="dt">size_t</span>     last_child;  <span class="co">// etc</span>
    <span class="dt">size_t</span>     next_sibling;
    <span class="dt">size_t</span>     prev_sibling;
}</code></pre></div>
<p>Please note that you should not rely on this particular structure; the above definitions are given only to provide an idea on how the tree is organized. To access and modify node properties, please use the APIs provided through the <code>Tree</code> (low-level) or the <code>NodeRef</code> (high-level) classes.</p>
<p>You may have noticed above the use of a <code>csubstr</code> class. This class is defined in another library, <a href="https://github.com/biojppm/c4core">c4core</a>, which is imported by ryml (so technically it's not a dependency, is it?). This is a library I use with my projects consisting of multiplatform low-level utilities. One of these is <code>c4::csubstr</code> (the name comes from &quot;constant substring&quot;) which is a non-owning read-only string view, with many methods that make it practical to use (I would certainly argue more practical than <code>std::string</code>). In fact, <code>c4::csubstr</code> and its writeable counterpart <code>c4::substr</code> are the workhorses of the ryml parsing and serialization code; you can browse these classes here: <a href="https://github.com/biojppm/c4core/blob/master/src/c4/substr.hpp">c4/substr.hpp</a>.</p>
<p>Now, let's parse and traverse a tree. To obtain a <code>NodeRef</code> from the tree, you only need to invoke <code>operator[]</code>. This operator can take indices (when invoked on sequence and map nodes) and also strings (only when invoked on map nodes):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ryml::Tree tree = ryml::parse(<span class="st">&quot;[a, b, {c: 0, d: 1}]&quot;</span>);

<span class="co">// note: show_val() was defined above</span>

show_val(tree[<span class="dv">0</span>]); <span class="co">// &quot;a&quot;</span>
show_val(tree[<span class="dv">1</span>]); <span class="co">// &quot;b&quot;</span>
show_val(tree[<span class="dv">2</span>][ <span class="dv">0</span> ]); <span class="co">// &quot;0&quot; // index-based</span>
show_val(tree[<span class="dv">2</span>][ <span class="dv">1</span> ]); <span class="co">// &quot;1&quot; // index-based</span>
show_val(tree[<span class="dv">2</span>][<span class="st">&quot;c&quot;</span>]); <span class="co">// &quot;0&quot; // string-based</span>
show_val(tree[<span class="dv">2</span>][<span class="st">&quot;d&quot;</span>]); <span class="co">// &quot;1&quot; // string-based</span>

<span class="co">// note that trying to obtain the value on a non-value</span>
<span class="co">// node such as a container will fail an assert:</span>
<span class="co">// ERROR, assertion triggered: a container has no value</span>
show_val(tree[<span class="dv">2</span>]);
<span class="co">// ERROR: the same</span>
show_val(tree.rootref());

<span class="co">// the same for keys:</span>
show_keyval(tree[<span class="dv">0</span>]); <span class="co">// ERROR: sequence element has no key</span>
show_keyval(tree[<span class="dv">2</span>][<span class="dv">0</span>]); <span class="co">// ok</span></code></pre></div>
<p>The square bracket operators <code>Tree::operator[csubstr]</code> and <code>Tree::operator[size_t]</code> do a lookup on the root node and return a <code>NodeRef</code>. The first overload (valid only for map nodes) looks for a child having the given key, and the second overload looks for the i-th root's child. If you prefer to stick to the low level API, you can use <code>Tree::find_child()</code> which takes a node on which the child should be looked for and also that child's key or position within the parent.</p>
<p>Please note that since a ryml tree uses indexed linked lists for storing children, the complexity of <code>Tree::operator[csubstr]</code> and <code>Tree::operator[size_t]</code> is linear on the number of root children. If you use it with a large tree where the root has many children, you may get a performance hit. To avoid this hit, you can create your own accelerator structure. For example, before doing a lookup, do a single traverse at the root level to fill an <code>std::map&lt;csubstr,size_t&gt;</code> mapping key names to node indices; with a node index, a lookup (via <code>Tree::get()</code>) is O(1), so this way you can get O(log n) lookup from a key.</p>
<p>As for <code>NodeRef</code>, the difference from <code>NodeRef::operator[]</code> to <code>Tree::operator[]</code> is that the latter refers to the root node, whereas the former can be invoked on any node. But the lookup process is the same for both and their algorithmic complexity is the same: they are both linear in the number of direct children; but depending on the data, that number may be very different from one to another.</p>
<p>Now, let's address how to mutate the tree via <code>operator[]</code>. We should stress that there is an important difference to the mutability behavior of the STL's <code>std::map::operator[]</code>. Consider when a non-existing key or index is requested via <code>operator[]</code>. Unlike with <code>std::map</code>, <strong>this operator does not modify the tree</strong>. Instead you get a seed-state <code>NodeRef</code>, and the tree will be modified only when this seed-state reference is written to. Thus <code>NodeRef</code> can either point to a valid tree node, or if no such node exists it will be in seed-state by holding the index or name passed to <code>operator[]</code>. To allow for this, <code>NodeRef</code> is a simple structure with a declaration like:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> NodeRef
{
    <span class="co">// a pointer to the tree</span>
    Tree * <span class="va">m_tree</span>; 
    <span class="co">// either the (tree-scoped) index of an existing node or the (node-scoped) index of a seed state</span>
    <span class="dt">size_t</span> <span class="va">m_node_or_seed_id</span>;
    <span class="co">// the key name of a seed state. null when valid</span>
    <span class="at">const</span> <span class="dt">char</span>* <span class="va">m_seed_name</span>;

<span class="kw">public</span>:

    <span class="co">// this can be used to query whether a node is in seed state</span>
    <span class="dt">bool</span> valid()
    {
        <span class="cf">return</span> <span class="va">m_node_or_seed_id</span> != NONE
               &amp;&amp;
               <span class="va">m_seed_name</span> == <span class="kw">nullptr</span>;
    }

    <span class="co">// forward all calls to m_tree. For example:</span>
    csubstr val() <span class="at">const</span> { assert(valid()); <span class="cf">return</span> <span class="va">m_tree</span>-&gt;val(<span class="va">m_node_or_seed_id</span>); }
    <span class="dt">void</span> set_val(csubstr v) { <span class="cf">if</span>(!valid()) {<span class="co">/*create node in tree*/</span>;} <span class="va">m_tree</span>-&gt;set_val(<span class="va">m_node_or_seed_id</span>, v); }

    <span class="co">// etc...</span>
};</code></pre></div>
<p>To iterate over children:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span>(NodeRef c : node.children())
{
    <span class="bu">std::</span>cout &lt;&lt; c.key() &lt;&lt; <span class="st">&quot;---&quot;</span> &lt;&lt; c.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<p>To iterate over siblings:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span>(NodeRef c : node.siblings())
{
    <span class="bu">std::</span>cout &lt;&lt; c.key() &lt;&lt; <span class="st">&quot;---&quot;</span> &lt;&lt; c.val() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}</code></pre></div>
<h3 id="creating-a-tree">Creating a tree</h3>
<p>To create a tree programatically:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ryml::Tree tree;
NodeRef r = tree.rootref();

<span class="co">// Each container node must be explicitly set (either MAP or SEQ):</span>
r |= ryml::MAP;

r[<span class="st">&quot;foo&quot;</span>] = <span class="st">&quot;1&quot;</span>; <span class="co">// ryml works only with strings.</span>
<span class="co">// Note that the tree will be __pointing__ at the</span>
<span class="co">// strings &quot;foo&quot; and &quot;1&quot; used here. You need</span>
<span class="co">// to make sure they have at least the same</span>
<span class="co">// lifetime as the tree.</span>

<span class="co">// does not change the tree until s is written to.</span>
ryml::NodeRef s = r[<span class="st">&quot;seq&quot;</span>]; <span class="co">// here, s is not valid()</span>
s |= ryml::SEQ; <span class="co">// now s is valid()</span>

s.append_child() = <span class="st">&quot;bar0&quot;</span>; <span class="co">// this child is now __pointing__ at &quot;bar0&quot;</span>
s.append_child() = <span class="st">&quot;bar1&quot;</span>;
s.append_child() = <span class="st">&quot;bar2&quot;</span>;

<span class="co">// emit to stdout (can also emit to FILE* or ryml::span)</span>
<span class="ex">emit</span>(tree); <span class="co">// prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>

<span class="co">// serializing: using operator&lt;&lt; instead of operator=</span>
<span class="co">// will make the tree serialize the value into a char</span>
<span class="co">// arena inside the tree. This arena can be reserved at will.</span>
<span class="dt">int</span> ch3 = <span class="dv">33</span>, ch4 = <span class="dv">44</span>;
s.append_child() &lt;&lt; ch3;
s.append_child() &lt;&lt; ch4;

{
    <span class="bu">std::</span>string tmp = <span class="st">&quot;child5&quot;</span>;
    s.append_child() &lt;&lt; tmp;   <span class="co">// requires #include &lt;c4/yml/std/string.hpp&gt;</span>
    <span class="co">// now tmp can go safely out of scope, as it was</span>
    <span class="co">// serialized to the tree&#39;s internal string arena</span>
    <span class="co">// Note the include highlighted above is required so that ryml</span>
    <span class="co">// knows how to turn an std::string into a c4::csubstr/c4::substr.</span>
}

<span class="ex">emit</span>(tree); <span class="co">// now prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>
            <span class="co">//  - 33</span>
            <span class="co">//  - 44</span>
            <span class="co">//  - child5</span>

<span class="co">// to serialize keys:</span>
r.append_child() &lt;&lt; ryml::key(<span class="dv">66</span>) &lt;&lt; <span class="dv">7</span>;

<span class="ex">emit</span>(tree); <span class="co">// now prints the following:</span>
            <span class="co">// foo: 1</span>
            <span class="co">// seq:</span>
            <span class="co">//  - bar0</span>
            <span class="co">//  - bar1</span>
            <span class="co">//  - bar2</span>
            <span class="co">//  - 33</span>
            <span class="co">//  - 44</span>
            <span class="co">//  - child5</span>
            <span class="co">// 66: 7</span>
}</code></pre></div>
<h3 id="low-level-api">Low-level API</h3>
<p>The low-level api is an index-based API accessible from the <a href="src/c4/yml/tree.hpp"><code>ryml::Tree</code></a> object. Here are some examples:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> print_keyval(Tree <span class="at">const</span>&amp; t, <span class="dt">size_t</span> elm_id)
{
    <span class="bu">std::</span>cout &lt;&lt; t.get_key(elm_id)
              &lt;&lt; <span class="st">&quot;: &quot;</span>
              &lt;&lt; t.get_val(elm_id) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
}

ryml::Tree t = parse(<span class="st">&quot;{foo: 1, bar: 2, baz: 3}&quot;</span>)

<span class="dt">size_t</span> root_id = t.root_id();
<span class="dt">size_t</span> foo_id  = t.first_child(root_id);
<span class="dt">size_t</span> bar_id  = t.next_sibling(foo_id);
<span class="dt">size_t</span> baz_id  = t.last_child(root_id);

assert(baz == t.next_sibling(bar_id));
assert(bar == t.prev_sibling(baz_id));

print_keyval(t, foo_id); <span class="co">// &quot;foo: 1&quot;</span>
print_keyval(t, bar_id); <span class="co">// &quot;bar: 2&quot;</span>
print_keyval(t, baz_id); <span class="co">// &quot;baz: 3&quot;</span>

<span class="co">// to iterate over the children of a node:</span>
<span class="cf">for</span>(<span class="dt">size_t</span> i  = t.first_child(root_id);
           i != ryml::NONE;
           i  = t.next_sibling(i))
{
    <span class="co">// ...</span>
}

<span class="co">// to iterate over the siblings of a node:</span>
<span class="cf">for</span>(<span class="dt">size_t</span> i  = t.first_sibling(foo_id);
           i != ryml::NONE;
           i  = t.next_sibling(i))
{
    <span class="co">// ...</span>
}</code></pre></div>
<h3 id="custom-types">Custom types</h3>
<p>ryml provides code to serialize the basic intrinsic types (integers, floating points and strings): you can see it in the <a href="https://github.com/biojppm/c4core/blob/master/src/c4/charconv.hpp">the <code>c4/charconv.hpp</code> header</a>. For types other than these, you need to instruct ryml how to serialize your type, and here we explain how to do this.</p>
<p>There are two distinct type categories when serializing to a YAML tree: leaf types (value or key-value) and container types (sequences or maps).</p>
<h4 id="leaf-types">Leaf types</h4>
<p>These are types which should serialize to a string, resulting in a leaf node in the YAML tree.</p>
<p>For these, overload the <code>to_chars(c4::substr, T)/from_chars(c4::csubstr, *T)</code> functions.</p>
<p>Here's an example for a 3D vector type:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> vec3 { <span class="dt">float</span> x, y, z; };

<span class="co">// format v to the given string view + return the number of</span>
<span class="co">// characters written into it. The view size (buf.len) must</span>
<span class="co">// be strictly respected. Return the number of characters</span>
<span class="co">// that need to be written. So if the return value</span>
<span class="co">// is larger than buf.len, ryml will resize the buffer and</span>
<span class="co">// call this again with a larger buffer of the correct sizeXS.</span>
<span class="dt">size_t</span> to_chars(c4::substr buf, vec3 v)
{
    <span class="co">// this call to c4::format() is the type-safe equivalent</span>
    <span class="co">// of snprintf(buf.str, buf.len, &quot;(%f,%f,%f)&quot;, v.x, v.y, v.z)</span>
    <span class="cf">return</span> c4::format(buf, <span class="st">&quot;({},{},{})&quot;</span>, v.x, v.y, v.z);
}

<span class="dt">bool</span> from_chars(c4::csubstr buf, vec3 *v)
{
    <span class="co">// equivalent to sscanf(buf.str, &quot;(%f,%f,%f)&quot;, &amp;v-&gt;x, &amp;v-&gt;y, &amp;v-&gt;z)</span>
    <span class="co">// --- actually snscanf(buf.str, buf.len, ...) but there&#39;s</span>
    <span class="co">// no such function in the standard.</span>
    <span class="dt">size_t</span> ret = c4::unformat(buf, <span class="st">&quot;({},{},{})&quot;</span>, v-&gt;x, v-&gt;y, v-&gt;z);
    <span class="cf">return</span> ret != c4::csubstr::npos;
}</code></pre></div>
<p>Now you can provide your formats with For a live example you can look at <a href="https://github.com/biojppm/c4core/blob/master/src/c4/std/string.hpp">the <code>std::string</code> serialization code</a>.</p>
<h4 id="container-types">Container types</h4>
<p>These are types requiring child nodes (ie, either sequences or maps).</p>
<p>For these, overload the <code>write()/read()</code> functions. For example,</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> foo {
<span class="kw">struct</span> MyStruct; <span class="co">// a container-type struct</span>
{
    <span class="dt">int</span> subject;
    <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="dt">int</span>&gt; counts;
};
  
<span class="co">// ... will need these functions to convert to YAML:</span>
<span class="dt">void</span> write(c4::yml::NodeRef *n, MyStruct <span class="at">const</span>&amp; v);
<span class="dt">void</span>  read(c4::yml::NodeRef <span class="at">const</span>&amp; n, MyStruct *v);
} <span class="co">// namespace foo</span></code></pre></div>
<p>which could be implemented as:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// include the functions for std::string and std::map (not included by default)</span>
<span class="pp">#include </span><span class="im">&lt;c4/yml/std/map.hpp&gt;</span>
<span class="pp">#include </span><span class="im">&lt;c4/yml/std/string.hpp&gt;</span>
  
<span class="dt">void</span> foo::read(c4::yml::NodeRef <span class="at">const</span>&amp; n, MyStruct *v)
{
    n[<span class="st">&quot;subject&quot;</span>] &gt;&gt; v-&gt;subject;
    n[<span class="st">&quot;counts&quot;</span>] &gt;&gt; v-&gt;counts;
}
  
<span class="dt">void</span> foo::write(c4::yml::NodeRef *n, MyStruct <span class="at">const</span>&amp; v)
{
    *n |= c4::yml::MAP;

    NodeRef ch = n-&gt;append_child();
    ch.set_key(<span class="st">&quot;subject&quot;</span>);
    ch.set_val_serialized(v.subject);

    ch = n-&gt;append_child();
    ch.set_key(<span class="st">&quot;counts&quot;</span>);
    write(&amp;ch, v.counts);
}</code></pre></div>
<p>To harness <a href="http://en.cppreference.com/w/cpp/language/adl">C++'s ADL rules</a>, it is important to overload these functions in the namespace of the type you're serializing (or in the c4::yml namespace). Generic examples can be seen in the (optional) implementations of <code>std::vector</code> or <code>std::map</code>, at their respective headers <a href="src/c4/yml/std/vector.hpp"><code>c4/yml/std/vector.hpp</code></a> and <a href="src/c4/yml/std/map.hpp"><code>c4/yml/std/map.hpp</code></a>.</p>
<h3 id="stl-interoperation">STL interoperation</h3>
<p>ryml does not use the STL internally, but you can use ryml to serialize and deserialize STL containers. That is, the use of STL is opt-in: you need to <code>#include</code> the proper ryml header for the container you want to serialize, or provide an implementation of your own, as above. Having done that, you can serialize / deserialize your containers with a single step. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ryml_std.hpp&gt;</span><span class="pp"> </span><span class="co">// include this before any other ryml header</span>
<span class="pp">#include </span><span class="im">&lt;ryml.hpp&gt;</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="dt">int</span>&gt; m({{<span class="st">&quot;foo&quot;</span>, <span class="dv">1</span>}, {<span class="st">&quot;bar&quot;</span>, <span class="dv">2</span>}});
    ryml::Tree t;
    t.rootref() &lt;&lt; m; <span class="co">// serialization of the map happens here</span>
    
    <span class="ex">emit</span>(t);
    <span class="co">// foo: 1</span>
    <span class="co">// bar: 2</span>
    
    t[<span class="st">&quot;foo&quot;</span>] &lt;&lt; <span class="dv">1111</span>;  <span class="co">// serialize an integer into</span>
                       <span class="co">// the tree&#39;s arena, and make</span>
                       <span class="co">// foo&#39;s value point at it</span>
    t[<span class="st">&quot;bar&quot;</span>] &lt;&lt; <span class="dv">2222</span>;  <span class="co">// the same, but for bar</span>
    
    <span class="ex">emit</span>(t);
    <span class="co">// foo: 1111</span>
    <span class="co">// bar: 2222</span>
    
    m.clear();
    t.rootref() &gt;&gt; m; <span class="co">// deserialization of the map happens here</span>

    assert(m[<span class="st">&quot;foo&quot;</span>] == <span class="dv">1111</span>); <span class="co">// ok</span>
    assert(m[<span class="st">&quot;bar&quot;</span>] == <span class="dv">2222</span>); <span class="co">// ok</span>
}</code></pre></div>
<p>The <a href="src/ryml_std.hpp"><code>&lt;ryml_std.hpp&gt;</code></a> header includes every std type implementation available in ryml. But you can include just a specific header if you are interested only in a particular container; these headers are located under a specific directory in the ryml source folder: <a href="src/c4/yml/std">c4/yml/std</a>. You can browse them to learn how to implement your custom type: for containers, see for example <a href="src/c4/yml/std/vector.hpp">the <code>std::vector</code> implementation</a>, or <a href="src/c4/yml/std/map.hpp">the <code>std::map</code> implementation</a>; for an example of value nodes, see <a href="https://github.com/biojppm/c4core/src/c4/std/string.hpp">the <code>std::string</code> implementation</a>. If you'd like to see a particular STL container implemented, feel free to <a href="https://github.com/biojppm/rapidyaml/issues">submit a pull request or open an issue</a>.</p>
<p>The need for separate inclusion of ryml's std interoperation headers is dictated by ryml's design requirement of not forcing clients to use the STL.</p>
<p>Please take note of the following pitfall when using the std headers: you have to include the std header before any other headers that use functions from it. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// the to_csubstr(std::string const&amp;) overload is not found in the resolution set</span>
<span class="pp">#include </span><span class="im">&lt;ryml.hpp&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ryml_std.hpp&gt;</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>string in = <span class="st">R&quot;({&quot;a&quot;:&quot;b&quot;,&quot;c&quot;:null,&quot;d&quot;:&quot;e&quot;})&quot;</span>;
    <span class="co">// COMPILE ERROR: to_csubstr() not found for std::string</span>
    <span class="bu">std::</span>string yaml = ryml::preprocess_json&lt;<span class="bu">std::</span>string&gt;(c4::to_csubstr(in));
}</code></pre></div>
<p>But this works:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ryml_std.hpp&gt;</span><span class="pp"> </span><span class="co">// note the inclusion order changed</span>
<span class="pp">#include </span><span class="im">&lt;ryml.hpp&gt;</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>string in = <span class="st">R&quot;({&quot;a&quot;:&quot;b&quot;,&quot;c&quot;:null,&quot;d&quot;:&quot;e&quot;})&quot;</span>;
    <span class="co">// OK:</span>
    <span class="bu">std::</span>string yaml = ryml::preprocess_json&lt;<span class="bu">std::</span>string&gt;(c4::to_csubstr(in));
}</code></pre></div>
<p>This constraint also applies to the conversion functions for your types; just like with the STL's headers, they should be included prior to ryml's headers.</p>
<h3 id="custom-formatting-for-intrinsic-types">Custom formatting for intrinsic types</h3>
<p>Sometimes the general formatting from ryml may not be what is required.</p>
<p>Consider the following:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">NodeRef r = tree.rootref();

<span class="dt">bool</span> t = <span class="kw">true</span>;
<span class="dt">float</span> a = <span class="fl">24.0f</span>;
<span class="dt">float</span> b = <span class="fl">2.41f</span>;

r[<span class="st">&quot;t&quot;</span>] &lt;&lt; t;
r[<span class="st">&quot;a&quot;</span>] &lt;&lt; a;
r[<span class="st">&quot;b&quot;</span>] &lt;&lt; b;
print_keyval(r[<span class="st">&quot;t&quot;</span>]); <span class="co">// &quot;t=1&quot; -- true was formatted as an int</span>
print_keyval(r[<span class="st">&quot;a&quot;</span>]); <span class="co">// &quot;a=24&quot; -- the decimal was lost with general formatting</span>
print_keyval(r[<span class="st">&quot;b&quot;</span>]); <span class="co">// &quot;b=2.41&quot; -- as expected</span></code></pre></div>
<p>The behavior above may not be ideal in some cases. There are alternatives for this situation:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// if you want the decimal to remain, you can provide the string yourself:</span>
r[<span class="st">&quot;t&quot;</span>] &lt;&lt; (t ? <span class="st">&quot;true&quot;</span> : <span class="st">&quot;false&quot;</span>);
<span class="bu">std::</span>string sa = ...; <span class="co">// something resulting in &quot;24.0&quot;</span>
r[<span class="st">&quot;a&quot;</span>] &lt;&lt; c4::to_csubstr(sa);

print_keyval(r[<span class="st">&quot;t&quot;</span>]); <span class="co">// &quot;t=true&quot; -- as expected</span>
print_keyval(r[<span class="st">&quot;a&quot;</span>]); <span class="co">// &quot;a=24.0&quot; -- as expected</span>
print_keyval(r[<span class="st">&quot;b&quot;</span>]); <span class="co">// &quot;b=2.41&quot; -- as expected</span></code></pre></div>
<p>If, understandably, you want to avoid the likely allocation caused by the <code>std::to_string()</code> antipattern (or even worse, the <code>std::stringstream::str()</code> allocation cookie monster), <a href="https://github.com/biojppm/c4core/tree/master/src/c4/format.hpp">ryml has you covered</a>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;c4/format.hpp&gt;</span><span class="pp"> </span><span class="co">// look for the appropriate formatting functions in this header</span>
<span class="co">//...</span>

<span class="dt">int</span> precision = <span class="dv">2</span>; <span class="co">// print floats with two digits.</span>
r[<span class="st">&quot;a&quot;</span>] &lt;&lt; c4::fmt::real(val, precision); <span class="co">// OK, result: &quot;24.00&quot;</span>

<span class="co">// c4::fmt::real() is a lazy marker which will be used by ryml to format the</span>
<span class="co">// float directly in the arena without any extra allocation (other than</span>
<span class="co">// possible arena growth, which would happen just the same for the approach</span>
<span class="co">// above). It calls ftoa() on the arena range.</span></code></pre></div>
<p>Again, note that you don't have to use the tree's arena. If you use <code>operator=</code>, the <code>csubstr</code> you provide will be directly used instead.</p>
<h3 id="custom-allocators-and-error-handlers">Custom allocators and error handlers</h3>
<p>ryml accepts your own allocators and error handlers. Read through <a href="src/c4/yml/common.hpp">this header file</a> to set it up.</p>
<p>Please note the following about the use of custom allocators with ryml. If you use static ryml trees or parsers, you need to make sure that their allocator has the same lifetime. So you can't use ryml's default allocator, as it is declared in a ryml file, and the standard provides no guarantee on the relative initialization order, such that the allocator is constructed before and destroyed after your variables (in fact you are pretty much guaranteed to see this fail). So please carefully consider your choices, and ponder whether you really need to use ryml static trees and parsers. If you do need this, then you will need to declare and use an allocator from a ryml memory resource that outlives the tree and/or parser.</p>
<h3 id="using-ryml-to-parse-json-and-preprocessing-functions">Using ryml to parse JSON, and preprocessing functions</h3>
<p>Although JSON is generally a subset of YAML, <a href="https://stackoverflow.com/questions/42124227/why-does-the-yaml-spec-mandate-a-space-after-the-colon">there is an exception that is valid JSON, but not valid YAML</a>:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="kw">{</span><span class="fu">&quot;a&quot;:</span><span class="st">&quot;b&quot;</span><span class="kw">}</span>  <span class="co"># note the missing space after the semicolon</span></code></pre></div>
<p>As a result, you will get a parse error if you try to do this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> tree = ryml::parse(<span class="st">&quot;{</span><span class="sc">\&quot;</span><span class="st">a</span><span class="sc">\&quot;</span><span class="st">:</span><span class="sc">\&quot;</span><span class="st">b</span><span class="sc">\&quot;</span><span class="st">}&quot;</span>);</code></pre></div>
<p>This behavior is intended, and this was chosen to save added complexity in the parser code.</p>
<p>However, you can still parse this with ryml if (prior to parsing) you preprocess the JSON into valid YAML, adding the missing spaces after the semicolons. ryml provides a freestanding function to do this: <code>ryml::preprocess_json()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;c4/yml/preprocess.hpp&gt;</span>
<span class="co">// you can also use in-place overloads</span>
<span class="kw">auto</span> yaml = ryml::preprocess_json&lt;<span class="bu">std::</span>string&gt;(<span class="st">&quot;{</span><span class="sc">\&quot;</span><span class="st">a</span><span class="sc">\&quot;</span><span class="st">:</span><span class="sc">\&quot;</span><span class="st">b</span><span class="sc">\&quot;</span><span class="st">}&quot;</span>);
<span class="co">// now you have a buffer with valid yaml - note the space:</span>
<span class="bu">std::</span>cout &lt;&lt; yaml &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">// {&quot;a&quot;: &quot;b&quot;}</span>
<span class="co">// ... which you can parse:</span>
ryml::Tree t = ryml::parse(to_substr(yaml));
<span class="bu">std::</span>cout &lt;&lt; t[<span class="st">&quot;a&quot;</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">// b</span></code></pre></div>
<p>There is also <code>ryml::preprocess_rxmap()</code>, a function to convert non-standard relaxed maps (ie, keys with implicit true values) into standard YAML maps.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;c4/yml/preprocess.hpp&gt;</span>
<span class="co">// you can also use in-place overloads</span>
<span class="kw">auto</span> yaml = ryml::preprocess_rxmap&lt;<span class="bu">std::</span>string&gt;(<span class="st">&quot;{a, b, c, d: [e, f, g]}&quot;</span>);
<span class="bu">std::</span>cout &lt;&lt; yaml &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">// {a: 1, b: 1, c: 1, d: [e, f, g]}</span>
ryml::Tree t = ryml::parse(to_substr(yaml));
<span class="bu">std::</span>cout &lt;&lt; t[<span class="st">&quot;a&quot;</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">// 1</span></code></pre></div>
<hr />
<h2 id="other-languages">Other languages</h2>
<p>One of the aims of ryml is to provide an efficient YAML API for other languages. There's already a cursory implementation for Python (using only the low-level API). After ironing out the general approach, other languages are likely to follow: probably (in order) JavaScript, C#, Java, Ruby, PHP, Octave and R (all of this is possible because we're using <a href="http://www.swig.org/">SWIG</a>, which makes it easy to do so).</p>
<h3 id="python">Python</h3>
<p>(Note that this is a work in progress. Additions will be made and things will be changed.) With that said, here's an example of the Python API:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> ryml

<span class="co"># because ryml does not take ownership of the source buffer</span>
<span class="co"># ryml cannot accept strings; only bytes or bytearrays</span>
src <span class="op">=</span> b<span class="st">&quot;{HELLO: a, foo: b, bar: c, baz: d, seq: [0, 1, 2, 3]}&quot;</span>

<span class="kw">def</span> check(tree):
    <span class="co"># for now, only the index-based low-level API is implemented</span>
    <span class="cf">assert</span> tree.size() <span class="op">==</span> <span class="dv">10</span>
    <span class="cf">assert</span> tree.root_id() <span class="op">==</span> <span class="dv">0</span>
    <span class="cf">assert</span> tree.first_child(<span class="dv">0</span>) <span class="op">==</span> <span class="dv">1</span>
    <span class="cf">assert</span> tree.next_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">2</span>
    <span class="cf">assert</span> tree.first_sibling(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">2</span>
    <span class="cf">assert</span> tree.last_sibling(<span class="dv">1</span>) <span class="op">==</span> <span class="dv">5</span>
    <span class="co"># use bytes objects for queries</span>
    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;foo&quot;</span>) <span class="op">==</span> <span class="dv">1</span>
    <span class="cf">assert</span> tree.key(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;foo&quot;</span>)
    <span class="cf">assert</span> tree.val(<span class="dv">1</span>) <span class="op">==</span> b<span class="st">&quot;b&quot;</span>)
    <span class="cf">assert</span> tree.find_child(<span class="dv">0</span>, b<span class="st">&quot;seq&quot;</span>) <span class="op">==</span> <span class="dv">5</span>
    <span class="cf">assert</span> tree.is_seq(<span class="dv">5</span>)
    <span class="co"># to loop over children:</span>
    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.children(tree, <span class="dv">5</span>)):
        <span class="cf">assert</span> tree.val(ch) <span class="op">==</span> [b<span class="st">&quot;0&quot;</span>, b<span class="st">&quot;1&quot;</span>, b<span class="st">&quot;2&quot;</span>, b<span class="st">&quot;3&quot;</span>][i]
    <span class="co"># to loop over siblings:</span>
    <span class="cf">for</span> i, sib <span class="kw">in</span> <span class="bu">enumerate</span>(ryml.siblings(tree, <span class="dv">5</span>)):
        <span class="cf">assert</span> tree.key(sib) <span class="op">==</span> [b<span class="st">&quot;HELLO&quot;</span>, b<span class="st">&quot;foo&quot;</span>, b<span class="st">&quot;bar&quot;</span>, b<span class="st">&quot;baz&quot;</span>, b<span class="st">&quot;seq&quot;</span>][i]
    <span class="co"># to walk over all elements</span>
    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> tree.size()
    <span class="cf">for</span> n, indentation_level <span class="kw">in</span> ryml.walk(tree):
        <span class="co"># just a dumb emitter</span>
        left <span class="op">=</span> <span class="st">&quot;  &quot;</span> <span class="op">*</span> indentation_level
        <span class="cf">if</span> tree.is_keyval(n):
           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.key(n), tree.val(n))
        <span class="cf">elif</span> tree.is_val(n):
           <span class="bu">print</span>(<span class="st">&quot;- </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(left, tree.val(n))
        <span class="cf">elif</span> tree.is_keyseq(n):
           <span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}{}</span><span class="st">:&quot;</span>.<span class="bu">format</span>(left, tree.key(n))
        visited[inode] <span class="op">=</span> <span class="va">True</span>
    <span class="cf">assert</span> <span class="va">False</span> <span class="kw">not</span> <span class="kw">in</span> visited
    <span class="co"># </span><span class="al">NOTE</span><span class="co"> about encoding!</span>
    k <span class="op">=</span> tree.get_key(<span class="dv">5</span>)
    <span class="bu">print</span>(k)  <span class="co"># &#39;&lt;memory at 0x7f80d5b93f48&gt;&#39;</span>
    <span class="cf">assert</span> k <span class="op">==</span> b<span class="st">&quot;seq&quot;</span>               <span class="co"># ok, as expected</span>
    <span class="cf">assert</span> k <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>                <span class="co"># not ok - </span><span class="al">NOTE</span><span class="co"> THIS! </span>
    <span class="cf">assert</span> <span class="bu">str</span>(k) <span class="op">!=</span> <span class="st">&quot;seq&quot;</span>           <span class="co"># not ok</span>
    <span class="cf">assert</span> <span class="bu">str</span>(k, <span class="st">&quot;utf8&quot;</span>) <span class="op">==</span> <span class="st">&quot;seq&quot;</span>   <span class="co"># ok again</span>

<span class="co"># parse immutable buffer</span>
tree <span class="op">=</span> ryml.parse(src)
check(tree) <span class="co"># OK</span>

<span class="co"># also works, but requires bytearrays or</span>
<span class="co"># objects offering writeable memory</span>
mutable <span class="op">=</span> <span class="bu">bytearray</span>(src)
tree <span class="op">=</span> ryml.parse_in_situ(mutable)
check(tree) <span class="co"># OK</span></code></pre></div>
<p>As expected, the performance results so far are encouraging. In a <a href="api/python/parse_bm.py">timeit benchmark</a> compared against <a href="https://pyyaml.org/">PyYaml</a> and <a href="https://yaml.readthedocs.io/en/latest/">ruamel.yaml</a>, ryml parses quicker by a factor of 30x-50x:</p>
<pre><code>+-----------------------+-------+----------+---------+----------------+
| case                  | iters | time(ms) | avg(ms) | avg_read(MB/s) |
+-----------------------+-------+----------+---------+----------------+
| parse:RuamelYaml      |    88 | 800.483  |  9.096  |      0.234     |
| parse:PyYaml          |    88 | 541.370  |  6.152  |      0.346     |
| parse:RymlRo          |  3888 | 776.020  |  0.200  |     10.667     |
| parse:RymlRoReuse     |  1888 | 381.558  |  0.202  |     10.535     |
| parse:RymlRw          |  3888 | 775.121  |  0.199  |     10.679     |
| parse:RymlRwReuse     |  3888 | 774.534  |  0.199  |     10.687     |
+-----------------------+-------+----------+---------+----------------+</code></pre>
<p>(Note that the results above are somewhat biased towards ryml, because it does not perform any type conversions: return types are merely <code>memoryviews</code> to the source buffer.)</p>
<hr />
<h2 id="yaml-standard-conformance">YAML standard conformance</h2>
<p>ryml is under active development, but is close to feature complete. The following YAML core features are well covered in the unit tests: * mappings * sequences * complex keys * literal blocks * quoted scalars * tags * anchors and references * UTF8 is expected to mostly work</p>
<p>Of course, there are many dark corners in YAML, and there certainly can appear cases which ryml fails to parse. Your <a href="https://github.com/biojppm/rapidyaml/issues">bug reports or pull requests!</a> are very welcome.</p>
<p>See also <a href="./ROADMAP.md">the roadmap</a> for a list of future work.</p>
<h3 id="test-suite-status">Test suite status</h3>
<p>Integration of the &gt;300 cases in the <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a> is ongoing work. Each of these tests have several subparts: * in-yaml: mildly, plainly or extremely difficult-to-parse yaml * in-json: equivalent json (where possible/meaningful) * out-yaml: equivalent standard yaml * events: equivalent libyaml events allowing to establish correctness of the parsed results</p>
<p>When testing, ryml tries to parse each of the 3 yaml/json parts. If the parsing suceeds, then the ryml test will emit the parsed tree, then parse the emitted result and verify that emission is idempotent, ie that the emitted result is the same as its input without any loss of information. To ensure correctness, this happens over four levels of parse/emission pairs, resulting on ~200 checks per test case.</p>
<p>Please note that in <a href="http://matrix.yaml.io/">their own words</a>, the tests from the YAML test suite <em>contain a lot of edge cases that don't play such an important role in real world examples</em>. Despite the extreme focus of the test suite, as of May 2020, ryml only fails to parse ~30 out of the <sub>1000=</sub>3x300 cases from the test suite. Out of all other cases, all the ~200 checks per case are 100% successful for consistency over parse/emit pairs --- but please note that the events part is not yet read in and used to check for correctness, and therefore that <strong>even though ryml may suceed in parsing, there still exists a minority of cases which may not be correct</strong>. Currently, I would estimate this fraction at somewhere around 5%. These are the suite cases where ryml fails to parse any of its subparts: <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/EXG3.tml">EXG3</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/M7A3.tml">M7A3</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/735Y.tml">735Y</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/82AN.tml">82AN</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/9YRD.tml">9YRD</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/EX5H.tml">EX5H</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/HS5T.tml">HS5T</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/7T8X.tml">7T8X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/RZP5.tml">RZP5</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/FH7J.tml">FH7J</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/PW8X.tml">PW8X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/CN3R.tml">CN3R</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6BCT.tml">6BCT</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/G5U8.tml">G5U8</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/K858.tml">K858</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/NAT4.tml">NAT4</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/9MMW.tml">9MMW</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/DC7X.tml">DC7X</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/L94M.tml">L94M</a>,</p>
<p>Except for the known limitations listed next, all other suite cases are expected to work.</p>
<hr />
<h2 id="known-limitations">Known limitations</h2>
<p>ryml makes no effort to follow the standard in the following situations:</p>
<ul>
<li><code>%YAML</code> directives have no effect and are ignored.</li>
<li><code>%TAG</code> directives have no effect and are ignored. All schemas are assumed to be the default YAML 2002 schema.</li>
<li>container elements are not accepted as mapping keys. keys must be simple strings and cannot themselves be mappings or sequences. But mapping values can be any of the above. <a href="https://github.com/yaml/yaml-test-suite">YAML test suite</a> cases: <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/4FJ6.tml">4FJ6</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6BFJ.tml">6BFJ</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6PBE.tml">6PBE</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/6PBE.tml">6PBE</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/KK5P.tml">KK5P</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/KZN9.tml">KZN9</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/LX3P.tml">LX3P</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/M5DY.tml">M5DY</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/Q9WF.tml">Q9WF</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/SBG9.tml">SBG9</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/X38W.tml">X38W</a>, <a href="https://github.com/yaml/yaml-test-suite/tree/master/test/XW4D.tml">XW4D</a>.</li>
</ul>
<hr />
<h2 id="alternative-libraries">Alternative libraries</h2>
<p>Why this library? Because none of the existing libraries was quite what I wanted. There are two C/C++ libraries that I know of:</p>
<ul>
<li><a href="https://github.com/yaml/libyaml">libyaml</a></li>
<li><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></li>
</ul>
<p>The standard <a href="https://github.com/yaml/libyaml">libyaml</a> is a bare C library. It does not create a representation of the data tree, so it can't qualify as practical. My initial idea was to wrap parsing and emitting around libyaml, but to my surprise I found out it makes heavy use of allocations and string duplications when parsing. I briefly pondered on sending PRs to reduce these allocation needs, but not having a permanent tree to store the parsed data was too much of a downside.</p>
<p><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a> is full of functionality, but is heavy on the use of node-pointer-based structures like <code>std::map</code>, allocations, string copies and slow C++ stream serializations. This is generally a sure way of making your code slower, and strong evidence of this can be seen in the benchmark results above.</p>
<p>When performance and low latency are important, using contiguous structures for better cache behavior and to prevent the library from trampling over the client's caches, parsing in place and using non-owning strings is of central importance. Hence this Rapid YAML library which, with minimal compromise, bridges the gap from efficiency to usability. This library takes inspiration from <a href="https://github.com/Tencent/rapidjson">RapidJSON</a> and <a href="http://rapidxml.sourceforge.net/">RapidXML</a>.</p>
<hr />
<h2 id="license">License</h2>
<p>ryml is permissively licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
