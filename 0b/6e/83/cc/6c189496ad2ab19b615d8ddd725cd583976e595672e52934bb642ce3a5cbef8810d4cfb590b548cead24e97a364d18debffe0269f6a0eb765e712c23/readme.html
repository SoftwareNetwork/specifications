<p><a href="https://travis-ci.org/Tessil/array-hash"><img
src="https://travis-ci.org/Tessil/array-hash.svg?branch=master"
alt="Build Status" /></a> <a
href="https://ci.appveyor.com/project/Tessil/array-hash/branch/master"><img
src="https://ci.appveyor.com/api/projects/status/t50rr5bm6ejf350x/branch/master?svg=true"
alt="Build status" /></a></p>
<h2
id="a-c-implementation-of-a-fast-and-memory-efficient-hash-mapset-for-strings">A
C++ implementation of a fast and memory efficient hash map/set for
strings</h2>
<p>Cache conscious hash map and hash set for strings based on the
“Cache-conscious collision resolution in string hash tables.” (Askitis
Nikolas and Justin Zobel, 2005) paper. You can find some details
regarding the structure <a
href="https://tessil.github.io/2017/06/22/hat-trie.html#array-hash-table">here</a>.</p>
<p>Thanks to its cache friendliness, the structure provides fast lookups
while keeping a low memory usage. The main drawback is the rehash
process which is a bit slow and need some spare memory to copy the
strings from the old hash table to the new hash table (it can’t use
<code>std::move</code> as the other hash tables using
<code>std::string</code> as key).</p>
<p align="center">
<img src="https://tessil.github.io/images/array_hash.png" width="500px" />
</p>
<p>Four classes are provided: <code>tsl::array_map</code>,
<code>tsl::array_set</code>, <code>tsl::array_pg_map</code> and
<code>tsl::array_pg_set</code>. The first two are faster and use a power
of two growth policy, the last two use a prime growth policy instead and
are able to cope better with a poor hash function. Use the prime version
if there is a chance of repeating patterns in the lower bits of your
hash (e.g. you are storing pointers with an identity hash function). See
<a href="#growth-policy">GrowthPolicy</a> for details.</p>
<p>A <strong>benchmark</strong> of <code>tsl::array_map</code> against
other hash maps can be found <a
href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">here</a>.
This page also gives some advices on which hash table structure you
should try for your use case (useful if you are a bit lost with the
multiple hash tables implementations in the <code>tsl</code> namespace).
You can also find another benchmark on the <a
href="https://github.com/Tessil/hat-trie#benchmark"><code>tsl::hat-trie</code></a>
page.</p>
<h3 id="overview">Overview</h3>
<ul>
<li>Header-only library, just add the <a href="include/">include</a>
directory to your include path and you are ready to go. If you use
CMake, you can also use the <code>tsl::array_hash</code> exported target
from the <a href="CMakeLists.txt">CMakeLists.txt</a>.</li>
<li>Low memory usage with good performances, see the <a
href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">benchmark</a>
for some numbers.</li>
<li>Support for move-only and non-default constructible values.</li>
<li>Strings with null characters inside them are supported (you can thus
store binary data as key).</li>
<li>If the hash is known before a lookup, it is possible to pass it as
parameter to speed-up the lookup (see <code>precalculated_hash</code>
parameter in <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a>).</li>
<li>Support for efficient serialization and deserialization (see <a
href="#serialization">example</a> and the
<code>serialize/deserialize</code> methods in the <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a>
for details).</li>
<li>By default the maximum allowed size for a key is set to 65 535. This
can be raised through the <code>KeySizeT</code> template parameter (see
<a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a>
for details).</li>
<li>By default the maximum size of the map is limited to 4 294 967 296
elements. This can be raised through the <code>IndexSizeT</code>
template parameter (see <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a>
for details).</li>
</ul>
<h3 id="differences-compare-to-stdunordered_map">Differences compare to
<code>std::unordered_map</code></h3>
<p><code>tsl::array_map</code> tries to have an interface similar to
<code>std::unordered_map</code>, but some differences exist: - Iterator
invalidation doesn’t behave in the same way, any operation modifying the
hash table invalidate them (see <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a>
for details). - References and pointers to keys or values in the map are
invalidated in the same way as iterators to these keys-values. - Erase
operations have an amortized runtime complexity of O(1) for
<code>tsl::array_map</code>. An erase operation will delete the key
immediatly but for the value part of the map, the deletion may be
delayed. The destructor of the value is only called when the ratio
between the size of the map and the size of the map + the number of
deleted values still stored is low enough. The method
<code>shrink_to_fit</code> may be called to force the deletion. - The
key and the value are stored separatly and not in a
<code>std::pair&lt;const Key, T&gt;</code>. Methods like
<code>insert</code> or <code>emplace</code> take the key and the value
separatly instead of a <code>std::pair</code>. The insert method looks
like
<code>std::pair&lt;iterator, bool&gt; insert(const CharT* key, const T&amp; value)</code>
instead of
<code>std::pair&lt;iterator, bool&gt; insert(const std::pair&lt;const Key, T&gt;&amp; value)</code>
(see <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a>
for details). - For iterators, <code>operator*()</code> and
<code>operator-&gt;()</code> return a reference and a pointer to the
value <code>T</code> instead of
<code>std::pair&lt;const Key, T&gt;</code>. For an access to the key
string, the <code>key()</code> (which returns a
<code>const CharT*</code>) or <code>key_sv()</code> (which returns a
<code>std::basic_string_view&lt;CharT&gt;</code>) method of the iterator
must be called. - No support for some bucket related methods (like
<code>bucket_size</code>, <code>bucket</code>, …).</p>
<p>These differences also apply between <code>std::unordered_set</code>
and <code>tsl::array_set</code>.</p>
<p>Thread-safety and exception guarantees are similar to the STL
containers.</p>
<h3 id="hash-function">Hash function</h3>
<p>The default hash function used by the structure depends on the
presence of <code>std::string_view</code>. If it is available,
<code>std::hash&lt;std::string_view&gt;</code> is used, otherwise a
simple <a
href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash">FNV-1a</a>
hash function is used to avoid any dependency.</p>
<p>If you can’t use C++17 or later, we recommend to replace the hash
function with something like <a
href="https://github.com/google/cityhash">CityHash</a>, MurmurHash, <a
href="https://github.com/google/farmhash">FarmHash</a>, … for better
performances. On the tests we did, CityHash64 offers a ~40% improvement
on reads compared to FNV-1a.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;city.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> str_hash <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> key<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>key_size<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> CityHash64<span class="op">(</span>key<span class="op">,</span> key_size<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> str_hash<span class="op">&gt;</span> map<span class="op">;</span></span></code></pre></div>
<p>The <code>std::hash&lt;std::string&gt;</code> can’t be used
efficiently as the structure doesn’t store any <code>std::string</code>
object. Any time a hash would be needed, a temporary
<code>std::string</code> would have to be created.</p>
<h3 id="growth-policy">Growth policy</h3>
<p>The library supports multiple growth policies through the
<code>GrowthPolicy</code> template parameter. Three policies are
provided by the library but you can easily implement your own if
needed.</p>
<ul>
<li><strong><a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1power__of__two__growth__policy.html">tsl::ah::power_of_two_growth_policy.</a></strong>
Default policy used by <code>tsl::array_map/set</code>. This policy
keeps the size of the bucket array of the hash table to a power of two.
This constraint allows the policy to avoid the usage of the slow modulo
operation to map a hash to a bucket, instead of <code>hash %
2<sup>n</sup></code>, it uses <code>hash &amp; (2<sup>n</sup> -
1)</code> (see <a
href="https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues">fast
modulo</a>). Fast but this may cause a lot of collisions with a poor
hash function as the modulo with a power of two only masks the most
significant bits in the end.</li>
<li><strong><a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1prime__growth__policy.html">tsl::ah::prime_growth_policy.</a></strong>
Default policy used by <code>tsl::array_pg_map/set</code>. The policy
keeps the size of the bucket array of the hash table to a prime number.
When mapping a hash to a bucket, using a prime number as modulo will
result in a better distribution of the hash across the buckets even with
a poor hash function. To allow the compiler to optimize the modulo
operation, the policy use a lookup table with constant primes modulos
(see <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1prime__growth__policy.html#details">API</a>
for details). Slower than
<code>tsl::ah::power_of_two_growth_policy</code> but more secure.</li>
<li><strong><a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1mod__growth__policy.html">tsl::ah::mod_growth_policy.</a></strong>
The policy grows the map by a customizable growth factor passed in
parameter. It then just use the modulo operator to map a hash to a
bucket. Slower but more flexible.</li>
</ul>
<p>To implement your own policy, you have to implement the following
interface.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> custom_policy <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Called on hash table construction and rehash, min_bucket_count_in_out is the minimum buckets</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that the hash table needs. The policy can change it to a higher number of buckets if needed </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and the hash table will use this value as bucket count. If 0 bucket is asked, then the value</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// must stay at 0.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> custom_policy<span class="op">(</span><span class="bu">std::</span>size_t<span class="op">&amp;</span> min_bucket_count_in_out<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the bucket [0, bucket_count()) to which the hash belongs. </span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If bucket_count() is 0, it must always return 0.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t<span class="op"> </span>bucket_for_hash<span class="op">(</span><span class="bu">std::</span>size_t<span class="op"> </span>hash<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the number of buckets that should be used on next growth</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t<span class="op"> </span>next_bucket_count<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Maximum number of buckets supported by the policy</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t<span class="op"> </span>max_bucket_count<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reset the growth policy as if the policy was created with a bucket count of 0.</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// After a clear, the policy must always return 0 when bucket_for_hash() is called.</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> clear<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="installation">Installation</h3>
<p>To use the library, just add the <a href="include/">include</a>
directory to your include path. It is a <strong>header-only</strong>
library.</p>
<p>If you use CMake, you can also use the <code>tsl::array_hash</code>
exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a>
with <code>target_link_libraries</code>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example where the array-hash project is stored in a third-party directory</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">add_subdirectory</span>(third-party/array-hash)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">target_link_libraries</span>(<span class="bn">your_target</span> <span class="ot">PRIVATE</span> <span class="bn">tsl::array_hash</span>)  </span></code></pre></div>
<p>If the project has been installed through <code>make install</code>,
you can also use <code>find_package(tsl-array-hash REQUIRED)</code>
instead of <code>add_subdirectory</code>.</p>
<p>The code should work with any C++11 standard-compliant compiler and
has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/Tessil/array-hash.git</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> array-hash/tests</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> build</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> build</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cmake</span> ..</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cmake</span> <span class="at">--build</span> .</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ex">./tsl_array_hash_tests</span></span></code></pre></div>
<h3 id="usage">Usage</h3>
<p>The API can be found <a
href="https://tessil.github.io/array-hash/doc_without_string_view/html">here</a>.
If <code>std::string_view</code> is available, the API changes slightly
and can be found <a
href="https://tessil.github.io/array-hash/doc/html/">here</a>.</p>
<h3 id="example">Example</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tsl/array_map.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tsl/array_set.h&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map of const char* to int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> map <span class="op">=</span> <span class="op">{{</span><span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;two&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    map<span class="op">[</span><span class="st">&quot;three&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    map<span class="op">[</span><span class="st">&quot;four&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    map<span class="op">.</span>insert<span class="op">(</span><span class="st">&quot;five&quot;</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    map<span class="op">.</span>insert_ks<span class="op">(</span><span class="st">&quot;six_with_extra_chars_we_ignore&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    map<span class="op">.</span>erase<span class="op">(</span><span class="st">&quot;two&quot;</span><span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// When template parameter StoreNullTerminator is true (default) and there is no</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// null character in the strings.</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> map<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> map<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;{&quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>key<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If StoreNullTerminator is false for space efficiency or you are storing null characters, </span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// you can access to the size of the key.</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> map<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> map<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;{&quot;</span><span class="op">).</span>write<span class="op">(</span>it<span class="op">.</span>key<span class="op">(),</span> it<span class="op">.</span>key_size<span class="op">())</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Better, use key_sv() if you compiler provides access to std::string_view.</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> map<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> map<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;{&quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>key_sv<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Or if you just want the values.</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> value<span class="op">:</span> map<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;{&quot;</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map of const char32_t* to int</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> map_char32 <span class="op">=</span> <span class="op">{{</span><span class="st">U&quot;one&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="st">U&quot;two&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    map_char32<span class="op">[</span><span class="st">U&quot;three&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set of const char*</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    tsl<span class="op">::</span>array_set<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> set <span class="op">=</span> <span class="op">{</span><span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">,</span> <span class="st">&quot;three&quot;</span><span class="op">};</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    set<span class="op">.</span>insert<span class="op">({</span><span class="st">&quot;four&quot;</span><span class="op">,</span> <span class="st">&quot;five&quot;</span><span class="op">});</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> set<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> set<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;{&quot;</span> <span class="op">&lt;&lt;</span> it<span class="op">.</span>key<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;}&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="serialization">Serialization</h4>
<p>The library provides an efficient way to serialize and deserialize a
map or a set so that it can be saved to a file or send through the
network. To do so, it requires the user to provide a function object for
both serialization and deserialization.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> serializer <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Must support the following types for U: std::uint64_t, float and T if a map is used.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> U<span class="op">&amp;</span> value<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> CharT<span class="op">*</span> value<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>value_size<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> deserializer <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Must support the following types for U: std::uint64_t, float and T if a map is used.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    U <span class="kw">operator</span><span class="op">()();</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>CharT<span class="op">*</span> value_out<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>value_size<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Note that the implementation leaves binary compatibilty (endianness,
float binary representation, size of int, …) of the types it
serializes/deserializes in the hands of the provided function objects if
compatibilty is required.</p>
<p>More details regarding the <code>serialize</code> and
<code>deserialize</code> methods can be found in the <a
href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a>.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tsl/array_map.h&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> serializer <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    serializer<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_ostream</span><span class="op">.</span>exceptions<span class="op">(</span><span class="va">m_ostream</span><span class="op">.</span>badbit <span class="op">|</span> <span class="va">m_ostream</span><span class="op">.</span>failbit<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_ostream</span><span class="op">.</span>open<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>             <span class="kw">typename</span> <span class="bu">std::</span>enable_if<span class="op">&lt;</span><span class="bu">std::</span>is_arithmetic<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">&gt;::</span>type<span class="op">*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_ostream</span><span class="op">.</span>write<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> <span class="dt">char</span><span class="op">*&gt;(&amp;</span>value<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span>T<span class="op">));</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="dt">char32_t</span><span class="op">*</span> value<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>value_size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_ostream</span><span class="op">.</span>write<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> <span class="dt">char</span><span class="op">*&gt;(</span>value<span class="op">),</span> value_size<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">char32_t</span><span class="op">));</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ofstream<span class="op"> </span><span class="va">m_ostream</span><span class="op">;</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> deserializer <span class="op">{</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    deserializer<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_istream</span><span class="op">.</span>exceptions<span class="op">(</span><span class="va">m_istream</span><span class="op">.</span>badbit <span class="op">|</span> <span class="va">m_istream</span><span class="op">.</span>failbit <span class="op">|</span> <span class="va">m_istream</span><span class="op">.</span>eofbit<span class="op">);</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_istream</span><span class="op">.</span>open<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>             <span class="kw">typename</span> <span class="bu">std::</span>enable_if<span class="op">&lt;</span><span class="bu">std::</span>is_arithmetic<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">&gt;::</span>type<span class="op">*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    T <span class="kw">operator</span><span class="op">()()</span> <span class="op">{</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        T value<span class="op">;</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_istream</span><span class="op">.</span>read<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(&amp;</span>value<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span>T<span class="op">));</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">char32_t</span><span class="op">*</span> value_out<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>value_size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_istream</span><span class="op">.</span>read<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>value_out<span class="op">),</span> value_size<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">char32_t</span><span class="op">));</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ifstream<span class="op"> </span><span class="va">m_istream</span><span class="op">;</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="bu">std::</span>int64_t<span class="op">&gt;</span> map <span class="op">=</span> <span class="op">{{</span><span class="st">U&quot;one&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="st">U&quot;two&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> </span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>                                                        <span class="op">{</span><span class="st">U&quot;three&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="st">U&quot;four&quot;</span><span class="op">,</span> <span class="dv">4</span><span class="op">}};</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name <span class="op">=</span> <span class="st">&quot;array_map.data&quot;</span><span class="op">;</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>        serializer serial<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>        map<span class="op">.</span>serialize<span class="op">(</span>serial<span class="op">);</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>        deserializer dserial<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> map_deserialized <span class="op">=</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="bu">std::</span>int64_t<span class="op">&gt;::</span>deserialize<span class="op">(</span>dserial<span class="op">);</span></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span>map <span class="op">==</span> map_deserialized<span class="op">);</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>        deserializer dserial<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>        <span class="co">/**</span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a><span class="co">         * If the serialized and deserialized map are hash compatibles (see conditions in API), </span></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a><span class="co">         * setting the argument to true speed-up the deserialization process as we don&#39;t have </span></span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a><span class="co">         * to recalculate the hash of each key. We also know how much space each bucket needs.</span></span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">bool</span> hash_compatible <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> map_deserialized <span class="op">=</span> </span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>            tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="bu">std::</span>int64_t<span class="op">&gt;::</span>deserialize<span class="op">(</span>dserial<span class="op">,</span> hash_compatible<span class="op">);</span></span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span>map <span class="op">==</span> map_deserialized<span class="op">);</span></span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5
id="serialization-with-boost-serialization-and-compression-with-zlib">Serialization
with Boost Serialization and compression with zlib</h5>
<p>It’s possible to use a serialization library to avoid some of the
boilerplate if the types to serialize are more complex.</p>
<p>The following example uses Boost Serialization with the Boost zlib
compression stream to reduce the size of the resulting serialized
file.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/archive/binary_iarchive.hpp&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/archive/binary_oarchive.hpp&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/iostreams/filter/zlib.hpp&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/iostreams/filtering_stream.hpp&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/serialization/split_free.hpp&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;boost/serialization/utility.hpp&gt;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tsl/array_map.h&gt;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Archive<span class="op">&gt;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> serializer <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    Archive<span class="op">&amp;</span> ar<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> val<span class="op">)</span> <span class="op">{</span> ar <span class="op">&amp;</span> val<span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> CharT<span class="op">&gt;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> CharT<span class="op">*</span> val<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>val_size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">.</span>save_binary<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> <span class="dt">void</span><span class="op">*&gt;(</span>val<span class="op">),</span> val_size<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span>CharT<span class="op">));</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>   </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Archive<span class="op">&gt;</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> deserializer <span class="op">{</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    Archive<span class="op">&amp;</span> ar<span class="op">;</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    T <span class="kw">operator</span><span class="op">()()</span> <span class="op">{</span> T val<span class="op">;</span> ar <span class="op">&amp;</span> val<span class="op">;</span> <span class="cf">return</span> val<span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> CharT<span class="op">&gt;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>CharT<span class="op">*</span> val_out<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>val_size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        ar<span class="op">.</span>load_binary<span class="op">(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>val_out<span class="op">),</span> val_size<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span>CharT<span class="op">));</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  </span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> boost <span class="op">{</span> <span class="kw">namespace</span> serialization <span class="op">{</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Archive<span class="op">,</span> <span class="kw">class</span> CharT<span class="op">,</span> <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> serialize<span class="op">(</span>Archive <span class="op">&amp;</span> ar<span class="op">,</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span>CharT<span class="op">,</span> T<span class="op">&gt;&amp;</span> map<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> version<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    split_free<span class="op">(</span>ar<span class="op">,</span> map<span class="op">,</span> version<span class="op">);</span> </span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Archive<span class="op">,</span> <span class="kw">class</span> CharT<span class="op">,</span> <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> save<span class="op">(</span>Archive <span class="op">&amp;</span> ar<span class="op">,</span> <span class="at">const</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span>CharT<span class="op">,</span> T<span class="op">&gt;&amp;</span> map<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> version<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    serializer<span class="op">&lt;</span>Archive<span class="op">&gt;</span> serial<span class="op">{</span>ar<span class="op">};</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    map<span class="op">.</span>serialize<span class="op">(</span>serial<span class="op">);</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Archive<span class="op">,</span> <span class="kw">class</span> CharT<span class="op">,</span> <span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> load<span class="op">(</span>Archive <span class="op">&amp;</span> ar<span class="op">,</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span>CharT<span class="op">,</span> T<span class="op">&gt;&amp;</span> map<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> version<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    deserializer<span class="op">&lt;</span>Archive<span class="op">&gt;</span> deserial<span class="op">{</span>ar<span class="op">};</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>    map <span class="op">=</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span>CharT<span class="op">,</span> T<span class="op">&gt;::</span>deserialize<span class="op">(</span>deserial<span class="op">);</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a><span class="op">}}</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="bu">std::</span>int64_t<span class="op">&gt;</span> map <span class="op">=</span> <span class="op">{{</span><span class="st">U&quot;one&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="st">U&quot;two&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> </span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>                                                        <span class="op">{</span><span class="st">U&quot;three&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="st">U&quot;four&quot;</span><span class="op">,</span> <span class="dv">4</span><span class="op">}};</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name <span class="op">=</span> <span class="st">&quot;array_map.data&quot;</span><span class="op">;</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ofstream<span class="op"> </span>ofs<span class="op">;</span></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>        ofs<span class="op">.</span>exceptions<span class="op">(</span>ofs<span class="op">.</span>badbit <span class="op">|</span> ofs<span class="op">.</span>failbit<span class="op">);</span></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>        ofs<span class="op">.</span>open<span class="op">(</span>file_name<span class="op">,</span> <span class="bu">std::</span>ios<span class="bu">::</span>binary<span class="op">);</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>        <span class="ex">boost::</span>iostreams<span class="ex">::</span>filtering_ostream<span class="op"> </span>fo<span class="op">;</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>        fo<span class="op">.</span>push<span class="op">(</span><span class="ex">boost::</span>iostreams<span class="ex">::</span>zlib_compressor<span class="op">());</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>        fo<span class="op">.</span>push<span class="op">(</span>ofs<span class="op">);</span></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>        <span class="ex">boost::</span>archive<span class="ex">::</span>binary_oarchive<span class="op"> </span>oa<span class="op">(</span>fo<span class="op">);</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>        oa <span class="op">&lt;&lt;</span> map<span class="op">;</span></span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ifstream<span class="op"> </span>ifs<span class="op">;</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>        ifs<span class="op">.</span>exceptions<span class="op">(</span>ifs<span class="op">.</span>badbit <span class="op">|</span> ifs<span class="op">.</span>failbit <span class="op">|</span> ifs<span class="op">.</span>eofbit<span class="op">);</span></span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>        ifs<span class="op">.</span>open<span class="op">(</span>file_name<span class="op">,</span> <span class="bu">std::</span>ios<span class="bu">::</span>binary<span class="op">);</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>        <span class="ex">boost::</span>iostreams<span class="ex">::</span>filtering_istream<span class="op"> </span>fi<span class="op">;</span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>        fi<span class="op">.</span>push<span class="op">(</span><span class="ex">boost::</span>iostreams<span class="ex">::</span>zlib_decompressor<span class="op">());</span></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>        fi<span class="op">.</span>push<span class="op">(</span>ifs<span class="op">);</span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>        <span class="ex">boost::</span>archive<span class="ex">::</span>binary_iarchive<span class="op"> </span>ia<span class="op">(</span>fi<span class="op">);</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>        tsl<span class="op">::</span>array_map<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">,</span> <span class="bu">std::</span>int64_t<span class="op">&gt;</span> map_deserialized<span class="op">;</span>   </span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>        ia <span class="op">&gt;&gt;</span> map_deserialized<span class="op">;</span></span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span>map <span class="op">==</span> map_deserialized<span class="op">);</span></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="license">License</h3>
<p>The code is licensed under the MIT license, see the <a
href="LICENSE">LICENSE file</a> for details.</p>
