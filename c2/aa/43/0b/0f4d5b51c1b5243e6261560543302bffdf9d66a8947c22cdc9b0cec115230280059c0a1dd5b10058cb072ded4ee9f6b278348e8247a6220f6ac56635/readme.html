<p>C++ Mathematical Expression Toolkit Library Documentation</p>
<p>Section 00 - Introduction Section 01 - Capabilities Section 02 -
Example Expressions Section 03 - Copyright Notice Section 04 - Downloads
&amp; Updates Section 05 - Installation Section 06 - Compilation Section
07 - Compiler Compatibility Section 08 - Built-In Operations &amp;
Functions Section 09 - Fundamental Types Section 10 - Components Section
11 - Compilation Options Section 12 - Expression Structures Section 13 -
Variable, Vector &amp; String Definition Section 14 - Vector Processing
Section 15 - User Defined Functions Section 16 - Expression Dependents
Section 17 - Hierarchies Of Symbol Tables Section 18 - Unknown Unknowns
Section 19 - Enabling &amp; Disabling Features Section 20 - Expression
Return Values Section 21 - Compilation Errors Section 22 - Runtime
Library Packages Section 23 - Helpers &amp; Utils Section 24 - Runtime
Checks Section 25 - Benchmarking Section 26 - Exprtk Notes Section 27 -
Simple Exprtk Example Section 28 - Build Options Section 29 - Files
Section 30 - Language Structure</p>
<p>[SECTION 00 - INTRODUCTION] The C++ Mathematical Expression Toolkit
Library (ExprTk) is a simple to use, easy to integrate and extremely
efficient run-time mathematical expression parsing and evaluation
engine. The parsing engine supports numerous forms of functional and
logic processing semantics and is easily extensible.</p>
<pre><code>
[SECTION 01 - CAPABILITIES]
The  ExprTk expression  evaluator supports  the following  fundamental
arithmetic operations, functions and processes:

 (00) Types:           Scalar, Vector, String

 (01) Basic operators: +, -, *, /, %, ^

 (02) Assignment:      :=, +=, -=, *=, /=, %=

 (03) Equalities &amp;
      Inequalities:    =, ==, &lt;&gt;, !=, &lt;, &lt;=, &gt;, &gt;=

 (04) Logic operators: and, mand, mor, nand, nor, not, or, shl, shr,
                       xnor, xor, true, false

 (05) Functions:       abs, avg, ceil, clamp, equal, erf, erfc,  exp,
                       expm1, floor, frac,  log, log10, log1p,  log2,
                       logn, max,  min, mul,  ncdf,  not_equal, root,
                       round, roundn, sgn, sqrt, sum, swap, trunc

 (06) Trigonometry:    acos, acosh, asin, asinh, atan, atanh,  atan2,
                       cos,  cosh, cot,  csc, sec,  sin, sinc,  sinh,
                       tan, tanh, hypot, rad2deg, deg2grad,  deg2rad,
                       grad2deg

 (07) Control
      structures:      if-then-else, ternary conditional, switch-case,
                       return-statement

 (08) Loop statements: while, for, repeat-until, break, continue

 (09) String
      processing:      in, like, ilike, concatenation

 (10) Optimisations:   constant-folding, simple strength reduction and
                       dead code elimination

 (11) Runtime checks:  vector bounds, string bounds, loop iteration,
                       execution-time bounds and compilation process
                       checkpointing, assert statements

 (12) Calculus:        numerical integration and differentiation
</code></pre>
<p>[SECTION 02 - EXAMPLE EXPRESSIONS] The following is a short listing
of infix format based mathematical expressions that can be parsed and
evaluated using the ExprTk library.</p>
<ol type="1">
<li>sqrt(1 - (3 / x^2))</li>
<li>clamp(-1, sin(2 * pi * x) + cos(y / 2 * pi), +1)</li>
<li>sin(2.34e-3 * x)</li>
<li>if(((x[2] + 2) == 3) and ((y + 5) &lt;= 9), 1 + w, 2 / z)</li>
<li>inrange(-2, m, +2) == if(({-2 &lt;= m} and [m &lt;= +2]), 1, 0)</li>
<li>({1/1}<em>[1/2]+(1/3)) - {1/4}<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>+(1/6) -
({1/7}+[1/8]</em>(1/9))</li>
<li>a * exp(2.2 / 3.3 * t) + c</li>
<li>z := x + sin(2.567 * pi / y)</li>
<li>u := 2.123 * {pi * z} / (w := x + cos(y / pi))</li>
<li>2x + 3y + 4z + 5w == 2 * x + 3 * y + 4 * z + 5 * w</li>
<li>3(x + y) / 2.9 + 1.234e+12 == 3 * (x + y) / 2.9 + 1.234e+12</li>
<li>(x + y)3.3 + 1 / 4.5 == [x + y] * 3.3 + 1 / 4.5</li>
<li>(x + y[i])z + 1.1 / 2.7 == (x + y[i]) * z + 1.1 / 2.7</li>
<li>(sin(x / pi) cos(2y) + 1) == (sin(x / pi) * cos(2 * y) + 1)</li>
<li>75x^17 + 25.1x^5 - 35x^4 - 15.2x^3 + 40x^2 - 15.3x + 1</li>
<li>(avg(x,y) &lt;= x + y ? x - y : x * y) + 2.345 * pi / x</li>
<li>while (x &lt;= 100) { x -= 1; }</li>
<li>x &lt;= ‘abc123’ and (y in ‘AString’) or (‘1x2y3z’ != z)</li>
<li>((x + ‘abc’) like ‘<em>123</em>’) or (‘a123b’ ilike y)</li>
<li>sgn(+1.2^3.4z / -5.6y) &lt;= {-7.8^9 / -10.11x }</li>
</ol>
<pre><code>
[SECTION 03 - COPYRIGHT NOTICE]
Free  use  of  the  C++  Mathematical  Expression  Toolkit  Library is
permitted under the guidelines and in accordance with the most current
version of the MIT License.

   (1) https://www.opensource.org/licenses/MIT
   (2) SPDX-License-Identifier: MIT
   (3) SPDX-FileCopyrightText : Copyright (C) 1999-2024 Arash Partow
</code></pre>
<p>[SECTION 04 - DOWNLOADS &amp; UPDATES] The most recent version of the
C++ Mathematical Expression Toolkit Library including all updates and
tests can be found at the following locations:</p>
<ol type="1">
<li>Download: https://www.partow.net/programming/exprtk/index.html</li>
<li>Mirror Repository: https://github.com/ArashPartow/exprtk
https://github.com/ArashPartow/exprtk-extras</li>
</ol>
<pre><code>
[SECTION 05 - INSTALLATION]
The header  file exprtk.hpp  should be  placed in a project or  system
include path (e.g: /usr/include/).
</code></pre>
<p>[SECTION 06 - COMPILATION] The ExprTk package contains the ExprTk
header, a set of simple examples and a benchmark and unit test suite.
The following is a list of commands to build the various components:</p>
<ol type="a">
<li>For a complete build: make clean all</li>
<li>For a PGO build: make clean pgo</li>
<li>To strip executables: make strip_bin</li>
<li>Execute valgrind check: make valgrind_check</li>
</ol>
<pre><code>
[SECTION 07 - COMPILER COMPATIBILITY]
ExprTk has been built error and warning free using the following set
of C++ compilers:

  (*) GNU Compiler Collection (3.5+)
  (*) Clang/LLVM (1.1+)
  (*) Microsoft Visual Studio C++ Compiler (7.1+)
  (*) Intel C++ Compiler (8.x+)
  (*) AMD Optimizing C++ Compiler (1.2+)
  (*) Nvidia C++ Compiler (19.x+)
  (*) PGI C++ (10.x+)
  (*) Circle C++ (circa: b81c37d2bb227c)
  (*) IBM XL C/C++ (9.x+)
  (*) C++ Builder (XE4+)
</code></pre>
<p>[SECTION 08 - BUILT-IN OPERATIONS &amp; FUNCTIONS]</p>
<ol start="0" type="1">
<li><p>Arithmetic &amp; Assignment Operators +———-+———————————————————+
| OPERATOR | DEFINITION | +———-+———————————————————+ | + | Addition
between x and y. (eg: x + y) | +———-+———————————————————+ | - |
Subtraction between x and y. (eg: x - y) | +———-+———————————————————+ |
* | Multiplication between x and y. (eg: x * y) |
+———-+———————————————————+ | / | Division between x and y. (eg: x / y) |
+———-+———————————————————+ | % | Modulus of x with respect to y. (eg: x
% y) | +———-+———————————————————+ | ^ | x to the power of y. (eg: x ^ y)
| +———-+———————————————————+ | := | Assign the value of x to y. Where y
is either a variable| | | or vector type. (eg: y := x) |
+———-+———————————————————+ | += | Increment x by the value of the
expression on the right | | | hand side. Where x is either a variable or
vector type. | | | (eg: x += abs(y - z)) | +———-+———————————————————+ |
-= | Decrement x by the value of the expression on the right | | | hand
side. Where x is either a variable or vector type. | | | (eg: x[i] -=
abs(y + z)) | +———-+———————————————————+ | <em>= | Assign the
multiplication of x by the value of the | | | expression on the
righthand side to x. Where x is either| | | a variable or vector type. |
| | (eg: x </em>= abs(y / z)) | +———-+———————————————————+ | /= | Assign
the division of x by the value of the expression | | | on the right-hand
side to x. Where x is either a | | | variable or vector type. (eg: x[i +
j] /= abs(y * z)) | +———-+———————————————————+ | %= | Assign x modulo
the value of the expression on the right| | | hand side to x. Where x is
either a variable or vector | | | type. (eg: x[2] %= y ^ 2) |
+———-+———————————————————+</p></li>
<li><p>Equalities &amp; Inequalities +———-+———————————————————+ |
OPERATOR | DEFINITION | +———-+———————————————————+ | == or = | True only
if x is strictly equal to y. (eg: x == y) | +———-+———————————————————+ |
&lt;&gt; or != | True only if x does not equal y. (eg: x &lt;&gt; y or x
!= y) | +———-+———————————————————+ | &lt; | True only if x is less than
y. (eg: x &lt; y) | +———-+———————————————————+ | &lt;= | True only if x
is less than or equal to y. (eg: x &lt;= y) | +———-+———————————————————+
| &gt; | True only if x is greater than y. (eg: x &gt; y) |
+———-+———————————————————+ | &gt;= | True only if x greater than or
equal to y. (eg: x &gt;= y) | +———-+———————————————————+</p></li>
<li><p>Boolean Operations +———-+———————————————————+ | OPERATOR |
DEFINITION | +———-+———————————————————+ | true | True state or any value
other than zero (typically 1). | +———-+———————————————————+ | false |
False state, value of exactly zero. | +———-+———————————————————+ | and |
Logical AND, True only if x and y are both true. | | | (eg: x and y) |
+———-+———————————————————+ | mand | Multi-input logical AND, True only
if all inputs are | | | true. Left to right short-circuiting of
expressions. | | | (eg: mand(x &gt; y, z &lt; w, u or v, w and x)) |
+———-+———————————————————+ | mor | Multi-input logical OR, True if at
least one of the | | | inputs are true. Left to right short-circuiting
of | | | expressions. (eg: mor(x &gt; y, z &lt; w, u or v, w and x)) |
+———-+———————————————————+ | nand | Logical NAND, True only if either x
or y is false. | | | (eg: x nand y) | +———-+———————————————————+ | nor |
Logical NOR, True only if the result of x or y is false | | | (eg: x nor
y) | +———-+———————————————————+ | not | Logical NOT, Negate the logical
sense of the input. | | | (eg: not(x and y) == x nand y) |
+———-+———————————————————+ | or | Logical OR, True if either x or y is
true. (eg: x or y) | +———-+———————————————————+ | xor | Logical XOR,
True only if the logical states of x and y | | | differ. (eg: x xor y) |
+———-+———————————————————+ | xnor | Logical XNOR, True iff the
biconditional of x and y is | | | satisfied. (eg: x xnor y) |
+———-+———————————————————+ | &amp; | Similar to AND but with left to
right expression short | | | circuiting optimisation. (eg: (x &amp; y)
== (y and x)) | +———-+———————————————————+ | | | Similar to OR but with
left to right expression short | | | circuiting optimisation. (eg: (x |
y) == (y or x)) | +———-+———————————————————+</p></li>
<li><p>General Purpose Functions +———-+———————————————————+ | FUNCTION |
DEFINITION | +———-+———————————————————+ | abs | Absolute value of x.
(eg: abs(x)) | +———-+———————————————————+ | avg | Average of all the
inputs. | | | (eg: avg(x,y,z,w,u,v) == (x + y + z + w + u + v) / 6) |
+———-+———————————————————+ | ceil | Smallest integer that is greater
than or equal to x. | +———-+———————————————————+ | clamp | Clamp x in
range between r0 and r1, where r0 &lt; r1. | | | (eg: clamp(r0,x,r1)) |
+———-+———————————————————+ | equal | Equality test between x and y using
normalised epsilon | +———-+———————————————————+ | erf | Error function
of x. (eg: erf(x)) | +———-+———————————————————+ | erfc | Complimentary
error function of x. (eg: erfc(x)) | +———-+———————————————————+ | exp |
e to the power of x. (eg: exp(x)) | +———-+———————————————————+ | expm1 |
e to the power of x minus 1, where x is very small. | | | (eg: expm1(x))
| +———-+———————————————————+ | floor | Largest integer that is less than
or equal to x. | | | (eg: floor(x)) | +———-+———————————————————+ | frac
| Fractional portion of x. (eg: frac(x)) | +———-+———————————————————+ |
hypot | Hypotenuse of x and y (eg: hypot(x,y) = sqrt(x<em>x + y</em>y))|
+———-+———————————————————+ | iclamp | Inverse-clamp x outside of the
range r0 and r1. Where | | | r0 &lt; r1. If x is within the range it
will snap to the | | | closest bound. (eg: iclamp(r0,x,r1) |
+———-+———————————————————+ | inrange | In-range returns ‘true’ when x is
within the range r0 | | | and r1. Where r0 &lt; r1. (eg:
inrange(r0,x,r1) | +———-+———————————————————+ | log | Natural logarithm
of x. (eg: log(x)) | +———-+———————————————————+ | log10 | Base 10
logarithm of x. (eg: log10(x)) | +———-+———————————————————+ | log1p |
Natural logarithm of 1 + x, where x is very small. | | | (eg: log1p(x))
| +———-+———————————————————+ | log2 | Base 2 logarithm of x. (eg:
log2(x)) | +———-+———————————————————+ | logn | Base N logarithm of x.
where n is a positive integer. | | | (eg: logn(x,8)) |
+———-+———————————————————+ | max | Largest value of all the inputs. (eg:
max(x,y,z,w,u,v)) | +———-+———————————————————+ | min | Smallest value of
all the inputs. (eg: min(x,y,z,w,u)) | +———-+———————————————————+ | mul
| Product of all the inputs. | | | (eg: mul(x,y,z,w,u,v,t) == (x * y * z
* w * u * v * t)) | +———-+———————————————————+ | ncdf | Normal
cumulative distribution function. (eg: ncdf(x)) |
+———-+———————————————————+ | not_equal| Not-equal test between x and y
using normalised epsilon | +———-+———————————————————+ | pow | x to the
power of y. (eg: pow(x,y) == x ^ y) | +———-+———————————————————+ | root
| Nth-Root of x. where n is a positive integer. | | | (eg: root(x,3) ==
x^(1/3)) | +———-+———————————————————+ | round | Round x to the nearest
integer. (eg: round(x)) | +———-+———————————————————+ | roundn | Round x
to n decimal places (eg: roundn(x,3)) | | | where n &gt; 0 and is an
integer. | | | (eg: roundn(1.2345678,4) == 1.2346) |
+———-+———————————————————+ | sgn | Sign of x, -1 where x &lt; 0, +1
where x &gt; 0, else zero. | | | (eg: sgn(x)) |
+———-+———————————————————+ | sqrt | Square root of x, where x &gt;= 0.
(eg: sqrt(x)) | +———-+———————————————————+ | sum | Sum of all the
inputs. | | | (eg: sum(x,y,z,w,u,v,t) == (x + y + z + w + u + v + t)) |
+———-+———————————————————+ | swap | Swap the values of the variables x
and y and return the | | &lt;=&gt; | current value of y. (eg: swap(x,y)
or x &lt;=&gt; y) | +———-+———————————————————+ | trunc | Integer portion
of x. (eg: trunc(x)) | +———-+———————————————————+</p></li>
<li><p>Trigonometry Functions +———-+———————————————————+ | FUNCTION |
DEFINITION | +———-+———————————————————+ | acos | Arc cosine of x
expressed in radians. Interval [-1,+1] | | | (eg: acos(x)) |
+———-+———————————————————+ | acosh | Inverse hyperbolic cosine of x
expressed in radians. | | | (eg: acosh(x)) | +———-+———————————————————+
| asin | Arc sine of x expressed in radians. Interval [-1,+1] | | | (eg:
asin(x)) | +———-+———————————————————+ | asinh | Inverse hyperbolic sine
of x expressed in radians. | | | (eg: asinh(x)) |
+———-+———————————————————+ | atan | Arc tangent of x expressed in
radians. Interval [-1,+1] | | | (eg: atan(x)) |
+———-+———————————————————+ | atan2 | Arc tangent of (x / y) expressed in
radians. [-pi,+pi] | | | eg: atan2(x,y) | +———-+———————————————————+ |
atanh | Inverse hyperbolic tangent of x expressed in radians. | | | (eg:
atanh(x)) | +———-+———————————————————+ | cos | Cosine of x. (eg: cos(x))
| +———-+———————————————————+ | cosh | Hyperbolic cosine of x. (eg:
cosh(x)) | +———-+———————————————————+ | cot | Cotangent of x. (eg:
cot(x)) | +———-+———————————————————+ | csc | Cosecant of x. (eg: csc(x))
| +———-+———————————————————+ | sec | Secant of x. (eg: sec(x)) |
+———-+———————————————————+ | sin | Sine of x. (eg: sin(x)) |
+———-+———————————————————+ | sinc | Sine cardinal of x. (eg: sinc(x)) |
+———-+———————————————————+ | sinh | Hyperbolic sine of x. (eg: sinh(x))
| +———-+———————————————————+ | tan | Tangent of x. (eg: tan(x)) |
+———-+———————————————————+ | tanh | Hyperbolic tangent of x. (eg:
tanh(x)) | +———-+———————————————————+ | deg2rad | Convert x from degrees
to radians. (eg: deg2rad(x)) | +———-+———————————————————+ | deg2grad |
Convert x from degrees to gradians. (eg: deg2grad(x)) |
+———-+———————————————————+ | rad2deg | Convert x from radians to
degrees. (eg: rad2deg(x)) | +———-+———————————————————+ | grad2deg |
Convert x from gradians to degrees. (eg: grad2deg(x)) |
+———-+———————————————————+</p></li>
<li><p>String Processing +———-+———————————————————+ | FUNCTION |
DEFINITION | +———-+———————————————————+ | = , == | All common
equality/inequality operators are applicable | | !=, &lt;&gt; | to
strings and are applied in a case sensitive manner. | | &lt;=, &gt;= |
In the following example x, y and z are of type string. | | &lt; , &gt;
| (eg: not((x &lt;= ‘AbC’) and (‘1x2y3z’ &lt;&gt; y)) or (z == x) |
+———-+———————————————————+ | in | True only if x is a substring of y. |
| | (eg: x in y or ‘abc’ in ‘abcdefgh’) | +———-+———————————————————+ |
like | True only if the string x matches the pattern y. | | | Available
wildcard characters are ‘<em>’ and ’?’ denoting | | | zero or more and
zero or one matches respectively. | | | (eg: x like y or ’abcdefgh’ like
’a?d</em>h’) | +———-+———————————————————+ | ilike | True only if the
string x matches the pattern y in a | | | case insensitive manner.
Available wildcard characters | | | are ‘<em>’ and ’?’ denoting zero or
more and zero or one | | | matches respectively. | | | (eg: x ilike y or
’a1B2c3D4e5F6g7H’ ilike ’a?d</em>h’) | +———-+———————————————————+ |
[r0:r1] | The closed interval[r0,r1] of the specified string. | | | eg:
Given a string x with a value of ‘abcdefgh’ then: | | | 1. x[1:4] ==
‘bcde’ | | | 2. x[ :4] == x[:8 / 2] == ‘abcde’ | | | 3. x[2 + 1: ] ==
x[3:] ==‘defgh’ | | | 4. x[ : ] == x[:] == ‘abcdefgh’ | | | 5.
x[4/2:3+1] == x[2:4] == ‘cde’ | | | | | | Note: Both r0 and r1 are
assumed to be integers, where | | | r0 &lt;= r1. They may also be the
result of an expression, | | | in the event they have fractional
components truncation | | | shall be performed. (eg: 1.67 –&gt; 1) |
+———-+———————————————————+ | := | Assign the value of x to y. Where y is
a mutable string | | | or string range and x is either a string or a
string | | | range. eg: | | | 1. y := x | | | 2. y := ‘abc’ | | | 3. y
:= x[:i + j] | | | 4. y := ‘0123456789’[2:7] | | | 5. y :=
‘0123456789’[2i + 1:7] | | | 6. y := (x := ‘0123456789’[2:7]) | | | 7.
y[i:j] := x | | | 8. y[i:j] := (x + ‘abcdefg’[8 / 4:5])[m:n] | | | | | |
Note: For options 7 and 8 the shorter of the two ranges | | | will
denote the number characters that are to be copied.|
+———-+———————————————————+ | + | Concatenation of x and y. Where x and y
are strings or | | | string ranges. eg | | | 1. x + y | | | 2. x + ‘abc’
| | | 3. x + y[:i + j] | | | 4. x[i:j] + y[2:3] + ‘0123456789’[2:7] | |
| 5. ‘abc’ + x + y | | | 6. ‘abc’ + ‘1234567’ | | | 7. (x + ‘a1B2c3D4’ +
y)[i:2j] | +———-+———————————————————+ | += | Append to x the value of y.
Where x is a mutable string | | | and y is either a string or a string
range. eg: | | | 1. x += y | | | 2. x += ‘abc’ | | | 3. x += y[:i + j] +
‘abc’ | | | 4. x += ‘0123456789’[2:7] | +———-+———————————————————+ |
&lt;=&gt; | Swap the values of x and y. Where x and y are mutable | | |
strings. (eg: x &lt;=&gt; y) | +———-+———————————————————+ | [] | The
string size operator returns the size of the string | | | being
actioned. | | | eg: | | | 1. ‘abc’[] == 3 | | | 2. var max_str_length :=
max(s0[], s1[], s2[], s3[]) | | | 3. (‘abc’ + ‘d’)[] == 6 | | | 4.
((‘abc’ + ‘xyz’)[1:4])[] == 4 | +———-+———————————————————+</p></li>
<li><p>Control Structures +———-+———————————————————+ |STRUCTURE |
DEFINITION | +———-+———————————————————+ | if | If x is true then return
y else return z. | | | eg: | | | 1. if (x, y, z) | | | 2. if ((x + 1)
&gt; 2y, z + 1, w / v) | | | 3. if (x &gt; y) z; | | | 4. if (x &lt;=
2<em>y) { z + w }; | +———-+———————————————————+ | if-else | The
if-else/else-if statement. Subject to the condition | | | branch the
statement will return either the value of the| | | consequent or the
alternative branch. | | | eg: | | | 1. if (x &gt; y) z; else w; | | | 2.
if (x &gt; y) z; else if (w != u) v; | | | 3. if (x &lt; y) { z; w + 1;
} else u; | | | 4. if ((x != y) and (z &gt; w)) | | | { | | | y :=
sin(x) / u; | | | z := w + 1; | | | } | | | else if (x &gt; (z + 1)) | |
| { | | | w := abs (x - y) + z; | | | u := (x + 1) &gt; 2y ? 2u : 3u; |
| | } | +———-+———————————————————+ | switch | The first true case
condition that is encountered will | | | determine the result of the
switch. If none of the case | | | conditions hold true, the default
action is assumed as | | | the final return value. This is sometimes
also known as | | | a multi-way branch mechanism. | | | eg: | | | switch
| | | { | | | case x &gt; (y + z) : 2 </em> x / abs(y - z); | | | case x
&lt; 3 : sin(x + y); | | | default : 1 + x; | | | } |
+———-+———————————————————+ | while | The structure will repeatedly
evaluate the internal | | | statement(s) ‘while’ the condition is true.
The final | | | statement in the final iteration shall be used as the |
| | return value of the loop. | | | eg: | | | while ((x -= 1) &gt; 0) |
| | { | | | y := x + z; | | | w := u + y; | | | } |
+———-+———————————————————+ | repeat/ | The structure will repeatedly
evaluate the internal | | until | statement(s) ‘until’ the condition is
true. The final | | | statement in the final iteration shall be used as
the | | | return value of the loop. | | | eg: | | | repeat | | | y := x
+ z; | | | w := u + y; | | | until ((x += 1) &gt; 100) |
+———-+———————————————————+ | for | The structure will repeatedly
evaluate the internal | | | statement(s) while the condition is true. On
each loop | | | iteration, an ‘incrementing’ expression is evaluated. |
| | The conditional is mandatory whereas the initialiser | | | and
incrementing expressions are optional. | | | eg: | | | for (var x := 0;
(x &lt; n) and (x != y); x += 1) | | | { | | | y := y + x / 2 - z; | | |
w := u + y; | | | } | +———-+———————————————————+ | break | Break
terminates the execution of the nearest enclosed | | break[] | loop,
allowing for the execution to continue on external| | | to the loop. The
default break statement will set the | | | return value of the loop to
NaN, where as the return | | | based form will set the value to that of
the break | | | expression. | | | eg: | | | while ((i += 1) &lt; 10) | |
| { | | | if (i &lt; 5) | | | j -= i + 2; | | | else if (i % 2 == 0) | |
| break; | | | else | | | break[2i + 3]; | | | } |
+———-+———————————————————+ | continue | Continue results in the
remaining portion of the nearest| | | enclosing loop body to be skipped.
| | | eg: | | | for (var i := 0; i &lt; 10; i += 1) | | | { | | | if (i
&lt; 5) | | | continue; | | | j -= i + 2; | | | } |
+———-+———————————————————+ | return | Return immediately from within the
current expression. | | | With the option of passing back a variable
number of | | | values (scalar, vector or string). eg: | | | 1. return
[1]; | | | 2. return [x, ‘abx’]; | | | 3. return [x, x + y,‘abx’]; | | |
4. return []; | | | 5. if (x &lt; y) | | | return [x, x - y,
‘result-set1’, 123.456]; | | | else | | | return [y, x + y,
‘result-set2’]; | +———-+———————————————————+ | ?: | Ternary conditional
statement, similar to that of the | | | above denoted if-statement. | |
| eg: | | | 1. x ? y : z | | | 2. x + 1 &gt; 2y ? z + 1 : (w / v) | | |
3. min(x,y) &gt; z ? (x &lt; y + 1) ? x : y : (w * v) |
+———-+———————————————————+ | ~ | Evaluate each sub-expression, then
return as the result | | | the value of the last sub-expression. This is
sometimes | | | known as multiple sequence point evaluation. | | | eg: |
| | ~(i := x + 1, j := y / z, k := sin(w/u)) == (sin(w/u))) | | | ~{i :=
x + 1; j := y / z; k := sin(w/u)} == (sin(w/u))) |
+———-+———————————————————+ | [*] | Evaluate any consequent for which its
case statement is | | | true. The return value will be either zero or
the result| | | of the last consequent to have been evaluated. | | | eg:
| | | [*] | | | { | | | case (x + 1) &gt; (y - 2) : x := z / 2 + sin(y /
pi); | | | case (x + 2) &lt; abs(y + 3) : w / 4 + min(5y,9); | | | case
(x + 3) == (y * 4) : y := abs(z / 6) + 7y; | | | } |
+———-+———————————————————+ | [] | The vector size operator returns the
size of the vector | | | being actioned. | | | eg: | | | 1. v[] | | | 2.
max_size := max(v0[],v1[],v2[],v3[]) |
+———-+———————————————————+</p></li>
</ol>
<p>Note01: In the tables above, the symbols x, y, z, w, u and v where
appropriate may represent any of one the following:</p>
<ol type="1">
<li>Literal numeric/string value</li>
<li>A variable</li>
<li>A vector element</li>
<li>A vector</li>
<li>A string</li>
<li>An expression comprised of [1], [2] or [3] (eg: 2 + x / vec[3])</li>
</ol>
<pre><code>
[SECTION 09 - FUNDAMENTAL TYPES]
ExprTk supports three fundamental types which can be used freely in
expressions. The types are as follows:

   (1) Scalar
   (2) Vector
   (3) String


(1) Scalar Type
The scalar type  is a singular  numeric value. The  underlying type is
that used  to specialise  the ExprTk  components (float,  double, long
double, MPFR et al).


(2) Vector Type
The vector type is a fixed size sequence of contiguous scalar  values.
A  vector  can be  indexed  resulting in  a  scalar value.  Operations
between a vector and scalar will result in a vector with a size  equal
to that  of the  original vector,  whereas operations  between vectors
will result in a  vector of size equal  to that of the  smaller of the
two. In both mentioned cases, the operations will occur element-wise.


(3) String Type
The string type is a variable length sequence of 8-bit chars.  Strings
can be  assigned and  concatenated to  one another,  they can  also be
manipulated via sub-ranges using the range definition syntax.  Strings
however can not interact with scalar or vector types.
</code></pre>
<p>[SECTION 10 - COMPONENTS] There are three primary components, that
are specialised upon a given numeric type, which make up the core of
ExprTk. The components are as follows:</p>
<ol type="1">
<li><p>Symbol Table exprtk::symbol_table<NumericType></p></li>
<li><p>Expression exprtk::expression<NumericType></p></li>
<li><p>Parser exprtk::parser<NumericType></p></li>
<li><p>Symbol Table A structure that is used to store references to
variables, constants and functions that are to be used within
expressions. Furthermore in the context of composited recursive
functions the symbol table can also be thought of as a simple
representation of a stack specific for the expression(s) that reference
it. The following is a list of the types a symbol table can
handle:</p></li>
</ol>
<ol type="a">
<li>Numeric variables</li>
<li>Numeric constants</li>
<li>Numeric vector elements</li>
<li>String variables</li>
<li>String constants</li>
<li>Functions</li>
<li>Vararg functions</li>
</ol>
<p>During the compilation process if an expression is found to require
any of the elements noted above, the expression’s associated
symbol_table will be queried for the element and if present a reference
to the element will be embedded within the expression’s AST. This allows
for the original element to be modified independently of the expression
instance and to also allow the expression to be evaluated using the
current value of the element.</p>
<p>The example below demonstrates the relationship between variables,
symbol_table and expression. Note the variables are modified as they
normally would in a program, and when the expression is evaluated the
current values assigned to the variables shall be used.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t; typedef exprtk::parser<double>
parser_t;</p>
<p>double x = 0; double y = 0;</p>
<p>symbol_table_t symbol_table; expression_t expression; parser_t
parser;</p>
<p>std::string expression_string = “x * y + 3”;</p>
<p>symbol_table.add_variable(“x”,x);
symbol_table.add_variable(“y”,y);</p>
<p>expression.register_symbol_table(symbol_table);</p>
<p>parser.compile(expression_string,expression);</p>
<p>x = 1.0; y = 2.0; expression.value(); // 1 * 2 + 3</p>
<p>x = 3.7; expression.value(); // 3.7 * 2 + 3</p>
<p>y = -9.0; expression.value(); // 3.7 * -9 + 3</p>
<p>// ‘x * -9 + 3’ for x in range of [0,100) in steps of 0.0001 for (x =
0.0; x &lt; 100.0; x += 0.0001) { expression.value(); // x * -9 + 3
}</p>
<p>Note02: Any variable reference provided to a given symbol_table
instance, must have a lifetime at least as long as the lifetime of the
symbol_table instance. In the event the variable reference is
invalidated before the symbol_table or any dependent expression
instances have been destructed, then any associated expression
evaluations or variable referencing via the symbol_table instance will
result in undefined behaviour.</p>
<p>The following bit of code instantiates a symbol_table and expression
instance, then proceeds to demonstrate various ways in which references
to variables can be added to the symbol_table, and how those references
are subsequently invalidated resulting in various forms of undefined
behaviour.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t;</p>
<p>symbol_table_t symbol_table; expression_t expression;</p>
<p>std::deque<double > y {1.1, 2.2, 3.3}; std::vector<double> z {4.4,
5.5, 6.6}; double* w = new double(123.456);</p>
<p>{ double x = 123.4567; symbol_table.add_variable(“x”, x); } //
Reference to variable x has been invalidated</p>
<p>symbol_table.add_variable(“y”, y.back());</p>
<p>y.pop_back(); // Reference to variable y has been invalidated</p>
<p>symbol_table.add_variable(“z”, z.front());</p>
<p>z.erase(z.begin()); // Reference to variable z has been
invalidated</p>
<p>symbol_table.add_variable(“w”, *w);</p>
<p>delete w; // Reference to variable w has been invalidated</p>
<p>const std::string expression_string = “x + y / z * w”;</p>
<pre><code>             // Compilation of expression will succeed</code></pre>
<p>parser.compile(expression_string,expression);</p>
<p>expression.value(); // Evaluation will result in undefined behaviour
// due to ‘x’ and ‘w’ having been destroyed.</p>
<p>symbol_table.get_variable(“x”)-&gt;ref() = 135.791; // Assignment
will result in undefined behaviour</p>
<p>A compiled expression that references variables from a symbol_table
is dependent on that symbol_table instance and the variables it holds
being valid.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t;</p>
<p>symbol_table_t symbol_table; expression_t expression;</p>
<p>double x = 123.456;</p>
<p>symbol_table.add_variable(“x”, x);</p>
<p>const std::string expression_string = “(x + 1) / 2”;</p>
<pre><code>             // Compilation of the expression will succeed</code></pre>
<p>parser.compile(expression_string,expression);</p>
<pre><code>             // Clear all variables from symbol_table</code></pre>
<p>symbol_table.clear();</p>
<p>expression.value(); // Evaluation will result in undefined behaviour
// because the reference to ‘x’ having been destroyed // during the
clearing of the symbol_table</p>
<p>In the above example, an expression is compiled that references
variable “x”. As part of the compilation process the node holding the
variable “x” is obtained from the symbol_table and embedded in the AST
of the expression - in short the expression is now referencing the node
that holds the variable “x”. The following diagram depicts the
dependencies between the variable x, the symbol table and the
expression:</p>
<pre><code>  +--[Symbol Table]--+
  |                  |
  | +- ------+       |
  | | x-node |       |
  | +-----A--+       |    +--[Expression]--+
  +---|---|----------+    |  +---------+   |
      v   |               |  |  A.S.T  |   |
      |   +--------&lt;--------[.]        |   |
+-----+                   |  +---------+   |
|                         +----------------+</code></pre>
<p>+-v-[variable]—+ | x: 123.456 | +—————-+</p>
<p>When the clear method is called on the symbol table the X-Node is
destroyed, so now the expression is referencing a node that has been
destroyed. From this point onwards any attempts to reference the
expression instance will result in undefined behaviour. Simply put the
above example violates the requirement that the lifetime of any objects
referenced by expressions should exceed the lifetime of the expression
instance.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t;</p>
<p>symbol_table_t symbol_table; expression_t expression;</p>
<p>double x = 123.456;</p>
<p>symbol_table.add_variable(“x”, x);</p>
<p>const std::string expression_string = “(x + 1) / 2”;</p>
<pre><code>             // Compilation of the expression will succeed</code></pre>
<p>parser.compile(expression_string,expression);</p>
<p>expression.value();</p>
<pre><code>             // Release the expression and its dependents</code></pre>
<p>expression.release();</p>
<pre><code>             // Clear all variables from symbol_table</code></pre>
<p>symbol_table.clear();</p>
<p>expression.value(); // Will return null_node value of NaN</p>
<p>In the above example the expression is released before the associated
symbol_table is cleared of its variables, which resolves the undefined
behaviour issue noted in the previous example.</p>
<p>Note03: It is possible to register multiple symbol_tables with a
single expression object. In the event an expression has multiple symbol
tables, and where there exists conflicts between symbols, the
compilation stage will resolve the conflicts based on the order of
registration of the symbol_tables to the expression. For a more
expansive discussion please review section [17 - Hierarchies Of Symbol
Tables]</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t; typedef exprtk::parser<double>
parser_t;</p>
<p>symbol_table_t symbol_table0; symbol_table_t symbol_table1;</p>
<p>expression_t expression; parser_t parser;</p>
<p>double x0 = 123.0; double x1 = 678.0;</p>
<p>std::string expression_string = “x + 1”;</p>
<p>symbol_table0.add_variable(“x”,x0);
symbol_table1.add_variable(“x”,x1);</p>
<p>expression.register_symbol_table(symbol_table0);
expression.register_symbol_table(symbol_table1);</p>
<p>parser.compile(expression_string,expression);</p>
<p>expression.value(); // 123 + 1</p>
<p>The symbol table supports adding references to external instances of
types that can be accessed within expressions via the following
methods:</p>
<ol type="1">
<li>bool add_variable (const std::string&amp; name, scalar_t&amp; )</li>
<li>bool add_constant (const std::string&amp; name, const scalar_t&amp;
)</li>
<li>bool add_stringvar (const std::string&amp; name, std::string&amp;
)</li>
<li>bool add_vector (const std::string&amp; name, vector_type&amp;
)</li>
<li>bool add_function (const std::string&amp; name, function_t&amp;
)</li>
<li>bool create_stringvar(const std::string&amp; name,const
std::string&amp;)</li>
<li>bool create_variable (const std::string&amp; name, const T&amp;
)</li>
</ol>
<p>Note04: The ‘vector’ type must be comprised from a contiguous array
of scalars with a size that is larger than zero. The vector type itself
can be any one of the following:</p>
<ol type="1">
<li>std::vector<scalar_t></li>
<li>scalar_t(&amp;v)[N]</li>
<li>scalar_t* and array size</li>
<li>exprtk::vector_view<scalar_t></li>
</ol>
<p>When registering a variable, vector, string or function with an
instance of a symbol_table, the call to ‘add_…’ may fail and return a
false result due to one or more of the following reasons:</p>
<ol type="1">
<li>Variable name contains invalid characters or is ill-formed</li>
<li>Variable name conflicts with a reserved word (eg: ‘while’)</li>
<li>Variable name conflicts with a previously registered variable</li>
<li>A vector of size (length) zero is being registered</li>
<li>A free function exceeding fifteen parameters is being
registered</li>
<li>The symbol_table instance is in an invalid state</li>
</ol>
<p>Note05: The symbol_table has a method called clear, which when
invoked will clear all variables, vectors, strings and functions
registered with the symbol_table instance. If this method is to be
called, then one must make sure that all compiled expression instances
that reference variables belonging to that symbol_table instance are
released (aka call release method on expression) before calling the
clear method on the symbol_table instance, otherwise undefined
behaviours will occur.</p>
<p>A further property of symbol tables is that they can be classified at
instantiation as either being mutable (by default) or immutable. This
property determines if variables, vectors or strings registered with the
symbol table can undergo modifications within expressions that reference
them. The following demonstrates construction of an immutable symbol
table instance:</p>
<p>symbol_table_t immutable_symbol_table
(symbol_table_t::symtab_mutability_type::e_immutable);</p>
<p>When a symbol table, that has been constructed as being immutable, is
registered with an expression, any statements in the expression string
that modify the variables that are managed by the immutable symbol table
will result in a compilation error. The operations that trigger the
mutability constraint are the following assignment operators:</p>
<ol type="1">
<li>Assignment: :=</li>
<li>Assign operation: +=, -=, *=, /= , %=</li>
</ol>
<p>const std::string expression_str = “x += x + 123.456”;</p>
<p>symbol_table_t immutable_symbol_table
(symbol_table_t::symtab_mutability_type::e_immutable);</p>
<p>T x = 0.0;</p>
<p>immutable_symbol_table.add_variable(“x” , x);</p>
<p>expression_t expression;
expression.register_symbol_table(immutable_symbol_table);</p>
<p>parser_t parser;</p>
<p>parser.compile(expression_str, expression); // Compile error because
of assignment to variable x</p>
<p>In the above example, variable x is registered to an immutable symbol
table, making it an immutable variable within the context of any
expressions that reference it. The expression string being compiled uses
the addition assignment operator which will modify the value of variable
x. The compilation process detects this semantic violation and proceeds
to halt compilation and return the appropriate error.</p>
<p>One of the main reasons for this functionality is that, one may want
the immutability properties that come with constness of a variable such
as scalars, vectors and strings, but not necessarily the accompanying
compile time const-folding optimisations, that would result in the value
of the variables being retrieved only once at compile time, causing
external updates to the variables to not be part of the expression
evaluation.</p>
<p>symbol_table_t immutable_symbol_table
(symbol_table_t::symtab_mutability_type::e_immutable);</p>
<p>T x = 0.0;</p>
<p>const std::string expression_str = “x + (y + y)”;</p>
<p>immutable_symbol_table.add_variable(“x” , x );
immutable_symbol_table.add_constant(“y” , 123.0);</p>
<p>expression_t expression;
expression.register_symbol_table(immutable_symbol_table);</p>
<p>parser_t parser; parser.compile(expression_str, expression);</p>
<p>for (; x &lt; 10.0; ++x) { const auto expected_value = x + (123.0 +
123.0); const auto result_value = expression.value();
assert(expression.value() != expected_value); }</p>
<p>In the above example, there are two variables X and Y. Where Y is a
constant and X is a normal variable. Both are registered with a symbol
table that is immutable. The expression when compiled will result in the
“(y + y)” part being const-folded at compile time to the literal value
of 246. Whereas the current value of X, being updated via the for-loop,
externally to the expression and the symbol table shall be observable to
the expression upon each evaluation.</p>
<ol start="2" type="1">
<li>Expression A structure that holds an Abstract Syntax Tree or AST for
a specified expression and is used to evaluate said expression.
Evaluation of the expression is accomplished by performing a post-order
traversal of the AST. If a compiled Expression uses variables or user
defined functions, it will have an associated Symbol Table, which will
contain references to said variables, functions or strings. An example
AST structure for the denoted expression is as follows:</li>
</ol>
<p>Expression: z := (x + y^-2.345) * sin(pi / min(w - 7.3,v))</p>
<pre><code>              [Root]
                |
           [Assignment]
    ________/        \_____
   /                       \</code></pre>
<p>Variable(z) [Multiplication] ____________/ ___________ /<br />
/ [Unary-Function(sin)] [Addition] | ____/ ____ [Division] /  
<em><strong>/ _</strong> Variable(x) [Exponentiation] /<br />
</em>_____/ ______ Constant(pi) [Binary-Function(min)] /   ____/
_<strong> Variable(y) [Negation] /<br />
| / Variable(v) Constant(2.345) / / [Subtraction] </strong>_<em>/
_</em>__ /<br />
Variable(w) Constant(7.3)</p>
<p>The above denoted AST shall be evaluated in the following order:</p>
<ol type="1">
<li>Load Variable (z) (10) Load Constant (7.3)</li>
<li>Load Variable (x) (11) Subtraction (09 &amp; 10)</li>
<li>Load Variable (y) (12) Load Variable (v)</li>
<li>Load Constant (2.345) (13) Min (11 &amp; 12)</li>
<li>Negation (04) (14) Division (08 &amp; 13)</li>
<li>Exponentiation (03 &amp; 05) (15) Sin (14)</li>
<li>Addition (02 &amp; 06) (16) Multiplication (07 &amp; 15)</li>
<li>Load Constant (pi) (17) Assignment (01 &amp; 16)</li>
<li>Load Variable (w)</li>
</ol>
<p>Generally an expression in ExprTk can be thought of as a free
function similar to those found in imperative languages. This form of
pseudo function will have a name, it may have a set of one or more
inputs and will return at least one value as its result. Furthermore the
function when invoked, may cause a side-effect that changes the state of
the host program.</p>
<p>As an example the following is a pseudo-code definition of a free
function that performs a computation taking four inputs, modifying one
of them and returning a value based on some arbitrary calculation:</p>
<p>ResultType foo(InputType x, InputType y, InputType z, InputType w) {
w = 2 * x^y + z; // Side-Effect return abs(x - y) / z; // Return Result
}</p>
<p>Given the above definition the following is a functionally equivalent
version using ExprTk:</p>
<p>const std::string foo_str = ” w := 2 * x^y + z; ” ” abs(x - y) / z;
“;</p>
<p>T x, y, z, w;</p>
<p>symbol_table_t symbol_table; symbol_table.add_variable(“x”,x);
symbol_table.add_variable(“y”,y); symbol_table.add_variable(“z”,z);
symbol_table.add_variable(“w”,w);</p>
<p>expression_t foo; foo.register_symbol_table(symbol_table);</p>
<p>parser_t parser; if (!parser.compile(foo_str,foo)) { // Error in
expression… return; }</p>
<p>T result = foo.value();</p>
<ol start="3" type="1">
<li>Parser A component which takes as input a string representation of
an expression and attempts to compile said input with the result being
an instance of Expression. If an error is encountered during the
compilation process, the parser will stop compiling and return an error
status code, with a more detailed description of the error(s) and its
location within the input provided by the ‘get_error’ interface.</li>
</ol>
<p>Note06: The exprtk::expression and exprtk::symbol_table components
are reference counted entities. Copy constructing or assigning to or
from either component will result in a shallow copy and a reference
count increment, rather than a complete replication. Furthermore the
expression and symbol_table components being Default-Constructible,
Copy-Constructible and Copy-Assignable make them compatible with various
C++ standard library containers and adaptors such as std::vector,
std::map, std::stack etc.</p>
<p>The following is an example of two unique expressions, after having
been instantiated and compiled, one expression is assigned to the other.
The diagrams depict their initial and post assignment states, including
which control block each expression references and their associated
reference counts.</p>
<pre><code>exprtk::expression e0; // constructed expression, eg: x + 1
exprtk::expression e1; // constructed expression, eg: 2z + y</code></pre>
<p>+—–[ e0 cntrl block]—-+ +—–[ e1 cntrl block]—–+ | 1. Expression Node
‘x+1’ | | 1. Expression Node ‘2z+y’ | | 2. Ref Count: 1 |&lt;-+ | 2. Ref
Count: 1 |&lt;-+ +————————–+ | +—————————+ | | | +–[ e0 expression]–+ |
+–[ e1 expression]–+ | | 1. Reference to ]——+ | 1. Reference to ]——-+ |
e0 Control Block | | e1 Control Block | +——————–+ +——————–+</p>
<p>e0 = e1; // e0 and e1 are now 2z+y</p>
<pre><code>           +-----[ e1 cntrl block]-----+
           | 1. Expression Node &#39;2z+y&#39; |</code></pre>
<p>+———–&gt;| 2. Ref Count: 2 |&lt;———-+ | +—————————+ | | | | +–[ e0
expression]–+ +–[ e1 expression]–+ | +—[ 1. Reference to | | 1.
Reference to ]—+ | e1 Control Block | | e1 Control Block | +——————–+
+——————–+</p>
<p>The reason for the above complexity and restrictions of deep copies
for the expression and symbol_table components is because expressions
may include user defined variables or functions. These are embedded as
references into the expression’s AST. When copying an expression, said
references need to also be copied. If the references are blindly copied,
it will then result in two or more identical expressions utilising the
exact same references for variables. This obviously is not the default
assumed scenario and will give rise to non-obvious behaviours when using
the expressions in various contexts such as multi-threading et al.</p>
<p>The prescribed method for cloning an expression is to compile it from
its string form. Doing so will allow the ‘user’ to properly consider the
exact source of user defined variables and functions.</p>
<p>Note07: The exprtk::parser is a non-copyable and non-thread safe
component, and should only be shared via either a reference, a shared
pointer or a std::ref mechanism, and considerations relating to
synchronisation taken into account where appropriate. The parser
represents an object factory, specifically a factory of expressions, and
generally should not be instantiated solely on a per expression
compilation basis.</p>
<p>The following diagram and example depicts the flow of data and
operations for compiling multiple expressions via the parser and
inserting the newly minted exprtk::expression instances into a
std::vector.</p>
<pre><code>                  +----[exprtk::parser]---+
                  |   Expression Factory  |
                  | parser_t::compile(...)|
                +--&gt; ~.~.~.~.~.~.~.~.~.~ -&gt;--+
                | +-----------------------+  |</code></pre>
<p>Expressions in | | Expressions as string form ^ V exprtk::expression
| | instances [s0:‘x+1’]—&gt;–+ | | +-[e0: x+1] | | | |
[s1:‘2z+y’]–&gt;–+–+ +-&gt;+-[e1: 2z+y] | | [s2:‘sin(k+w)’]-+ +-[e2:
sin(k+w)]</p>
<p>const std::string expression_str[3] = { “x + 1”, “2x + y”, “sin(k +
w)” };</p>
<p>std::vector<expression_t> expression_list;</p>
<p>parser_t parser; expression_t expression; symbol_table_t
symbol_table;</p>
<p>expression.register_symbol_table(symbol_table);</p>
<p>for (std::size_t i = 0; i &lt; 3; ++i) { if
(parser.compile(expression_str[i],expression)) {
expression_list.push_back(expression); } else std::cout &lt;&lt; “Error
in” &lt;&lt; expression_str[i] &lt;&lt; “”; }</p>
<p>for (auto&amp; e : expression_list) { e.value(); }</p>
<pre><code>
[SECTION 11 - COMPILATION OPTIONS]
The exprtk::parser  when being  instantiated takes  as input  a set of
options  to be  used during  the compilation  process of  expressions.
An  example instantiation  of exprtk::parser  where only  the  joiner,
commutative and strength reduction options are enabled is as  follows:

   typedef exprtk::parser&lt;NumericType&gt;::settings_t settings_t;

   const std::size_t compile_options =
                        settings_t::e_joiner            +
                        settings_t::e_commutative_check +
                        settings_t::e_strength_reduction;

   parser_t parser(compile_options);


Currently  nine  types  of compile  time  options  are supported,  and
enabled by default. The options and their explanations are as follows:

   (1) Replacer
   (2) Joiner
   (3) Numeric Check
   (4) Bracket Check
   (5) Sequence Check
   (6) Commutative Check
   (7) Strength Reduction Check
   (8) Stack And Node Depth Check
   (9) Expression Size Check


(1) Replacer (e_replacer)
Enable replacement of specific  tokens with other tokens.  For example
the token  &quot;true&quot; of  type symbol  shall be  replaced with the numeric
token of value one.

   (a) (x &lt; y) == true   ---&gt;  (x &lt; y) == 1
   (b) false == (x &gt; y)  ---&gt;  0 == (x &gt; y)


(2) Joiner (e_joiner)
Enable  joining  of  multi-character  operators  that  may  have  been
incorrectly  disjoint in the  string  representation  of the specified
expression. For example the consecutive tokens of &quot;&gt;&quot; &quot;=&quot; will  become
&quot;&gt;=&quot; representing  the &quot;greater  than or  equal to&quot;  operator. If  not
properly resolved the  original form will  cause a compilation  error.
The  following  is  a listing  of the  scenarios that  the joiner  can
handle:

   (a) &#39;&gt;&#39; &#39;=&#39;  ---&gt;  &#39;&gt;=&#39;  (gte)
   (b) &#39;&lt;&#39; &#39;=&#39;  ---&gt;  &#39;&lt;=&#39;  (lte)
   (c) &#39;=&#39; &#39;=&#39;  ---&gt;  &#39;==&#39;  (equal)
   (d) &#39;!&#39; &#39;=&#39;  ---&gt;  &#39;!=&#39;  (not-equal)
   (e) &#39;&lt;&#39; &#39;&gt;&#39;  ---&gt;  &#39;&lt;&gt;&#39;  (not-equal)
   (f) &#39;:&#39; &#39;=&#39;  ---&gt;  &#39;:=&#39;  (assignment)
   (g) &#39;+&#39; &#39;=&#39;  ---&gt;  &#39;+=&#39;  (addition assignment)
   (h) &#39;-&#39; &#39;=&#39;  ---&gt;  &#39;-=&#39;  (subtraction assignment)
   (i) &#39;*&#39; &#39;=&#39;  ---&gt;  &#39;*=&#39;  (multiplication assignment)
   (j) &#39;/&#39; &#39;=&#39;  ---&gt;  &#39;/=&#39;  (division assignment)
   (k) &#39;%&#39; &#39;=&#39;  ---&gt;  &#39;%=&#39;  (modulo assignment)
   (l) &#39;+&#39; &#39;-&#39;  ---&gt;  &#39;-&#39;   (subtraction)
   (m) &#39;-&#39; &#39;+&#39;  ---&gt;  &#39;-&#39;   (subtraction)
   (n) &#39;-&#39; &#39;-&#39;  ---&gt;  &#39;+&#39;   (addition)
   (o) &#39;&lt;=&#39; &#39;&gt;&#39; ---&gt;  &#39;&lt;=&gt;&#39; (swap)


An example of the transformation that takes place is as follows:

   (a) (x &gt; = y) and (z ! = w)  ---&gt;  (x &gt;= y) and (z != w)


(3) Numeric Check (e_numeric_check)
Enable validation of tokens representing numeric types so as to  catch
any errors prior  to the costly  process of the  main compilation step
commencing.


(4) Bracket Check (e_bracket_check)
Enable  the  check for  validating  the ordering  of  brackets in  the
specified expression.


(5) Sequence Check (e_sequence_check)
Enable the  check for  validating that  sequences of  either pairs  or
triplets of tokens make sense.  For example the following sequence  of
tokens when encountered will raise an error:

   (a) (x + * 3)  ---&gt;  sequence error


(6) Commutative Check (e_commutative_check)
Enable the check that will transform sequences of pairs of tokens that
imply a multiplication operation.  The following are some  examples of
such transformations:

   (a) 2x             ---&gt;  2 * x
   (b) 25x^3          ---&gt;  25 * x^3
   (c) 3(x + 1)       ---&gt;  3 * (x + 1)
   (d) (x + 1)4       ---&gt;  (x + 1) * 4
   (e) 5foo(x,y)      ---&gt;  5 * foo(x,y)
   (f) foo(x,y)6 + 1  ---&gt;  foo(x,y) * 6 + 1
   (g) (4((2x)3))     ---&gt;  4 * ((2 * x) * 3)
   (h) w / (x - y)z   ---&gt;  w / (x - y) * z


(7) Strength Reduction Check (e_strength_reduction)
Enable  the  use  of  strength  reduction  optimisations  during   the
compilation  process.  In  ExprTk  strength  reduction   optimisations
predominantly involve  transforming sub-expressions  into other  forms
that  are algebraically  equivalent yet  less costly  to compute.  The
following are examples of the various transformations that can occur:

   (a) (x / y) / z               ---&gt;  x / (y * z)
   (b) (x / y) / (z / w)         ---&gt;  (x * w) / (y * z)
   (c) (2 * x) - (2 * y)         ---&gt;  2 * (x - y)
   (d) (2 / x) / (3 / y)         ---&gt;  (2 / 3) / (x * y)
   (e) (2 * x) * (3 * y)         ---&gt;  6 * (x * y)
   (f) (2 * x) * (2 - 4 / 2)     ---&gt;  0
   (g) (3 - 6 / 2) / (2 * x)     ---&gt;  0
   (h) avg(x,y,z) * (2 - 4 / 2)  ---&gt;  0


Note08: When using strength reduction in conjunction with  expressions
whose inputs or sub-expressions may result in values nearing either of
the bounds of the underlying  numeric type (eg: double), there  may be
the  possibility of a decrease in the precision of results.

In  the following  example the  given expression  which represents  an
attempt at computing the average  between x and y will  be transformed
as follows:

   (0.5 * x) + (y * 0.5) ---&gt; 0.5 * (x + y)

There  may be  situations where  the above  transformation will  cause
numerical overflows and  that the original  form of the  expression is
desired over the strength reduced form. In these situations it is best
to turn off strength reduction optimisations  or to use a type with  a
larger numerical bound.


(8) Stack And Node Depth Check
ExprTk  incorporates   a  recursive   descent  parser.   When  parsing
expressions comprising inner sub-expressions, the recursive nature  of
the parsing process causes the stack to grow. If the expression causes
the stack to grow  beyond the stack size  limit, this would lead  to a
stackoverflow  and  its  associated  stack  corruption  and   security
vulnerability issues.

Similarly to parsing, evaluating an expression may cause the stack  to
grow. Such things like user defined functions, composite functions and
the general nature of the AST  being evaluated can cause the stack  to
grow,  and may  result in  potential stackoverflow  issues as  denoted
above.

ExprTk provides a set of checks that prevent both of the above denoted
problems at  compile time.  These checks rely on  two specific  limits
being set on the parser settings instance, these limits are:

   1. max_stack_depth (default: 400  )
   2. max_node_depth  (default: 10000)


The following demonstrates how these two parser parameters can be set:

   parser_t parser;

   parser.settings().set_max_stack_depth(100);
   parser.settings().set_max_node_depth(200);


In  the  above  code, during  parsing if  the stack  depth reaches  or
exceeds  100 levels,  the parsing  process will  immediately halt  and
return with a failure.  Similarly, during synthesizing the  AST nodes,
if the  compilation process  detects an  AST tree  depth exceeding 200
levels the parsing process will halt and return a parsing failure.


(9) Expression Size Check
ExprTk allows for expression  local variables, vectors and  strings to
be defined. As such the amount  of data in terms of bytes  consumed by
the  expression  locals  can  also  be  limited,  so  as  to   prevent
expressions once compiled from consuming large amounts of data.

The maximum number of bytes an expression&#39;s locally defined  variables
may use can  be set via  the parser settings  prior to compilation  as
follows:

   using expression_t = exprtk::expression&lt;double&gt;;
   using parser_t     = exprtk::parser&lt;double&gt;;

   expression_t expression;
   parser_t     parser;

   parser.settings().set_max_total_local_symbol_size_bytes(16);

   const std::string expression1 = &quot;var x := 1; var y := 1;&quot;;
   const std::string expression2 = &quot;var x := 1; var v[2] := [1];&quot;;

   expression_t expression;

   parser.compile(expression1, expression); // compilation success
   parser.compile(expression2, expression); // compilation error

In the above example, the expression&#39;s max total local symbol size has
been set to 16 bytes. The numeric type being used is double which is 8
bytes  per  instance.  The  first  expression  (expression1)  compiles
successfully because the total local symbol size is 16 bytes, 8  bytes
for each of the variables x and y.

However the second expression (expression2) fails to compile. This  is
because the  total number  of bytes  needed for  the expression  is 24
bytes, 8 bytes for  the variable x and  16 bytes for the  vector v, as
such  exceeding  the  previously  set limit  of  16  bytes.  The error
diagnostic generated by  the parser on  compilation failure will  look
like the following:

   ERR161 - Adding vector &#39;v&#39; of size 2 bytes will exceed max total
   local symbol size of: 16 bytes, current total size: 8 bytes


(10) Vector Size Check
When  defining  an  expression local  vector,  ExprTk  uses a  default
maximum vector size of two billion elements. One may want to limit the
maximum vector size to be either smaller or larger than the  specified
default value. The  maximum size value  can be changed  via the parser
settings.

   parser_t parser;

   parser.settings().set_max_local_vector_size(1000000);

   std::string expression1 = &quot;var v[1e6] := [123]&quot;;
   std::string expression2 = &quot;var v[1e9] := [123]&quot;;

   expression_t expression;

   parser.compile(expression1, expression); // compilation success
   parser.compile(expression2, expression); // compilation error


In the above code, the maximum local vector size is set to one million
elements. During  compilation of  an expression  if there  is a vector
definition where the vector&#39;s size exceeds the maximum allowed  vector
size  a  compilation  error shall  be  emitted.  The error  diagnostic
generated by  the parser  on compilation  failure will  look like  the
following:

   ERR160 - Invalid vector size. Must be an integer in the
   range [0,1000000], size: 1000000000

</code></pre>
<p>[SECTION 12 - EXPRESSION STRUCTURES] Exprtk supports mathematical
expressions in numerous forms based on a simple imperative programming
model. This section will cover the following topics related to general
structure and programming of expressions using ExprTk:</p>
<ol type="1">
<li><p>Multi-Statement Expressions</p></li>
<li><p>Statements And Side-Effects</p></li>
<li><p>Conditional Statements</p></li>
<li><p>Special Functions</p></li>
<li><p>Multi-Statement Expressions Expressions in ExprTk can be
comprised of one or more statements, which may sometimes be called
sub-expressions. The following are two examples of expressions stored in
std::string variables, the first a single statement and the second a
multi-statement expression:</p></li>
</ol>
<p>std::string single_statement = ” z := x + y “;</p>
<p>std::string multi_statement = ” var temp := x; ” ” x := y + z; ” ” y
:= temp; “;</p>
<p>In a multi-statement expression, the final statement will determine
the overall result of the expression. In the following multi-statement
expression, the result of the expression when evaluated will be ‘2.3’,
which will also be the value stored in the ‘y’ variable.</p>
<p>z := x + y; y := 2.3;</p>
<p>As demonstrated in the expression above, statements within an
expression are separated using the semi-colon ‘;’ operator. In the event
two statements are not separated by a semi-colon, and the implied
multiplication feature is active (enabled by default), the compiler will
assume a multiplication operation between the two statements.</p>
<p>In the following example we have a multi-statement expression
composed of two variable definitions and initialisations for variables x
and y and two seemingly separate mathematical operations.</p>
<p>var x:= 2; var y:= 3; x + 1 y * 2</p>
<p>However the result of the expression will not be 6 as may have been
assumed based on the calculation of ‘y * 2’, but rather the result will
be 8. This is because the compiler will have conjoined the two
mathematical statements into one via a multiplication operation. The
expression when compiled will actually evaluate as the following:</p>
<p>var x:= 2; var y:= 3; x + 1 * y * 2; // 2 + 1 * 3 * 2 == 8</p>
<p>In ExprTk any valid statement will itself return a value. This value
can further be used in conjunction with other statements. This includes
language structures such as if-statements, loops (for, while) and the
switch statement. Typically the last statement executed in the given
construct (conditional, loop etc), will be the value that is
returned.</p>
<p>In the following example, the return value of the expression will be
11, which is the sum of the variable ‘x’ and the final value computed
within the loop body upon its last iteration:</p>
<p>var x := 1; x + for (var i := x; i &lt; 10; i += 1) { i / 2; i + 1;
}</p>
<ol start="2" type="1">
<li>Statements And Side-Effects Statements themselves may have side
effects, which in-turn affects the proceeding statements in
multi-statement expressions.</li>
</ol>
<p>A statement is said to have a side-effect if it causes the state of
the expression to change in some way - this includes but is not limited
to the modification of the state of external variables used within the
expression. Currently the following actions being present in a statement
will cause it to have a side-effect:</p>
<ol type="a">
<li>Assignment operation (explicit or potentially)</li>
<li>Invoking a user-defined function that has side-effects</li>
</ol>
<p>The following are examples of expressions where the side-effect
status of the statements (sub-expressions) within the expressions have
been noted:</p>
<p>+-+———————-+——————————+ |#| Expression | Side Effect Status |
+-+———————-+——————————+ |0| x + y | False | +-+———————-+——————————+ |1|
z := x + y | True - Due to assignment | +-+———————-+——————————+ |2|
abs(x - y) | False | +-+———————-+——————————+ |3| abs(x - y); | False | |
| z := (x += y); | True - Due to assignments | +-+———————-+——————————+
|4| var t := abs(x - y); | True - Due to initialisation | | | t + x; |
False | | | z := (x += y); | True - Due to assignments |
+-+———————-+——————————+ |5| foo(x - y) | True - user defined function |
+-+———————-+——————————+</p>
<p>Note09: In example 5 from the above set, it is assumed the user
defined function foo has been registered as having a side-effect. By
default all user defined functions are assumed to have side-effects,
unless they are configured in their constructors to not have side-
effects using the ‘disable_has_side_effects’ free function. For more
information review Section 15 - User Defined Functions sub-section 7
Function Side-Effects.</p>
<p>At this point we can see that there will be expressions composed of
certain kinds of statements that when executed will not affect the
nature of the expression’s result. These statements are typically called
‘dead code’. These statements though not influencing the final result
will still be executed and as such they will consume processing time
that could otherwise be saved. Consequently ExprTk attempts to detect
and remove such statements from expressions.</p>
<p>The ‘Dead Code Elimination’ (DCE) optimisation process, which is
enabled by default, will remove any statements that are determined to
not have a side-effect in a multi-statement expression, excluding the
final or last statement.</p>
<p>By default the final statement in an expression will always be
present regardless of its side-effect status, as it is the statement
whose value shall be used as the result of the expression.</p>
<p>In order to further explain the actions taken during the DCE process,
lets review the following expression:</p>
<p>var x := 2; // Statement 1 var y := x + 2; // Statement 2 x + y; //
Statement 3 y := x + 3y; // Statement 4 x - y; // Statement 5</p>
<p>The above expression has five statements. Three of them (1, 2 and 4)
actively have side-effects. The first two are variable declaration and
initialisations, where as the third is due to an assignment operation.
There are two statements (3 and 5), that do not explicitly have
side-effects, however the latter, statement 5, is the final statement in
the expression and hence will be assumed to have a side-effect.</p>
<p>During compilation when the DCE optimisation is applied to the above
expression, statement 3 will be removed from the expression, as it has
no bearing on the final result of expression, the rest of the statements
will all remain. The optimised form of the expression is as follows:</p>
<p>var x := 2; // Statement 1 var y := x + 2; // Statement 2 y := x +
3y; // Statement 3 x - y; // Statement 4</p>
<ol start="3" type="1">
<li>Conditional Statements (If-Then-Else) ExprTk supports two forms of
conditional branching or otherwise known as if-statements. The first
form, is a simple function based conditional statement, that takes
exactly three input expressions: condition, consequent and alternative.
The following is an example expression that utilises the function based
if-statement.</li>
</ol>
<p>x := if (y &lt; z, y + 1, 2 * z)</p>
<p>In the example above, if the condition ‘y &lt; z’ is true, then the
consequent ‘y + 1’ will be evaluated, its value shall be returned and
subsequently assigned to the variable ‘x’. Otherwise the alternative ‘2
* z’ will be evaluated and its value will be returned. This is
essentially the simplest form of an if-then-else statement. A simple
variation of the expression where the value of the if-statement is used
within another statement is as follows:</p>
<p>x := 3 * if (y &lt; z, y + 1, 2 * z) / 2</p>
<p>The second form of if-statement resembles the standard syntax found
in most imperative languages. There are two variations of the
statement:</p>
<ol type="a">
<li><p>If-Statement</p></li>
<li><p>If-Then-Else Statement</p></li>
<li><p>If-Statement This version of the conditional statement returns
the value of the consequent expression when the condition expression is
true, else it will return a quiet NaN value as its result.</p></li>
</ol>
<p>Example 1: x := if (y &lt; z) y + 3;</p>
<p>Example 2: x := if (y &lt; z) { y + 3 };</p>
<p>The two example expressions above are equivalent. If the condition ‘y
&lt; z’ is true, the ‘x’ variable shall be assigned the value of the
consequent ‘y + 3’, otherwise it will be assigned the value of quiet
NaN. As previously discussed, if-statements are value returning
constructs, and if not properly terminated using a semi-colon, will
end-up combining with the next statement via a multiplication operation.
The following example will NOT result in the expected value of ‘w + x’
being returned:</p>
<p>x := if (y &lt; z) y + 3 // missing semi-colon ‘;’ w + x</p>
<p>When the above supposed multi-statement expression is compiled, the
expression will have a multiplication inserted between the two
‘intended’ statements resulting in the unanticipated expression:</p>
<p>x := (if (y &lt; z) y + 3) * w + x</p>
<p>The solution to the above situation is to simply terminate the
conditional statement with a semi-colon as follows:</p>
<p>x := if (y &lt; z) y + 3; w + x</p>
<ol start="2" type="a">
<li>If-Then-Else Statement The second variation of the if-statement is
to allow for the use of Else and Else-If cascading statements. Examples
of such statements are as follows:</li>
</ol>
<p>Example 1: Example 2: Example 3: if (x &lt; y) if (x &lt; y) if (x
&gt; y + 1) z := x + 3; { y := abs(x - z); else y := z + x; else y := x
- z; z := x + 3; { } y := z + x; else z := x + 3; y := x - z; };</p>
<p>Example 4: Example 5: Example 6: if (2 * x &lt; max(y,3)) if (x &lt;
y) if (x &lt; y or (x + z) &gt; y) { z := x + 3; { y := z + x; else if
(2y != z) z := x + 3; z := x + 3; { y := x - z; } z := x + 3; } else if
(2y - z) y := x - z; else if (abs(2y - z) &gt;= 3) y := x - z; } y := x
- z; else else x * x; { z := abs(x * x); x * y * z; };</p>
<p>In the case where there is no final else statement and the flow
through the conditional arrives at this final point, the same rules
apply to this form of if-statement as to the previous. That is a quiet
NaN shall be returned as the result of the if-statement. Furthermore the
same requirements of terminating the statement with a semi-colon
apply.</p>
<ol start="4" type="1">
<li>Special Functions The purpose of special functions in ExprTk is to
provide compiler generated equivalents of common mathematical
expressions which can be invoked by using the ‘special function’ syntax
(eg: <span
class="math inline"><em>f</em>12(<em>x</em>, <em>y</em>, <em>z</em>)<em>o</em><em>r</em></span>f82(x,y,z,w)).</li>
</ol>
<p>Special functions dramatically decrease the total evaluation time of
expressions which would otherwise have been written using the common
form by reducing the total number of nodes in the evaluation tree of an
expression and by also leveraging the compiler’s ability to correctly
optimise such expressions for a given architecture.</p>
<pre><code>      3-Parameter                       4-Parameter</code></pre>
<p>+————-+————-+ +————–+——————+ | Prototype | Operation | | Prototype |
Operation | +————-+————-+ +————–+——————+ $f00(x,y,z) | (x + y) / z
$f48(x,y,z,w) | x + ((y + z) / w) $f01(x,y,z) | (x + y) * z
$f49(x,y,z,w) | x + ((y + z) * w) $f02(x,y,z) | (x + y) - z
$f50(x,y,z,w) | x + ((y - z) / w) $f03(x,y,z) | (x + y) + z
$f51(x,y,z,w) | x + ((y - z) * w) $f04(x,y,z) | (x - y) + z
$f52(x,y,z,w) | x + ((y * z) / w) $f05(x,y,z) | (x - y) / z
$f53(x,y,z,w) | x + ((y * z) * w) $f06(x,y,z) | (x - y) * z
$f54(x,y,z,w) | x + ((y / z) + w) $f07(x,y,z) | (x * y) + z
$f55(x,y,z,w) | x + ((y / z) / w) $f08(x,y,z) | (x * y) - z
$f56(x,y,z,w) | x + ((y / z) * w) $f09(x,y,z) | (x * y) / z
$f57(x,y,z,w) | x - ((y + z) / w) $f10(x,y,z) | (x * y) * z
$f58(x,y,z,w) | x - ((y + z) * w) $f11(x,y,z) | (x / y) + z
$f59(x,y,z,w) | x - ((y - z) / w) $f12(x,y,z) | (x / y) - z
$f60(x,y,z,w) | x - ((y - z) * w) $f13(x,y,z) | (x / y) / z
$f61(x,y,z,w) | x - ((y * z) / w) $f14(x,y,z) | (x / y) * z
$f62(x,y,z,w) | x - ((y * z) * w) $f15(x,y,z) | x / (y + z)
$f63(x,y,z,w) | x - ((y / z) / w) $f16(x,y,z) | x / (y - z)
$f64(x,y,z,w) | x - ((y / z) * w) $f17(x,y,z) | x / (y * z)
$f65(x,y,z,w) | ((x + y) * z) - w $f18(x,y,z) | x / (y / z)
$f66(x,y,z,w) | ((x - y) * z) - w $f19(x,y,z) | x * (y + z)
$f67(x,y,z,w) | ((x * y) * z) - w $f20(x,y,z) | x * (y - z)
$f68(x,y,z,w) | ((x / y) * z) - w $f21(x,y,z) | x * (y * z)
$f69(x,y,z,w) | ((x + y) / z) - w $f22(x,y,z) | x * (y / z)
$f70(x,y,z,w) | ((x - y) / z) - w $f23(x,y,z) | x - (y + z)
$f71(x,y,z,w) | ((x * y) / z) - w $f24(x,y,z) | x - (y - z)
$f72(x,y,z,w) | ((x / y) / z) - w $f25(x,y,z) | x - (y / z)
$f73(x,y,z,w) | (x * y) + (z * w) $f26(x,y,z) | x - (y * z)
$f74(x,y,z,w) | (x * y) - (z * w) $f27(x,y,z) | x + (y * z)
$f75(x,y,z,w) | (x * y) + (z / w) $f28(x,y,z) | x + (y / z)
$f76(x,y,z,w) | (x * y) - (z / w) $f29(x,y,z) | x + (y + z)
$f77(x,y,z,w) | (x / y) + (z / w) $f30(x,y,z) | x + (y - z)
$f78(x,y,z,w) | (x / y) - (z / w) $f31(x,y,z) | x * y^2 + z
$f79(x,y,z,w) | (x / y) - (z * w) $f32(x,y,z) | x * y^3 + z
$f80(x,y,z,w) | x / (y + (z * w)) $f33(x,y,z) | x * y^4 + z
$f81(x,y,z,w) | x / (y - (z * w)) $f34(x,y,z) | x * y^5 + z
$f82(x,y,z,w) | x * (y + (z * w)) $f35(x,y,z) | x * y^6 + z
$f83(x,y,z,w) | x * (y - (z * w)) $f36(x,y,z) | x * y^7 + z
$f84(x,y,z,w) | x<em>y^2 + z</em>w^2 $f37(x,y,z) | x * y^8 + z
$f85(x,y,z,w) | x<em>y^3 + z</em>w^3 $f38(x,y,z) | x * y^9 + z
$f86(x,y,z,w) | x<em>y^4 + z</em>w^4 $f39(x,y,z) | x * log(y)+z
$f87(x,y,z,w) | x<em>y^5 + z</em>w^5 $f40(x,y,z) | x * log(y)-z
$f88(x,y,z,w) | x<em>y^6 + z</em>w^6 $f41(x,y,z) | x * log10(y)+z
$f89(x,y,z,w) | x<em>y^7 + z</em>w^7 $f42(x,y,z) | x * log10(y)-z
$f90(x,y,z,w) | x<em>y^8 + z</em>w^8 $f43(x,y,z) | x * sin(y)+z
$f91(x,y,z,w) | x<em>y^9 + z</em>w^9 $f44(x,y,z) | x * sin(y)-z
$f92(x,y,z,w) | (x and y) ? z : w $f45(x,y,z) | x * cos(y)+z
$f93(x,y,z,w) | (x or y) ? z : w $f46(x,y,z) | x * cos(y)-z
$f94(x,y,z,w) | (x &lt; y) ? z : w $f47(x,y,z) | x ? y : z $f95(x,y,z,w)
| (x &lt;= y) ? z : w $f96(x,y,z,w) | (x &gt; y) ? z : w $f97(x,y,z,w) |
(x &gt;= y) ? z : w $f98(x,y,z,w) | (x == y) ? z : w $f99(x,y,z,w) |
x<em>sin(y)+z</em>cos(w)</p>
<pre><code>
[SECTION 13 - VARIABLE, VECTOR &amp; STRING DEFINITION]
ExprTk supports the definition of expression local variables,  vectors
and  strings.  The definitions  must  be unique  as  shadowing is  not
allowed and object lifetimes are based  on scope. Definitions use  the
following general form:

   var &lt;name&gt; := &lt;initialiser&gt;;

(1) Variable Definition
Variables are  of numeric  type denoting  a single  value. They can be
explicitly initialised to a value, otherwise they will be defaulted to
zero. The following are examples of variable definitions:

   (a) Initialise x to zero
       var x;

   (b) Initialise y to three
       var y := 3;

   (c) Initialise z to the expression
       var z := if (max(1, x + y) &gt; 2, w, v);

   (d) Initialise const literal n
       var n := 12 / 3;


(2) Vector Definition
Vectors are arrays of a common numeric type. The elements in a  vector
can be explicitly initialised, otherwise they will all be defaulted to
zero. The following are examples of vector definitions:

   (a) Initialise all values to zero
       var x[3];

   (b) Initialise all values to zero
       var x[3] := {};

   (c) Initialise all values to given value or expression
       var x[3]   := [ 42 ];
       var y[x[]] := [ 123 + 3y + sin(w / z) ];

   (d) Initialise all values iota style
       var v[4] := [ 0 : +1];  //  0,  1,  2,  3
       var v[5] := [-3 : -2];  // -3, -5, -7, -9, -11

   (e) Initialise the first two values, all other elements to zero
       var x[3] := { (1 + x[2]) / x[], (sin(y[0] / x[]) + 3) / x[] };

   (f) Initialise the first three (all) values
       const var size := 3;
       var x[size] := { 1, 2, 3 };

   (g) Initialise vector from a vector
       var x[4] := { 1, 2, 3, 4 };
       var y[3] := x;
       var w[5] := { 1, 2 }; // 1, 2, 0, 0, 0

   (h) Initialise vector from a smaller vector
       var x[3] := { 1, 2, 3 };
       var y[5] := x;   // 1, 2, 3, ??, ??

   (i) Non-initialised vector
       var x[3] := null; // ?? ?? ??

   (j) Error as there are too many initialisers
       var x[3] := { 1, 2, 3, 4 };

   (k) Error as a vector of size zero is not allowed.
       var x[0];


(3) String Definition
Strings are sequences comprised of 8-bit characters. They can only be
defined  with an explicit  initialisation  value. The  following  are
examples of string variable definitions:

   (a) Initialise to a string
       var x := &#39;abc&#39;;

   (b) Initialise to an empty string
       var x := &#39;&#39;;

   (c) Initialise to a string expression
       var x := &#39;abc&#39; + &#39;123&#39;;

   (d) Initialise to a string range
       var x := &#39;abc123&#39;[2:4];

   (e) Initialise to another string variable
       var x := &#39;abc&#39;;
       var y := x;

   (f) Initialise to another string variable range
       var x := &#39;abc123&#39;;
       var y := x[2:4];

   (g) Initialise to a string expression
       var x := &#39;abc&#39;;
       var y := x + &#39;123&#39;;

   (h) Initialise to a string expression range
       var x := &#39;abc&#39;;
       var y := (x + &#39;123&#39;)[1:3];


(4) Return Value
Variable and vector  definitions have a  return value. In  the case of
variable definitions, the value  to which the variable  is initialised
will be returned. Where as for vectors, the value of the first element
(eg: v[0]) shall be returned.

   8 == ((var x := 7;) + 1)
   4 == (var y[3] := {4, 5, 6};)


(5) Variable/Vector Assignment
The value of a variable can be assigned to a vector and a vector or  a
vector expression can be assigned to a variable.

  (a) Variable To Vector:
      Every element of the vector is assigned the value of the variable
      or expression.
      var x    := 3;
      var y[3] := { 1, 2, 3 };
      y := x + 1;

  (b) Vector To Variable:
      The variable is assigned the value of the first element of the
      vector (aka vec[0])
      var x    := 3;
      var y[3] := { 1, 2, 3 };
      x := y + 1;


Note10: During the expression compilation phase, tokens are classified
based on the following priorities:

   (a) Reserved keywords or operators (+, -, and, or, etc)
   (b) Base functions (abs, sin, cos, min, max etc)
   (c) Symbol table variables
   (d) Expression local defined variables
   (e) Symbol table functions
   (f) Unknown symbol resolver based variables
</code></pre>
<p>[SECTION 14 - VECTOR PROCESSING] ExprTk provides support for various
forms of vector oriented arithmetic, inequalities and processing. The
various supported pairs are as follows:</p>
<ol type="a">
<li>vector and vector (eg: v0 + v1)</li>
<li>vector and scalar (eg: v + 33)</li>
<li>scalar and vector (eg: 22 * v)</li>
</ol>
<p>The following is a list of operations that can be used in conjunction
with vectors:</p>
<ol type="a">
<li>Arithmetic: +, -, *, /, %</li>
<li>Exponentiation: vector ^ scalar</li>
<li>Assignment: :=, +=, -=, *=, /=, %=, &lt;=&gt;</li>
<li>Inequalities: &lt;, &lt;=, &gt;, &gt;=, ==, =, equal</li>
<li>Boolean logic: and, nand, nor, or, xnor, xor</li>
<li>Unary operations: abs, acos, acosh, asin, asinh, atan, atanh, ceil,
cos, cosh, cot, csc, deg2grad, deg2rad, erf, erfc, exp, expm1, floor,
frac, grad2deg, log, log10, log1p, log2, rad2deg, round, sec, sgn, sin,
sinc, sinh, sqrt, swap, tan, tanh, trunc, thresholding</li>
<li>Aggregate and Reduce operations: avg, max, min, mul, dot, dotk, sum,
sumk, count, all_true, all_false, any_true, any_false</li>
<li>Transformation operations: copy, diff, reverse, rotate-left/right,
shift-left/right, sort, nth_element</li>
<li>BLAS-L1: axpy, axpby, axpyz, axpbyz, axpbz</li>
</ol>
<p>Note11: When one of the above described operations is being performed
between two vectors, the operation will only span the size of the
smallest vector. The elements of the larger vector outside of the range
will not be included. The operation itself will be processed
element-wise over values of the smaller of the two ranges.</p>
<p>The following simple example demonstrates the vector processing
capabilities by computing the dot-product of the vectors v0 and v1 and
then assigning it to the variable v0dotv1:</p>
<p>var v0[3] := { 1, 2, 3 }; var v1[3] := { 4, 5, 6 }; var v0dotv1 :=
sum(v0 * v1);</p>
<p>The following is a for-loop based implementation that is equivalent
to the previously mentioned dot-product computation expression:</p>
<p>var v0[3] := { 1, 2, 3 }; var v1[3] := { 4, 5, 6 }; var v0dotv1;</p>
<p>for (var i := 0; i &lt; min(v0[],v1[]); i += 1) { v0dotv1 += (v0[i] *
v1[i]); }</p>
<p>Note12: When the aggregate or reduction operations denoted above are
used in conjunction with a vector or vector expression, the return value
is not a vector but rather a single value.</p>
<p>var x[3] := { 1, 2, 3 };</p>
<p>sum(x) == 6 sum(1 + 2x) == 15 avg(3x + 1) == 7 min(1 / x) == (1 / 3)
max(x / 2) == (3 / 2) sum(x &gt; 0 and x &lt; 5) == x[]</p>
<p>When utilising external user defined vectors via the symbol table as
opposed to expression local defined vectors, the typical ‘add_vector’
method from the symbol table will register the entirety of the vector
that is passed. The following example attempts to evaluate the sum of
elements of the external user defined vector within a typical yet
trivial expression:</p>
<p>const std::string reduce_program = ” sum(2 * v + 1) “;</p>
<p>std::vector<T> v0 { T(1.1), T(2.2), ….. , T(99.99) };</p>
<p>symbol_table_t symbol_table; symbol_table.add_vector(“v”,v);</p>
<p>expression_t expression;
expression.register_symbol_table(symbol_table);</p>
<p>parser_t parser; parser.compile(reduce_program,expression);</p>
<p>T sum = expression.value();</p>
<p>For the most part, this is a very common use-case. However there may
be situations where one may want to evaluate the same vector oriented
expression many times over, but using different vectors or sub ranges of
the same vector of the same size to that of the original upon every
evaluation.</p>
<p>The usual solution is to either recompile the expression for the new
vector instance, or to copy the contents from the new vector to the
symbol table registered vector and then perform the evaluation. When the
vectors are large or the re-evaluation attempts are numerous, these
solutions can become rather time consuming and generally
inefficient.</p>
<p>std::vector<T> v1 { T(2.2), T(2.2), ….. , T(2.2) }; std::vector<T> v2
{ T(3.3), T(3.3), ….. , T(3.3) }; std::vector<T> v3 { T(4.4), T(4.4),
….. , T(4.4) };</p>
<p>std::vector&lt;std::vector<T>&gt; vv { v1, v2, v3 }; … T sum =
T(0);</p>
<p>for (auto&amp; new_vec : vv) { v = new_vec; // update vector sum +=
expression.value(); }</p>
<p>A solution to the above ‘efficiency’ problem, is to use the
exprtk::vector_view object. The vector_view is instantiated with a size
and backing based upon a vector. Upon evaluations if the backing needs
to be ‘updated’ to either another vector or sub-range, the vector_view
instance can be efficiently rebased, and the expression evaluated as
normal.</p>
<p>exprtk::vector_view<T> view =
exprtk::make_vector_view(v,v.size());</p>
<p>symbol_table_t symbol_table; symbol_table.add_vector(“v”,view);</p>
<p>…</p>
<p>T sum = T(0);</p>
<p>for (auto&amp; new_vec : vv) { view.rebase(new_vec.data()); // update
vector sum += expression.value(); }</p>
<p>Another useful feature of exprtk::vector_view is that all such
vectors can have their sizes modified (or “resized”). The resizing of
the associated vectors can happen either between or during
evaluations.</p>
<p>std::vector<T> v = { 1, 2, 3, 4, 5, 6, 7, 8 }; exprtk::vector_view<T>
view = exprtk::make_vector_view(v,v.size());</p>
<p>symbol_table_t symbol_table; symbol_table.add_vector(“v”,view);</p>
<p>const std::string expression_string = “v[]”;</p>
<p>expression_t expression;
expression.register_symbol_table(symbol_table);</p>
<p>parser_t parser; parser.compile(expression_string, expression);</p>
<p>for (std::size_t i = 1; i &lt;= v.size(); ++i) { vv.set_size(i);
expression.value(); }</p>
<p>In the example above, a vector_view is instantiated with a
std::vector instance with eight elements and registered to the given
symbol_table. An expression is then compiled, which in this case simply
returns the size of the vector at that point in time. The expression is
evaluated eight times (size of vector times), where upon each iteration
the size of the vector is changed with values ranging from one to
eight.</p>
<p>Note13: When modifying the size of a vector, the new size must be at
least one or larger and must not exceed the original size of the
vector_view when it was instantiated.</p>
<p>Note14: The lifetime of any parser, symbol_table or expression
instance must not exceed that of any vector_view instance that has been
registered with it. Furthermore the lifetime of a vector_view must not
exceed that of the underlying vector instance it is associated with.</p>
<p>Note15: In a multi-threaded context the rebase function should not be
called during associated expression evaluation, as this will lead to
undefined behaviour (eg: torn reads and writes).</p>
<pre><code>
[SECTION 15 - USER DEFINED FUNCTIONS]
ExprTk provides a means  whereby custom functions can  be defined  and
utilised within  expressions.  The   concept  requires  the  user   to
provide a reference  to the function  coupled with an  associated name
that  will be invoked within  expressions. Functions may take numerous
inputs but will always return a single value of the underlying numeric
type.

During  expression  compilation  when required  the  reference  to the
function  shall be obtained from  the associated  symbol_table and  be
embedded into the expression.

There are six types of function interface:

  +---+----------------------+--------------+----------------------+
  | # |         Name         | Return Type  | Input Types          |
  +---+----------------------+--------------+----------------------+
  | 1 | ifunction            | Scalar       | Scalar               |
  | 2 | ivararg_function     | Scalar       | Scalar               |
  | 3 | igeneric_function    | Scalar       | Scalar,Vector,String |
  | 4 | igeneric_function II | String       | Scalar,Vector,String |
  | 5 | igeneric_function III| String/Scalar| Scalar,Vector,String |
  | 6 | function_compositor  | Scalar       | Scalar               |
  +---+----------------------+--------------+----------------------+

(1) ifunction
This interface supports zero to 20 input parameters of only the scalar
type (numbers). The  usage requires a custom function be  derived from
ifunction and to override one of the 21 function operators. As part of
the constructor the custom function will define how many parameters it
expects  to  handle.  The  following  example  defines  a  3 parameter
function called &#39;foo&#39;:

   template &lt;typename T&gt;
   struct foo final : public exprtk::ifunction&lt;T&gt;
   {
      foo() : exprtk::ifunction&lt;T&gt;(3)
      {}

      T operator()(const T&amp; v1, const T&amp; v2, const T&amp; v3) override
      {
         return T(1) + (v1 * v2) / T(v3);
      }
   };


(2) ivararg_function
This interface supports a variable number of scalar arguments as input
into the function. The function operator interface uses a  std::vector
specialised upon type T to facilitate parameter passing. The following
example defines a vararg function called &#39;boo&#39;:

   template &lt;typename T&gt;
   struct boo final : public exprtk::ivararg_function&lt;T&gt;
   {
      inline T operator()(const std::vector&lt;T&gt;&amp; arglist) override
      {
         T result = T(0);

         for (std::size_t i = 0; i &lt; arglist.size(); ++i)
         {
            result += arglist[i] / arglist[i &gt; 0 ? (i - 1) : 0];
         }

         return result;
      }
   };


(3) igeneric_function
This interface supports  a variable number  of arguments and  types as
input  into  the  function. The  function  operator  interface uses  a
std::vector  specialised  upon  the  type_store  type  to   facilitate
parameter passing.

    Scalar &lt;-- function(i_0, i_1, i_2....., i_N)


The  fundamental  types  that  can  be  passed  into  the  function as
parameters and their views are as follows:

   (1) Scalar - scalar_view
   (2) Vector - vector_view
   (3) String - string_view


The above denoted type  views provide non-const reference-like  access
to each parameter, as such modifications made to the input  parameters
will  persist after  the function  call has  completed. The  following
example defines a generic function called &#39;too&#39;:

   template &lt;typename T&gt;
   struct too final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::parameter_list_t
                                                     parameter_list_t;

      too()
      {}

      inline T operator()(parameter_list_t parameters) override
      {
         for (std::size_t i = 0; i &lt; parameters.size(); ++i)
         {
            ...
         }

         return T(0);
      }
   };


In the example above, the input &#39;parameters&#39; to the function operator,
parameter_list_t,  is  a  type  of  std::vector  of  type_store.  Each
type_store  instance  has  a  member  called  &#39;type&#39;  which  holds the
enumeration pertaining to the underlying type of the type_store. There
are three type enumerations:

   (1) e_scalar - literals, variables, vector elements, expressions
       eg: 123.456, x, vec[3x + 1], 2x + 3

   (2) e_vector - vectors, vector expressions
       eg: vec1, 2 * vec1 + vec2 / 3

   (3) e_string - strings, string literals and range variants of both
       eg: &#39;AString&#39;, s0, &#39;AString&#39;[x:y], s1[1 + x:] + &#39;AString&#39;


Each of the  parameters can be  accessed using its  designated view.
A typical loop for processing the parameters is as follows:

   inline T operator()(parameter_list_t parameters)
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::generic_type
                                                     generic_type;

      typedef typename generic_type::scalar_view scalar_t;
      typedef typename generic_type::vector_view vector_t;
      typedef typename generic_type::string_view string_t;

      for (std::size_t i = 0; i &lt; parameters.size(); ++i)
      {
         generic_type&amp; gt = parameters[i];

         if (generic_type::e_scalar == gt.type)
         {
            scalar_t x(gt);
            ...
         }
         else if (generic_type::e_vector == gt.type)
         {
            vector_t vector(gt);
            ...
         }
         else if (generic_type::e_string == gt.type)
         {
            string_t string(gt);
            ...
         }
      }

      return T(0);
   }


Most often than not a custom generic function will require a  specific
sequence of parameters, rather than some arbitrary sequence of  types.
In those situations, ExprTk can perform compile-time type checking  to
validate that function invocations  are carried out using  the correct
sequence of parameters. Furthermore  performing the checks at  compile
-time rather than at run-time (aka every time the function is invoked)
will result in expression evaluation performance gains.

Compile-time type  checking of  input parameters  can be  requested by
passing  a string  to the  constructor of  the igeneric_function  that
represents the required sequence of parameter types. When no parameter
sequence is provided, it is implied the function can accept a variable
number of parameters comprised of any of the fundamental types.

Each fundamental type has an  associated character. The following is a
listing of said characters and their meanings:

   (1) T - Scalar
   (2) V - Vector
   (3) S - String
   (4) Z - Zero or no parameters
   (5) ? - Any type (Scalar, Vector or String)
   (6) * - Wildcard operator
   (7) | - Parameter sequence delimiter


No other characters other than the seven denoted above may be included
in the parameter sequence  definition. If any such  invalid characters
do exist, registration of the associated generic function to a  symbol
table (&#39;add_function&#39; method) will fail. If the parameter sequence  is
modified resulting in it becoming  invalid after having been added  to
the symbol table but before the compilation step, a compilation  error
will be incurred.

The  following   example  demonstrates   a  simple   generic  function
implementation with a user specified parameter sequence:

   template &lt;typename T&gt;
   struct moo final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::parameter_list_t
                                                     parameter_list_t;

      moo()
      : exprtk::igeneric_function&lt;T&gt;(&quot;SVTT&quot;)
      {}

      inline T operator()(parameter_list_t parameters) override
      {
         ...
      }
   };


In the example above the  generic function &#39;moo&#39; expects exactly  four
parameters in the following sequence:

   (1) String
   (2) Vector
   (3) Scalar
   (4) Scalar

Note16: The &#39;Z&#39; or no parameter option may not be used in  conjunction
with any other type option in a parameter sequence. When  incorporated
in the parameter  sequence list, the  &#39;No Parameter&#39; option  indicates
that the function may be invoked without any parameters being  passed.
For more information refer to the section: &#39;Zero Parameter Functions&#39;


(4) igeneric_function II
This interface is identical to  the igeneric_function, in that in  can
consume an  arbitrary number  of parameters  of varying  type, but the
difference being  that the  function returns  a string  and as such is
treated as a string when  invoked within expressions. As a  result the
function call can  alias a string  and interact with  other strings in
situations such as concatenation and equality operations.

    String &lt;-- function(i_0, i_1, i_2....., i_N)


The following example defines a generic function  named &#39;toupper&#39; with
the string return type function operator being explicitly overridden:

   template &lt;typename T&gt;
   struct toupper final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef exprtk::igeneric_function&lt;T&gt; igenfunct_t;
      typedef typename igenfunct_t::generic_type generic_t;
      typedef typename igenfunct_t::parameter_list_t parameter_list_t;
      typedef typename generic_t::string_view string_t;

      toupper()
      : exprtk::igeneric_function&lt;T&gt;(&quot;S&quot;,igenfunct_t::e_rtrn_string)
      {}

      inline T operator()(std::string&amp; result,
                          parameter_list_t parameters) override
      {
         result.clear();

         string_t string(parameters[0]);

         for (std::size_t i = 0; i &lt; string.size(); ++i)
         {
            result += std::toupper(string[i]);
         }

         return T(0);
      }
   };


In the example above the  generic function &#39;toupper&#39; expects only  one
input parameter  of type  string, as  noted by  the parameter sequence
string passed during the  constructor. Furthermore a second  parameter
is passed to the constructor indicating that it should be treated as a
string returning function -  by default it is  assumed to be a  scalar
returning function.

When executed,  the function  will return  as a  result a  copy of the
input string converted to uppercase form. An example expression  using
the toupper function registered as the symbol &#39;toupper&#39; is as follows:

   &quot;&#39;ABCDEF&#39; == toupper(&#39;aBc&#39;) + toupper(&#39;DeF&#39;)&quot;


Note17: When  adding a  string type  returning generic  function to  a
symbol  table  the  &#39;add_function&#39;  is  invoked.  The  example   below
demonstrates how this can be done:

   toupper&lt;T&gt; tu;

   exprtk::symbol_table&lt;T&gt; symbol_table;

   symbol_table.add_function(&quot;toupper&quot;,tu);


Note18: Two further refinements to the  type checking facility are the
possibilities  of  a variable  number  of common  types  which can  be
accomplished by using a wildcard &#39;*&#39; and a special &#39;any type&#39; which is
done using  the &#39;?&#39;  character. It  should be  noted that the wildcard
operator is  associated with  the previous  type in  the sequence  and
implies one or more of that type.

   template &lt;typename T&gt;
   struct zoo final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::parameter_list_t
                                                     parameter_list_t;

      zoo()
      : exprtk::igeneric_function&lt;T&gt;(&quot;SVT*V?&quot;)
      {}

      inline T operator()(parameter_list_t parameters) override
      {
         ...
      }
   };


In the example above the generic function &#39;zoo&#39; expects at least  five
parameters in the following sequence:

   (1) String
   (2) Vector
   (3) One or more Scalars
   (4) Vector
   (5) Any type (one type of either a scalar, vector or string)


A final  piece of  type checking  functionality is  available for  the
scenarios where  a single  function name  is intended  to be  used for
multiple distinct parameter sequences,  another name for this  feature
is function  overloading. The  parameter sequences  are passed  to the
constructor as a  single string delimited  by the pipe  &#39;|&#39; character.
Two specific overrides of the  function operator are provided one  for
standard generic functions and one for string returning functions. The
overrides are as follows:

      // Scalar &lt;-- function(psi,i_0,i_1,....,i_N)
      inline T operator()(const std::size_t&amp; ps_index,
                          parameter_list_t parameters)
      {
         ...
      }

      // String &lt;-- function(psi,i_0,i_1,....,i_N)
      inline T operator()(const std::size_t&amp; ps_index,
                          std::string&amp; result,
                          parameter_list_t parameters)
      {
         ...
      }


When the function  operator is invoked  the &#39;ps_index&#39; parameter  will
have as its value the index of the parameter sequence that matches the
specific invocation. This way complex and time consuming type checking
conditions need not  be executed in  the function itself  but rather a
simple and efficient  dispatch to a  specific implementation for  that
particular parameter sequence can be performed.

   template &lt;typename T&gt;
   struct roo final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::parameter_list_t
                                                     parameter_list_t;

      moo()
      : exprtk::igeneric_function&lt;T&gt;(&quot;SVTT|SS|TTV|S?V*S&quot;)
      {}

      inline T operator()(const std::size_t&amp; ps_index,
                          parameter_list_t parameters) override
      {
         ...
      }
   };


In the example above there are four distinct parameter sequences  that
can be processed  by the generic  function &#39;roo&#39;. Any  other parameter
sequences will cause a compilation error. The four valid sequences are
as follows:

    Sequence-0    Sequence-1    Sequence-2    Sequence-3
      &#39;SVTT&#39;         &#39;SS&#39;          &#39;TTV&#39;       &#39;S?V*S&#39;
   (1) String    (1) String    (1) Scalar    (1) String
   (2) Vector    (2) String    (2) Scalar    (2) Any Type
   (3) Scalar                  (3) Vector    (3) One or more Vectors
   (4) Scalar                                (4) String


(5) igeneric_function III
In this section we will discuss an extension of the  igeneric_function
interface that will allow for the overloading of a user defined custom
function, where by it can return either a scalar or string value  type
depending on the input parameter  sequence with which the function  is
invoked.

   template &lt;typename T&gt;
   struct foo final : public exprtk::igeneric_function&lt;T&gt;
   {
      typedef typename exprtk::igeneric_function&lt;T&gt;::parameter_list_t
                                                     parameter_list_t;

      foo()
      : exprtk::igeneric_function&lt;T&gt;
        (
          &quot;T:T|S:TS&quot;,
          igfun_t::e_rtrn_overload
        )
      {}

      // Scalar value returning invocations
      inline T operator()(const std::size_t&amp; ps_index,
                          parameter_list_t parameters) override
      {
         ...
      }

      // String value returning invocations
      inline T operator()(const std::size_t&amp; ps_index,
                          std::string&amp; result,
                          parameter_list_t&amp; parameters) override
      {
         ...
      }
   };


In the  example above  the custom  user defined  function &quot;foo&quot; can be
invoked by using  either one of  two input parameter  sequences, which
are defined as follows:

   Sequence-0    Sequence-1
   &#39;T&#39; -&gt; T      &#39;TS&#39; -&gt; S
   (1) Scalar    (1) Scalar
                 (2) String


The parameter  sequence definitions  are identical  to the  previously
defined igeneric_function, with the exception of the inclusion  of the
return type - which can only be either a scalar T or a string S.


(6) function_compositor
The function  compositor is  a factory  that allows  one to define and
construct a function using ExprTk syntax. The functions are limited to
returning a single scalar value and consuming up to six parameters  as
input.

All composited functions are registered with a symbol table,  allowing
them  to  call  other  functions  and  use  variables  that  have been
registered with the symbol  table instance. Furthermore the  functions
can be  recursive in  nature due  to the  inherent function  prototype
forwarding  that  occurs during  construction.  The following  example
defines,  by using  two different  methods, composited  functions and
implicitly registering the functions with the denoted symbol table.

   typedef exprtk::symbol_table&lt;T&gt;         symbol_table_t;
   typedef exprtk::function_compositor&lt;T&gt;  compositor_t;
   typedef typename compositor_t::function function_t;

   T avogadro = T(6.022e23);

   symbol_table_t symbol_table;

   symbol_table.add_constant(&quot;avogadro&quot;, avogadro);

   compositor_t compositor(symbol_table);

   // Define function koo0(v1, v2) { ... }
   compositor.add(
      function_t(&quot;koo0&quot;),
      .vars(&quot;v1&quot;, &quot;v2&quot;)
      .expression
      (
         &quot; 1 + cos(v1 * v2) / avogadro; &quot;
      ));

   // Define function koo1(x, y, z) { ... }
   compositor.add(
      function_t()
      .name(&quot;koo1&quot;)
      .var(&quot;x&quot;).var(&quot;y&quot;).var(&quot;z&quot;)
      .expression
      (
         &quot;1 + koo0(x * y, 3) / z;&quot;
      ));


A function compositor can also be instantiated without a symbol_table.
When this is the case an internal symbol_table is used for holding the
references to the composited functions.

   compositor_t compositor;

   // Define function koo2(v1, v2) { ... }
   compositor.add(
      function_t(&quot;koo2&quot;),
      .vars(&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;)
      .expression
      ( &quot; abs(v1 * v2) / v3; &quot; ));


When wanting to  reference functions from  the compositor above  in an
expression, the compositor&#39;s symbol_table  will need to be  registered
with the expression  prior to compilation,  as is demonstrated  in the
following code:

   expression_t expression;
   .
   .
   expression.register_symbol_table(compositor.symbol_table());


In the situation where  more than one symbol table&#39;s contents will  be
required by the functions  being composited, then those  symbol tables
can be registered as auxiliary symbol tables with the compositor:

   symbol_table_t global_symbol_table;
   symbol_table_t local_symbol_table;
   .
   .
   .
   compositor_t compositor;

   compositor.add_auxiliary_symtab(global_symbol_table);
   compositor.add_auxiliary_symtab(local_symbol_table );

Note19: In the event, that two or more symbol tables contain similarly
named  variables,  vectors,  strings   or  functions,  the  order   of
registration with the compositor shall determine the symbol table from
which the target symbol will be referenced.


(7) Using Functions In Expressions
For the above denoted custom and composited functions to be used in an
expression, an instance of each function needs to be registered with a
symbol_table that  has been  associated with  the expression instance.
The following demonstrates how all the pieces are put together:

   typedef exprtk::symbol_table&lt;double&gt;        symbol_table_t;
   typedef exprtk::expression&lt;double&gt;          expression_t;
   typedef exprtk::parser&lt;double&gt;              parser_t;
   typedef exprtk::function_compositor&lt;double&gt; compositor_t;
   typedef typename compositor_t::function     function_t;

   foo&lt;double&gt; f;
   boo&lt;double&gt; b;
   too&lt;double&gt; t;
   toupper&lt;double&gt; tu;

   symbol_table_t symbol_table;
   compositor_t   compositor(symbol_table);

   symbol_table.add_function(&quot;foo&quot;,f);
   symbol_table.add_function(&quot;boo&quot;,b);
   symbol_table.add_function(&quot;too&quot;,t);

   symbol_table
      .add_function(&quot;toupper&quot;, tu, symbol_table_t::e_ft_strfunc);

   compositor.add(
      function_t(&quot;koo&quot;)
      .var(&quot;v1&quot;)
      .var(&quot;v2&quot;)
      .expression
      (
         &quot;1 + cos(v1 * v2) / 3;&quot;
      ));

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   const std::string expression_str =
      &quot; if (foo(1,2,3) + boo(1) &gt; boo(1/2, 2/3, 3/4, 4/5)) &quot;
      &quot;    koo(3,4);                                       &quot;
      &quot; else                                               &quot;
      &quot;    too(2 * v1 + v2 / 3, &#39;abcdef&#39;[2:4], 3.3);       &quot;
      &quot;                                                    &quot;;

   parser_t parser;
   parser.compile(expression_str,expression);

   expression.value();


(8) Function Side-Effects
All function calls are assumed  to have side-effects by default.  This
assumption implicitly disables constant folding optimisations when all
parameters being passed to the function are deduced as being constants
at compile time.

If it is certain that the function being registered does not have  any
side-effects and can  be correctly constant folded  where appropriate,
then during the construction of the function the side-effect trait  of
the function can be disabled.

   template &lt;typename T&gt;
   struct foo final : public exprtk::ifunction&lt;T&gt;
   {
      foo() : exprtk::ifunction&lt;T&gt;(3)
      {
         exprtk::disable_has_side_effects(*this);
      }

      T operator()(const T&amp; v1, const T&amp; v2, const T&amp; v3) override
      { ... }
   };


(9) Zero Parameter Functions
When  either  an  ifunction,  ivararg_function  or   igeneric_function
derived type is defined with zero number of parameters, there are  two
calling  conventions  within  expressions  that  are  allowed.  For  a
function named &#39;foo&#39; with zero input parameters the calling styles are
as follows:

   (1)  x + sin(foo()- 2) / y
   (2)  x + sin(foo  - 2) / y


By default the  zero parameter trait  is disabled. In  order to enable
it, a process similar to that of  enabling of the side-effect trait is
carried out:

   template &lt;typename T&gt;
   struct foo final : public exprtk::ivararg_function&lt;T&gt;
   {
      foo()
      {
         exprtk::enable_zero_parameters(*this);
      }

      inline T operator()(const std::vector&lt;T&gt;&amp; arglist) override
      { ... }
   };


Note20: For the igeneric_function  type, there  also needs to be a &#39;Z&#39;
parameter sequence  defined in order for the  zero parameter  trait to
properly take effect otherwise a compilation error will occur.


(10) Free Functions
The ExprTk symbol  table supports the  registration of free  functions
and lambdas  (anonymous functors)  for use  in expressions.  The basic
requirements  are similar  to those  found in  ifunction derived  user
defined  functions. This  includes  support  for free  functions using
anywhere from zero up to fifteen input parameters of scalar type, with
a return type that is also scalar. Furthermore such functions will  by
default be assumed to have side-effects and hence will not participate
in constant folding optimisations.

In the following  example, a one  input parameter free  function named
&#39;compute1&#39;,  a  two  input  parameter  template  free  function  named
&#39;compute2&#39; and a three input parameter lambda named &#39;compute3&#39; will be
registered with the given symbol_table instance:

   double compute1(double v0)
   {
      return 2.0 * std::abs(v0);
   }

   template &lt;typename T&gt;
   T compute2(T v0, T v1)
   {
      return 2.0 * v0 + v1 / 3.0;
   }
   .
   .
   .

   typedef exprtk::symbol_table&lt;double&gt; symbol_table_t;

   symbol_table_t symbol_table;

   symbol_table.add_function(&quot;compute1&quot;, compute1);
   symbol_table.add_function(&quot;compute2&quot;, compute2&lt;double&gt;);

   symbol_table.add_function(
      &quot;compute3&quot;,
      [](double v0, double v1, double v2) -&gt; double
      { return v0 / v1 + v2; });


Note21: Similar to  variables registered with  symbol_table instances,
for any of the following function providers:

   1. ifunction
   2. ivararg_function
   3. igeneric_function
   4. function_compositor
   5. Free function
   7. Lambda


Their instance lifetimes must exceed the symbol_tables and expressions
they are  registered with.  In the  event that  is not  the case,  the
expected result shall be undefined behaviour.
</code></pre>
<p>[SECTION 16 - EXPRESSION DEPENDENTS] Any expression that is not a
literal (aka constant) will have dependencies. The types of
‘dependencies’ an expression can have are as follows:</p>
<ol type="a">
<li>Variables</li>
<li>Vectors</li>
<li>Strings</li>
<li>Functions</li>
<li>Assignments</li>
</ol>
<p>In the following example the denoted expression has its various
dependencies listed:</p>
<p>z := abs(x + sin(2 * pi / y))</p>
<ol type="a">
<li>Variables: x, y, z and pi</li>
<li>Functions: abs, sin</li>
<li>Assignments: z</li>
</ol>
<p>ExprTk allows for the derivation of expression dependencies via the
‘dependent_entity_collector’ (DEC). When activated either through
‘compile_options’ at the construction of the parser or through calls to
enabler methods just prior to compilation, the DEC will proceed to
collect any of the relevant types that are encountered during the
parsing phase. Once the compilation process has successfully completed,
the caller can then obtain a list of symbols and their associated types
from the DEC.</p>
<p>The kinds of questions one can ask regarding the dependent entities
within an expression are as follows:</p>
<ul>
<li>What user defined variables, vectors or strings are used?</li>
<li>What functions or custom user functions are used?</li>
<li>Which variables, vectors or strings have values assigned to
them?</li>
</ul>
<p>The following example demonstrates usage of the DEC in determining
the dependents of the given expression:</p>
<p>typedef typename parser_t:: dependent_entity_collector::symbol_t
symbol_t;</p>
<p>const std::string expression_string = “z := abs(x + sin(2 * pi /
y))”;</p>
<p>T x,y,z;</p>
<p>parser_t parser; symbol_table_t symbol_table;</p>
<p>symbol_table.add_variable(“x”,x); symbol_table.add_variable(“y”,y);
symbol_table.add_variable(“z”,z);</p>
<p>expression_t expression;
expression.register_symbol_table(symbol_table);</p>
<p>// Collect only variable and function symbols
parser.dec().collect_variables() = true;
parser.dec().collect_functions() = true;</p>
<p>if (!parser.compile(expression_string,expression)) { // error…. }</p>
<p>std::deque<symbol_t> symbol_list;</p>
<p>parser.dec().symbols(symbol_list);</p>
<p>for (std::size_t i = 0; i &lt; symbol_list.size(); ++i) { const
symbol_t&amp; symbol = symbol_list[i];</p>
<pre><code>  switch (symbol.second)
  {
     case parser_t::e_st_variable : ... break;
     case parser_t::e_st_vector   : ... break;
     case parser_t::e_st_string   : ... break;
     case parser_t::e_st_function : ... break;
  }</code></pre>
<p>}</p>
<p>Note22: The ‘symbol_t’ type is a std::pair comprising of the symbol
name (std::string) and the associated type of the symbol as denoted by
the cases in the switch statement.</p>
<p>Having particular symbols (variable or function) present in an
expression is one form of dependency. Another and just as interesting
and important type of dependency is that of assignments. Assignments are
the set of dependent symbols that ‘may’ have their values modified
within an expression. The following are example expressions and their
associated assignments:</p>
<pre><code>   Assignments   Expression</code></pre>
<ol type="1">
<li>x x := y + z</li>
<li>x, y x += y += z</li>
<li>x, y, z x := y += sin(z := w + 2)</li>
<li>w, z if (x &gt; y, z := x + 2, w := ‘A String’)</li>
<li>None x + y + z</li>
</ol>
<p>Note23: In expression 4, both variables ‘w’ and ‘z’ are denoted as
being assignments even though only one of them can ever be modified at
the time of evaluation. Furthermore the determination of which of the
two variables the modification will occur upon can only be known with
certainty at evaluation time and not beforehand, hence both are listed
as being candidates for assignment.</p>
<p>The following builds upon the previous example demonstrating the
usage of the DEC in determining the ‘assignments’ of the given
expression:</p>
<p>// Collect assignments parser.dec().collect_assignments() = true;</p>
<p>if (!parser.compile(expression_string,expression)) { // error…. }</p>
<p>std::deque<symbol_t> symbol_list;</p>
<p>parser.dec().assignment_symbols(symbol_list);</p>
<p>for (std::size_t i = 0; i &lt; symbol_list.size(); ++i) {
symbol_t&amp; symbol = symbol_list[i];</p>
<pre><code>  switch (symbol.second)
  {
     case parser_t::e_st_variable : ... break;
     case parser_t::e_st_vector   : ... break;
     case parser_t::e_st_string   : ... break;
  }</code></pre>
<p>}</p>
<p>Note24: The assignments will only consist of variable types and as
such will not contain symbols denoting functions.</p>
<pre><code>
[SECTION 17 - HIERARCHIES OF SYMBOL TABLES]
Most situations will only require a single symbol_table instance to be
associated with a given expression instance.

However as an expression can have more than one symbol table  instance
associated  with  itself,  when  building  more  complex  systems that
utilise many expressions  where each can  in turn utilise  one or more
variables  from  a  large set  of  potential  variables, functions  or
constants, it becomes evident  that grouping variables into  layers of
symbol_tables will simplify and streamline the overall process.

A recommended hierarchy of symbol tables is the following:

   (a) Global constant value symbol table
   (b) Global non side-effect functions symbol table
   (c) Global variable symbol table
   (d) Expression specific variable symbol table


(a) Global constant value symbol table
This symbol table will  contain constant variables denoting  immutable
values. These variables can be made available to all expressions,  and
in turn expressions  will assume the  values themselves will  never be
modified for the  duration of the  process run-time. Examples  of such
variables are:

   (1) pi or e
   (2) speed_of_light
   (3) avogadro_number
   (4) num_cpus


(b) Global non side-effect functions symbol table
This symbol table will contain  only user defined functions that  will
not  incur  any  side-effects  that  are  observable  to  any  of  the
expressions that invoke them. These functions shall be  thread-safe or
threading invariant and  will not maintain  any form of  state between
invocations. Examples of such functions are:

   (1) calc_volume_of_sphere(r)
   (2) distance(x0,y0,x1,y1)


(c) Global variable symbol table
This symbol table  will contain variables  that will be  accessible to
all associated expressions  and will not  be specific or  exclusive to
any one expression. This variant  differs from (a) in that  the values
of the  variables can  change (or  be updated)  between evaluations of
expressions  -   but  through   properly  scheduled   evaluations  are
guaranteed  to never  change during  the evaluation  of any  dependent
expressions. Furthermore it  is assumed that  these variables will  be
used in a  read-only context and  that no expressions  will attempt to
modify these variables via assignments or other means.

   (1) price_of_stock_xyz
   (2) outside_temperature or inside_temperature
   (3) fuel_in_tank
   (4) num_customers_in_store
   (5) num_items_on_shelf


(d) Expression specific variable symbol table
This  symbol_table  is  the most  common form,  and is  used to  store
variables that are specific and exclusive to a particular  expression.
That is to say references  to variables in this symbol_table  will not
be  part of  another expression.  Though it  may be  possible to  have
expressions that  contain the  variables with  the same  name, in that
case those variables will be distinctly different. Which would mean if
a particular  expression were  to be  compiled twice,  each expression
would have its  own unique symbol_table  which in turn  would have its
own instances of those variables. Examples of such variables could be:

   (1) x or y
   (2) customer_name


The following is a diagram depicting a possible variant of the denoted
symbol  table  hierarchies.  In  the  diagram  there  are  two  unique
expressions, each of  which have a  reference to the  Global constant,
functions and variables symbol tables and an exclusive reference to  a
local symbol table.

  +-------------------------+    +-------------------------+
  |     Global Constants    |    |     Global Functions    |
  |       Symbol Table      |    |       Symbol Table      |
  +----o--o-----------------+    +--------------------o----+
       |  |                                           |
       |  |                                           +-------+
       |  +-------------------&gt;----------------------------+  |
       |         +----------------------------+            |  |
       |         |      Global Variables      |            |  |
       |  +------o        Symbol Table        o-----+      |  V
       |  |      +----------------------------+     |      |  |
       |  |                                         |      |  |
       |  | +----------------+   +----------------+ |      |  |
       |  | | Symbol Table 0 |   | Symbol Table 1 | |      V  |
       |  | +--o-------------+   +--o-------------+ |      |  |
       |  |    |                    |               |      |  |
       |  |    |                    |               |      |  |
    +--V--V----V---------+        +-V---------------V--+   |  |
    |    Expression 0    |        |    Expression 1    |&lt;--+--+
    |  &#39;2 * sin(x) - y&#39;  |        |  &#39;k + abs(x - y)&#39;  |
    +--------------------+        +--------------------+


Bringing  all of  the above  together, in  the following  example the
hierarchy  of  symbol  tables  are instantiated  and  initialised. An
expression that makes use of various elements of each symbol table is
then compiled and later on evaluated:

   typedef exprtk::symbol_table&lt;double&gt; symbol_table_t;
   typedef exprtk::expression&lt;double&gt;   expression_t;

   // Setup global constants symbol table
   symbol_table_t glbl_const_symbol_table;
   glbl_const_symbtab.add_constants(); // pi, epsilon and inf
   glbl_const_symbtab.add_constant(&quot;speed_of_light&quot;,299e6);
   glbl_const_symbtab.add_constant(&quot;avogadro_number&quot;,6e23);

   // Setup global function symbol table
   symbol_table_t glbl_funcs_symbol_table;
   glbl_func_symbtab.add_function(&#39;distance&#39;,distance);
   glbl_func_symbtab.add_function(&#39;calc_spherevol&#39;,calc_sphrvol);

   ......

   // Setup global variable symbol table
   symbol_table_t glbl_variable_symbol_table;
   glbl_variable_symbtab.add_variable(&#39;temp_outside&#39;,thermo.outside);
   glbl_variable_symbtab.add_variable(&#39;temp_inside&#39; ,thermo.inside );
   glbl_variable_symbtab.add_variable(&#39;num_cstmrs&#39;,store.num_cstmrs);

   ......

   double x,y,z;

   // Setup expression specific symbol table
   symbol_table_t symbol_table;
   symbol_table.add_variable(&#39;x&#39;,x);
   symbol_table.add_variable(&#39;y&#39;,y);
   symbol_table.add_variable(&#39;z&#39;,z);

   expression_t expression;

   // Register the various symbol tables
   expression
      .register_symbol_table(symbol_table);

   expression
      .register_symbol_table(glbl_funcs_symbol_table);

   expression
      .register_symbol_table(glbl_const_symbol_table);

   expression
      .register_symbol_table(glbl_variable_symbol_table);

   const std::string expression_str =
      &quot;abs(temp_inside - temp_outside) + 2 * speed_of_light / x&quot;;

   parser_t parser;
   parser.compile(expression_str,expression);

   ......

   while (keep_evaluating)
   {
     ....

     T result = expression.value();

     ....
   }
</code></pre>
<p>[SECTION 18 - UNKNOWN UNKNOWNS] In this section we will discuss the
process of handling expressions with a mix of known and unknown
variables. Initially a discussion into the types of expressions that
exist will be provided, then a series of possible solutions will be
presented for each scenario.</p>
<p>When parsing an expression, there may be situations where one is not
fully aware of what if any variables will be used prior to the
expression being compiled.</p>
<p>This can become problematic, as in the default scenario it is assumed
the symbol_table that is registered with the expression instance will
already possess the externally available variables, functions and
constants needed during the compilation of the expression.</p>
<p>In the event there are symbols in the expression that can’t be mapped
to either a reserved word, or located in the associated symbol_table(s),
an “Undefined symbol” error will be raised and the compilation process
will fail.</p>
<p>The numerous scenarios that can occur when compiling an expression
with ExprTk generally fall into one of the following three
categories:</p>
<ol type="a">
<li><p>No external variables</p></li>
<li><p>Predetermined set of external variables</p></li>
<li><p>Unknown set of variables</p></li>
<li><p>No external variables These are expressions that contain no
external variables but may contain local variables. As local variables
cannot be accessed externally from the expression, it is assumed that
such expressions will not have a need for a symbol_table and furthermore
expressions which don’t make use of functions that have side-effects
will be evaluated completely at compile time resulting in a constant
return value. The following are examples of such expressions:</p></li>
</ol>
<ol type="1">
<li>1 + 2</li>
<li>var x := 3; 2 * x - 3</li>
<li>var x := 3; var y := abs(x - 8); x - y / 7</li>
</ol>
<ol start="2" type="a">
<li>Predetermined set of external variables These are expressions that
are comprised of externally available variables and functions and will
only compile successfully if the symbols that correspond to the
variables and functions are already defined in their associated
symbol_table(s). This is by far the most common scenario when using
ExprTk.</li>
</ol>
<p>As an example, one may have three external variables: x, y and z
which have been registered with the associated symbol_table, and will
then need to compile and evaluate expressions comprised of any subset of
these three variables. The following are a few examples of such
expressions:</p>
<ol type="1">
<li>1 + x</li>
<li>x / y</li>
<li>2 * x * y / z</li>
</ol>
<p>In this scenario one can use the ‘dependent_entity_collector’
component as described in [Section 16] to further determine which of the
registered variables were actually used in the given expression. As an
example once the set of utilised variables are known, any further
‘attention’ can be restricted to only those variables when evaluating
the expression. This can be quite useful when dealing with expressions
that can draw from a set of hundreds or even thousands of variables.</p>
<ol start="3" type="a">
<li>Unknown set of variables These are expressions that are comprised of
symbols other than the standard ExprTk reserved words or what has been
registered with their associated symbol_table, and will normally fail
compilation due to the associated symbol_table not having a reference to
them. As such this scenario can be seen as a combination of scenario B,
where one may have a symbol_table with registered variables, but would
also like to handle the situation of variables that aren’t present in
said symbol_table.</li>
</ol>
<p>When dealing with expressions of category (c), one must perform all
of the following:</p>
<ol type="1">
<li>Determine the variables used in the expression</li>
<li>Populate a symbol_table(s) with the entities from (1)</li>
<li>Compile the expression</li>
<li>Provide a means by which the entities from (1) can be modified</li>
</ol>
<p>Depending on the nature of processing, steps (1) and (2) can be done
either independently of each other or combined into one. The following
example will initially look at solving the problem of unknown variables
with the latter method using the ‘unknown_symbol_resolver’
component.</p>
<p>typedef exprtk::symbol_table<T> symbol_table_t; typedef
exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>T x = T(123.456); T y = T(789.123);</p>
<p>symbol_table_t unknown_var_symbol_table;</p>
<p>symbol_table_t symbol_table; symbol_table.add_variable(“x”,x);
symbol_table.add_variable(“y”,y);</p>
<p>expression_t expression;
expression.register_symbol_table(unknown_var_symbol_table);
expression.register_symbol_table(symbol_table);</p>
<p>parser_t parser; parser.enable_unknown_symbol_resolver();</p>
<p>const std::string expression_str = “x + abs(y / 3k) * z + 2”;</p>
<p>parser.compile(expression_str,expression);</p>
<p>In the example above, the symbols ‘k’ and ‘z’ will be treated as
unknown symbols. The parser in the example is set to handle unknown
symbols using the built-in default unknown_symbol_resolver (USR). The
default USR will automatically resolve any unknown symbols as a variable
(scalar type). The new variables will be added to the primary
symbol_table, which in this case is the ‘unknown_var_symbol_table’
instance. Once the compilation has completed successfully, the variables
that were resolved during compilation can be accessed from the primary
symbol_table using the ‘get_variable_list’ and ‘variable_ref’ methods
and then if needed can be modified accordingly after which the
expression itself can be evaluated.</p>
<p>std::vector<std::string> variable_list;</p>
<p>unknown_var_symbol_table.get_variable_list(variable_list);</p>
<p>for (const auto&amp; var_name : variable_list) { T&amp; v =
unknown_var_symbol_table.variable_ref(var_name);</p>
<pre><code>  v = ...;</code></pre>
<p>}</p>
<p>…</p>
<p>expression.value();</p>
<p>Note25: As previously mentioned the default USR will automatically
assume any unknown symbol to be a valid scalar variable, and will then
proceed to add said symbol as a variable to the primary symbol_table of
the associated expression during the compilation process. However a
problem that may arise, is that expressions that are parsed with the USR
enabled, but contain ‘typos’ or otherwise syntactic errors may
inadvertently compile successfully due to the simplistic nature of the
default USR. The following are some example expressions:</p>
<ol type="1">
<li>1 + abz(x + 1)</li>
<li>sine(y / 2) - coz(3x)</li>
</ol>
<p>The two expressions above contain misspelt symbols (abz, sine, coz)
which if implied multiplications and default USR are enabled during
compilation will result in them being assumed to be valid ‘variables’,
which obviously is not the intended outcome by the user. A possible
solution to this problem is for one to implement their own specific USR
that will perform a user defined business logic in determining if an
encountered unknown symbol should be treated as a variable or if it
should raise a compilation error. The following example demonstrates a
simple user defined USR:</p>
<p>typedef exprtk::symbol_table<T> symbol_table_t; typedef
exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>template <typename T> struct my_usr final : public
parser_t::unknown_symbol_resolver { typedef typename
parser_t::unknown_symbol_resolver usr_t;</p>
<pre><code>  bool process(const std::string&amp; unknown_symbol,
               typename usr_t::usr_symbol_type&amp; st,
               T&amp; default_value,
               std::string&amp; error_message) override
  {
     if (0 != unknown_symbol.find(&quot;var_&quot;))
     {
        error_message = &quot;Invalid symbol: &quot; + unknown_symbol;
        return false;
     }

     st = usr_t::e_usr_variable_type;
     default_value = T(123.123);

     return true;
  }</code></pre>
<p>};</p>
<p>…</p>
<p>T x = T(123.456); T y = T(789.123);</p>
<p>symbol_table_t unknown_var_symbol_table;</p>
<p>symbol_table_t symbol_table; symbol_table.add_variable(“x”,x);
symbol_table.add_variable(“y”,y);</p>
<p>expression_t expression;
expression.register_symbol_table(unknown_var_symbol_table);
expression.register_symbol_table(symbol_table);</p>
<p>my_usr<T> musr;</p>
<p>parser_t parser;
parser.enable_unknown_symbol_resolver(&amp;musr);</p>
<p>std::string expression_str = “var_x + abs(var_y - 3) * var_z”;</p>
<p>parser.compile(expression_str,expression);</p>
<p>In the example above, a user specified USR is defined, and is
registered with the parser enabling the USR functionality. Subsequently
during the compilation process when an unknown symbol is encountered,
the USR’s process method will be invoked. The USR in the example will
only ‘accept’ unknown symbols that have a prefix of ‘var_’ as being
valid variables, all other unknown symbols will result in a compilation
error being raised.</p>
<p>In the example above the callback of the USR that is invoked during
the unknown symbol resolution process only allows for scalar variables
to be defined and resolved - as that is the simplest and most common
form.</p>
<p>There is a further extended version of the callback that can be
overridden that will allow for more control and choice over the type of
symbol being resolved. The following is an example definition of said
extended callback:</p>
<p>template <typename T> struct my_usr final : public
parser_t::unknown_symbol_resolver { typedef typename
parser_t::unknown_symbol_resolver usr_t;</p>
<pre><code> my_usr()
 : usr_t(usr_t::e_usrmode_extended)
 {}

 bool process(const std::string&amp; unknown_symbol,
              symbol_table_t&amp;    symbol_table,
              std::string&amp;       error_message) override
 {
    bool result = false;

    if (0 == unknown_symbol.find(&quot;var_&quot;))
    {
       // Default value of zero
       result = symbol_table.create_variable(unknown_symbol,0);

       if (!result)
       {
          error_message = &quot;Failed to create variable...&quot;;
       }
    }
    else if (0 == unknown_symbol.find(&quot;str_&quot;))
    {
       // Default value of empty string
       result = symbol_table.create_stringvar(unknown_symbol,&quot;&quot;);

       if (!result)
       {
          error_message = &quot;Failed to create string variable...&quot;;
       }
    }
    else
       error_message = &quot;Indeterminable symbol type.&quot;;

    return result;
 }</code></pre>
<p>};</p>
<p>In the example above, the USR callback when invoked will pass the
primary symbol table associated with the expression being parsed. The
symbol resolution business logic can then determine under what
conditions a symbol will be resolved including its type (scalar, string,
vector etc) and default value. When the callback successfully returns
the symbol parsing and resolution process will again be executed by the
parser. The idea here is that given the primary symbol table will now
have the previously detected unknown symbol registered, it will be
correctly resolved and the general parsing processing can then resume as
per normal.</p>
<p>Note26: In order to have the USR’s extended mode callback be invoked
it is necessary to pass the e_usrmode_extended enum value during the
constructor of the user defined USR.</p>
<p>Note27: The primary symbol table for an expression is the first
symbol table to be registered with that instance of the expression.</p>
<p>Note28: For a successful symbol resolution using the normal USR all
of the following are required:</p>
<ol type="1">
<li>Only if successful shall the process method return TRUE</li>
<li>The default_value parameter will have been set</li>
<li>The error_message parameter will be empty</li>
<li>usr_symbol_type input parameter field will be set to either: (<em>)
e_usr_variable_type (</em>) e_usr_constant_type</li>
</ol>
<p>Note29: For a successful symbol resolution using the extended USR all
of the following are required:</p>
<ol type="1">
<li>Only if successful shall the process method return TRUE</li>
<li>symbol_table parameter will have had the newly resolved variable or
string added to it</li>
<li>error_message parameter will be empty</li>
</ol>
<pre><code>
[SECTION 19 - ENABLING &amp; DISABLING FEATURES]
The parser can be configured via its settings instance to either allow
or  disallow certain  features that  are available  within the  ExprTk
grammar. The features fall  into one  of the following six categories:

   (1) Base Functions
   (2) Control Flow Structures
   (3) Logical Operators
   (4) Arithmetic Operators
   (5) Inequality Operators
   (6) Assignment Operators


(1) Base Functions
The list of available base functions is as follows:

   abs, acos, acosh, asin,  asinh, atan, atanh, atan2,  avg, ceil,
   clamp,  cos,  cosh, cot,  csc,  equal, erf,  erfc,  exp, expm1,
   floor,  frac,  hypot,  iclamp, like,  log,  log10,  log2, logn,
   log1p, mand, max, min, mod,  mor, mul, ncdf, pow, root,  round,
   roundn, sec, sgn, sin, sinc, sinh, sqrt, sum, swap, tan,  tanh,
   trunc, not_equal, inrange, deg2grad, deg2rad, rad2deg, grad2deg


The above mentioned base functions  can be either enabled or  disabled
&#39;all&#39; at once, as is demonstrated below:

   parser_t parser;
   expression_t expression;

   parser.settings().disable_all_base_functions();

   parser
      .compile(&quot;2 * abs(2 - 3)&quot;,expression); // compilation failure

   parser.settings().enable_all_base_functions();

   parser
      .compile(&quot;2 * abs(2 - 3)&quot;,expression); // compilation success


One can also enable or disable specific base functions. The  following
example  demonstrates  the disabling  of  the trigonometric  functions
&#39;sin&#39; and &#39;cos&#39;:

   parser_t parser;
   expression_t expression;

   parser.settings()
      .disable_base_function(settings_t::e_bf_sin)
      .disable_base_function(settings_t::e_bf_cos);

   parser
      .compile(&quot;(sin(x) / cos(x)) == tan(x)&quot;,expression); // failure

   parser.settings()
      .enable_base_function(settings_t::e_bf_sin)
      .enable_base_function(settings_t::e_bf_cos);

   parser
      .compile(&quot;(sin(x) / cos(x)) == tan(x)&quot;,expression); // success


(2) Control Flow Structures
The list of available control flow structures is as follows:

   (a) If or If-Else
   (b) Switch statement
   (c) For Loop
   (d) While Loop
   (e) Repeat Loop


The  above  mentioned  control flow structures  can be  either enabled
or disabled &#39;all&#39; at once, as is demonstrated below:

   parser_t parser;
   expression_t expression;

   const std::string program =
      &quot; var x := 0;                      &quot;
      &quot; for (var i := 0; i &lt; 10; i += 1) &quot;
      &quot; {                                &quot;
      &quot;   x += i;                        &quot;
      &quot; }                                &quot;;

   parser.settings().disable_all_control_structures();

   parser
      .compile(program,expression); // compilation failure

   parser.settings().enable_all_control_structures();

   parser
      .compile(program,expression); // compilation success


One can also enable or  disable specific control flow structures.  The
following example demonstrates the  disabling of the for-loop  control
flow structure:

   parser_t parser;
   expression_t expression;

   const std::string program =
      &quot; var x := 0;                      &quot;
      &quot; for (var i := 0; i &lt; 10; i += 1) &quot;
      &quot; {                                &quot;
      &quot;   x += i;                        &quot;
      &quot; }                                &quot;;

   parser.settings()
      .disable_control_structure(settings_t::e_ctrl_for_loop);

   parser
      .compile(program,expression); // failure

   parser.settings()
      .enable_control_structure(settings_t::e_ctrl_for_loop);

   parser
      .compile(program,expression); // success


(3) Logical Operators
The list of available logical operators is as follows:

   and, nand, nor, not, or, xnor, xor, &amp;, |


The  above  mentioned  logical  operators  can  be  either  enabled or
disabled &#39;all&#39; at once, as is demonstrated below:

   parser_t parser;
   expression_t expression;

   parser.settings().disable_all_logic_ops();

   parser
      .compile(&quot;1 or not(0 and 1)&quot;,expression); // compilation failure

   parser.settings().enable_all_logic_ops();

   parser
      .compile(&quot;1 or not(0 and 1)&quot;,expression); // compilation success


One  can  also  enable  or  disable  specific  logical  operators. The
following  example  demonstrates  the disabling  of the  &#39;and&#39; logical
operator:

   parser_t parser;
   expression_t expression;

   parser.settings()
      .disable_logic_operation(settings_t::e_logic_and);

   parser
      .compile(&quot;1 or not(0 and 1)&quot;,expression); // failure

   parser.settings()
      .enable_logic_operation(settings_t::e_logic_and);

   parser
      .compile(&quot;1 or not(0 and 1)&quot;,expression); // success


(4) Arithmetic Operators
The list of available arithmetic operators is as follows:

   +, -, *, /, %, ^


The  above mentioned  arithmetic operators  can be  either enabled  or
disabled &#39;all&#39; at once, as is demonstrated below:

   parser_t parser;
   expression_t expression;

   parser.settings().disable_all_arithmetic_ops();

   parser
      .compile(&quot;1 + 2 / 3&quot;,expression); // compilation failure

   parser.settings().enable_all_arithmetic_ops();

   parser
      .compile(&quot;1 + 2 / 3&quot;,expression); // compilation success


One  can also  enable or  disable specific  arithmetic operators.  The
following  example  demonstrates  the disabling  of  the  addition &#39;+&#39;
arithmetic operator:

   parser_t parser;
   expression_t expression;

   parser.settings()
      .disable_arithmetic_operation(settings_t::e_arith_add);

   parser
      .compile(&quot;1 + 2 / 3&quot;,expression); // failure

   parser.settings()
      .enable_arithmetic_operation(settings_t::e_arith_add);

   parser
      .compile(&quot;1 + 2 / 3&quot;,expression); // success


(5) Inequality Operators
The list of available inequality operators is as follows:

   &lt;, &lt;=, &gt;, &gt;=, ==, =, != &lt;&gt;


The  above mentioned  inequality operators  can be  either enabled  or
disabled &#39;all&#39; at once, as is demonstrated below:

   parser_t parser;
   expression_t expression;

   parser.settings().disable_all_inequality_ops();

   parser
      .compile(&quot;1 &lt; 3&quot;,expression); // compilation failure

   parser.settings().enable_all_inequality_ops();

   parser
      .compile(&quot;1 &lt; 3&quot;,expression); // compilation success


One  can also  enable or  disable specific  inequality operators.  The
following  example demonstrates  the disabling  of  the  less-than &#39;&lt;&#39;
inequality operator:

   parser_t parser;
   expression_t expression;

   parser.settings()
      .disable_inequality_operation(settings_t::e_ineq_lt);

   parser
      .compile(&quot;1 &lt; 3&quot;,expression); // failure

   parser.settings()
      .enable_inequality_operation(settings_t::e_ineq_lt);

   parser
      .compile(&quot;1 &lt; 3&quot;,expression); // success


(6) Assignment Operators
The list of available assignment operators is as follows:

   :=, +=, -=, *=, /=, %=


The  above mentioned  assignment operators  can be  either enabled  or
disabled &#39;all&#39; at once, as is demonstrated below:

   T x = T(0);

   parser_t       parser;
   expression_t   expression;
   symbol_table_t symbol_table;

   symbol_table.add_variable(&quot;x&quot;,x);

   expression.register_symbol_table(symbol_table);

   parser.settings().disable_all_assignment_ops();

   parser
      .compile(&quot;x := 3&quot;,expression); // compilation failure

   parser.settings().enable_all_assignment_ops();

   parser
      .compile(&quot;x := 3&quot;,expression); // compilation success


One  can also  enable or  disable specific  assignment operators.  The
following  example demonstrates  the  disabling  of the  &#39;+=&#39; addition
assignment operator:

   T x = T(0);

   parser_t       parser;
   expression_t   expression;
   symbol_table_t symbol_table;

   symbol_table.add_variable(&quot;x&quot;,x);

   expression.register_symbol_table(symbol_table);

   parser.settings()
      .disable_assignment_operation(settings_t::e_assign_addass);

   parser
      .compile(&quot;x += 3&quot;,expression); // failure

   parser.settings()
      .enable_assignment_operation(settings_t::e_assign_addass);

   parser
      .compile(&quot;x += 3&quot;,expression); // success


Note30: In the  event of  a  base  function  being  disabled, one  can
redefine  the  base  function  using  the  standard  custom   function
definition process.  In the  following example  the &#39;sin&#39;  function is
disabled then redefined as a function taking degree input.

   template &lt;typename T&gt;
   struct sine_deg final : public exprtk::ifunction&lt;T&gt;
   {
      sine_deg() : exprtk::ifunction&lt;T&gt;(1) {}

      inline T operator()(const T&amp; v) override
      {
         const T pi = exprtk::details::numeric::constant::pi;
         return std::sin((v * T(pi)) / T(180));
      }
   };

    ...

   typedef exprtk::symbol_table&lt;T&gt; symbol_table_t;
   typedef exprtk::expression&lt;T&gt;   expression_t;
   typedef exprtk::parser&lt;T&gt;       parser_t;

   typedef typename parser_t::settings_store settings_t;

   sine_deg&lt;T&gt; sine;

   symbol_table.add_reserved_function(&quot;sin&quot;,sine);

   expression_t expression;

   expression.register_symbol_table(symbol_table);

   parser_t parser;

   parser.settings()
      .disable_base_function(settings_t::e_bf_sin);

   parser.compile(&quot;1 + sin(30)&quot;,expression);


In the example above, the custom &#39;sin&#39; function is registered with the
symbol_table using the method &#39;add_reserved_function&#39;. This is done so
as to bypass the checks for reserved words that are carried out on the
provided symbol names when calling the standard &#39;add_function&#39; method.
Normally if  a user  specified symbol  name conflicts  with any of the
ExprTk reserved words, the add_function call will fail.
</code></pre>
<p>[SECTION 20 - EXPRESSION RETURN VALUES] ExprTk expressions can return
immediately from any point by utilising the return call. Furthermore the
return call can be used to transfer out multiple return values from
within the expression.</p>
<p>If an expression evaluation exits using a return point, the result of
the call to the ‘value’ method will be NaN, and it is expected that the
return values will be available from the results_context.</p>
<p>In the following example there are three return points in the
expression. If neither of the return points are hit, then the expression
will return normally.</p>
<p>const std::string expression_string = ” if (x &lt; y) ” ” return [x +
1,‘return-call 1’]; ” ” else if (x &gt; y) ” ” return [y / 2, y + 1,
‘return-call 2’]; ” ” else if (equal(x,y)) ” ” x + y; ” ” return [x, y,
x + y, x - y, ‘return-call 3’] “;</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t; typedef exprtk::parser<double>
parser_t;</p>
<p>symbol_table_t symbol_table; expression_t expression; parser_t
parser;</p>
<p>double x = 0; double y = 0;</p>
<p>symbol_table.add_variable(“x”,x);
symbol_table.add_variable(“y”,y);</p>
<p>expression.register_symbol_table(symbol_table);</p>
<p>parser.compile(expression_string,expression);</p>
<p>T result = expression.value();</p>
<p>if (expression.return_invoked()) { typedef exprtk::results_context<T>
results_context_t; typedef typename results_context_t::type_store_t
type_t; typedef typename type_t::scalar_view scalar_t; typedef typename
type_t::vector_view vector_t; typedef typename type_t::string_view
string_t;</p>
<pre><code>  const results_context_t&amp; results = expression.results();

  for (std::size_t i = 0; i &lt; results.count(); ++i)
  {
     type_t t = results[i];

     switch (t.type)
     {
        case type_t::e_scalar : ...
                                break;

        case type_t::e_vector : ...
                                break;

        case type_t::e_string : ...
                                break;

        default               : continue;
     }</code></pre>
<p>}</p>
<p>In the above example, there are three possible “return” points and
one regular result. Only one of the four paths can ever be realised.
Hence it is necessary to capture the result of the expression value
method call. In the event, the call to return_invoked is not true then
the non-return code path was executed and the result of the evaluation
will be the result of the expression’s value method.</p>
<p>Note31: Processing of the return results is similar to that of the
generic function call parameters.</p>
<p>The results_context provides getter methods for each of the possible
return types (scalar, vector and string) and can be used as follows:</p>
<p>typedef exprtk::symbol_table<T> symbol_table_t; typedef
exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>const std::string expression_str = ” if (x &gt; y) ” ” return [1]; ”
” else ” ” return [ x, x + y, 2 * v, s + ‘world’ ]; “;</p>
<p>symbol_table_t symbol_table; expression_t expression; parser_t
parser;</p>
<p>symbol_table.add_variable (“x”, x); symbol_table.add_variable (“y”,
y); symbol_table.add_variable (“z”, z); symbol_table.add_vector (“v”,
v); symbol_table.add_stringvar(“s”, s);</p>
<p>parser.compile(expression_str, expression);</p>
<p>expression.value();</p>
<p>typedef exprtk::results_context<T> results_context_t; const
results_context_t&amp; results = expression.results();</p>
<p>if (results.count() == 4) { T result_x0; T result_x1; std::string
result_s; std::vector<T> result_v;</p>
<pre><code>  results.get_scalar(0, result_x0);
  results.get_scalar(1, result_x1);
  results.get_string(3, result_s );
  results.get_vector(2, result_v );</code></pre>
<p>}</p>
<p>It is however recommended that if there is to be only a single flow
of execution through the expression, that the simpler approach of
registering external variables of appropriate type be used.</p>
<p>This method simply requires the variables that are to hold the
various results that are to be computed within the expression to be
registered with an associated symbol_table instance. Then within the
expression itself to have the result variables be assigned the
appropriate values.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t; typedef exprtk::parser<double>
parser_t;</p>
<p>const std::string expression_string = ” var x := 123.456; ” ” var s
:= ‘ijk’; ” ” result0 := x + 78.90; ” ” result1 := s + ‘123’ “;</p>
<p>double result0; std::string result1;</p>
<p>symbol_table_t symbol_table; symbol_table.add_variable
(“result0”,result0); symbol_table.add_stringvar(“result1”,result1);</p>
<p>expression_t expression;
expression.register_symbol_table(symbol_table);</p>
<p>parser_t parser; parser.compile(expression_string,expression);</p>
<p>expression.value();</p>
<p>printf(“Result0: %15.5f”, result0 ); printf(“Result1: %s” ,
result1.c_str());</p>
<p>In the example above, the expression will compute two results. As
such two result variables are defined to hold the values named result0
and result1 respectively. The first is of scalar type (double), the
second is of string type. Once the expression has been evaluated, the
two variables will have been updated with the new result values, and can
then be further utilised from within the calling host program.</p>
<p>There will be times when an expression may have multiple exit paths,
where not all the paths will be return-statement based. The following
example builds upon the previous examples, but this time at least one
path is not return based.</p>
<p>typedef exprtk::symbol_table<double> symbol_table_t; typedef
exprtk::expression<double> expression_t; typedef exprtk::parser<double>
parser_t;</p>
<p>double x = 100.0; double y = 200.0;</p>
<p>symbol_table_t symbol_table; expression_t expression; parser_t
parser;</p>
<p>symbol_table.add_variable (“x”, x); symbol_table.add_variable (“y”,
y);</p>
<p>expression.register_symbol_table(symbol_table);</p>
<p>const std::string expression_string = ” for (var i := 0; i &lt; 10; i
+= 1) ” ” { ” ” if (i &gt; x) ” ” { ” ” return [x + y, ‘return-call 1’];
” ” } ” ” else if (i &gt; y) ” ” { ” ” return [x - y, ‘return-call 2’];
” ” } ” ” }; ” ” ” ” x / y “;</p>
<p>parser.compile(expression_str, expression);</p>
<p>const auto result = expression.value();</p>
<p>if (expression.return_invoked()) { const auto results =
expression.results();</p>
<pre><code>  for (std::size_t i = 0; i &lt;  results.count(); ++i)
  {
     const auto&amp; rtrn_result = results[i];
     .
     .
     .
  }</code></pre>
<p>} else { printf(“result: %f”,result); }</p>
<p>After having called the value method on the expression, calling the
return_invoked method will determine if the expression completed due to
a return statement being invoked or if it finished normally.</p>
<pre><code>
[SECTION 21 - COMPILATION ERRORS]
When attempting to compile  a malformed or otherwise  erroneous ExprTk
expression, the  compilation process  will result  in an  error, as is
indicated  by  the  &#39;compile&#39;  method  returning  a  false  value.   A
diagnostic indicating the first error encountered and its cause can be
obtained by  invoking the  &#39;error&#39; method,  as is  demonstrated in the
following example:

   if (!parser.compile(expression_string,expression))
   {
      printf(&quot;Error: %s\n&quot;, parser.error().c_str());
      return false;
   }


Any error(s) resulting from a failed compilation will be stored in the
parser instance until the next time a compilation is performed. Before
then errors can be enumerated  in the order they occurred  by invoking
the &#39;get_error&#39; method which itself will return a &#39;parser_error&#39; type.
A parser_error object will contain an error diagnostic, an error  mode
(or class), and the character position of the error in the  expression
string. The following example demonstrates the enumeration of error(s)
in the event of a failed compilation.

   typedef exprtk::parser&lt;T&gt;          parser_t;
   typedef exprtk::parser_error::type error_t;

   if (!parser.compile(expression_string,expression))
   {
      for (std::size_t i = 0; i &lt; parser.error_count(); ++i)
      {
         typedef exprtk::parser_error::type error_t;

         error_t error = parser.get_error(i);

         printf(&quot;Error[%02d] Position: %02d Type: [%14s] Msg: %s\n&quot;,
                i,
                error.token.position,
                exprtk::parser_error::to_str(error.mode).c_str(),
                error.diagnostic.c_str());
      }

      return false;
   }


Assuming the  following expression &#39;2 + (3 / log(1 + x))&#39; which uses a
variable named &#39;x&#39;  that has not been registered  with the appropriate
symbol_table  instance and  is not  a locally  defined variable,  once
compiled the  above denoted post compilation error handling code shall
produce the following output:

  Error[00] Pos:17 Type:[Syntax] Msg: ERR184 - Undefined symbol: &#39;x&#39;


For  expressions  comprised  of  multiple  lines,  the  error position
provided in the  parser_error object can  be converted into  a pair of
line and column numbers by invoking the &#39;update_error&#39; function as  is
demonstrated by the following example:

   if (!parser.compile(program_str,expression))
   {
      for (std::size_t i = 0; i &lt; parser.error_count(); ++i)
      {
         typedef exprtk::parser_error::type error_t;

         error_t error = parser.get_error(i);

         exprtk::parser_error::update_error(error,program_str);

         printf(&quot;Error[%0lu] at line: %lu column: %lu\n&quot;,
                i,
                error.line_no,
                error.column_no);
      }

      return false;
   }


Note32: There are five distinct error modes in ExprTk which denote the
class of an error. These classes are as follows:

   (a) Syntax
   (b) Token
   (c) Numeric
   (d) Symbol Table
   (e) Lexer


(a) Syntax Errors
These are errors  related to invalid  syntax found within  the denoted
expression. Examples are invalid sequences of operators and variables,
incorrect number  of parameters  to functions,  invalid conditional or
loop structures and invalid use of keywords.

   eg:  &#39;for := sin(x,y,z) + 2 * equal &gt; until[2 - x,3]&#39;


(b) Token Errors
Errors in this class relate to  token level errors detected by one  or
more of the following checkers:

   (1) Bracket Checker
   (2) Numeric Checker
   (3) Sequence Checker


(c) Numeric Errors
This class of  error is related  to conversion of  numeric values from
their  string form  to the  underlying numerical  type (float,  double
etc).

(d) Symbol Table Errors
This is the class of errors related to failures when interacting  with
the registered symbol_table instance. Errors such as not being able to
find,  within  the  symbol_table,  symbols  representing  variables or
functions, to being unable to create new variables in the symbol_table
via the &#39;unknown symbol resolver&#39; mechanism.

Note33: The function compositor  also supports  error message handling
similar to how it is  done via the parser. The  following demonstrates
how after a failed function  composition the associated errors can  be
enumerated.

   typedef exprtk::function_compositor&lt;T&gt;  compositor_t;
   typedef typename compositor_t::function function_t;

   compositor_t compositor;

   const bool compositor_result =
   compositor.add(
      function_t(&quot;foobar&quot;)
      .vars(&quot;x&quot;,&quot;y&quot;)
      .expression
      ( &quot; x + y / z &quot; ));

   if (!compositor_result)
   {
      printf(&quot;Error: %s\n&quot;, compositor.error().c_str());

      for (std::size_t i = 1; i &lt; compositor.error_count(); ++i)
      {
         typedef exprtk::parser_error::type error_t;

         error_t error = compositor.get_error(i);

         printf(&quot;Err No.: %02d  Pos: %02d  Type: [%14s] Msg: %s\n&quot;,
                static_cast&lt;unsigned int&gt;(i),
                static_cast&lt;unsigned int&gt;(error.token.position),
                exprtk::parser_error::to_str(error.mode).c_str(),
                error.diagnostic.c_str());
      }
   }

</code></pre>
<p>[SECTION 22 - RUNTIME LIBRARY PACKAGES] ExprTk includes a range of
extensions, that provide functionalities beyond simple numerical
calculations. Currently the available packages are:</p>
<p>+—+——————–+———————————–+ | # | Package Name | Namespace/Type |
+—+——————–+———————————–+ | 1 | Basic I/O | exprtk::rtl::io::package<T> |
| 2 | File I/O | exprtk::rtl::io::file::package<T> | | 3 | Vector
Operations | exprtk::rtl::vecops::package<T> |
+—+——————–+———————————–+</p>
<p>In order to make the features of a specific package available within
an expression, an instance of the package must be added to the
expression’s associated symbol table. In the following example, the file
I/O package is made available for the given expression:</p>
<p>typedef exprtk::symbol_table<T> symbol_table_t; typedef
exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>exprtk::rtl::io::file::package<T> fileio_package;</p>
<p>const std::string expression_string = ” var file_name := ‘file.txt’;
” ” var stream := null; ” ” ” ” stream := open(file_name,‘w’); ” ” ” ”
write(stream,‘Hello world….’); ” ” ” ” close(stream); ” ” “;</p>
<p>symbol_table_t symbol_table;
symbol_table.add_package(fileio_package);</p>
<p>expression_t expression;
expression.register_symbol_table(symbol_table);</p>
<p>parser_t parser; parser.compile(expression_string,expression);</p>
<p>expression.value();</p>
<ol type="1">
<li>Basic I/O functions:</li>
</ol>
<ol type="a">
<li>print</li>
<li>println</li>
</ol>
<ol start="2" type="1">
<li>File I/O functions:</li>
</ol>
<ol type="a">
<li>open (b) close</li>
<li>write (d) read</li>
<li>getline (f) eof</li>
</ol>
<ol start="3" type="1">
<li>Vector Operations functions:</li>
</ol>
<ol type="a">
<li>all_true (b) all_false</li>
<li>any_true (d) any_false</li>
<li>assign (f) count</li>
<li>copy (h) reverse</li>
<li>rotate-left (j) rotate-right</li>
<li>shift-left (l) shift-right</li>
<li>sort (n) nth_element</li>
<li>iota (p) sumk</li>
<li>axpy (r) axpby</li>
<li>axpyz (t) axpbyz</li>
<li>axpbz (v) dot</li>
<li>dotk (x) diff</li>
</ol>
<pre><code>
[SECTION 23 - HELPERS &amp; UTILS]
The  ExprTk library  provides a  series of  usage simplifications  via
helper routines that combine various processes into a single &#39;function
call&#39;  making  certain  actions   easier  to  carry  out   though  not
necessarily in the most efficient way possible. A list of the routines
are as follows:

   (a) collect_variables
   (b) collect_functions
   (c) compute
   (d) integrate
   (e) derivative
   (f) second_derivative
   (g) third_derivative


(a) collect_variables
This function will collect all the variable symbols in a given  string
representation of an expression and  return them in an STL  compatible
sequence  data structure  (eg: std::vector,  dequeue etc)  specialised
upon a std::string type. If an error occurs during the parsing of  the
expression  then  the return  value  of the  function  will be  false,
otherwise it will be  true. An example use  of the given routine is as
follows:

   const std::string expression = &quot;x + abs(y / z)&quot;;

   std::vector&lt;std::string&gt; variable_list;

   if (exprtk::collect_variables(expression, variable_list))
   {
      for (const auto&amp; var : variable_list)
      {
         ...
      }
   }
   else
     printf(&quot;An error occurred.&quot;);


(b) collect_functions
This function will collect all the function symbols in a given  string
representation of an expression and  return them in an STL  compatible
sequence  data structure  (eg: std::vector,  dequeue etc)  specialised
upon a std::string type. If an error occurs during the parsing of  the
expression  then  the return  value  of the  function  will be  false,
otherwise it  will be true. An example  use of the given routine is as
follows:

   const std::string expression = &quot;x + abs(y / cos(1 + z))&quot;;

   std::deque&lt;std::string&gt; function_list;

   if (exprtk::collect_functions(expression, function_list))
   {
      for (const auto&amp; func : function_list)
      {
         ...
      }
   }
   else
     printf(&quot;An error occurred.&quot;);


Note34: When  either the  &#39;collect_variables&#39;  or  &#39;collect_functions&#39;
free functions return  true - that  does not necessarily  indicate the
expression itself is  valid. It is  still possible that  when compiled
the expression may have certain  &#39;type&#39; related errors - though  it is
highly likely  that no  semantic errors  will occur  if either  return
true.

Note35: The default interface provided for both the  collect_variables
and collect_functions  free_functions, assumes  that expressions  will
only be  utilising the  ExprTk reserved  functions (eg:  abs, cos, min
etc). When user defined functions are  to be used in an expression,  a
symbol_table  instance  containing  said functions  can  be  passed to
either routine, and  will be incorporated  during the compilation  and
Dependent Entity  Collection processes.  In the  following example,  a
user  defined  free  function   named  &#39;foo&#39;  is  registered   with  a
symbol_table.  Finally  the   symbol_table  instance  and   associated
expression string are passed to the exprtk::collect_functions routine.

   template &lt;typename T&gt;
   T foo(T v)
   {
      return std::abs(v + T(2)) / T(3);
   }

   ......

   exprtk::symbol_table&lt;T&gt; sym_tab;

   symbol_table.add_function(&quot;foo&quot;,foo);

   const std::string expression = &quot;x + foo(y / cos(1 + z))&quot;;

   std::deque&lt;std::string&gt; function_list;

   if (exprtk::collect_functions(expression, sym_tab, function_list))
   {
      for (const auto&amp; func : function_list)
      {
         ...
      }
   }
   else
     printf(&quot;An error occurred.&quot;);


(c) compute
This free function  will compute the  value of an  expression from its
string form.  If an  invalid expression  is passed,  the result of the
function will be false indicating an error, otherwise the return value
will  be  true  indicating success.  The  compute  function has  three
overloads, the definitions of which are:

   (1) No variables
   (2) One variable called x
   (3) Two variables called x and y
   (3) Three variables called x, y and z


Example uses of  each of the  three overloads for  the compute routine
are as follows:

   T result = T(0);

   // No variables overload
   const std::string no_vars = &quot;abs(1 - (3 / pi)) * 5&quot;;

   if (!exprtk::compute(no_vars,result))
      printf(&quot;Failed to compute: %s&quot;,no_vars.c_str());
   else
      printf(&quot;Result: %15.5f\n&quot;,result);

   // One variable &#39;x&#39; overload
   T x = T(123.456);

   const std::string one_var = &quot;abs(x - (3 / pi)) * 5&quot;;

   if (!exprtk::compute(one_var, x, result))
      printf(&quot;Failed to compute: %s&quot;,one_var.c_str());
   else
      printf(&quot;Result: %15.5f\n&quot;,result);

   // Two variables &#39;x&#39; and &#39;y&#39; overload
   T y = T(789.012);

   const std::string two_var = &quot;abs(x - (y / pi)) * 5&quot;;

   if (!exprtk::compute(two_var, x, y, result))
      printf(&quot;Failed to compute: %s&quot;,two_var.c_str());
   else
      printf(&quot;Result: %15.5f\n&quot;,result);

   // Three variables &#39;x&#39;, &#39;y&#39; and &#39;z&#39; overload
   T z = T(345.678);

   const std::string three_var = &quot;abs(x - (y / pi)) * z&quot;;

   if (!exprtk::compute(three_var, x, y, z, result))
      printf(&quot;Failed to compute: %s&quot;,three_var.c_str());
   else
      printf(&quot;Result: %15.5f\n&quot;,result);


(d) integrate
This free function will attempt to perform a numerical integration  of
a single variable compiled expression over a specified range and  step
size. The numerical  integration is based  on the three  point form of
Simpson&#39;s rule. The  integrate function has  two overloads, where  the
variable of integration can  either be passed as  a reference or as  a
name in string form. Example usage of the function is as follows:

   typedef exprtk::symbol_table&lt;T&gt; symbol_table_t;
   typedef exprtk::expression&lt;T&gt;   expression_t;
   typedef exprtk::parser&lt;T&gt;       parser_t;

   const std::string expression_string = &quot;sqrt(1 - (x^2))&quot;;

   T x = T(0);

   symbol_table_t symbol_table;
   symbol_table.add_variable(&quot;x&quot;,x);

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   parser_t parser;
   parser.compile(expression_string,expression);

   ....

   // Integrate in domain [-1,1] using a reference to x variable
   T area1 = exprtk::integrate(expression, x, T(-1), T(1));

   // Integrate in domain [-1,1] using name of x variable
   T area2 = exprtk::integrate(expression, &quot;x&quot;, T(-1), T(1));


(e) derivative
This free function will attempt to perform a numerical differentiation
of a single variable compiled expression at a given point for a  given
epsilon, using a  variant of Newton&#39;s  difference quotient called  the
five-point stencil method. The derivative function has two  overloads,
where  the  variable of  differentiation  can either  be  passed as  a
reference or as a name in string form. Example usage of the derivative
function is as follows:

   typedef exprtk::symbol_table&lt;T&gt; symbol_table_t;
   typedef exprtk::expression&lt;T&gt;   expression_t;
   typedef exprtk::parser&lt;T&gt;       parser_t;

   const std::string expression_string = &quot;sqrt(1 - (x^2))&quot;;

   T x = T(0);

   symbol_table_t symbol_table;
   symbol_table.add_variable(&quot;x&quot;,x);

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   parser_t parser;
   parser.compile(expression_string,expression);

   ....

   // Differentiate expression at value of x = 12.3 using a reference
   // to the x variable
   x = T(12.3);
   T derivative1 = exprtk::derivative(expression, x);

   // Differentiate expression where value x = 45.6 using name
   // of the x variable
   x = T(45.6);
   T derivative2 = exprtk::derivative(expression, &quot;x&quot;);


(f) second_derivative
This  free  function  will  attempt  to  perform  a  numerical  second
derivative of a single variable  compiled expression at a given  point
for a given epsilon, using  a variant of Newton&#39;s difference  quotient
method. The second_derivative function  has  two overloads, where  the
variable of differentiation can either be passed as a reference or  as
a name in string form. Example usage of the second_derivative function
is as follows:

   typedef exprtk::symbol_table&lt;T&gt; symbol_table_t;
   typedef exprtk::expression&lt;T&gt;   expression_t;
   typedef exprtk::parser&lt;T&gt;       parser_t;

   const std::string expression_string = &quot;sqrt(1 - (x^2))&quot;;

   T x = T(0);

   symbol_table_t symbol_table;
   symbol_table.add_variable(&quot;x&quot;,x);

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   parser_t parser;
   parser.compile(expression_string,expression);

   ....

   // Second derivative of expression where value of x = 12.3 using a
   // reference to x variable
   x = T(12.3);
   T derivative1 = exprtk::second_derivative(expression,x);

   // Second derivative of expression where value of x = 45.6 using
   // name of x variable
   x = T(45.6);
   T derivative2 = exprtk::second_derivative(expression, &quot;x&quot;);


(g) third_derivative
This  free  function  will  attempt  to  perform  a  numerical   third
derivative of a single variable  compiled expression at a given  point
for a given epsilon, using  a variant of Newton&#39;s difference  quotient
method. The  third_derivative function  has two  overloads, where  the
variable of differentiation can either be passed as a reference or  as
a name in string form. Example  usage of the third_derivative function
is as follows:

   typedef exprtk::symbol_table&lt;T&gt; symbol_table_t;
   typedef exprtk::expression&lt;T&gt;   expression_t;
   typedef exprtk::parser&lt;T&gt;       parser_t;

   const std::string expression_string = &quot;sqrt(1 - (x^2))&quot;;

   T x = T(0);

   symbol_table_t symbol_table;
   symbol_table.add_variable(&quot;x&quot;,x);

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   parser_t parser;
   parser.compile(expression_string,expression);

   ....

   // Third derivative of expression where value of x = 12.3 using a
   // reference to the x variable
   x = T(12.3);
   T derivative1 = exprtk::third_derivative(expression, x);

   // Third derivative of expression where value of x = 45.6 using
   // name of the x variable
   x = T(45.6);
   T derivative2 = exprtk::third_derivative(expression, &quot;x&quot;);
</code></pre>
<p>[SECTION 24 - RUNTIME CHECKS] The ExprTk library provides the ability
to perform runtime checks during expression evaluation so as to ensure
memory access violation errors are caught and handled without causing
further issues. The checks typically cover:</p>
<ol type="1">
<li>Vector access and handling</li>
<li>String access and handling</li>
<li>Loop iteration checks</li>
<li>Compilation checkpointing</li>
<li>Assert statements</li>
</ol>
<ol type="1">
<li>Vector Access Runtime Checks Expressions that contain vectors where
elements of the vectors may be accessed using indexes that can only be
determined at runtime may result in memory access violations when the
index is out of the vector’s bound. Some examples of problematic
expressions are as follows:</li>
</ol>
<ol type="1">
<li>vec[i]</li>
<li>vec[i + j]</li>
<li>vec[i + 10]</li>
<li>vec[i + vec[]] := x + y</li>
<li>vec[i + j] &lt;=&gt; vec[i]</li>
<li>vec[i + j] := (vec1 + vec2)[i + j]</li>
</ol>
<p>In the above expressions, it is assumed that the values used in the
index operator may either exceed the vector bounds or precede the
vector’s start, In short, the indexes may not necessarily be within the
range [0,vec[]).</p>
<p>ExprTk provides the ability to inject a runtime check at the point of
index evaluation and handle situations where the index violates the
vector’s bounds. This capability is done by registering a user-
implemented Vector Access Runtime Check (VARTC) to the parser before
expression compilation. Initially a VARTC can be defined as follows:</p>
<p>struct my_vector_access_rtc final : public
exprtk::vector_access_runtime_check { bool
handle_runtime_violation(violation_context&amp; context) override { //
Handling of the violation return …; } };</p>
<p>Then an instance of the VARTC can be registered with a parser
instance as follows:</p>
<p>my_vector_access_rtc vartc;</p>
<p>exprtk::symbol_table<T> symbol_table;</p>
<p>T i; T x; T y; std::vector<T> vec = { 0, 1, 2, 3, 4 };</p>
<p>symbol_table.add_variable(“i” , i ); symbol_table.add_variable(“x” ,
x ); symbol_table.add_variable(“y” , y ); symbol_table.add_vector
(“vec”, vec);</p>
<p>exprtk::expression<T> expression; exprtk::parser<T> parser;</p>
<p>parser.register_vector_access_runtime_check(vartc);</p>
<p>std::string expression = “vec[i + vec[]] := x + y”;</p>
<p>parser.compile(expression_str, expression);</p>
<p>try { expression.value(); } catch (std::runtime_error&amp; rte) {
printf(“Exception: %s”, rte.what()); }</p>
<p>Note36: The lifetime of any parser or expression instance must not
exceed that of any VARTC instance that has been registered with it.</p>
<p>When a vector access violation occurs, the registered VARTC
instance’s handle_runtime_violation method will be invoked, coupled with
it a violation_context shall be provided that will contain the following
members:</p>
<ol type="1">
<li><p>base_ptr: Of type void*, which points to the first element of the
vector. The base_ptr can also be used as a key to determine the vector
upon which the access violation has occurred.</p></li>
<li><p>end_ptr : Of type void*, which points to one position after the
last element of the vector</p></li>
<li><p>access_ptr: Of type void*, points to the memory location which is
the base_ptr offset by the derived index value.</p></li>
<li><p>type_size: Size of the vector’s element type in bytes. This value
can be used to determine the number of elements in the vector based on
the base_ptr and end_ptr.</p></li>
</ol>
<p>The implementation of the handle_runtime_violation method can at this
point perform various actions such as:</p>
<ol type="1">
<li>Log the violation</li>
<li>Throw an exception (eg: std::runtime_error)</li>
<li>Remedy the access_ptr to allow for the evaluation to continue</li>
</ol>
<p>Note37: When employing option [3], handle_runtime_violation needs to
return true, otherwise the caller will assume an unhandled access
violation and default to using the base_ptr.</p>
<p>It is recommended, at the very least, to throw an exception when
handling vector access violations and to only consider option [3] when
the the ramifications of changing the access_ptr are well
understood.</p>
<p>The following are simple examples of how the handle_runtime_violation
can be implemented.</p>
<p>Example 1: Log the access violation to stdout and then throw a
runtime error exception:</p>
<p>bool handle_runtime_violation(violation_context&amp; context)
override { printf(“ERROR - Runtime vector access violation.” “base: %p
end: %p access: %p typesize: %lu”, context.base_ptr , context.end_ptr ,
context.access_ptr, context.type_size);</p>
<pre><code>  throw std::runtime_error(&quot;Runtime vector access violation.&quot;);
  return false;</code></pre>
<p>}</p>
<p>Example 2: Handle the access violation by resetting the access
pointer to the last value in the vector.</p>
<p>bool handle_runtime_violation(violation_context&amp; context)
override { context.access_ptr =
static_cast&lt;char*&gt;(context.end_ptr) - context.type_size; return
true; }</p>
<p>Note38: The return value of true in the above handler method signals
the caller to continue the vector access using the updated
access_ptr.</p>
<ol start="2" type="1">
<li>String Access Runtime Checks Expressions that contain strings where
elements or substrings of the strings may be accessed using indexes that
can only be determined at runtime may result in memory access violations
when the index or range is out of the string’s bound. Examples of
problematic expressions are as follows:</li>
</ol>
<ol type="1">
<li>s[i : j + k]</li>
<li>s[i : j + k][-x : y]</li>
<li>(s1 + s2)[i : j + k]</li>
<li>‘01234’[5 + i]</li>
<li>s += s[i : j + k]</li>
<li>s[i : j + k] := ‘chappy days’[1 : ]</li>
</ol>
<p>To enable string access runtime checks all one needs to do is simply
use the following define before the ExprTk header is included or as part
of the compilation define parameters:</p>
<p>exprtk_enable_range_runtime_checks</p>
<p>When the above define is used, and a string related runtime access
violation occurs a std::runtime_error exception will be thrown. The
following demonstrates the general flow of handling the access
violation:</p>
<p>parser.compile(expression_string, expression) . . try {
expression.value(); } catch (std::runtime_error&amp; rte) {
printf(“Exception: %s”, rte.what()); }</p>
<ol start="3" type="1">
<li>Loop Iteration Checks Expressions that contain loop structures (eg:
for/while/repeat et al) can be problematic from a usage point of view
due to the difficulty in determining the following:</li>
</ol>
<ol type="1">
<li>Will the loop ever complete (aka is this an infinite loop?)</li>
<li>Maximum loop execution time</li>
</ol>
<p>ExprTk provides the ability to inject a runtime check within loop
conditionals, and to have the result of the check either signal the loop
to continue or for the check to raise a loop violation error.</p>
<p>The process involves instantiating a user defined loop_runtime_check
(LRTC), registering the instance with a exprtk::parser instance and
specifying which loop types the check is to performed upon. The
following code demonstrates a how custom LRTC can be instantiated and
registered with the associated parser:</p>
<p>typedef exprtk::parser<T> parser_t; typedef
exprtk::loop_runtime_check loop_runtime_check_t;</p>
<p>my_loop_rtc loop_rtc; loop_runtime_check.loop_set =
loop_runtime_check_t::e_all_loops;
loop_runtime_check.max_loop_iterations = 100000;</p>
<p>parser_t parser;</p>
<p>parser.register_loop_runtime_check(loop_rtc);</p>
<p>The following is an example of how one could derive from and
implement a custom loop_runtime_check:</p>
<p>struct my_loop_rtc final : exprtk::loop_runtime_check {</p>
<pre><code>  bool check() override
  {
     //
     return ...
  }

  void handle_runtime_violation
     (const exprtk::violation_context&amp;) override
  {
     throw std::runtime_error(&quot;Loop runtime violation.&quot;);
  }</code></pre>
<p>};</p>
<p>In the above code, if either the check method returns false or the
loop iteration count exceeds the max_loop_iterations value, the
handle_runtime_violation method will be invoked, coupled with it a
violation_context shall be provided that will contain the following
members:</p>
<ol type="1">
<li><p>loop: Of type loop_types. This value denotes the type of loop
that triggered the violation (e_for_loop, e_while_loop,
e_repeat_until_loop).</p></li>
<li><p>violation: Of type type. This value denotes the type of violation
(e_iteration_count, e_timeout)</p></li>
<li><p>iteration_count: Of type uint64_t. The number of iterations that
the triggering loop has executed since the start of the
expression.</p></li>
</ol>
<p>Note39: The lifetime of any parser or expression instance must not
exceed that of any LRTC instance that has been registered with it.</p>
<p>The following is an example implementation of an LRTC that supports
loop timeout violations:</p>
<p>struct timeout_loop_rtc final : exprtk::loop_runtime_check { using
time_point_t = std::chrono::time_point<std::chrono::steady_clock>;</p>
<pre><code>  std::size_t iterations_ = 0;
  time_point_t timeout_tp_;

  bool check() override
  {
     if (std::chrono::steady_clock::now() &gt;= timeout_tp_)
     {
        // handle_runtime_violation shall be invoked
        return false;
     }

     return true;
  }

  void handle_runtime_violation
     (const exprtk::violation_context&amp;) override
  {
     throw std::runtime_error(&quot;Loop timed out&quot;);
  }

  void set_timeout_time(const time_point_t&amp; timeout_tp)
  {
     timeout_tp_ = timeout_tp;
  }</code></pre>
<p>};</p>
<p>In the above code, the check method shall be invoked on each
iteration of the associated loop. Within the method the current time is
compared to the setup timeout time-point, in the event the current time
exceeds the timeout, the method returns false, triggering the violation,
which in turn will result in the handle_runtime_violation being
invoked.</p>
<p>The following code demonstrates how the above defined LRTC can be
used to ensure that at the very least the loop portion(s) of an
expression will never exceed a given amount of execution time.</p>
<p>typedef exprtk::parser<T> parser_t; typedef
exprtk::loop_runtime_check loop_runtime_check_t;</p>
<p>my_loop_rtc loop_rtc; loop_rtc.loop_set =
loop_runtime_check_t::e_all_loops; loop_rtc.max_loop_iterations =
100000;</p>
<p>parser_t parser;</p>
<p>parser.register_loop_runtime_check(loop_rtc); . . . . using
std::chrono; const auto max_duration = seconds(25);</p>
<p>try { loop_rtc.set_timeout_time(steady_clock::now() + max_duration);
expression.value();</p>
<pre><code>  loop_rtc.set_timeout_time(steady_clock::now() + max_duration);
  expression.value();

  loop_rtc.set_timeout_time(steady_clock::now() + max_duration);
  expression.value();</code></pre>
<p>} catch(std::runtime_error&amp; exception) { printf(“Exception:
%s”,exception.what()); }</p>
<ol start="4" type="1">
<li>Compilation Process Checkpointing When compiling an expression, one
may require the compilation process to periodically checkpoint its
internal state, subsequently at the checkpoint one can then make the
decision to continue the compilation process or to immediately terminate
and return.</li>
</ol>
<p>The following are reasons one may want to checkpoint the compilation
process:</p>
<ol type="1">
<li>Determine if the compilation process has run for far too long</li>
<li>Determine if the current stack frame size exceeds a limit</li>
<li>Enforce an external termination request</li>
</ol>
<p>ExprTk provides the ability to inject a checkpoint into the
compilation process that will be evaluated periodically. This capability
is achieved by registering a user-implemented compilation check (CCK) to
the parser before expression compilation. Initially a CCK can be defined
as follows:</p>
<p>struct compilation_timeout_check final : public
exprtk::compilation_check { bool
continue_compilation(compilation_context&amp; context) override { //
Determine if compilation should continue return …; } };</p>
<p>An example checkpoint use-case could be that we do not want the
compilation process to take longer than a maximum defined period, eg:
five seconds. The associated compilation check implementation could be
as follows:</p>
<p>struct my_compilation_timeout_check final : public
exprtk::compilation_check {</p>
<pre><code>  bool continue_compilation(compilation_context&amp; context)
  override
  {
     static constexpr std::size_t max_iters_per_check = 1000;

     if (++iterations_ &gt;= max_iters_per_check)
     {
        if (std::chrono::steady_clock::now() &gt;= timeout_tp_)
        {
           context.error_message = &quot;Compilation has timed-out&quot;;
           return false;
        }

        iterations_ = 0;
     }

     return true;
  }

  using time_point_t = std::chrono::time_point&lt;std::chrono::steady_clock&gt;;

  void set_timeout_time(const time_point_t&amp; timeout_tp)
  {
     timeout_tp_ = timeout_tp;
  }

  std::size_t iterations_ = 0;
  time_point_t timeout_tp_;</code></pre>
<p>};</p>
<p>Usage of the above defined compilation check will require registering
the check with the parser, setting up the expiry time and then
proceeding to compile the expression. The following is a general outline
of what will be needed:</p>
<p>typedef exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>expression_t expression;</p>
<p>my_compilation_timeout_check compilation_timeout_check;</p>
<p>parser_t parser; parser.
register_compilation_timeout_check(compilation_timeout_check);</p>
<p>const auto max_duration = std::chrono::seconds(5); const auto
timeout_tp = std::chrono::steady_clock::now() + max_duration;</p>
<p>compilation_timeout_check.set_timeout_time(timeout_tp);</p>
<p>if (!parser.compile(large_expression_string, expression)) {
printf(“Error: %s”, parser.error().c_str()); return; }</p>
<ol start="5" type="1">
<li>Assert statements ExprTk supports the use of assert statements to
verify pre and post conditions during the evaluation of expressions. The
assert statements are only active when a user defined assert handler is
registered with the parser before expression compilation, otherwise they
are compiled out, this is similar to how asserts are included/excluded
in C++ coupled with the definition of NDEBUG. The assert syntax has
three variations as described below:</li>
</ol>
<p>assert(x + y &gt; i); assert(x + y &gt; i, ‘assert statement 1’);
assert(x + y &gt; i, ‘assert statement 1’, ‘ASSERT01’);</p>
<p>The three assert statement input parameters are as follows:</p>
<ol type="1">
<li>assert condition (mandatory)</li>
<li>assert message (optional)</li>
<li>assert id (optional)</li>
</ol>
<p>The assert condition is essentially a boolean statement that is
expected to be true during evaluation. The other two parameters of
assert message and ID are string values that are intended to provide
feedback to the handler and to ensure the uniqueness of assert statement
respectively. The three parameters denoted above and the offset of the
assert statement from the beginning of the expression are placed inside
assert_context that is provided as part of the assert_check handler. A
user defined assert_check handler can be defined as follows:</p>
<p>struct my_assert_handler final : public exprtk::assert_check { void
handle_assert(const assert_context&amp; ctxt) override {
printf(“condition: [%s] ”, ctxt.condition.c_str()); printf(“message:
[%s] ”, ctxt.message .c_str()); printf(“id: [%s] ”, ctxt.id .c_str());
printf(“offset: [%lu]”, ctxt.offet ); // throw std::runtime_error(…..);
} };</p>
<p>Once the assert_check handler has been registered with the parser,
expressions that contain assert statements will have their asserts
compiled in as part final evaluable expression instance:</p>
<p>typedef exprtk::symbol_table<T> symbol_table_t; typedef
exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>const std::string program = ” var x := 4; ” ” ” ” for (var i := 0; i
&lt; 10; i += 1) ” ” { ” ” assert(i &lt; x, ‘assert statement 1’); ” ” }
“;</p>
<p>my_assert_handler handler;</p>
<p>expression_t expression; parser_t parser;</p>
<p>parser.register_assert_check(handler); parser.compile(program,
expression);</p>
<ol start="6" type="1">
<li>Runtime Check Overheads All of the above mentioned runtime checks
will incur an execution time overhead during the evaluation of
expressions. This is an unfortunate but necessary side-effect of the
process when runtime safety is of concern.</li>
</ol>
<p>A recommendation to consider, that is not demonstrated above, is that
in the check method of the LRTC, one should not evaluate the timeout
condition on every call to check (aka on every loop iteration). Instead
a counter should be maintained and incremented on each call and when the
counter exceeds some predefined amount (eg: 10000 iterations), then the
timeout based check can be preformed. The reasoning here is that
incrementing an integer should be far less expensive than computing the
current “now” time-point.</p>
<ol start="7" type="1">
<li><p>Runtime Check Limitations The available RTC mechanisms in ExprTk
are limited to implementing said checks only within ExprTk based syntax
sections of an expression. The RTCs will not be active within user
defined functions, or composited functions that have been compiled with
parser instances that don’t have the same set of RTC configurations
enabled.</p></li>
<li><p>Runtime Handlers When implementing stateful run-time check
handlers one must be careful to ensure the handler is setup correctly or
reset between calls to the expression::value or parser::compile
methods.</p></li>
</ol>
<p>The following example code utilises the compilation timeout RTC and
expression loop duration RTC examples from above to demonstrate the need
to reset the internal state of the various handlers before compilation
and valuation processes are invoked, as not doing so will affect the
ability for the next expression in the list to either be correctly
compiled or evaluated due to the potential of erroneous timeouts
occurring.</p>
<p>typedef exprtk::expression<T> expression_t; typedef exprtk::parser<T>
parser_t;</p>
<p>my_compilation_timeout_check compilation_timeout_check;</p>
<p>my_loop_rtc loop_rtc; loop_rtc.loop_set =
loop_runtime_check_t::e_all_loops; loop_rtc.max_loop_iterations =
100000;</p>
<p>parser_t parser; parser.register_loop_runtime_check(loop_rtc);
parser.
register_compilation_timeout_check(compilation_timeout_check);</p>
<p>const auto compile_timeout_tp = <a href=""></a> { const auto
max_duration = std::chrono::seconds(5); return
std::chrono::steady_clock::now() + max_duration; };</p>
<p>const auto loop_timeout_tp = <a href=""></a> { const auto
max_duration = std::chrono::seconds(10); return
std::chrono::steady_clock::now() + max_duration; };</p>
<p>const std::vector<std::string> expressions = { “x + y / 2”, “sin(x) /
cos(y) + 1”, “clamp(-1, sin(2 * pi * x) + cos(y / 2 * pi), +1)” };</p>
<p>for (const auto&amp; expr_str : expressions) { // Reset the timeout
for the compilation RTC compilation_timeout_check
.set_timeout_time(compile_timeout_tp());</p>
<pre><code>  expression_t expression;

  if (!parser.compile(large_expression_string, expression))
  {
     printf(&quot;Error: %s\t\n&quot;, parser.error().c_str());
     continue;
  }

  try
  {
     // Reset the timeout for the loop duration RTC
     loop_rtc.set_timeout_time(loop_timeout_tp());

     expression.value();
  }
  catch(std::runtime_error&amp; exception)
  {
     printf(&quot;Exception: %s\n Expression: %s\n&quot;,
            exception.what(),
            expr_str.c_str());
  }</code></pre>
<p>}</p>
<pre><code>
[SECTION 25 - BENCHMARKING]
As part of the ExprTk package there is an expression benchmark utility
named &#39;exprtk_benchmark&#39;. The utility attempts to determine expression
evaluation  speed (or  rate of  evaluations -  evals  per  second), by
evaluating each expression numerous times and mutating the  underlying
variables  of  the  expression between  each  evaluation.  The utility
assumes any  valid ExprTk  expression (containing  conditionals, loops
etc), however  it will  only make  use of  a predefined  set of scalar
variables, namely: a, b, c, x, y, z and w. That being said expressions
themselves  can  contain any  number  of local  variables,  vectors or
strings. There are two modes of operation:

   (1) Default
   (2) User Specified Expressions


(1) Default
The default mode is  enabled simply by executing  the exprtk_benchmark
binary with no command line parameters. In this mode a predefined  set
of expressions will be evaluated in three phases:

   (a) ExprTk evaluation
   (b) Native evaluation
   (c) ExprTk parse


In the first two  phases (a and b)  a list of predefined  (hard-coded)
expressions  will  be  evaluated using  both  ExprTk  and native  mode
implementations.  This  is  done so  as  to  compare evaluation  times
between ExprTk and native implementations. The set of expressions used
are as follows:

   (01) (y + x)
   (02) 2 * (y + x)
   (03) (2 * y + 2 * x)
   (04) ((1.23 * x^2) / y) - 123.123
   (05) (y + x / y) * (x - y / x)
   (06) x / ((x + y) + (x - y)) / y
   (07) 1 - ((x * y) + (y / x)) - 3
   (08) (5.5 + x) + (2 * x - 2 / 3 * y) * (x / 3 + y / 4) + (y + 7.7)
   (09) 1.1x^1 + 2.2y^2 - 3.3x^3 + 4.4y^15 - 5.5x^23 + 6.6y^55
   (10) sin(2 * x) + cos(pi / y)
   (11) 1 - sin(2 * x) + cos(pi / y)
   (12) sqrt(111.111 - sin(2 * x) + cos(pi / y) / 333.333)
   (13) (x^2 / sin(2 * pi / y)) - x / 2
   (14) x + (cos(y - sin(2 / x * pi)) - sin(x - cos(2 * y / pi))) - y
   (15) clamp(-1.0, sin(2 * pi * x) + cos(y / 2 * pi), +1.0)
   (16) max(3.33, min(sqrt(1 - sin(2 * x) + cos(pi / y) / 3), 1.11))
   (17) if((y + (x * 2.2)) &lt;= (x + y + 1.1), x - y, x*y) + 2 * pi / x


The  third  and  final  phase  (c),  is  used  to  determine   average
compilation rates  (compiles per  second) for  expressions of  varying
complexity. Each expression is compiled 100K times and the average for
each expression is output.


(2) User Specified Expressions
In this mode two parameters are passed to the utility via the  command
line:

   (a) A name of a text file containing one expression per line
   (b) An integer representing the number of evaluations per expression


An  example execution  of the  benchmark utility  in this  mode is  as
follows:

   ./exprtk_benchmark my_expressions.txt 1000000


The  above  invocation  will  load  the  expressions  from  the   file
&#39;my_expressions.txt&#39; and will then proceed to evaluate each expression
one million  times, varying  the above  mentioned variables  (x, y,  z
etc.) between each evaluation, and at the end of each expression round
a print out of  running times, result of a single evaluation and total
sum of results is provided as demonstrated below:

   Expression 1 of 7 4.770 ns 47700 ns  ( 9370368.0) &#39;((((x+y)+z)))&#39;
   Expression 2 of 7 4.750 ns 47500 ns  ( 1123455.9) &#39;((((x+y)-z)))&#39;
   Expression 3 of 7 4.766 ns 47659 ns  (21635410.7) &#39;((((x+y)*z)))&#39;
   Expression 4 of 7 5.662 ns 56619 ns  ( 1272454.9) &#39;((((x+y)/z)))&#39;
   Expression 5 of 7 4.950 ns 49500 ns  ( 4123455.9) &#39;((((x-y)+z)))&#39;
   Expression 6 of 7 7.581 ns 75810 ns  (-4123455.9) &#39;((((x-y)-z)))&#39;
   Expression 7 of 7 4.801 ns 48010 ns  (       0.0) &#39;((((x-y)*z)))&#39;


The benchmark utility can be very useful when investigating evaluation
efficiency  issues with  ExprTk or  simply during  the prototyping  of
expressions. As an example, lets take the following expression:

   1 / sqrt(2x) * e^(3y)


Lets say we would like to determine which sub-part  of the  expression
takes the  most time  to evaluate  and perhaps  attempt to  rework the
expression based on the results. In order to do this we will create  a
text file  called &#39;test.txt&#39;  and then  proceed to  make some educated
guesses  about  how  to  break   the  expression  up  into  its   more
&#39;interesting&#39; sub-parts which we will  then add as one expression  per
line to the file. An example breakdown may be as follows:

   1 / sqrt(2x) * e^(3y)
   1 / sqrt(2x)
   e^(3y)


The  benchmark with  the given  file, where  each expression  will be
evaluated 100K times can be executed as follows:

   ./exprtk_benchmark test.txt 100000
   Expr 1 of 3 90.340 ns 9034000 ns (296417859.3) &#39;1/sqrt(2x)*e^(3y)&#39;
   Expr 2 of 3 11.100 ns 1109999 ns (    44267.3) &#39;1/sqrt(2x)&#39;
   Expr 3 of 3 77.830 ns 7783000 ns (615985286.6) &#39;e^(3y)&#39;
   [*] Number Of Evals:         300000
   [*] Total Time:              0.018sec
   [*] Total Single Eval Time:  0.000ms


From the results above we conclude that the third expression  (e^(3y))
consumes the largest amount of time. The variable &#39;e&#39;, as used in both
the  benchmark  and  in the  expression,  is  an approximation  of the
transcendental mathematical constant e (2.71828182845904...) hence the
sub-expression  should perhaps be  modified  to use the generally more
efficient built-in &#39;exp&#39; function.

   ./exprtk_benchmark test.txt 1000000
   Expr 1 of 5 86.563 ns 8656300ns (296417859.6) &#39;1/sqrt(2x)*e^(3y)&#39;
   Expr 2 of 5 40.506 ns 4050600ns (296417859.6) &#39;1/sqrt(2x)*exp(3y)&#39;
   Expr 3 of 5 14.248 ns 1424799ns (    44267.2) &#39;1/sqrt(2x)&#39;
   Expr 4 of 5 88.840 ns 8884000ns (615985286.9) &#39;e^(3y)&#39;
   Expr 5 of 5 29.267 ns 2926699ns (615985286.9) &#39;exp(3y)&#39;
   [*] Number Of Evals:        5000000
   [*] Total Time:             0.260sec
   [*] Total Single Eval Time: 0.000ms


The above output demonstrates the  results from  making the previously
mentioned modification to the expression. As can be seen the new  form
of the expression using the &#39;exp&#39; function reduces the evaluation time
by over 50%, in other words increases the evaluation rate by two fold.
</code></pre>
<p>[SECTION 26 - EXPRTK NOTES] The following is a list of facts and
suggestions one may want to take into account when using ExprTk:</p>
<ol start="0" type="1">
<li><p>Precision and performance of expression evaluations are the
dominant principles of the ExprTk library.</p></li>
<li><p>ExprTk uses a rudimentary imperative programming model with
syntax based on languages such as Pascal and C. Furthermore ExprTk is an
LL(2) type grammar and is processed using a recursive descent parsing
algorithm.</p></li>
<li><p>Supported types are float, double, long double and MPFR/GMP.
Generally any user defined numerical type that supports all the basic
floating point arithmetic operations: -,+,*,/,^,% etc; unary and binary
operations: sin,cos,min,max,equal etc and any other ExprTk dependent
operations can be used to specialise the various components: expression,
parser and symbol_table.</p></li>
<li><p>Standard arithmetic operator precedence is applied (BEDMAS). In
general C, Pascal or Rust equivalent unary, binary, logical and
equality/inequality operator precedence rules apply. eg: a == b and c
&gt; d + 1 —&gt; (a == b) and (c &gt; (d + 1)) x - y &lt;= z / 2 —&gt;
(x - y) &lt;= (z / 2) a - b / c * d<sup>2</sup>3 —&gt; a - ((b / c) *
d<sup>(2</sup>3))</p></li>
<li><p>Results of expressions that are deemed as being ‘valid’ are to
exist within the set of Real numbers. All other results will be of the
value: Not-A-Number (NaN). However this may not necessarily be a
requirement for user defined numerical types, eg: complex number
type.</p></li>
<li><p>Supported user defined types are numeric and string variables,
numeric vectors and functions.</p></li>
<li><p>All reserved words, keywords, variable, vector, string and
function names are case-insensitive.</p></li>
<li><p>Variable, vector, string variable and function names must begin
with a letter (A-Z or a-z), then can be comprised of any combination of
letters, digits, underscores and non-consecutive dots, ending in either
a letter (A-Z or a-z), digit or underscore. (eg: x, y2, var1,
power_func99, person.age, item.size.0). The associated regex pattern is:
[a-zA-Z][a-zA-Z0-9_]<em>(.[a-zA-Z0-9_]+)</em></p></li>
<li><p>Expression lengths and sub-expression lists are limited only by
storage capacity.</p></li>
<li><p>The life-time of objects registered with or created from a
specific symbol-table must span at least the lifetime of the symbol
table instance and all compiled expressions which utilise objects, such
as variables, strings, vectors, function compositor functions and
functions of that symbol-table, otherwise the result will be undefined
behaviour.</p></li>
<li><p>Equal and not_equal are normalised-epsilon equality routines,
which use epsilons of 0.0000000001 and 0.000001 for double and float
types respectively.</p></li>
<li><p>All trigonometric functions assume radian input unless stated
otherwise.</p></li>
<li><p>Expressions may contain white-space characters such as space,
tabs, new-lines, control-feed et al. (‘’, ‘,’, ‘,’, ’)</p></li>
<li><p>Strings may be comprised of any combination of letters, digits
special characters including (~!@#$%^&amp;*()[]|=+ ,./?&lt;&gt;;:“`~_)
or hexadecimal escaped sequences (eg: \0x30) and must be enclosed with
single-quotes. eg: ‘Frankly my dear, \0x49 do n0t give a damn!’</p></li>
<li><p>User defined normal functions can have up to 20 parameters, where
as user defined generic-functions and vararg-functions can have an
unlimited number of parameters.</p></li>
<li><p>The inbuilt polynomial functions can be at most of degree
12.</p></li>
<li><p>Where appropriate constant folding optimisations may be applied.
(eg: The expression ‘2 + (3 - (x / y))’ becomes ‘5 - (x / y)’)</p></li>
<li><p>If the strength reduction compilation option has been enabled,
then where applicable strength reduction optimisations may be
applied.</p></li>
<li><p>String processing capabilities are available by default. To turn
them off, the following needs to be defined at compile time:
exprtk_disable_string_capabilities</p></li>
<li><p>Composited functions can call themselves or any other functions
that have been defined prior to their own definition.</p></li>
<li><p>Recursive calls made from within composited functions will have a
stack size bound by the stack of the executing architecture.</p></li>
<li><p>User defined functions by default are assumed to have side
effects. As such an “all constant parameter” invocation of such
functions wont result in constant folding. If the function has no
side-effects then that can be noted during the constructor of the
ifunction allowing it to be constant folded where appropriate.</p></li>
<li><p>The entity relationship between symbol_table and an expression is
many-to-many. However the intended ‘typical’ use-case where possible, is
to have a single symbol table manage the variable and function
requirements of multiple expressions.</p></li>
<li><p>The common use-case for an expression is to have it compiled only
ONCE and then subsequently have it evaluated multiple times. An
extremely inefficient and suboptimal approach would be to recompile an
expression from its string form every time it requires
evaluating.</p></li>
<li><p>It is strongly recommended that the return value of method
invocations from the parser and symbol_table types be taken into
account. Specifically the ‘compile’ method of the parser and the
‘add_xxx’ set of methods of the symbol_table as they denote either the
success or failure state of the invoked call. Continued processing from
a failed state without having first rectified the underlying issue will
in turn result in further failures and undefined behaviours.</p></li>
<li><p>The following are examples of compliant floating point value
representations:</p>
<ol type="1">
<li>12345 (06) -123.456</li>
<li>+123.456e+12 (07) 123.456E-12</li>
<li>+012.045e+07 (08) .1234</li>
<li><ol start="1234" type="1">
<li><pre><code>    (09) -56789.</code></pre></li>
</ol></li>
<li>123.456f (10) -321.654E+3L</li>
</ol></li>
<li><p>Expressions may contain any of the following comment styles:</p>
<ol type="1">
<li>// …. </li>
<li><h1 id="section">…. </h1></li>
<li>/* …. */</li>
</ol></li>
<li><p>The ‘null’ value type is a special non-zero type that
incorporates specific semantics when undergoing operations with the
standard numeric type. The following is a list of type and boolean
results associated with the use of ‘null’:</p>
<ol type="1">
<li>null +,-,*,/,% x –&gt; x</li>
<li>x +,-,*,/,% null –&gt; x</li>
<li>null +,-,*,/,% null –&gt; null</li>
<li>null == null –&gt; true</li>
<li>null == x –&gt; true</li>
<li>x == null –&gt; true</li>
<li>x != null –&gt; false</li>
<li>null != null –&gt; false</li>
<li>null != x –&gt; false</li>
</ol></li>
<li><p>The following is a list of reserved words and symbols used by
ExprTk. Attempting to add a variable or custom function to a symbol
table using any of the reserved words will result in a failure.</p>
<p>abs, acos, acosh, and, asin, asinh, assert, atan, atan2, atanh, avg,
break, case, ceil, clamp, continue, cosh, cos, cot, csc, default,
deg2grad, deg2rad, else, equal, erfc, erf, exp, expm1, false, floor,
for, frac, grad2deg, hypot, iclamp, if, ilike, in, inrange, in, like,
log, log10, log1p, log2, logn, mand, max, min, mod, mor, mul, nand,
ncdf, nor, not, not_equal, not, null, or, pow, rad2deg, repeat, return,
root, roundn, round, sec, sgn, shl, shr, sinc, sinh, sin, sqrt, sum,
swap, switch, tanh, tan, true, trunc, until, var, while, xnor,
xor</p></li>
<li><p>Every valid ExprTk statement is a “value returning” expression.
Unlike some languages that limit the types of expressions that can be
performed in certain situations, in ExprTk any valid expression can be
used in any “value consuming” context. eg:</p>
<p>var y := 3; for (var x := switch { case 1 : 7; case 2 : -1 + ~{var
x{};}; default : y &gt; 2 ? 3 : 4; }; x != while (y &gt; 0) { y -= 1; };
x -= { if (min(x,y) &lt; 2 * max(x,y)) x + 2; else x + y - 3; } ) { (x +
y) / (x - y); };</p></li>
<li><p>It is recommended when prototyping expressions that the ExprTk
REPL be utilised, as it supports all the features available in the
library, including complete error analysis, benchmarking and dependency
dumps etc which allows for rapid coding/prototyping and debug cycles
without the hassle of having to recompile test programs with expressions
that have been hard-coded. It is also a good source of truth for how the
library’s various features can be applied.</p></li>
<li><p>For performance considerations, one should assume the actions of
expression, symbol table and parser instance instantiation and
destruction, and the expression compilation process itself to be of high
latency. Hence none of them should be part of any performance critical
code paths, and should instead occur entirely either before or after
such code paths.</p></li>
<li><p>Deep copying an expression instance for the purposes of
persisting to disk or otherwise transmitting elsewhere with the intent
to ‘resurrect’ the expression instance later on is not possible due to
the reasons described in the final note of Section 10. The
recommendation is to instead simply persist the string form of the
expression and compile the expression at run-time on the
target.</p></li>
<li><p>The correctness and robustness of the ExprTk library is
maintained by having a comprehensive suite of unit tests and functional
tests all of which are run using sanitizers (ASAN, UBSAN, LSAN, MSAN,
TSAN). Additionally, continuous fuzz-testing provided by Google OSS
Fuzz, and static analysis via Synopsis Coverity.</p></li>
<li><p>The library name ExprTk is pronounced “Ex-Pee-Ar-Tee-Kay” or
simply “Mathematical Expression Toolkit”</p></li>
<li><p>For general support, inquires or bug/issue reporting:
https://www.partow.net/programming/exprtk/index.html#support</p></li>
<li><p>Before jumping in and using ExprTk, do take the time to peruse
the documentation and all of the examples, both in the main and the
extras distributions. Having an informed general view of what can and
can’t be done, and how something should be done with ExprTk, will likely
result in a far more productive and enjoyable programming
experience.</p></li>
</ol>
<pre><code>
[SECTION 27 - SIMPLE EXPRTK EXAMPLE]
The following is a  simple yet complete example  demonstrating typical
usage of the ExprTk Library.  The example instantiates a symbol  table
object, adding to it  three variables named x,  y and z, and  a custom
user defined function, that accepts only two parameters, named myfunc.
The  example then  proceeds to  instantiate an  expression object  and
register to it the symbol table instance.

A parser is  then instantiated, and  the string representation  of the
expression  and  the  expression object  are  passed  to the  parser&#39;s
compile  method   for  compilation.   If  an   error  occurred  during
compilation, the compile method will return false, leading to a series
of  error diagnostics  being printed  to stdout.  Otherwise the  newly
compiled expression is evaluated  by invoking  the expression object&#39;s
value method, and subsequently printing the result  of the computation
to stdout.


--- snip ---
#include &lt;cstdio&gt;
#include &lt;string&gt;

#include &quot;exprtk.hpp&quot;

template &lt;typename T&gt;
struct myfunc final : public exprtk::ifunction&lt;T&gt;
{
   myfunc() : exprtk::ifunction&lt;T&gt;(2) {}

   T operator()(const T&amp; v1, const T&amp; v2) override
   {
      return T(1) + (v1 * v2) / T(3);
   }
};

int main()
{
   typedef exprtk::symbol_table&lt;double&gt; symbol_table_t;
   typedef exprtk::expression&lt;double&gt;   expression_t;
   typedef exprtk::parser&lt;double&gt;       parser_t;
   typedef exprtk::parser_error::type   error_t;

   const std::string expression_string =
      &quot;z := 2 myfunc([4 + sin(x / pi)^3],y ^ 2)&quot;;

   double x = 1.1;
   double y = 2.2;
   double z = 3.3;

   myfunc&lt;double&gt; mf;

   symbol_table_t symbol_table;
   symbol_table.add_constants();
   symbol_table.add_variable(&quot;x&quot;,x);
   symbol_table.add_variable(&quot;y&quot;,y);
   symbol_table.add_variable(&quot;z&quot;,z);
   symbol_table.add_function(&quot;myfunc&quot;,mf);

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   parser_t parser;

   if (!parser.compile(expression_string,expression))
   {
      // A compilation error has occurred. Attempt to
      // print all errors to stdout.

      printf(&quot;Error: %s\tExpression: %s\n&quot;,
             parser.error().c_str(),
             expression_string.c_str());

      for (std::size_t i = 0; i &lt; parser.error_count(); ++i)
      {
         // Include the specific nature of each error
         // and its position in the expression string.

         error_t error = parser.get_error(i);

         printf(&quot;Error: %02d Position: %02d &quot;
                &quot;Type: [%s] &quot;
                &quot;Message: %s &quot;
                &quot;Expression: %s\n&quot;,
                static_cast&lt;int&gt;(i),
                static_cast&lt;int&gt;(error.token.position),
                exprtk::parser_error::to_str(error.mode).c_str(),
                error.diagnostic.c_str(),
                expression_string.c_str());
      }

      return 1;
   }

   // Evaluate the expression and obtain its result.

   double result = expression.value();

   printf(&quot;Result: %10.5f\n&quot;,result);

   return 0;
}
--- snip ---
</code></pre>
<p>[SECTION 28 - BUILD OPTIONS] When building ExprTk there are a number
of defines that will enable or disable certain features and
capabilities. The defines can either be part of a compiler command line
switch or scoped around the include to the ExprTk header. The defines
are as follows:</p>
<ol type="1">
<li><p>exprtk_enable_debugging</p></li>
<li><p>exprtk_disable_cardinal_pow_optimisation</p></li>
<li><p>exprtk_disable_comments</p></li>
<li><p>exprtk_disable_break_continue</p></li>
<li><p>exprtk_disable_sc_andor</p></li>
<li><p>exprtk_disable_return_statement</p></li>
<li><p>exprtk_disable_enhanced_features</p></li>
<li><p>exprtk_disable_string_capabilities</p></li>
<li><p>exprtk_disable_superscalar_unroll</p></li>
<li><p>exprtk_disable_rtl_io</p></li>
<li><p>exprtk_disable_rtl_io_file</p></li>
<li><p>exprtk_disable_rtl_vecops</p></li>
<li><p>exprtk_disable_caseinsensitivity</p></li>
<li><p>exprtk_enable_range_runtime_checks</p></li>
<li><p>exprtk_enable_debugging This define will enable printing of debug
information to stdout during the compilation process.</p></li>
<li><p>exprtk_disable_cardinal_pow_optimisation This define will disable
the optimisation invoked when constant integers are used as powers in
exponentiation expressions (eg: x^7).</p></li>
<li><p>exprtk_disable_comments This define will disable the ability for
expressions to have comments. Expressions that have comments when parsed
with a build that has this option, will result in a compilation
failure.</p></li>
<li><p>exprtk_disable_break_continue This define will disable the
loop-wise ‘break’ and ‘continue’ capabilities. Any expression that
contains those keywords will result in a compilation failure.</p></li>
<li><p>exprtk_disable_sc_andor This define will disable the
short-circuit ‘&amp;’ (and) and ‘|’ (or) operators</p></li>
<li><p>exprtk_disable_return_statement This define will disable use of
return statements within expressions.</p></li>
<li><p>exprtk_disable_enhanced_features This define will disable all
enhanced features such as strength reduction and special function
optimisations and expression specific type instantiations. This feature
will reduce compilation times and binary sizes but will also result in
massive performance degradation of expression evaluations.</p></li>
<li><p>exprtk_disable_string_capabilities This define will disable all
string processing capabilities. Any expression that contains a string or
string related syntax will result in a compilation failure.</p></li>
<li><p>exprtk_disable_superscalar_unroll This define will set the loop
unroll batch size to 4 operations per loop instead of the default 8
operations. This define is used in operations that involve vectors and
aggregations over vectors. When targeting non-superscalar architectures,
it may be recommended to build using this particular option if
efficiency of evaluations is of concern.</p></li>
<li><p>exprtk_disable_rtl_io This define will disable all of basic IO
RTL package features. When present, any attempt to register the basic IO
RTL package with a given symbol table will fail causing a compilation
error.</p></li>
<li><p>exprtk_disable_rtl_io_file This define will disable the file I/O
RTL package features. When present, any attempts to register the file
I/O package with a given symbol table will fail causing a compilation
error.</p></li>
<li><p>exprtk_disable_rtl_vecops This define will disable the extended
vector operations RTL package features. When present, any attempts to
register the vector operations package with a given symbol table will
fail causing a compilation error.</p></li>
<li><p>exprtk_disable_caseinsensitivity This define will disable
case-insensitivity when matching variables and functions. Furthermore
all reserved and keywords will only be acknowledged when in all
lower-case.</p></li>
<li><p>exprtk_enable_range_runtime_checks This define will enable
run-time checks pertaining to vector indexing operations used in any of
the vector-to-vector and vector-to-scalar operations.</p></li>
</ol>
<pre><code>
[SECTION 29 - FILES]
The source distribution of ExprTk is comprised of the following set of
files:

   (00) Makefile
   (01) readme.txt
   (02) exprtk.hpp
   (03) exprtk_test.cpp
   (04) exprtk_benchmark.cpp
   (05) exprtk_simple_example_01.cpp
   (06) exprtk_simple_example_02.cpp
   (07) exprtk_simple_example_03.cpp
   (08) exprtk_simple_example_04.cpp
   (09) exprtk_simple_example_05.cpp
   (10) exprtk_simple_example_06.cpp
   (11) exprtk_simple_example_07.cpp
   (12) exprtk_simple_example_08.cpp
   (13) exprtk_simple_example_09.cpp
   (14) exprtk_simple_example_10.cpp
   (15) exprtk_simple_example_11.cpp
   (16) exprtk_simple_example_12.cpp
   (17) exprtk_simple_example_13.cpp
   (18) exprtk_simple_example_14.cpp
   (19) exprtk_simple_example_15.cpp
   (20) exprtk_simple_example_16.cpp
   (21) exprtk_simple_example_17.cpp
   (22) exprtk_simple_example_18.cpp
   (23) exprtk_simple_example_19.cpp
   (24) exprtk_simple_example_20.cpp
   (25) exprtk_simple_example_21.cpp
   (26) exprtk_simple_example_22.cpp
   (27) exprtk_simple_example_23.cpp
   (28) exprtk_simple_example_24.cpp


Details for each of the above examples can be found here:

  https://www.partow.net/programming/exprtk/index.html#examples


Various extended and advanced examples using ExprTk are available
via the following:

   (00) exprtk_american_option_binomial_model.cpp
   (01) exprtk_archimedes_pi.cpp
   (02) exprtk_arithmetic_evaluator.cpp
   (03) exprtk_binomial_coefficient.cpp
   (04) exprtk_bsm_benchmark.cpp
   (05) exprtk_calc.cpp
   (06) exprtk_collatz.cpp
   (07) exprtk_compilation_timeout.cpp
   (08) exprtk_degree_trigonometry_example.cpp
   (09) exprtk_exprgen.cpp
   (00) exprtk_extract_dependents.cpp
   (11) exprtk_e_10kdigits.cpp
   (12) exprtk_factorize_fermat.cpp
   (13) exprtk_factorize_pollard.cpp
   (14) exprtk_fizzbuzz.cpp
   (15) exprtk_funcall_benchmark.cpp
   (16) exprtk_game_of_life.cpp
   (17) exprtk_gcd.cpp
   (18) exprtk_gnuplot.cpp
   (19) exprtk_gnuplot_multi.cpp
   (10) exprtk_groups_examples.cpp
   (21) exprtk_immutable_symbol_table_example.cpp
   (22) exprtk_import_packages.cpp
   (23) exprtk_instruction_primer.cpp
   (24) exprtk_jump_diffusion_process.cpp
   (25) exprtk_loop_timeout_rtc.cpp
   (26) exprtk_magic_square.cpp
   (27) exprtk_mandelbrot.cpp
   (28) exprtk_max_subarray_sum.cpp
   (29) exprtk_maze_generator.cpp
   (20) exprtk_miller_rabin_primality_test.cpp
   (31) exprtk_montecarlo_e.cpp
   (32) exprtk_montecarlo_option_pricing_model.cpp
   (33) exprtk_montecarlo_pi.cpp
   (34) exprtk_naive_primes.cpp
   (35) exprtk_normal_random_marsaglia_method.cpp
   (36) exprtk_nqueens_problem.cpp
   (37) exprtk_nthroot_bisection.cpp
   (38) exprtk_ornstein_uhlenbeck_process.cpp
   (39) exprtk_pascals_triangle.cpp
   (30) exprtk_pi_10kdigits.cpp
   (41) exprtk_prime_sieve.cpp
   (42) exprtk_prime_sieve_vectorized.cpp
   (43) exprtk_pyramid.cpp
   (44) exprtk_pythagorean_triples.cpp
   (45) exprtk_recursive_fibonacci.cpp
   (46) exprtk_repl.cpp
   (47) exprtk_riddle.cpp
   (48) exprtk_rtc_overhead.cpp
   (49) exprtk_sudoku_solver.cpp
   (50) exprtk_sumofprimes.cpp
   (51) exprtk_symtab_functions.cpp
   (52) exprtk_testgen.cpp
   (53) exprtk_tower_of_hanoi.cpp
   (54) exprtk_truthtable_gen.cpp
   (55) exprtk_vectorized_binomial_model.cpp
   (56) exprtk_vectornorm.cpp
   (57) exprtk_vector_benchmark.cpp
   (58) exprtk_vector_benchmark_multithreaded.cpp
   (59) exprtk_vector_resize_example.cpp
   (60) exprtk_vector_resize_inline_example.cpp
   (61) exprtk_wiener_process_pi.cpp


Details for each of the above examples can be found here:

   https://partow.net/programming/exprtk/index.html#variousexamples
</code></pre>
<p>[SECTION 30 - LANGUAGE STRUCTURE] The following are the various
language structures available within ExprTk and their structural
representations.</p>
<ol start="0" type="1">
<li><p>If Statement</p></li>
<li><p>Else Statement</p></li>
<li><p>Ternary Statement</p></li>
<li><p>While Loop</p></li>
<li><p>Repeat Until Loop</p></li>
<li><p>For Loop</p></li>
<li><p>Switch Statement</p></li>
<li><p>Multi Subexpression Statement</p></li>
<li><p>Multi Case-Consequent Statement</p></li>
<li><p>Variable Definition Statement</p></li>
<li><p>Vector Definition Statement</p></li>
<li><p>String Definition Statement</p></li>
<li><p>Range Statement</p></li>
<li><p>Return Statement</p></li>
<li><ul>
<li>If Statement +————————————————————-+ | | | [if] —&gt; [(] —&gt;
[condition] -+-&gt; [,] -+ | | | | | | +—————&lt;—————+ | | | | | | | |
+——————&lt;——————+ | | | | | | | +–&gt; [consequent] —&gt; [,] —&gt;
[alternative] —&gt; [)] | | | | | +–&gt; [)] –+-&gt; [{] —&gt;
[expression*] —&gt; [}] –+ | | | | | | | +———&lt;———-+ | | +—-&lt;—–+ |
| | | v | | +–&gt; [consequent] –&gt; [;] -{*}-&gt; [else-statement] | |
| +————————————————————-+</li>
</ul></li>
<li><ul>
<li>Else Statement +————————————————————-+ | | | [else] -+-&gt;
[alternative] —&gt; [;] | | | | | +–&gt; [{] —&gt; [expression*] —&gt;
[}] | | | | | +–&gt; [if-statement] | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>Ternary Statement +————————————————————-+ | | | [condition] —&gt;
[?] —&gt; [consequent] —&gt; [:] –+ | | | | | +————————&lt;————————+ | |
| | | +–&gt; [alternative] –&gt; [;] | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>While Loop +————————————————————-+ | | | [while] —&gt; [(] —&gt;
[condition] —&gt; [)] —+ | | | | | +———————-&lt;———————-+ | | | | |
+–&gt; [{] —&gt; [expression*] —&gt; [}] | | |
+————————————————————-+</li>
</ul></li>
<li><ul>
<li>Repeat Until Loop +————————————————————-+ | | | [repeat] —&gt;
[expression*] —+ | | | | | +————–&lt;—————+ | | | | | +–&gt; [until]
—&gt; [(] —&gt; [condition] —&gt;[)] | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>For Loop +————————————————————-+ | | | [for] —&gt; [(] -+-&gt;
[initialise expression] –+–+ | | | | | | | +————-&gt;—————+ v | | | | |
+———————–&lt;————————+ | | | | | +–&gt; [;] -+-&gt; [condition] -+-&gt;
[;] —+ | | | | | | | +——-&gt;——–+ v | | | | | +——————&lt;———+——–+ | | |
| | | +–&gt; [increment expression] -+-&gt; [)] –+ | | | | |
+——————&lt;——————-+ | | | | | +–&gt; [{] —&gt; [expression*] —&gt; [}] |
| | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>Switch Statement +————————————————————-+ | | | [switch] —&gt; [{] —+
| | | | | +———&lt;———-+———–&lt;———–+ | | | | | | +–&gt; [case] —&gt;
[condition] —&gt; [:] —+ | | | | | | | +——————-&lt;——————–+ | | | | | |
| +–&gt; [consequent] —&gt; [;] ———&gt;——–+ | | | | | | | | | | +–&gt;
[default] —&gt; [consequent] —&gt; [;] —+ | | | | | |
+———————&lt;———————-+ | | | | | +–&gt; [}] | | |
+————————————————————-+</li>
</ul></li>
<li><ul>
<li>Multi Subexpression Statement +————————————————————-+ | | |
+————–&lt;—————+ | | | | | | [~] —&gt; [{(] -+-&gt; [expression] -+-&gt;
[;,] —+ | | | | | +—————-&lt;—————-+ | | | | | +–&gt; [})] | | |
+————————————————————-+</li>
</ul></li>
<li><ul>
<li>Multi Case-Consequent Statement +————————————————————-+ | | | [[*]]
—&gt; [{] —+ | | | | | +——–&lt;——–+————–&lt;———-+ | | | | | | +–&gt;
[case] —&gt; [condition] —&gt; [:] —+ | | | | | | | +——————-&lt;——————–+
| | | | | | | +–&gt; [consequent] —&gt; [;] —+——&gt;——+ | | | | | +–&gt;
[}] | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>Variable Definition Statement +————————————————————-+ | | | [var]
—&gt; [symbol] -+-&gt; [:=] -+-&gt; [expression] -+-&gt; [;] | | | | | |
| | +—–&gt; [{}] –&gt;–+ | | | | | | +————-&gt;————-+ | | |
+————————————————————-+</li>
</ul></li>
<li><ul>
<li>Vector Definition Statement +————————————————————-+ | | | [var]
—&gt; [symbol] —&gt; [[] —&gt; [constant] —&gt; []] –+ | | | | |
+—————————&lt;—————————+ | | | | | | +———&gt;———+ | | | | | | | +–&gt;
[:=] —&gt; [{] -+-+-&gt; [expression] -+-&gt; [}] —&gt; [;] | | | | | |
+–&lt;— [,] &lt;—–+ | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>String Definition Statement +————————————————————-+ | | | [var]
–&gt; [symbol] –&gt; [:=] –&gt; [str-expression] —&gt; [;] | | |
+————————————————————-+</li>
</ul></li>
<li><ul>
<li>Range Statement +————————————————————-+ | | | +——–&gt;——–+ | | | | |
| [[] -+-&gt; [expression] -+-&gt; [:] -+-&gt; [expression] -+–&gt; []]
| | | | | | +——–&gt;——–+ | | | +————————————————————-+</li>
</ul></li>
<li><ul>
<li>Return Statement +————————————————————-+ | | | [return] —&gt; [[]
-+-&gt; [expression] -+-&gt; []] —&gt; [;] | | | | | | +–&lt;— [,]
&lt;—–+ | | | +————————————————————-+</li>
</ul></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>1/5<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
