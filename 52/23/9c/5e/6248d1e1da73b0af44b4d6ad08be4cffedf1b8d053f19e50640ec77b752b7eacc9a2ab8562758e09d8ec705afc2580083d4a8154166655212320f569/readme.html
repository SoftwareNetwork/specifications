<h1 id="units">UNITS</h1>
<p>A compile-time, header-only, dimensional analysis library built on c++14 with no dependencies.</p>
<p><a href="https://travis-ci.org/nholthaus/units"><img src="https://travis-ci.org/nholthaus/units.svg?branch=master" alt="Linux build" /></a> <a href="https://ci.appveyor.com/project/nholthaus/units"><img src="https://ci.appveyor.com/api/projects/status/github/nholthaus/units?svg=true&amp;branch=master" alt="Windows build" /></a> <a href="https://coveralls.io/github/nholthaus/units?branch=master"><img src="https://coveralls.io/repos/github/nholthaus/units/badge.svg?branch=master" alt="Coverage Status" /></a> <img src="https://img.shields.io/badge/license-MIT-orange.svg" alt="license" /> <img src="https://img.shields.io/badge/%C2%A9-Nic_Holthaus-orange.svg" alt="copyright" /> <img src="https://img.shields.io/badge/language-c++-blue.svg" alt="language" /> <img src="https://img.shields.io/badge/std-c++14-blue.svg" alt="c++" /><br><img src="https://img.shields.io/badge/MSVC-2015-ff69b4.svg" alt="msvc2015" /> <img src="https://img.shields.io/badge/MSVC-2017-ff69b4.svg" alt="msvc2017" /> <img src="https://img.shields.io/badge/GCC-4.9.3-ff69b4.svg" alt="gcc-4.9.3" /> <img src="https://img.shields.io/badge/GCC-5.4.0-ff69b4.svg" alt="gcc-5.4.0" /> <img src="https://img.shields.io/badge/CLANG-3.4-ff69b4.svg" alt="clang-3.4" /></p>
<h1 id="get-in-touch">Get in touch</h1>
<p>If you are using <code>units.h</code> in production code, I'd love to hear from you via GitHub issues!</p>
<h1 id="latest-release---v2.3.1">Latest Release - v2.3.1</h1>
<h2 id="get-it">Get it</h2>
<p><a href="https://github.com/nholthaus/units/releases/tag/v2.3.1"><img src="https://img.shields.io/badge/Download-v2.3.1-green.svg" alt="DOWNLOAD" /></a></p>
<h2 id="new-in-v2.3.1">New in v2.3.1</h2>
<p><strong>This version removes support for the Visual Studio 2013 compiler.</strong></p>
<p>Features: - units now include constexpr <code>name()</code> and <code>abbreviation()</code> member functions, which do not really on string/iostream. - Builds with VS2017 Ninja generator out of the box - string conversions are now locale aware - added unary incremement and decremement operators (<code>++</code>,<code>--</code>), as well as unary <code>+</code> operator.</p>
<p>Bug fixs: - fixed compilation error when iostream was disabled</p>
<h2 id="new-in-v2.3.0">New in v2.3.0</h2>
<p>Features: - 5x compile time improvement on MSVC. - 1.5x compile time improvement on GCC. - Even more dramatic reductions in compile time can be acheived if you opt-in to specific unit definitions instead of using all the library-defined types (which is the default value). Check out <a href="#enabling-a-subset-of-units-to-improve-compilation-time">Enabling a subset of units to improve compilation time</a> for instructions. - Adds std::cout support for units with no defined abbreviation (they show up as a combination of SI base units) - Support for <code>std::numeric_limits</code> of unit types. - Assignment operators for unit types: <code>-=</code>, <code>+=</code>, <code>/=</code>, <code>*=</code>. - Added <code>min</code> and <code>max</code> overloads for units types in <code>units::math</code>. - Added <code>to_string</code> function and <code>abbreviation</code> functions: ```cpp auto len = 3.5_m; auto str = units::length::to_string(len); auto abv = units::length::abbreviation(len);</p>
<p>std::cout &lt;&lt; str; // prints &quot;3.5 m&quot; std::cout &lt;&lt; abv; // prints &quot;m&quot; <code>- Added units of data and data transfer: `bits`, `bytes`, `bits_per_second`, and `bytes_per_second`. - Adds `value()` member for accessing underlying type. - Adds `value_type` trait, as a synonym for `underlying_type`. - Adds definitions for Julian and Gregorian years. - Thanks to @dinocore1, `units` now supports cmake install and `find_packages`. From the [pull request](https://github.com/nholthaus/units/pull/84):</code>cmake # To have cmake install units library to a local 'install' directory: mkdir build cd build cmake -DCMAKE_INSTALL_PREFIX=&quot;install&quot; .. cmake --build . --target install # The units library can then be used in some other cmake project using # the standard 'find_package' command. Like so: find_package(units) ``<code>Bug fixes: - Fixed singualr name of</code>siemen<code>to be</code>siemens<code>(Thanks @Oxyd) - Fixed bug with</code>cubrt` operation (Thanks <span class="citation">@PearCoding</span>) - fixed constexpr relational operators bug - fixed exponential temperature conversions (Thanks <span class="citation">@guarndt</span>)</p>
<h2 id="tested-on">Tested on</h2>
<ul>
<li>gcc-4.9.3</li>
<li>gcc-5.4.0</li>
<li>clang-3.4</li>
<li>msvc2015</li>
<li>msvc2017</li>
</ul>
<p>Does this library work on your compiler? If so, let me know!</p>
<h1 id="contents">Contents</h1>
<!-- TOC -->
<ul>
<li><a href="#units">UNITS</a></li>
<li><a href="#get-in-touch">Get in touch</a></li>
<li><a href="#latest-release---v231">Latest Release - v2.3.1</a>
<ul>
<li><a href="#get-it">Get it</a></li>
<li><a href="#new-in-v231">New in v2.3.1</a></li>
<li><a href="#new-in-v230">New in v2.3.0</a></li>
<li><a href="#tested-on">Tested on</a></li>
</ul></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#getting-started-guide">Getting started guide</a></li>
<li><a href="#unit-initialization">Unit initialization</a></li>
<li><a href="#unit-tags">Unit tags</a></li>
<li><a href="#unit-containers">Unit containers</a></li>
<li><a href="#unit-literals">Unit Literals</a></li>
<li><a href="#cmath-functions"><code>&lt;cmath&gt;</code> Functions</a></li>
<li><a href="#exponentials-and-square-roots">Exponentials and Square Roots</a></li>
<li><a href="#removing-type-safety">Removing type safety</a></li>
<li><a href="#efficiency">Efficiency</a></li>
<li><a href="#pure-compile-time-unit-manipulation">Pure Compile-time Unit Manipulation</a></li>
<li><a href="#conversion-without-unit-containers">Conversion without unit containers</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#defining-new-units">Defining new units</a></li>
<li><a href="#unit-definition-macros">Unit definition macros</a></li>
<li><a href="#unit-type-traits">Unit Type Traits</a></li>
<li><a href="#changing-the-underlying-type-of-unit_t">Changing the underlying type of <code>unit_t</code></a></li>
<li><a href="#disabling-iostream">Disabling IOStream</a></li>
<li><a href="#enabling-a-subset-of-units-to-improve-compilation-time">Enabling a subset of units to improve compilation time</a></li>
<li><a href="#macro-clashes">Macro clashes</a>
<ul>
<li><a href="#windows-macros">Windows macros</a></li>
<li><a href="#arm-macros">ARM macros</a></li>
</ul></li>
<li><a href="#cmake-instructions">CMake Instructions</a></li>
<li><a href="#build-instructions">Build Instructions</a>
<ul>
<li><a href="#windows">Windows</a></li>
<li><a href="#linux">Linux</a></li>
</ul></li>
<li><a href="#previous-releases">Previous Releases</a></li>
</ul>
<!-- /TOC -->
<h1 id="documentation">Documentation</h1>
<p><a href="http://nholthaus.github.io/units">The full documentation is available <strong><em>here</em></strong></a>.</p>
<h1 id="description">Description</h1>
<p>The library consists of a single file (<a href="include/units.h">units.h</a>), plus unit tests. To incorporate the library into your project, simply copy the header into a location in your include path, or add the <a href="#cmake-instructions">included CMake project</a> into your build. Using the CMake project, you can also build the unit tests and documentation if desired.</p>
<p>The library provides a set of types, containers, and traits to solve dimensional analysis problems, that is, problems involving dimensioned physical quantities. The conversions between units are defined as ratios at compile time, making the library <em>incredibly</em> fast. Additionally, specifying units as <em>types</em>, rather than variable suffixes (or not at all), provides complete type-safety within the compiler. This means that code that accidentally misuses units or which has errors in the dimensional analysis <em>will fail at compile-time, not at run-time</em>.</p>
<p>The unit test file <code>unitTests/main.cpp</code> contains example usage of every type, trait, and function contained in the library, and while not exactly user-friendly, can be a valuable resource.</p>
<h1 id="getting-started-guide">Getting started guide</h1>
<p>Add <code>units.h</code> to your project, along with the <code>using</code> directive for literals</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;units.h&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> units::literals;</code></pre></div>
<p>Each &quot;dimension&quot; of unit is defined in its own namespace. See <a href="#namespaces">the namespaces section</a> for a complete list. The rest of the guide assumes you've included the namespaces you plan to use:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> units;
<span class="kw">using</span> <span class="kw">namespace</span> units::length;
<span class="kw">using</span> <span class="kw">namespace</span> units::time;
<span class="kw">using</span> <span class="kw">namespace</span> units::area;
<span class="kw">using</span> <span class="kw">namespace</span> units::velocity;</code></pre></div>
<p><strong>The easiest way to get started with the <code>units</code> library is to think of unit containers as <code>double</code> values.</strong> Unit containers are typically the units' non-plural name with the suffix <code>_t</code> (for type), e.g. <code>meter_t</code>. See <a href="http://nholthaus.github.io/units/namespaces.html">the documentation</a> for a complete list.</p>
<p>Units can (<em>and should!</em>) be used anywhere <code>double</code> values can be used:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span>          area = <span class="dv">15</span> * <span class="dv">5</span> + <span class="dv">10</span> * <span class="dv">10</span>;                <span class="co">// 175 m^2?</span>
<span class="dt">square_meter_t</span>  area = <span class="dv">15_m</span> * <span class="dv">5_m</span> + <span class="dv">10_m</span> * <span class="dv">10_m</span>;        <span class="co">// 175 m^2</span></code></pre></div>
<p>What makes unit types special is that unit conversions happen implicitly and automatically. Since unit conversions are evaluated at compile time, this means you can mix and match all the unit types you want with <em>no runtime penalty</em>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">foot_t</span>              len   = <span class="dv">5_m</span>;                            <span class="co">// simple implicit conversion</span>
<span class="dt">meters_per_second_t</span> speed = <span class="dv">60_mi</span> / <span class="dv">1_hr</span>;                   <span class="co">// more complex implicit conversion</span>
<span class="dt">square_meter_t</span>      area  = <span class="dv">15_m</span> * <span class="dv">5_m</span> + <span class="dv">1000_cm</span> * <span class="dv">1000_cm</span>; <span class="co">// previous example with mixed units</span></code></pre></div>
<p>Note the return type has the correct dimensions of area, even though the source types were all units of length. <code>units.h</code> has powerful dimensional analysis capabilities. But what happens if we get the return type wrong?</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">meter_t</span>  area = <span class="dv">15_m</span> * <span class="dv">5_m</span> + <span class="dv">10_m</span> * <span class="dv">10_m</span>;               <span class="co">// oops, m * m = m^2</span></code></pre></div>
<blockquote>
<p>E:/workspace/units/include/units.h(1405): error C2338: Units are not compatible.</p>
</blockquote>
<p>Your compiler will produce an &quot;incompatible units&quot; error if your dimensional analysis is incorrect. If your resulting unit types are complex, you could use <code>auto</code> for simplicity:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> result = <span class="dv">15_m</span> * <span class="dv">5_m</span> + <span class="dv">10_m</span> * <span class="dv">10_m</span>;                 <span class="co">//  m^2</span>
<span class="kw">auto</span> speed  = <span class="dv">60_mi</span> / <span class="dv">1_hr</span>;                             <span class="co">//  60 mph</span></code></pre></div>
<p><strong><em>NOTE: Think carefully about using <code>auto</code> for return types.</em></strong> When you explicitly declare the return type, the compiler can check the dimensional analysis for correctness, and produce errors at compile time if you make a mistake. When using <code>auto</code>, you are basically saying that whatever unit the right-hand side of the expression results to is correct (even if it's not). If you are only using <code>auto</code> because a complex unit type is not available in the library, try <a href="#defining-new-units">defining a new unit</a> as a better alternative.</p>
<p>More complex mathematical operations (<a href="http://nholthaus.github.io/units/namespaceunits_1_1math.html">almost every <code>&lt;cmath&gt;</code> operation actually</a>), including exponentials and square roots are possibe by using the <code>units::math</code> namespace .</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> units::math;

<span class="dt">meter_t</span> a = <span class="dv">3_m</span>;
<span class="dt">meter_t</span> b = <span class="dv">4_m</span>;
<span class="dt">meter_t</span> c = sqrt(pow&lt;<span class="dv">2</span>&gt;(a) + pow&lt;<span class="dv">2</span>&gt;(b));    <span class="co">// Pythagorean threorem.</span>

<span class="bu">std::</span>cout &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl;                <span class="co">// prints: &quot;5 m&quot;</span></code></pre></div>
<h1 id="unit-initialization">Unit initialization</h1>
<p>There are several ways to initialize unit values:</p>
<ul>
<li>Explicit initialization</li>
</ul>
<p><code>cpp   meter_t distance_m(10); // Explicit initialization from double   meter_t distance(10_m); // Explicit initialization from unit literal   meter_t dist(100_ft);   // Explicit initialization from unit literal of a different type</code></p>
<ul>
<li><code>make_unit&lt;...&gt;()</code> factory. The syntax is familiar to <code>boost::units</code> users, and allows explicit reference to the unit type for member variable initialization.</li>
</ul>
<p>```cpp class myClass { public:</p>
<pre><code>   myClass() : m_speed(make_unit&lt;miles_per_hour_t&gt;(100)) {}

 private:

   miles_per_hour_t m_speed;</code></pre>
<p>}; ```</p>
<h1 id="unit-tags">Unit tags</h1>
<p>Unit tags are the foundation of the unit library. Unit tags are types which are never instantiated in user code, but which provide the meta-information about different units, including how to convert between them, and how to determine their compatibility for conversion.</p>
<p>All unit tags are defined in namespaces under the <code>units</code> namespace, such as <code>units::length</code> or <code>units::angle</code>, to avoid name clashes between units of different physical quantities which share the same names (like pounds). SI base units are defined as &quot;categories&quot; in the <code>unit</code> namespace.</p>
<p>Units are defined in terms of 1. A scale factor relative to a base unit type. 2. A base unit 3. [optionally] a scale factor of <code>pi</code> 4. [optionally] a datum translation (such as the +/- 32 required to convert between <code>fahrenheit</code> and <code>celsius</code>)</p>
<p>All units have their origin in the Scientific International (SI) base unit system. A special exception is made for angle units, which are defined in SI as ( m * m^-1), and in this library they are treated as a basic unit type because of their important engineering applications.</p>
<p><em>Example</em>: the definitions of some common length units are:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> length
{
    <span class="kw">using</span> meters = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">1</span>&gt;, units::category::length_unit&gt;;    <span class="co">// meters are (1) unit of length in the SI system.</span>
    <span class="kw">using</span> feet = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">381</span>, <span class="dv">1250</span>&gt;, meters&gt;;                    <span class="co">// feet are 0.3048 meters.</span>
}</code></pre></div>
<h1 id="unit-containers">Unit containers</h1>
<p>Unit containers are the primary classes which will be instantiated in user code. They can be thought of as essentially equivalent to a <code>double</code>, except that they have unit type tags associated with them. They can be used wherever a double would be used to store a dimensioned quantity. Containers are derived from the <code>unit_t</code> class, and have the form <code>[unitname]_t</code>, e.g. <code>meter_t</code> or <code>radian_t</code>.</p>
<p>Unit containers are defined in terms of the units they represent, their underlying type, and an optional non-linear scale (think decibels or Richter scale). For example, <code>meter_t</code> would be defined:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="dt">meter_t</span> = units::<span class="dt">unit_t</span>&lt;units::length::meter, <span class="dt">double</span>, units::linear_scale&gt;</code></pre></div>
<p>or simply</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="dt">meter_t</span> = units::<span class="dt">unit_t</span>&lt;units::length::meter&gt;</code></pre></div>
<p>since the underlying type and scale parameters default to <code>double</code> and <code>linear_scale</code> respectively.</p>
<p>Units of compatible types (e.g length units) can be implicitly converted/assigned to one another. Units (with the exception of dimensionless types) cannot be implicitly converted to/from built-in types, such as <code>double</code>.</p>
<p>Units are constructed from built-in types, and the <code>toDouble()</code> method (or <code>operator()</code>) can be used to retrieve a built-in type value. That said, the user should prefer to operate within the unit type-space as much as is practical, and wrappers of most <code>&lt;cmath&gt;</code> functions are provided to enable operating solely in the <code>unit_t</code> domain.</p>
<p>The primary purpose of unit containers is to provide type safety and dimensional analysis for mathematical operations. for instance, the velocity of an object can be calculated:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> objectVelocity = <span class="dt">meter_t</span>(<span class="fl">100.0</span>) / <span class="dt">second_t</span>(<span class="fl">2.0</span>);</code></pre></div>
<p>The resulting velocity type will be deduced to be <code>velocity::meters_per_second</code> with a value of 50.0. Additionally, if the return type if specified, the type system will verify that the units are compatible. For example, the following will fail to compile:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">units::velocity::meters_per_second objectVelocity = <span class="dt">square_meter_t</span>(<span class="fl">100.0</span>) / <span class="dt">second_t</span>(<span class="fl">2.0</span>); <span class="co">// Error: Unit types are not compatible.`</span></code></pre></div>
<p>Unit containers can (and should!) be used to perform implicit conversions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">units::time::<span class="dt">second_t</span> a;
units::time::<span class="dt">minute_t</span> b(<span class="fl">1.0</span>);

a = b;  <span class="co">// a == 60.0</span></code></pre></div>
<p>Arithmetic can be performed on unit containers the same way it can for built-in types. However, unlike built-in types, the return value of unit-type arithmetic will be the proper unit to represent the resulting quantity.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> units::length;
<span class="kw">using</span> <span class="kw">namespace</span> units::area;

<span class="dt">meter_t</span> a_m(<span class="fl">1.0</span>), b_m(<span class="fl">2.0</span>), c_m;
<span class="dt">foot_t</span>  a_ft(<span class="fl">1.0</span>), b_ft(<span class="fl">2.0</span>), c_ft;

c_m = a_m + b_m;                            <span class="co">// OK. c == 3m</span>
c_ft = a_m + b_m;                           <span class="co">// OK. resulting 3m is converted to ft.</span>
<span class="kw">auto</span> result = a_m + b_ft;                   <span class="co">// OK. result is `meter_t` (left-most unit)</span>

<span class="kw">auto</span> result_sm = a_m * b_m;                 <span class="co">// OK. result_sm is `square_meter_t`.</span>
<span class="kw">auto</span> result_s = a_m / b_m;                  <span class="co">// OK. result_s is `dimensionless_t`.</span>
<span class="kw">auto</span> result = a_m * b_ft;                   <span class="co">// OK. result is `square_meter_t` (left-most unit)</span>

<span class="kw">auto</span> result = a_m * <span class="dt">square_meter_t</span>(<span class="fl">1.0</span>);    <span class="co">// OK. units can always be multiplied. Result is `cubed&lt;meter_t&gt;`.</span>
<span class="kw">auto</span> result = a_m * <span class="dt">scalar_t</span>(<span class="fl">1.0</span>);          <span class="co">// OK. units can always be multiplied. Result is `meter_t`.</span></code></pre></div>
<p>Unsupported arithmetic, or improper return types will result in compiler errors:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">c_m = a_m + <span class="fl">5.0</span>;                            <span class="co">// Error. can&#39;t add scalars to dimensioned units.</span>
c_m = a_m + <span class="dt">scalar_t</span>(<span class="fl">5.0</span>);                  <span class="co">// Error. can&#39;t add scalars to dimensioned units.</span>
<span class="kw">auto</span> result = a_m + <span class="dt">square_meter_t</span>(<span class="fl">1.0</span>);    <span class="co">// Error. Incompatible units.</span></code></pre></div>
<p>By providing explicit return types for unit functions, the compiler can be used to verify the accuracy of the dimensional analysis, and thus avoiding costly errors.</p>
<h1 id="unit-literals">Unit Literals</h1>
<p>If you are using a compiler which supports user-defined literals (e.g. not Visual Studio 2013), then unit literals can be a convenient way to initialize and work with unit values:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> units::literals;

<span class="dt">meter_t</span> dist    = <span class="dv">10_m</span>;     <span class="co">// 10 m</span>
<span class="dt">meter_t</span> dist2   = <span class="dv">1_km</span>;     <span class="co">// 1000 m</span></code></pre></div>
<p>Literals can also be used for any temporary values in calculations, making them more readable:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> area = units::length::<span class="dt">meter_t</span>(<span class="dv">5</span>) * units::length::<span class="dt">meter_t</span>(<span class="dv">10</span>); <span class="co">// without literals</span>
<span class="kw">auto</span> area = <span class="dv">5_m</span> * <span class="dv">10_m</span>;                         <span class="co">// with literals</span></code></pre></div>
<p>All literals* are defined by their SI abbreviation preceded by an underscore, e.g. <code>_m</code> for meter. &quot;Square&quot; units are preceded by <code>_sq</code>, e.g. <code>_sq_m</code> for square meters. Non SI units use their most common abbreviations.</p>
<p>All literals are defined in the <code>units::literals</code> namespace, and in order to use literals in your code <strong><em>you must include the line <code>using units::literals</code></em></strong> (since there is no way to put a namespace on an operator).</p>
<p><em>* with the exception of <code>Teslas</code>, which use <code>_Te</code> for compatibility with MSVC compilers.</em></p>
<h1 id="cmath-functions"><code>&lt;cmath&gt;</code> Functions</h1>
<p>The <code>units</code> library include type-safe unit_t container wrappers for almost all of the <code>&lt;cmath&gt;</code> functions, <em>including</em> the c++11 extensions. These functions can be found in the <code>units::math</code> namespace. The <code>units</code> library versions don't conflict with <code>&lt;cmath&gt;</code>, and it's possible to use both libraries in the same code.</p>
<p>The overloaded functions ensure that only the proper unit types are accepted into the functions, and that the return value type matches the expected units, all without needing to result to the type-unsafe <code>toDouble()</code> member.</p>
<p>In <em>rare</em> cases, the overload resolution for a given type may be ambiguous. If so, simply prepend the function with the fully-qualified <code>units::math</code> prefix, e.g.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">meter_t</span> x(<span class="fl">2.0</span>);
<span class="dt">meter_t</span> y(<span class="fl">3.0</span>);
<span class="dt">square_meter_t</span> z(<span class="fl">1.0</span>);
<span class="dt">square_meter_t</span> result;

result = fma(x, y, z);                                              <span class="co">// Error: ambiguous</span>
<span class="dt">double</span> result = fma(x.toDouble(), y.toDouble(), z.toDouble());      <span class="co">// Warning: Unsafe!</span>
result = math::fma(x, y, z);                                        <span class="co">// OK.</span></code></pre></div>
<h1 id="exponentials-and-square-roots">Exponentials and Square Roots</h1>
<p>Many functions require units to be raised to some power. This can be accomplished using the <code>units::math::pow</code> function:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">square_meter_t</span> m2 = units::math::pow&lt;<span class="dv">2</span>&gt;(<span class="dt">meter_t</span>(<span class="fl">5.0</span>));  <span class="co">// m2 == 25.0</span></code></pre></div>
<p>The only constraint is that the exponential power (given in the template argument) must be known at compile time, so that the type system can deduce the output type. This differs from the <code>&lt;cmath&gt; pow</code> implementation, which takes exponent values at runtime.</p>
<p>Square roots are also provided with the <code>units::math::sqrt</code> function. Due to the nature of the <code>sqrt</code> operation, the units library can often provide exact conversions for square root operations, but <em>not in every case</em>. The rest of the time, the <code>sqrt</code> unit will be a <em>rational_approximation</em> of the real value. These are guaranteed to be accurate to at least 10 decimal places.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">meter_t</span> m = units::math::sqrt(<span class="dt">square_meter_t</span>(<span class="fl">4.0</span>));     <span class="co">// m == 2.0</span></code></pre></div>
<h1 id="removing-type-safety">Removing type safety</h1>
<p>When interfacing with APIs, libraries, and frameworks which aren't <code>unit</code> enabled, it may be necessary (if regrettable) to remove the type-safety of a unit container and expose its underlying type. This is possible using the <code>unit_cast</code> function, or the <code>to&lt;&gt;</code> member function.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> units;
<span class="kw">using</span> <span class="kw">namespace</span> units::length;

<span class="co">// Get double value from a unit container (double is the default underlying type of the units library)</span>
<span class="dt">meter_t</span> dist(<span class="dv">10</span>);
<span class="dt">double</span> dval = unit_cast&lt;<span class="dt">double</span>&gt;(dist);
<span class="dt">double</span> dval2 = dist.to&lt;<span class="dt">double</span>&gt;();

<span class="co">// Get integer value (potentially narrowing, be careful!)</span>
<span class="dt">int</span> ival = unit_cast&lt;<span class="dt">int</span>&gt;(dist);
<span class="dt">int</span> ival2 = dist.to&lt;<span class="dt">int</span>&gt;();</code></pre></div>
<p>Both functions produce the same results, the choice of syntax is simply a user preference.</p>
<p>To determine the underlying type of the unit container, the (verbose) trait <code>units::traits::unit_t_traits&lt;decltype(dist)&gt;::underlying_type</code> could be used.</p>
<h1 id="efficiency">Efficiency</h1>
<p>Complex, recurively-defined conversions are performed in just 5 instructions:</p>
<pre><code>    year_t twoYears(2.0);
    week_t twoYearsInWeeks = twoYears;
00007FF7BDB57FF6  xorps       xmm9,xmm9  
00007FF7BDB57FFA  cvtsi2sd    xmm9,rax  
00007FF7BDB57FFF  mulsd       xmm9,mmword ptr [__real@4000000000000000 (07FF7BDBB31A0h)]  
00007FF7BDB58008  divsd       xmm9,mmword ptr [__real@401c000000000000 (07FF7BDBB33C0h)]  
00007FF7BDB58011  movsd       mmword ptr [rbp+6Fh],xmm9  
    EXPECT_EQ(week_t(104.286), twoYearsInWeeks);
00007FF7BDB58017  ...</code></pre>
<p>In the library, the year to week conversion is defined in terms of <code>years -&gt; days -&gt; hours -&gt; minutes -&gt; seconds -&gt; minutes -&gt; hours -&gt; days -&gt; weeks</code> but the total conversion ratio is computed at compile-time and the math is optimized to two floating-point operations.</p>
<p>Unit conversions between equivalent types are optimized away completely, and generate <em>no machine code</em>.</p>
<h1 id="pure-compile-time-unit-manipulation">Pure Compile-time Unit Manipulation</h1>
<p>In many cases, unit equations are used to determine derived values from a set of values which are known at compile-time. In these situations, it would be optimal to pre-compute the derived values <em>at compile time</em>, thus generating no machine code and incurring no run-time penalty.</p>
<p>The <code>unit_value_t</code> class is the mechanism in the units library to perform compile-time arithmetic. The <code>unit_value_t</code> class functions exactly the same way as <code>std::ratio</code>, but with an associated unit tag and the ensuing type safety.</p>
<p>For a simple example, let's define a right triangle whose hypotenuse is the sum of the squares of its side (a Pythagorean triple)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> RightTriangle
{
    <span class="kw">using</span> a = <span class="dt">unit_value_t</span>&lt;meters, <span class="dv">3</span>&gt;;
    <span class="kw">using</span> b = <span class="dt">unit_value_t</span>&lt;meters, <span class="dv">4</span>&gt;;
    <span class="kw">using</span> c = unit_value_sqrt&lt;unit_value_add&lt;unit_value_power&lt;a, <span class="dv">2</span>&gt;, unit_value_power&lt;b, <span class="dv">2</span>&gt;&gt;&gt;;
};</code></pre></div>
<p>The definition above is perfectly efficient, as it generates <em>no run-time code</em> whatsoever, and still provides all the type safety of unit containers. The values of <code>a</code>, <code>b</code>, and <code>c</code> can be accessed at runtime using the static <code>value()</code> method of <code>unit_value_t</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a = RightTriangle::a::value(); <span class="co">// a is `meter_t(3)`</span>
<span class="kw">auto</span> b = RightTriangle::b::value(); <span class="co">// b is `meter_t(4)`</span>
<span class="kw">auto</span> c = RightTriangle::c::value(); <span class="co">// c is `meter_t(5)`</span></code></pre></div>
<p>The available compile-time operations are:</p>
<ul>
<li><code>units::unit_value_add</code></li>
<li><code>units::unit_value_subtract</code></li>
<li><code>units::unit_value_multiply</code></li>
<li><code>units::unit_value_divide</code></li>
<li><code>units::unit_value_power</code></li>
<li><code>units::unit_value_sqrt</code></li>
</ul>
<h1 id="conversion-without-unit-containers">Conversion without unit containers</h1>
<p>The preferred method of conversion is implicitly though the use of unit containers, however unit conversion can be accomplished using <code>units::convert</code> for arithmetic types:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> val_in = convert&lt;feet, inches&gt;(<span class="fl">1.0</span>); <span class="co">// val_in == 12.0</span></code></pre></div>
<p>For type-safe conversion, prefer implicit conversion via unit_t type containers..</p>
<h1 id="namespaces">Namespaces</h1>
<p>Unit tags and containers are split into separate namespaces to avoid conflicting unit names which represent different physical quantities.</p>
<p>Unit tag and <code>unit_t</code> container definitions are defined in the following namespaces: - units::length - units::mass - units::time - units::angle (plane) - units::current - units::temperature - units::substance (amount of, i.e. moles) - units::luminous_intensity - units::solid_angle - units::frequency - units::velocity - units::angular_velocity - units::acceleration - units::force - units::pressure - units::charge - units::energy - units::power - units::voltage - units::capacitance - units::impedance - units::magnetic_flux - units::magnetic_field_strength - units::inductance - units::luminous_flux - units::illuminance - units::radiation - units::torque - units::area - units::volume - units::density - units::concentration - units::data - units::data_transfer_rate - units::constants (scalar and non-scalar physical constants like Avogadro's number)</p>
<p>Literal values for unit containers are defined in the <code>literals</code> namespace - units::literals</p>
<p>Mathematical operations like <code>sin</code>, <code>log</code>, <code>floor</code>, etc are defined in the following namespaces: - units::math</p>
<p>Type traits that you can use to test unit types are defined in the following namespaces: - units::traits</p>
<h1 id="defining-new-units">Defining new units</h1>
<p>The units library strives to provide built-in types for every conceivable unit, and before defining your own units you should double-check the namespaces to make sure it's not already included. That said, if you need to roll your own units, the library is extensible by design.</p>
<p>Defining new units is simple, as they can be recursively defined as ratio of previously-defined units in a way that mimics natural language and is highly readable:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> time
{
    <span class="kw">using</span> seconds = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">1</span>&gt;,   units::category::time_unit&gt;;
    <span class="kw">using</span> minutes = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">60</span>&gt;,  seconds&gt;;
    <span class="kw">using</span> hours   = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">60</span>&gt;,  minutes&gt;;
    <span class="kw">using</span> days    = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">24</span>&gt;,  hours&gt;;
    <span class="kw">using</span> weeks   = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">7</span>&gt;,   days&gt;;
    <span class="kw">using</span> years   = units::unit&lt;<span class="bu">std::</span>ratio&lt;<span class="dv">365</span>&gt;, days&gt;;
}</code></pre></div>
<p>Units are defined in the form: <code>using [unit] = unit&lt;std::ratio&lt;[number of base units per unit]&gt;, [base unit]&gt;;</code>, where: - the <code>[unit]</code> is what you are defining. - the <code>[base unit]</code> is the unit that <code>[unit]</code> will be defined in terms of, and - the <code>[number of base units per unit]</code> is the conversion ratio between the two, expressed as a <code>std::ratio</code> type.</p>
<p>Compound units are defined in a similar manner, with additional helper functions for polynomials:</p>
<pre><code>using acceleration = compound_unit&lt;meters, inverse&lt;squared&lt;seconds&gt;&gt;&gt;;      // (m / s^2)</code></pre>
<p>The available helpers are: - <code>units::inverse&lt;...&gt;</code> (inverts the unit, e.g. meters becomes meters^-1, or 1 / meters) - <code>units::squared&lt;...&gt;</code> (squares the unit, e.g. meters becomes meters^2) - <code>units::cubed&lt;...&gt;</code> (cubes the unit, e.g. meters becomes meters^3) - <code>units::square_root&lt;...&gt;</code> (takes the square root of the unit, e.g meters^2 becomes meters) - <code>units::atto&lt;...&gt;</code> through <code>units::exa&lt;...&gt;</code> metric prefixes</p>
<h1 id="unit-definition-macros">Unit definition macros</h1>
<p>Version <code>2.1.0</code> of the units library simplifies the task of adding new units by introducing a set of macros for unit definitions:</p>
<ul>
<li><code>UNIT_ADD(namespaceName, nameSingular, namePlural, abbreviation, definition)</code></li>
</ul>
<p>This macro adds a single new unit to the given namespace, as well as a literal definition and <code>cout</code> support based on the given <code>abbreviation</code>. e.g.</p>
<p><code>cpp   UNIT_ADD(length, foot, feet, ft, unit&lt;std::ratio&lt;381, 1250&gt;, meters&gt;)</code></p>
<p>Would create the <code>units::length::feet</code> tag, the <code>units::length::foot_t</code> container type, and the <code>_ft</code> literal.</p>
<ul>
<li><code>UNIT_ADD_WITH_METRIC_PREFIXES(namespaceName, nameSingular, namePlural, abbreviation, definition)</code></li>
</ul>
<p>This macro has the same functionality as <code>UNIT_ADD</code>, but additionally adds unit types with all metric prefixes from <code>femto</code> to <code>peta</code> (smaller and larger prefixes mostly result in arithmetic overflow).</p>
<ul>
<li><code>UNIT_ADD_WITH_CUSTOM_TYPE(namespaceName, nameSingular, namePlural, abbreviation, underlyingType, definition)</code></li>
</ul>
<p>This macro has the same functionality as <code>UNIT_ADD</code>, but additionally adds an <code>underlyingType</code> parameter, which can be used to create units with integral, or other underlying types. The library default underlying type is <code>double</code>. - <code>UNIT_ADD_DECIBEL(namespaceName, nameSingular, abbreviation)</code></p>
<p>Adds the decibel representation for a previously-defined unit. e.g.</p>
<p><code>cpp   UNIT_ADD_DECIBEL(power, watt, dBW)</code></p>
<p>Adds the <code>dBW_t</code> container, and the <code>_dBW</code> literal.</p>
<ul>
<li><code>UNIT_ADD_CATEGORY_TRAIT(unitCategory, baseUnit)</code></li>
</ul>
<p>This macro creates a type-trait to check whether a unit is of a certain category, e.g. length. This is only necessary if defining new categories of units which are not included in <code>units.h</code> at all. e.g.</p>
<p><code>cpp   UNIT_ADD_CATEGORY_TRAIT(length, meter)</code></p>
<p>Adds the <code>units::traits::is_length_unit</code> trait.</p>
<h1 id="unit-type-traits">Unit Type Traits</h1>
<p>The units library provides a comprehensive set of type-traits, which can be used in templated user code to enforce that the unit types have certain properties.</p>
<p>For example, let's say you want to write a function that validates that the square footage of an office (given in any units), meets the minimum size required by local ordinance.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> Units&gt;
<span class="dt">bool</span> isMinimumSize(Units x)
{
    <span class="cf">return</span> x &gt;= <span class="dt">square_feet_t</span>(<span class="fl">80.0</span>);
}</code></pre></div>
<p>This function will fail to compile if <code>Units</code> is not a unit of area (since incompatible unit types are not comparable), but it will produce a series difficult-to-understand template errors. Type traits could be used to make the error message more friendly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> Units&gt;
<span class="dt">bool</span> isMinimumSize(Units x)
{
    <span class="kw">static_assert</span>(units::traits::is_area_unit&lt;Units&gt;::value, <span class="st">&quot;Input value x must represent an area quantity.&quot;</span>);
    <span class="cf">return</span> x &gt;= <span class="dt">square_feet_t</span>(<span class="fl">80.0</span>);
}</code></pre></div>
<p>See the <code>units::traits</code> namespace for a list of all the supported traits.</p>
<h1 id="changing-the-underlying-type-of-unit_t">Changing the underlying type of <code>unit_t</code></h1>
<p>The default underlying type for all unit containers is <code>double</code>. However, this can be overridden by providing a definition for <code>UNIT_LIB_DEFAULT_TYPE</code>, e.g.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Use 64-bit integers as the underlying unit type</span>
<span class="pp">#define UNIT_LIB_DEFAULT_TYPE int64_t</span>
<span class="pp">#include </span><span class="im">&lt;units.h&gt;</span></code></pre></div>
<p><strong><em>NOTE:</em> changing the underlying type may result in unexpected behavior.</strong> Unit conversion makes heavy use of division, which may make integral types unsuitable except for niche embedded applications. Using excessively large types may increase the number of arithmetic overflow errors.</p>
<h1 id="disabling-iostream">Disabling IOStream</h1>
<p>For some embedded applications, it may be <a href="https://github.com/nholthaus/units/issues/32">desirable to remove all references to <code>&lt;iostream&gt;</code> in order to reduce compiled binary size and RAM requirements</a>. There are two ways to accomplish this:</p>
<ol style="list-style-type: decimal">
<li>If you are copy/pasting <code>units.h</code> into your project include directory, then simply define <code>UNIT_LIB_DISABLE_IOSTREAM</code> before including the header.</li>
</ol>
<p><code>cpp    #define UNIT_LIB_DISABLE_IOSTREAM    #include &lt;units.h&gt;</code></p>
<ol start="2" style="list-style-type: decimal">
<li>If you are including <code>units</code> in your project as a <code>CMake</code> target (using <code>add_subdirectory</code>), then all you need to do is set the <code>DISABLE_IOSTREAM</code> cache option, either using the cmake-gui, or by adding the option to the cmake command line during configuration:</li>
</ol>
<p><code>bash    cmake -DDISABLE_IOSTREAM=ON -DBUILD_TESTS=OFF ..    cmake --build . --config Release</code></p>
<h1 id="enabling-a-subset-of-units-to-improve-compilation-time">Enabling a subset of units to improve compilation time</h1>
<p>If you know that you only need a subset of the unit namespaces for your application, you can dramatically improve compilation time by disabling the default definitions, and then only opting-in to the namespaces you want. For example:</p>
<p><code>cpp   // Only use length and time   #define DISABLE_PREDEFINED_UNITS   #define ENABLE_PREDEFINED_LENGTH_UNITS   #define ENABLE_PREDEFINED_TIME_UNITS</code></p>
<p>The generic algorithm is 1. disable the pre-defined units using <code>#define DISABLE_PREDEFINED_UNITS</code> 2. opt-in to the namespaces you want using <code>#define ENABLE_PREDEFINED_&lt;namepsace name&gt;_UNITS</code></p>
<p>Additionally, for <code>CMake</code> users, there are equivalently-named cmake options defined which will automatically include the preprocessor definitions in your project.</p>
<h1 id="macro-clashes">Macro clashes</h1>
<p>With certain compilers, it is possible that system header files like <code>&lt;ctype.h&gt;</code> will define macros which conflict with the unit literals, which use SI abbreviations. In these cases, it is general safe and advisable to <code>#undef</code> the offending macros.</p>
<h2 id="windows-macros">Windows macros</h2>
<p><code>_T</code> is known to conflict, but is hardcoded into the compiler and can't be disabled. For this reason, <code>Tesla</code> units use the <code>_Te</code> abbreviation.</p>
<p>The following macros may need to be undefined on the Windows platform to use <code>units</code>:</p>
<p><code>cpp    #undef pascal    #include &lt;units.h&gt;</code></p>
<h2 id="arm-macros">ARM macros</h2>
<p>The following macros may need to be undefined on the ARM platform to use <code>units::literals</code>:</p>
<p><code>cpp    #undef _U    #undef _L    #undef _N    #undef _S    #undef _P    #undef _C    #undef _X    #undef _B    #define UNIT_LIB_DISABLE_IOSTREAM // it's prudent to disable IOStream on embedded platforms as well.    #include &lt;units.h&gt;</code></p>
<p>It's best to undefine macros on an as-needed basis.</p>
<h1 id="cmake-instructions">CMake Instructions</h1>
<p>There are several ways to incorporate <code>units.h</code> into your project. The simplest is to just copy <code>include/units.h</code> into your project include directory (which the licensing allows you to do). However, you'll have to properly set up the necessary compilation flags for C++14 (<code>-std=c++14</code> on gcc).</p>
<p>However, if you are already using CMake as your build system, the recommended way to include <code>units</code> is to copy the entire <code>units</code> project as a subdirectory within your own top-level project folder. Then, in your CMakeLists.txt file add</p>
<p>```cmake add_subdirectory(units)</p>
<p>add_executable(<span class="math inline"><em>P</em><em>R</em><em>O</em><em>J</em><em>E</em><em>C</em><em>T</em><sub><em>N</em></sub><em>A</em><em>M</em><em>E</em><em>m</em><em>a</em><em>i</em><em>n</em>.<em>c</em><em>p</em><em>p</em>)<em>t</em><em>a</em><em>r</em><em>g</em><em>e</em><em>t</em><sub><em>l</em></sub><em>i</em><em>n</em><em>k</em><sub><em>l</em></sub><em>i</em><em>b</em><em>r</em><em>a</em><em>r</em><em>i</em><em>e</em><em>s</em>(</span>{PROJECT_NAME} units) ```</p>
<p>Also, if you are distributing headers that depends on units.h, you shoud consider using cmake's <code>find_package</code> to check if the header is installed on the user's system:</p>
<pre><code>```cmake
find_package(units)

add_library(${PROJECT_NAME} my_lib.cpp)
target_link_libraries(${PROJECT_NAME} units::units)
```</code></pre>
<p>The include path properties are part of the <code>units</code> target, so adding it as a subdirectory and linking against it is all you need to do, no need to worry about additional include directories.</p>
<p>If you don't care about the unit tests, you can minimize compile time by invoking CMake with the following option:</p>
<p><code>bash    cmake -DBUILD_TESTS=OFF ..    cmake -build .</code> # Build Instructions</p>
<p>The library itself consists of a single header <a href="include/units.h">units.h</a>, and can be included into your project without being built.</p>
<p>The unit tests and documentation can be built with CMake. A doxygen installation is required to generate the documentation, and a Tex install is needed if pdf documentation is desired.</p>
<p>To build the tests:</p>
<h2 id="windows">Windows</h2>
<ol style="list-style-type: decimal">
<li>Ensure <a href="https://cmake.org/download/"><code>cmake</code></a> is installed, and that the <code>bin</code> directory is in your <code>%PATH%</code> variable, and that a compiler like <a href="https://www.visualstudio.com/post-download-vs?sku=community&amp;clcid=0x409&amp;downloadrename=true#"><code>Visual Studio 2015 Community Edition</code></a> is installed.</li>
<li>clone the repository or download the <code>.zip</code> package.</li>
<li>Open a <code>cmd</code> terminal and navigate to the source directory.</li>
<li>Type the following commands:</li>
</ol>
<ul>
<li><code>md build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li>The tests will be created in an executable called <code>unitLibTest.exe</code> in the folder <code>build/unitTests/Release</code>.</li>
</ol>
<h2 id="linux">Linux</h2>
<ol style="list-style-type: decimal">
<li>Ensure you are using cmake 3.2 or later. You can verify this with <code>cmake --version</code>.</li>
<li>Ensure you are using gcc version 4.9 or greater. You can verify this with <code>gcc --version</code>.</li>
<li>clone the repository or download the <code>.tar.gz</code> package.</li>
<li>Open a terminal and navigate to the source directory.</li>
<li>Type the following commands:</li>
</ol>
<ul>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -Wno-dev ..</code></li>
<li><code>cmake --build . --config Release</code></li>
</ul>
<ol start="6" style="list-style-type: decimal">
<li>The tests will be created in an executable called <code>unitLibTest</code> in the folder <code>build/unitTests</code>.</li>
</ol>
<h1 id="previous-releases">Previous Releases</h1>
<ul>
<li><a href="https://github.com/nholthaus/units/releases/tag/v2.0.3"><code>v2.0.3</code></a><br />
</li>
<li><code>unit_t</code> types are now trivial types.</li>
<li><code>unit_t</code> types support the unary minus (negation) operator.</li>
<li>Compile-time unit arithmetic via <code>unit_value_t</code>.</li>
<li>Unit-enabled ports of most <code>&lt;cmath&gt;</code> functions, including c++11 extensions.</li>
<li>Square-root manipulators for <code>unit</code>, <code>unit_t</code>, and <code>unit_value_t</code>.</li>
<li>Improved documentation.</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.3.0"><code>v1.3.0</code></a><br />
</li>
<li>Adds ostream support.</li>
<li>bug fixes.</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.2.2"><code>v1.2.2</code></a><br />
</li>
<li>Bug fixes (#1) and namespace cleanup.</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.2.0"><code>v1.2.0</code></a><br />
</li>
<li>Adds angular velocity units.</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.1.1"><code>v1.1.1</code></a><br />
</li>
<li>Adds Doxygen and additional type traits.</li>
<li><a href="https://github.com/nholthaus/units/releases/tag/v1.0.0"><code>v1.0.0</code></a><br />
</li>
<li>Initial release.</li>
</ul>
