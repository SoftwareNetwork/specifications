<h1 id="cpp-taskflow">Cpp-Taskflow <img align="right" width="10%" src="image/cpp-taskflow_logo.png"></h1>
<p><a href="https://app.codacy.com/app/tsung-wei-huang/cpp-taskflow?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=cpp-taskflow/cpp-taskflow&amp;utm_campaign=Badge_Grade_Dashboard"><img src="https://api.codacy.com/project/badge/Grade/bb04cb8e4aca401b8206c054e79fd5e3" alt="Codacy Badge" /></a> <a href="https://travis-ci.com/cpp-taskflow/cpp-taskflow"><img src="https://travis-ci.com/cpp-taskflow/cpp-taskflow.svg?branch=master" alt="Linux Build Status" /></a> <a href="https://ci.appveyor.com/project/TsungWeiHuang/cpp-taskflow"><img src="https://ci.appveyor.com/api/projects/status/te9bjp4yfhq7f8hq?svg=true" alt="Windows Build status" /></a> <a href="https://en.wikipedia.org/wiki/C%2B%2B#Standardization"><img src="image/cpp17.svg" alt="Standard" /></a> <a href="https://github.com/cpp-taskflow/cpp-taskflow/archive/master.zip"><img src="image/download.svg" alt="Download" /></a> <a href="https://cpp-taskflow.github.io/cpp-taskflow/index.html"><img src="image/api-doc.svg" alt="Wiki" /></a> <a href="./awesome-parallel-computing.md"><img src="image/awesome-resources.svg" alt="Resources" /></a></p>
<p>A fast C++ <em>header-only</em> library to help you quickly write parallel programs with complex task dependencies</p>
<h1 id="why-cpp-taskflow">Why Cpp-Taskflow?</h1>
<p>Cpp-Taskflow is by far faster, more expressive, and easier for drop-in integration than existing parallel task programming libraries such as <a href="http://www.nersc.gov/users/software/programming-models/openmp/openmp-tasking/">OpenMP Tasking</a> and Intel <a href="https://www.threadingbuildingblocks.org/tutorial-intel-tbb-flow-graph">TBB FlowGraph</a> in handling complex parallel workloads.</p>
<div class="figure">
<img src="image/performance.jpg" />

</div>
<p>Cpp-Taskflow lets you quickly implement task decomposition strategies that incorporate both regular and irregular compute patterns, together with an efficient <em>work-stealing</em> scheduler to optimize your multithreaded performance.</p>
<table>
<thead>
<tr class="header">
<th>Without Cpp-Taskflow</th>
<th>With Cpp-Taskflow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="image/profile_without_taskflow.gif" /></td>
<td><img src="image/profile_with_taskflow.gif" /></td>
</tr>
</tbody>
</table>
<p>Cpp-Taskflow has a unified interface for both <em>static</em> tasking and <em>dynamic</em> tasking, allowing users to quickly master our parallel task programming model in a natural idiom.</p>
<table>
<thead>
<tr class="header">
<th align="center">Static Tasking</th>
<th align="center">Dynamic Tasking</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="image/static_graph.png" /></td>
<td align="center"><img align="right" src="image/dynamic_graph.png" width="100%"></td>
</tr>
</tbody>
</table>
<p>Cpp-Taskflow provides a composable task dependency graph interface to enable high performance and high developer productivity at the same time.</p>
<div class="figure">
<img src="image/framework.png" />

</div>
<p>Cpp-Taskflow let users easily monitor the thread activities and analyze their programs' performance through <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool">chrome://tracing</a>.</p>
<div class="figure">
<img src="image/timeline.png" />

</div>
<p>Cpp-Taskflow is part of the <a href="https://www.darpa.mil/news-events/2017-09-13">DARPA IDEA research program</a>. We are committed to support trustworthy developments for both academic and industrial research projects in parallel computing. Check out <a href="#who-is-using-cpp-taskflow">Who is Using Cpp-Taskflow</a> and what our users say:</p>
<ul>
<li><em>&quot;Cpp-Taskflow is the cleanest Task API I've ever seen.&quot; <a href="https://github.com/damienhocking">damienhocking</a></em></li>
<li><em>&quot;Cpp-Taskflow has a very simple and elegant tasking interface. The performance also scales very well.&quot; <a href="https://github.com/totalgee">totalgee</a></em></li>
<li><em>&quot;Cpp-Taskflow lets me handle parallel processing in a smart way.&quot; <a href="https://cpp-learning.com/cpp-taskflow/">Hayabusa</a></em></li>
<li><em>&quot;Best poster award for open-source parallel programming library.&quot; <a href="https://github.com/CppCon/CppCon2018">Cpp Conference 2018</a></em></li>
</ul>
<p>See a quick <a href="https://cpp-taskflow.github.io/">presentation</a> and visit the <a href="https://cpp-taskflow.github.io/cpp-taskflow/index.html">documentation</a> to learn more about Cpp-Taskflow. Technical details can be referred to our <a href="doxygen/reference/ipdps19.pdf">IEEE IPDPS19 paper</a>.</p>
<p>:exclamation: Notice that starting at v2.2.0 (including this master branch) we isolated the executor interface from Taskflow to improve the programming model and performance. This caused a few breaks in using Cpp-Taskflow. Please refer to <a href="https://cpp-taskflow.github.io/cpp-taskflow/release-2-2-0.html">release-notes</a> for adapting to this new change.</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#get-started-with-cpp-taskflow">Get Started with Cpp-Taskflow</a></li>
<li><a href="#create-a-taskflow-graph">Create a Taskflow Graph</a></li>
<li><a href="#step-1-create-a-task">Step 1: Create a Task</a></li>
<li><a href="#step-2-define-task-dependencies">Step 2: Define Task Dependencies</a></li>
<li><a href="#step-3-execute-a-taskflow">Step 3: Execute a Taskflow</a></li>
<li><a href="#dynamic-tasking">Dynamic Tasking</a></li>
<li><a href="#step-1-create-a-subflow">Step 1: Create a Subflow</a></li>
<li><a href="#step-2-detach-or-join-a-subflow">Step 2: Detach or Join a Subflow</a></li>
<li><a href="#taskflow-composition">Taskflow Composition</a></li>
<li><a href="#debug-a-taskflow-graph">Debug a Taskflow Graph</a></li>
<li><a href="#monitor-thread-activities">Monitor Thread Activities</a></li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#caveats">Caveats</a></li>
<li><a href="#system-requirements">System Requirements</a></li>
<li><a href="#compile-unit-tests-and-examples">Compile Unit Tests and Examples</a></li>
<li><a href="#get-involved">Get Involved</a></li>
<li><a href="#who-is-using-cpp-taskflow">Who is Using Cpp-Taskflow?</a></li>
<li><a href="#contributors">Contributors</a></li>
</ul>
<h1 id="get-started-with-cpp-taskflow">Get Started with Cpp-Taskflow</h1>
<p>The following example <a href="./example/simple.cpp">simple.cpp</a> shows the basic Cpp-Taskflow API you need in most applications.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;taskflow/taskflow.hpp&gt;</span><span class="pp">  </span><span class="co">// Cpp-Taskflow is header-only</span>

<span class="dt">int</span> main(){
  
  tf::Executor executor;
  tf::Taskflow taskflow;

  <span class="kw">auto</span> [A, B, C, D] = taskflow.emplace(
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskA</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">//  task dependency graph</span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskB</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">// </span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskC</span><span class="sc">\n</span><span class="st">&quot;</span>; },               <span class="co">//          +---+          </span>
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TaskD</span><span class="sc">\n</span><span class="st">&quot;</span>; }                <span class="co">//    +----&gt;| B |-----+   </span>
  );                                                 <span class="co">//    |     +---+     |</span>
                                                     <span class="co">//  +---+           +-v-+ </span>
  A.precede(B);  <span class="co">// A runs before B                  //  | A |           | D | </span>
  A.precede(C);  <span class="co">// A runs before C                  //  +---+           +-^-+ </span>
  B.precede(D);  <span class="co">// B runs before D                  //    |     +---+     |    </span>
  C.precede(D);  <span class="co">// C runs before D                  //    +----&gt;| C |-----+    </span>
                                                     <span class="co">//          +---+          </span>
  executor.run(taskflow);

  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Compile and run the code with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="ex">g++</span> simple.cpp -std=c++1z -O2 -lpthread -o simple
<span class="ex">~</span>$ <span class="ex">./simple</span>
<span class="ex">TaskA</span>
<span class="ex">TaskC</span>  <span class="op">&lt;</span>-- concurrent with TaskB
<span class="ex">TaskB</span>  <span class="op">&lt;</span>-- concurrent with TaskC
<span class="ex">TaskD</span></code></pre></div>
<p>It is clear now Cpp-Taskflow is powerful in parallelizing tasks with complex dependencies. The following example demonstrates a concurrent execution of 10 tasks with 15 dependencies. With Cpp-Taskflow, you only need <strong><em>15 lines of code</em></strong>.</p>
<p><img align="right" src="image/complex.png" width="30%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// source dependencies</span>
S.precede(a0);    <span class="co">// S runs before a0</span>
S.precede(b0);    <span class="co">// S runs before b0</span>
S.precede(a1);    <span class="co">// S runs before a1</span>

<span class="co">// a_ -&gt; others</span>
a0.precede(a1);   <span class="co">// a0 runs before a1</span>
a0.precede(b2);   <span class="co">// a0 runs before b2</span>
a1.precede(a2);   <span class="co">// a1 runs before a2</span>
a1.precede(b3);   <span class="co">// a1 runs before b3</span>
a2.precede(a3);   <span class="co">// a2 runs before a3</span>

<span class="co">// b_ -&gt; others</span>
b0.precede(b1);   <span class="co">// b0 runs before b1</span>
b1.precede(b2);   <span class="co">// b1 runs before b2</span>
b2.precede(b3);   <span class="co">// b2 runs before b3</span>
b2.precede(a3);   <span class="co">// b2 runs before a3</span>

<span class="co">// target dependencies</span>
a3.precede(T);    <span class="co">// a3 runs before T</span>
b1.precede(T);    <span class="co">// b1 runs before T</span>
b3.precede(T);    <span class="co">// b3 runs before T</span></code></pre></div>
<h1 id="create-a-taskflow-graph">Create a Taskflow Graph</h1>
<p>Cpp-Taskflow defines a very expressive API to create task dependency graphs. Most applications are developed through the following three steps.</p>
<h2 id="step-1-create-a-task">Step 1: Create a Task</h2>
<p>Create a taskflow object to build a task dependency graph:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow taskflow;</code></pre></div>
<p>A task is a callable object for which <a href="https://en.cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> is applicable. Use the method <code>emplace</code> to create a task:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = taskflow.emplace([](){ <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task A</span><span class="sc">\n</span><span class="st">&quot;</span>; });</code></pre></div>
<p>You can create multiple tasks at one time:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> [A, B, C, D] = taskflow.emplace(
  [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task A</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task B</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task C</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task D</span><span class="sc">\n</span><span class="st">&quot;</span>; }
);</code></pre></div>
<h2 id="step-2-define-task-dependencies">Step 2: Define Task Dependencies</h2>
<p>You can add dependency links between tasks to enforce one task run after another. The dependency links must be specified in a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a>. The handle <code>Task</code> supports different methods for you to describe task dependencies.</p>
<p><strong>Precede</strong>: Adding a preceding link forces one task to run before another.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.precede(B);  <span class="co">// A runs before B.</span></code></pre></div>
<p><strong>Gather</strong>: Adding a gathering link forces one task to run after another.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.gather(B);  <span class="co">// A runs after B</span></code></pre></div>
<h2 id="step-3-execute-a-taskflow">Step 3: Execute a Taskflow</h2>
<p>To execute a taskflow, you need to create an <em>executor</em>. An executor manages a set of worker threads to execute a taskflow through an efficient <em>work-stealing</em> algorithm.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Executor executor; </code></pre></div>
<p>The executor provides a rich set of methods to run a taskflow. You can run a taskflow one or multiple times, or until a stopping criteria is met. These methods are non-blocking and all return a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> to let you query the execution status.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.run(taskflow);                                              <span class="co">// run the taskflow once</span>
executor.run(taskflow, [](){ <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;done 1 run</span><span class="sc">\n</span><span class="st">&quot;</span>; } );       <span class="co">// run once with a callback</span>
executor.run_n(taskflow, <span class="dv">4</span>);                                         <span class="co">// run four times</span>
executor.run_n(taskflow, <span class="dv">4</span>, [](){ <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;done 4 runs</span><span class="sc">\n</span><span class="st">&quot;</span>; });  <span class="co">// run 4 times with a callback</span>

<span class="co">// run n times until the predicate becomes true</span>
executor.run_until(taskflow, [counter=<span class="dv">4</span>](){ <span class="cf">return</span> --counter == <span class="dv">0</span>; } );

<span class="co">// run n times until the predicate becomes true and invoke the callback on completion</span>
executor.run_until(taskflow, [counter=<span class="dv">4</span>](){ <span class="cf">return</span> --counter == <span class="dv">0</span>; }, 
                             [](){ <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Execution finishes</span><span class="sc">\n</span><span class="st">&quot;</span>; } );</code></pre></div>
<p>You can call <code>wait_for_all</code> to block the executor until all associated taskflows complete.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.wait_for_all();  <span class="co">// block until all associated tasks finish</span></code></pre></div>
<p>Notice that executor does not own any taskflow. It is your responsibility to keep a taskflow alive during its execution, or it can result in undefined behavior. In most applications, you need only one executor to run multiple taskflows each representing a specific part of your parallel decomposition.</p>
<h1 id="dynamic-tasking">Dynamic Tasking</h1>
<p>Another powerful feature of Taskflow is <em>dynamic</em> tasking. Dynamic tasks are those created during the execution of a taskflow. These tasks are spawned by a parent task and are grouped together to a <em>subflow</em> graph. The example below demonstrates how to create a subflow that spawns three tasks at runtime.</p>
<p><img align="right" src="image/subflow_join.png" width="30%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create three regular tasks</span>
tf::Task A = tf.emplace([](){}).name(<span class="st">&quot;A&quot;</span>);
tf::Task C = tf.emplace([](){}).name(<span class="st">&quot;C&quot;</span>);
tf::Task D = tf.emplace([](){}).name(<span class="st">&quot;D&quot;</span>);

<span class="co">// create a subflow graph (dynamic tasking)</span>
tf::Task B = tf.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  tf::Task B3 = subflow.emplace([](){}).name(<span class="st">&quot;B3&quot;</span>);
  B1.precede(B3);
  B2.precede(B3);
}).name(<span class="st">&quot;B&quot;</span>);
            
A.precede(B);  <span class="co">// B runs after A </span>
A.precede(C);  <span class="co">// C runs after A </span>
B.precede(D);  <span class="co">// D runs after B </span>
C.precede(D);  <span class="co">// D runs after C </span></code></pre></div>
<p>By default, a subflow graph joins to its parent node. This guarantees a subflow graph to finish before the successors of its parent node. You can disable this feature by calling <code>subflow.detach()</code>. For example, detaching the above subflow will result in the following execution flow:</p>
<p><img align="right" src="image/subflow_detach.png" width="35%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create a &quot;detached&quot; subflow graph (dynamic tasking)</span>
tf::Task B = tf.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  tf::Task B3 = subflow.emplace([](){}).name(<span class="st">&quot;B3&quot;</span>);
  B1.precede(B3);
  B2.precede(B3);

  <span class="co">// detach this subflow from task B</span>
  subflow.detach();
}).name(<span class="st">&quot;B&quot;</span>);</code></pre></div>
<h2 id="step-1-create-a-subflow">Step 1: Create a Subflow</h2>
<p>Cpp-Taskflow has an unified interface for static and dynamic tasking. To create a subflow for dynamic tasking, emplace a callable with one argument of type <code>tf::Subflow</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = tf.emplace([] (tf::Subflow&amp; subflow) {});</code></pre></div>
<p>A subflow is a lightweight object that allows you to create arbitrary dependency graphs at runtime. All graph building methods defined in taskflow can be used in the subflow.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = tf.emplace([] (tf::Subflow&amp; subflow) {
  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task A is spawning two subtasks A1 and A2&quot;</span> &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
  <span class="kw">auto</span> [A1, A2] = subflow.emplace(
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;subtask A1&quot;</span> &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>; },
    [] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;subtask A2&quot;</span> &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>; }
    A1.precede(A2);
  );
});</code></pre></div>
<p>A subflow can be nested or recursive. You can create another subflow from the execution of a subflow and so on.</p>
<p><img align="right" src="image/nested_subflow.png" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = tf.emplace([] (tf::Subflow&amp; sbf) {
  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A spawns A1 &amp; subflow A2</span><span class="sc">\n</span><span class="st">&quot;</span>;
  tf::Task A1 = sbf.emplace([] () { 
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;subtask A1</span><span class="sc">\n</span><span class="st">&quot;</span>; 
  }).name(<span class="st">&quot;A1&quot;</span>);

  tf::Task A2 = sbf.emplace([] (tf::Subflow&amp; sbf2) {
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;A2 spawns A2_1 &amp; A2_2</span><span class="sc">\n</span><span class="st">&quot;</span>;
    tf::Task A2_1 = sbf2.emplace([] () { 
      <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;subtask A2_1</span><span class="sc">\n</span><span class="st">&quot;</span>; 
    }).name(<span class="st">&quot;A2_1&quot;</span>);
    tf::Task A2_2 = sbf2.emplace([] () { 
      <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;subtask A2_2</span><span class="sc">\n</span><span class="st">&quot;</span>; 
    }).name(<span class="st">&quot;A2_2&quot;</span>);
    A2_1.precede(A2_2);
  }).name(<span class="st">&quot;A2&quot;</span>);

  A1.precede(A2);
}).name(<span class="st">&quot;A&quot;</span>);</code></pre></div>
<h2 id="step-2-detach-or-join-a-subflow">Step 2: Detach or Join a Subflow</h2>
<p>A subflow will run after leaving the execution context of its parent task. By default, a subflow joins to its parent task. Depending on applications, you can detach a subflow to enable more parallelism.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Task A = tf.emplace([] (tf::Subflow&amp; subflow) {
  subflow.detach();  <span class="co">// detach this subflow from its parent task A</span>
});  <span class="co">// subflow starts to run after the callable scope</span></code></pre></div>
<p>Detaching or joining a subflow has different meaning in the completion status of its parent node. In a joined subflow, the completion of its parent node is defined as when all tasks inside the subflow (possibly nested) finish.</p>
<p><img align="right" src="image/joined_subflow_future.png" width="15%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> value {<span class="dv">0</span>};

<span class="co">// create a joined subflow</span>
tf::Task A = tf.emplace([&amp;] (tf::Subflow&amp; subflow) {
  subflow.emplace([&amp;]() { 
    value = <span class="dv">10</span>; 
  }).name(<span class="st">&quot;A1&quot;</span>);
}).name(<span class="st">&quot;A&quot;</span>);

<span class="co">// create a task B after A</span>
tf::Task B = tf.emplace([&amp;] () { 
  assert(value == <span class="dv">10</span>); 
}).name(<span class="st">&quot;B&quot;</span>);

<span class="co">// A1 must finish before A and therefore before B</span>
A.precede(B);</code></pre></div>
<p>When a subflow is detached from its parent task, it becomes a parallel execution line to the current flow graph and will eventually join to the same taskflow.</p>
<p><img align="right" src="image/detached_subflow_future.png" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> value {<span class="dv">0</span>};

<span class="co">// create a detached subflow</span>
tf::Task A = tf.emplace([&amp;] (tf::Subflow&amp; subflow) {
  subflow.emplace([&amp;]() { value = <span class="dv">10</span>; }).name(<span class="st">&quot;A1&quot;</span>);
  subflow.detach();
}).name(<span class="st">&quot;A&quot;</span>);

<span class="co">// create a task B after A</span>
tf::Task B = tf.emplace([&amp;] () { 
  <span class="co">// no guarantee for value to be 10</span>
}).name(<span class="st">&quot;B&quot;</span>);

A.precede(B);</code></pre></div>
<h1 id="taskflow-composition">Taskflow Composition</h1>
<p>A powerful feature of <code>tf::Taskflow</code> is its composability. You can create multiple task graphs from different parts of your workload and use them to compose a large graph through the <code>composed_of</code> method.</p>
<p><img align="right" src="image/composition.png" width="50%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Taskflow f1, f2;

<span class="co">// Add two tasks </span>
<span class="kw">auto</span> [f1A, f1B] = f1.emplace( 
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f1A</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f1B</span><span class="sc">\n</span><span class="st">&quot;</span>; }
);

<span class="co">// Add two tasks </span>
<span class="kw">auto</span> [f2A, f2B, f2C] = f2.emplace( 
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2A</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2B</span><span class="sc">\n</span><span class="st">&quot;</span>; },
  []() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Task f2C</span><span class="sc">\n</span><span class="st">&quot;</span>; }
);

<span class="co">// Use f1 to compose f2</span>
<span class="kw">auto</span> f1_module_task = f2.composed_of(f1);

f2A.precede(f1_module_task);
f2B.precede(f1_module_task);
f1_module_task.precede(f2C);</code></pre></div>
<p>Similarly, <code>composed_of</code> returns a task handle and you can use the same methods <code>precede</code> and <code>gather</code> to create dependencies. You can compose a taskflow from multiple taskflows and use the result to compose another taskflow and so on.</p>
<h1 id="debug-a-taskflow-graph">Debug a Taskflow Graph</h1>
<p>Concurrent programs are notoriously difficult to debug. Cpp-Taskflow leverages the graph properties to relieve the debugging pain. To debug a taskflow graph, (1) name tasks and dump the graph, and (2) start with one thread before going multiple. Currently, Cpp-Taskflow supports <a href="https://www.graphviz.org/">GraphViz</a> format.</p>
<h2 id="dump-a-taskflow-graph">Dump a Taskflow Graph</h2>
<p>Each time you create a task or add a dependency, it adds a node or an edge to the taskflow graph. You can dump it to a GraphViz format using the method <code>dump</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// debug.cpp</span>
tf::Taskflow taskflow;

tf::Task A = taskflow.emplace([] () {}).name(<span class="st">&quot;A&quot;</span>);
tf::Task B = taskflow.emplace([] () {}).name(<span class="st">&quot;B&quot;</span>);
tf::Task C = taskflow.emplace([] () {}).name(<span class="st">&quot;C&quot;</span>);
tf::Task D = taskflow.emplace([] () {}).name(<span class="st">&quot;D&quot;</span>);
tf::Task E = taskflow.emplace([] () {}).name(<span class="st">&quot;E&quot;</span>);

A.precede(B, C, E); 
C.precede(D);
B.precede(D, E); 

taskflow.dump(<span class="bu">std::</span>cout);</code></pre></div>
<p>Run the program and inspect whether dependencies are expressed in the right way. There are a number of free <a href="https://github.com/CodeFreezr/awesome-graphviz">GraphViz tools</a> you could find online to visualize your Taskflow graph.</p>
<p><img align="right" src="image/graphviz.png" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="ex">./debug</span>

<span class="ex">//</span> Taskflow with five tasks and six dependencies
<span class="ex">digraph</span> Taskflow {
  <span class="st">&quot;A&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;B&quot;</span>
  <span class="st">&quot;A&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;C&quot;</span>
  <span class="st">&quot;A&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;E&quot;</span>
  <span class="st">&quot;B&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;D&quot;</span>
  <span class="st">&quot;B&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;E&quot;</span>
  <span class="st">&quot;C&quot;</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="st">&quot;D&quot;</span>
}</code></pre></div>
<h2 id="dump-a-subflow-graph">Dump a Subflow Graph</h2>
<p>When you have dynamic tasks (subflows), you cannot simply use the <code>dump</code> method because it displays only the static portion. Instead, you need to execute the graph to spawn dynamic tasks first.</p>
<p><img align="right" src="image/debug_subflow.png" width="25%"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Executor executor;
tf::Taskflow taskflow;

tf::Task A = taskflow.emplace([](){}).name(<span class="st">&quot;A&quot;</span>);

<span class="co">// create a subflow of two tasks B1-&gt;B2</span>
tf::Task B = taskflow.emplace([] (tf::Subflow&amp; subflow) {
  tf::Task B1 = subflow.emplace([](){}).name(<span class="st">&quot;B1&quot;</span>);
  tf::Task B2 = subflow.emplace([](){}).name(<span class="st">&quot;B2&quot;</span>);
  B1.precede(B2);
}).name(<span class="st">&quot;B&quot;</span>);

A.precede(B);

executor.run(tf).get();  <span class="co">// run the taskflow</span>
tf.dump(<span class="bu">std::</span>cout);      <span class="co">// dump the graph including dynamic tasks</span></code></pre></div>
<h1 id="monitor-thread-activities">Monitor Thread Activities</h1>
<p>Understanding thread activities is very important for performance analysis. Cpp-Taskflow provides a default <em>observer</em> of type <code>tf::ExecutorObserver</code> that lets users observe when a thread starts or stops participating in task scheduling.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::executor executor;
<span class="kw">auto</span> observer = executor.make_observer&lt;tf::ExecutorObserver&gt;();</code></pre></div>
<p>When you are running a task dependency graph, the observer will automatically record the start and end timestamps of each executed task. You can dump the entire execution timelines into a JSON file.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.run(taskflow1);               <span class="co">// run a task dependency graph 1</span>
executor.run(taskflow2);               <span class="co">// run a task dependency graph 2</span>
executor.wait_for_all();               <span class="co">// block until all tasks finish</span>

<span class="bu">std::</span>ofstream ofs(<span class="st">&quot;timestamps.json&quot;</span>);
observer-&gt;dump(ofs);                   <span class="co">// dump the timeline to a JSON file</span></code></pre></div>
<p>You can open the chrome browser to visualize the execution timelines through the <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool">chrome://tracing</a> developer tool. In the tracing view, click the <code>Load</code> button to read the JSON file. You shall see the tracing graph.</p>
<div class="figure">
<img src="image/timeline.png" />

</div>
<p>Each task is given a name of <code>i_j</code> where <code>i</code> is the thread id and <code>j</code> is the task number. You can pan or zoom in/out the timeline to get into a detailed view.</p>
<h1 id="api-reference">API Reference</h1>
<p>The official <a href="https://cpp-taskflow.github.io/cpp-taskflow/index.html">documentation</a> explains a complete list of Cpp-Taskflow API. In this section, we highlight a short list of commonly used methods.</p>
<h2 id="taskflow-api">Taskflow API</h2>
<p>The class <code>tf::Taskflow</code> is the main place to create a task dependency graph. The table below summarizes a list of commonly used methods.</p>
<table style="width:54%;">
<colgroup>
<col width="12%" />
<col width="13%" />
<col width="11%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Argument</th>
<th>Return</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>emplace</td>
<td>callables</td>
<td>tasks</td>
<td>create a task with a given callable(s)</td>
</tr>
<tr class="even">
<td>placeholder</td>
<td>none</td>
<td>task</td>
<td>insert a node without any work; work can be assigned later</td>
</tr>
<tr class="odd">
<td>parallel_for</td>
<td>beg, end, callable, group</td>
<td>task pair</td>
<td>apply the callable in parallel and group-by-group to the result of dereferencing every iterator in the range</td>
</tr>
<tr class="even">
<td>parallel_for</td>
<td>beg, end, step, callable, group</td>
<td>task pair</td>
<td>apply the callable in parallel and group-by-group to a index-based range</td>
</tr>
<tr class="odd">
<td>reduce</td>
<td>beg, end, res, bop</td>
<td>task pair</td>
<td>reduce a range of elements to a single result through a binary operator</td>
</tr>
<tr class="even">
<td>transform_reduce</td>
<td>beg, end, res, bop, uop</td>
<td>task pair</td>
<td>apply a unary operator to each element in the range and reduce them to a single result through a binary operator</td>
</tr>
<tr class="odd">
<td>num_workers</td>
<td>none</td>
<td>size</td>
<td>query the number of working threads in the pool</td>
</tr>
<tr class="even">
<td>dump</td>
<td>ostream</td>
<td>none</td>
<td>dump the taskflow to an output stream in GraphViz format</td>
</tr>
</tbody>
</table>
<h3 id="emplaceplaceholder"><em>emplace/placeholder</em></h3>
<p>You can use <code>emplace</code> to create a task from a target callable.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create a task through emplace</span>
tf::Task task = tf.emplace([] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;my task</span><span class="sc">\n</span><span class="st">&quot;</span>; });</code></pre></div>
<p>When task cannot be determined beforehand, you can create a placeholder and assign the calalble later.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// create a placeholder and use it to build dependency</span>
tf::Task A = tf.emplace([](){});
tf::Task B = tf.placeholder();
A.precede(B);

<span class="co">// assign the callable later in the control flow</span>
B.work([](){ <span class="co">/* do something */</span> });</code></pre></div>
<h3 id="parallel_for"><em>parallel_for</em></h3>
<p>The method <code>parallel_for</code> creates a subgraph that applies the callable to each item in the given range of a container.</p>
<p><img align="right" width="40%" src="image/parallel_for.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// apply callable to each container item in parallel</span>
<span class="kw">auto</span> v = {<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>};
<span class="kw">auto</span> [S, T] = tf.parallel_for(
  v.begin(),    <span class="co">// beg of range</span>
  v.end(),      <span class="co">// end of range</span>
  [] (<span class="dt">int</span> i) { 
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;parallel in &quot;</span> &lt;&lt; i &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
  }
);
<span class="co">// add dependencies via S and T.</span></code></pre></div>
<p>Changing the group size can force intra-group tasks to run sequentially and inter-group tasks to run in parallel. Depending on applications, different group sizes can result in significant performance hit.</p>
<p><img align="right" width="20%" src="image/parallel_for_2.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// apply callable to two container items at a time in parallel</span>
<span class="kw">auto</span> v = {<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>};
<span class="kw">auto</span> [S, T] = tf.parallel_for(
  v.begin(),    <span class="co">// beg of range</span>
  v.end(),      <span class="co">// end of range</span>
  [] (<span class="dt">int</span> i) { 
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;AB and CD run in parallel&quot;</span> &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
  },
  <span class="dv">2</span>  <span class="co">// group two tasks at a time</span>
);</code></pre></div>
<p>By default, taskflow performs an even partition over worker threads if the group size is not specified (or equal to 0).</p>
<p>In addition to range-based iterator, <code>parallel_for</code> has another overload of index-based loop. The first three argument to this overload indicates starting index, ending index (exclusive), and step size.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [0, 10) with a step size of 2</span>
<span class="kw">auto</span> [S, T] = tf.parallel_for(
  <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">2</span>, 
  [] (<span class="dt">int</span> i) {
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;parallel_for on index &quot;</span> &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;
  }, 
  <span class="dv">2</span>  <span class="co">// group two tasks at a time</span>
);
<span class="co">// will print 0, 2, 4, 6, 8 (three groups, {0, 2}, {4, 6}, {8})</span></code></pre></div>
<p>You can also go opposite direction by reversing the starting index and the ending index with a negative step size.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [10, 0) with a step size of -2</span>
<span class="kw">auto</span> [S, T] = tf.parallel_for(
  <span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">2</span>, 
  [] (<span class="dt">int</span> i) {
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;parallel_for on index &quot;</span> &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;
  }
);
<span class="co">// will print 10, 8, 6, 4, 2 (group size decided by taskflow)</span></code></pre></div>
<h3 id="reducetransform_reduce"><em>reduce/transform_reduce</em></h3>
<p>The method <code>reduce</code> creates a subgraph that applies a binary operator to a range of items. The result will be stored in the referenced <code>res</code> object passed to the method. It is your responsibility to assign a correct initial value to the reduce call.</p>
<p><img align="right" width="45%" src="image/reduce.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> v = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>}; 
<span class="dt">int</span> sum {<span class="dv">0</span>};
<span class="kw">auto</span> [S, T] = tf.reduce(    <span class="co">// for example, 2 threads</span>
  v.begin(), v.end(), sum, <span class="bu">std::</span>plus&lt;<span class="dt">int</span>&gt;()
);  </code></pre></div>
<p>The method <code>transform_reduce</code> is similar to reduce, except it applies a unary operator before reduction. This is particular useful when you need additional data processing to reduce a range of elements.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>pari&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;&gt; v = { {<span class="dv">1</span>, <span class="dv">5</span>}, {<span class="dv">6</span>, <span class="dv">4</span>}, {<span class="dv">-6</span>, <span class="dv">4</span>} };
<span class="dt">int</span> min = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max();
<span class="kw">auto</span> [S, T] = tf.transform_reduce(v.begin(), v.end(), min, 
  [] (<span class="dt">int</span> l, <span class="dt">int</span> r) { <span class="cf">return</span> <span class="bu">std::</span>min(l, r); },
  [] (<span class="at">const</span> <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;&amp; pair) { <span class="cf">return</span> <span class="bu">std::</span>min(p.first, p.second); }
);</code></pre></div>
<p>By default, all reduce methods distribute the workload evenly across <code>std::thread::hardware_concurrency</code>.</p>
<h2 id="task-api">Task API</h2>
<p>Each time you create a task, the taskflow object adds a node to the present task dependency graph and return a <em>task handle</em> to you. A task handle is a lightweight object that defines a set of methods for users to access and modify the attributes of the associated task. The table below summarizes a list of commonly used methods.</p>
<table style="width:64%;">
<colgroup>
<col width="20%" />
<col width="16%" />
<col width="9%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Argument</th>
<th>Return</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>string</td>
<td>self</td>
<td>assign a human-readable name to the task</td>
</tr>
<tr class="even">
<td>work</td>
<td>callable</td>
<td>self</td>
<td>assign a work of a callable object to the task</td>
</tr>
<tr class="odd">
<td>precede</td>
<td>task list</td>
<td>self</td>
<td>enable this task to run <em>before</em> the given tasks</td>
</tr>
<tr class="even">
<td>gather</td>
<td>task list</td>
<td>self</td>
<td>enable this task to run <em>after</em> the given tasks</td>
</tr>
<tr class="odd">
<td>num_dependents</td>
<td>none</td>
<td>size</td>
<td>return the number of dependents (inputs) of this task</td>
</tr>
<tr class="even">
<td>num_successors</td>
<td>none</td>
<td>size</td>
<td>return the number of successors (outputs) of this task</td>
</tr>
</tbody>
</table>
<h3 id="name"><em>name</em></h3>
<p>The method <code>name</code> lets you assign a human-readable string to a task.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.name(<span class="st">&quot;my name is A&quot;</span>);</code></pre></div>
<h3 id="work"><em>work</em></h3>
<p>The method <code>work</code> lets you assign a callable to a task.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">A.work([] () { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello world!&quot;</span>; });</code></pre></div>
<h3 id="precede"><em>precede</em></h3>
<p>The method <code>precede</code> lets you add a preceding link from self to a task.</p>
<p><img align="right" width="20%" src="image/precede.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// make A runs before B</span>
A.precede(B);</code></pre></div>
<p>You can precede multiple tasks at one time.</p>
<p><img align="right" width="30%" src="image/broadcast.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// make A run before B, C, D, and E</span>
<span class="co">// B, C, D, and E run in parallel</span>
A.precede(B, C, D, E);</code></pre></div>
<h3 id="gather"><em>gather</em></h3>
<p>The method <code>gather</code> lets you add a preceding link from a task to self.</p>
<p><img align="right" width="30%" src="image/gather.png"></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// B, C, D, and E run in parallel</span>
<span class="co">// A runs after B, C, D, and E complete</span>
A.gather(B, C, D, E);</code></pre></div>
<h2 id="executor-api">Executor API</h2>
<p>The class <code>tf::Executor</code> is used for execution of one or multiple taskflow objects. The table below summarizes a list of commonly used methods.</p>
<table style="width:89%;">
<colgroup>
<col width="13%" />
<col width="20%" />
<col width="19%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Argument</th>
<th>Return</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Executor</td>
<td>N</td>
<td>none</td>
<td>construct an executor with N worker threads</td>
</tr>
<tr class="even">
<td>run</td>
<td>taskflow</td>
<td>future</td>
<td>run the taskflow once</td>
</tr>
<tr class="odd">
<td>run_n</td>
<td>taskflow, N</td>
<td>future</td>
<td>run the taskflow N times</td>
</tr>
<tr class="even">
<td>run_until</td>
<td>taskflow, binary predicate</td>
<td>future</td>
<td>keep running the task until the predicate returns true</td>
</tr>
<tr class="odd">
<td>make_observer</td>
<td>arguments to forward to user-derived constructor</td>
<td>pointer to the observer</td>
<td>create an observer to monitor the thread activities of the executor</td>
</tr>
</tbody>
</table>
<h3 id="executor"><em>Executor</em></h3>
<p>The constructor of tf::Executor takes an unsigned integer to initialize the executor with <code>N</code> worker threads.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">tf::Executor executor(<span class="dv">8</span>);  <span class="co">// create an executor of 8 worker threads</span></code></pre></div>
<p>The default value uses <code>std::thread::hardware_concurrency</code> to decide the number of worker threads.</p>
<h3 id="runrun_nrun_until"><em>run/run_n/run_until</em></h3>
<p>The run series are non-blocking call to execute a taskflow graph. Issuing multiple runs on the same taskflow will automatically synchronize to a sequential chain of executions.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">executor.run(taskflow);             <span class="co">// run a graph once</span>
executor.run_n(taskflow, <span class="dv">5</span>);        <span class="co">// run a graph five times</span>
executor.run_n(taskflow, my_pred);  <span class="co">// keep running a graph until the predicate becomes true</span></code></pre></div>
<p>The first run finishes before the second run, and the second run finishes before the third run.</p>
<h1 id="caveats">Caveats</h1>
<p>While Cpp-Taskflow enables the expression of very complex task dependency graph that might contain thousands of task nodes and links, there are a few amateur pitfalls and mistakes to be aware of.</p>
<ul>
<li>Having a cycle in a graph may result in running forever</li>
<li>Destructing a taskflow while it is running in one execution results in undefined behavior</li>
<li>Trying to modify a running task can result in undefined behavior</li>
</ul>
<p>Cpp-Taskflow is known to work on Linux distributions, MAC OSX, and Microsoft Visual Studio. Please <a href="mailto:twh760812@gmail.com">let me know</a> if you found any issues in a particular platform.</p>
<h1 id="system-requirements">System Requirements</h1>
<p>To use Cpp-Taskflow, you only need a <a href="https://en.wikipedia.org/wiki/C%2B%2B17">C++17</a> compiler: + GNU C++ Compiler v7.3 with -std=c++1z + Clang C++ Compiler v6.0 with -std=c++17 + Microsoft Visual Studio Version 15.7 (MSVC++ 19.14)</p>
<h1 id="compile-unit-tests-and-examples">Compile Unit Tests and Examples</h1>
<p>Cpp-Taskflow uses <a href="https://cmake.org/">CMake</a> to build examples and unit tests. We recommend using out-of-source build.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="fu">cmake</span> --version  # must be at least 3.9 or higher
<span class="ex">~</span>$ <span class="fu">mkdir</span> build
<span class="ex">~</span>$ <span class="bu">cd</span> build
<span class="ex">~</span>$ <span class="fu">cmake</span> ../
<span class="ex">~</span>$ <span class="fu">make</span> </code></pre></div>
<h2 id="unit-tests">Unit Tests</h2>
<p>Cpp-Taskflow uses <a href="https://github.com/onqtam/doctest">Doctest</a> for unit tests.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="ex">./unittest/taskflow</span></code></pre></div>
<p>Alternatively, you can use CMake's testing framework to run the unittest.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">~</span>$ <span class="bu">cd</span> build
<span class="ex">~</span>$ <span class="fu">make</span> test</code></pre></div>
<h2 id="examples">Examples</h2>
<p>The folder <code>example/</code> contains several examples and is a great place to learn to use Cpp-Taskflow.</p>
<table style="width:28%;">
<colgroup>
<col width="11%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="./example/simple.cpp">simple.cpp</a></td>
<td>uses basic task building blocks to create a trivial taskflow graph</td>
</tr>
<tr class="even">
<td><a href="./example/debug.cpp">debug.cpp</a></td>
<td>inspects a taskflow through the dump method</td>
</tr>
<tr class="odd">
<td><a href="./example/parallel_for.cpp">parallel_for.cpp</a></td>
<td>parallelizes a for loop with unbalanced workload</td>
</tr>
<tr class="even">
<td><a href="./example/reduce.cpp">reduce.cpp</a></td>
<td>performs reduce operations over linear containers</td>
</tr>
<tr class="odd">
<td><a href="./example/subflow.cpp">subflow.cpp</a></td>
<td>demonstrates how to create a subflow graph that spawns three dynamic tasks</td>
</tr>
<tr class="even">
<td><a href="./example/run_variants.cpp">run_variants.cpp</a></td>
<td>shows multiple ways to run a taskflow graph</td>
</tr>
<tr class="odd">
<td><a href="./example/composition.cpp">composition.cpp</a></td>
<td>demonstrates the decomposable interface of taskflow</td>
</tr>
<tr class="even">
<td><a href="./example/observer.cpp">observer.cpp</a></td>
<td>demonstrates how to monitor the thread activities in scheduling and running tasks</td>
</tr>
</tbody>
</table>
<h1 id="get-involved">Get Involved</h1>
<ul>
<li>Report bugs/issues by submitting a <a href="https://github.com/cpp-taskflow/cpp-taskflow/issues">GitHub issue</a></li>
<li>Submit contributions using <a href="https://github.com/cpp-taskflow/cpp-taskflow/pulls">pull requests</a></li>
<li>Learn more about Cpp-Taskflow by reading the <a href="https://cpp-taskflow.github.io/cpp-taskflow/index.html">documentation</a></li>
<li>Release notes are highlighted <a href="https://cpp-taskflow.github.io/cpp-taskflow/Releases.html">here</a></li>
<li>Read and cite our <a href="doxygen/reference/ipdps19.pdf">IPDPS19</a> paper</li>
<li>Visit a curated list of <a href="awesome-parallel-computing.md">awesome parallel computing resources</a></li>
</ul>
<h1 id="who-is-using-cpp-taskflow">Who is Using Cpp-Taskflow?</h1>
<p>Cpp-Taskflow is being used in both industry and academic projects to scale up existing workloads that incorporate complex task dependencies.</p>
<ul>
<li><a href="https://github.com/OpenTimer/OpenTimer">OpenTimer</a>: A High-performance Timing Analysis Tool for Very Large Scale Integration (VLSI) Systems</li>
<li><a href="https://github.com/tsung-wei-huang/DtCraft">DtCraft</a>: A General-purpose Distributed Programming Systems using Data-parallel Streams</li>
<li><a href="https://github.com/ForgeMistress/Firestorm">Firestorm</a>: Fighting Game Engine with Asynchronous Resource Loaders (developed by <a href="https://github.com/ForgeMistress">ForgeMistress</a>)</li>
<li><a href="https://shiva.gitbook.io/project/shiva">Shiva</a>: An extensible engine via an entity component system through scripts, DLLs, and header-only (C++)</li>
<li><a href="http://pid.lirmm.net/pid-framework/index.html">PID Framework</a>: A Global Development Methodology Supported by a CMake API and Dedicated C++ Projects</li>
<li><a href="https://github.com/novuscore/NovusCore">NovusCore</a>: An emulating project for World of Warcraft (Wrath of the Lich King 3.3.5a 12340 client build)</li>
</ul>
<p><a href="https://github.com/search?q=cpp-taskflow&amp;type=Code">More...</a></p>
<h1 id="contributors">Contributors</h1>
<p>Cpp-Taskflow is being actively developed and contributed by the following people:</p>
<ul>
<li><a href="https://tsung-wei-huang.github.io/">Tsung-Wei Huang</a> created the Cpp-Taskflow project and implemented the core routines</li>
<li><a href="https://github.com/clin99">Chun-Xun Lin</a> co-created the Cpp-Taskflow project and implemented the core routines</li>
<li><a href="https://ece.illinois.edu/directory/profile/mdfwong">Martin Wong</a> supported the Cpp-Taskflow project through NSF and DARPA funding</li>
<li><a href="https://github.com/aolofsson">Andreas Olofsson</a> supported the Cpp-Taskflow project through the DARPA IDEA project</li>
<li><a href="https://github.com/NanXiao">Nan Xiao</a> fixed compilation error of unittest on the Arch platform</li>
<li><a href="https://github.com/innermous">Vladyslav</a> fixed comment errors in README.md and examples</li>
<li><a href="https://github.com/vblanco20-1">vblanco20-1</a> fixed compilation error on Microsoft Visual Studio</li>
<li><a href="https://github.com/totalgee">Glen Fraser</a> created a standalone C++14-compatible <a href="./taskflow/threadpool/threadpool_cxx14.hpp">threadpool</a> for taskflow; various other fixes and examples</li>
<li><a href="https://github.com/gguo4">Guannan Guo</a> added different threadpool implementations to enhance the performance for taskflow</li>
<li><a href="https://github.com/patrikhuber">Patrik Huber</a> helped fixed typos in the documentation</li>
<li><a href="https://github.com/ForgeMistress">ForgeMistress</a> provided API ideas about sharing the executor to avoid thread over-subscriptiong issues</li>
<li><a href="https://github.com/Neumann-A">Alexander Neumann</a> helped modify the cmake build to make Cpp-Taskflow importable from external cmake projects</li>
<li><a href="https://github.com/paolobolzoni">Paolo Bolzoni</a> helped remove extraneous semicolons to suppress extra warning during compilation and contributed to a dataflow example</li>
<li><a href="https://github.com/Pursche">Pursche</a> fixed compilation warning on Microsoft Visual Studio</li>
<li><a href="https://github.com/KingDuckZ">KingDuckZ</a> helped discover the memory leak in the memory allocator used in graph and topology</li>
</ul>
<p>Meanwhile, we appreciate the support from many organizations for our development on Cpp-Taskflow. Please <a href="mailto:twh760812@gmail.com">let me know</a> if I forgot someone!</p>
<table>
<thead>
<tr class="header">
<th align="center"><a href="https://illinois.edu/"><img src="image/uiuc.png" width="100px"></a></th>
<th align="center"><a href="https://csl.illinois.edu/"><img src="image/csl.png" width="100px"></a></th>
<th align="center"><a href="https://www.nsf.gov/"><img src="image/nsf.png" width="100px"></a></th>
<th align="center"><a href="https://www.darpa.mil/news-events/2017-09-13"><img src="image/darpa.png" width="100px"></a></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h1 id="license">License</h1>
<p>Cpp-Taskflow is licensed under the <a href="./LICENSE">MIT License</a>.</p>
<hr />
