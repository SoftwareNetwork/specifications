<h1 id="turbopfor-fastest-integer-compression-build-status">TurboPFor: Fastest Integer Compression <a href="https://travis-ci.org/powturbo/TurboPFor"><img src="https://travis-ci.org/powturbo/TurboPFor.svg?branch=master" alt="Build Status" /></a></h1>
<ul>
<li><strong>TurboPFor: The new synonym for &quot;integer compression&quot;</strong></li>
<li>100% C (C++ headers), as simple as memcpy</li>
<li>:+1: <strong>Java</strong> Critical Natives/JNI. Access TurboPFor <strong>incl. SIMD/AVX2!</strong> from Java as fast as calling from C</li>
<li>:sparkles: <strong>FULL</strong> range 8/16/32/64 bits scalar + 16/32/64 bits SIMD functions</li>
<li>No other &quot;Integer Compression&quot; compress/decompress faster</li>
<li>:sparkles: Direct Access, <strong>integrated</strong> (SIMD/AVX2) FOR/delta/Delta of Delta/Zigzag for sorted/unsorted arrays</li>
<li>:new: <strong>16 bits</strong> + <strong>64 bits</strong> SIMD integrated functions</li>
<li><strong>For/PFor/PForDelta</strong></li>
<li><strong>Novel TurboPFor</strong> (PFor/PForDelta) scheme w./ <strong>direct access</strong> + <strong>SIMD/AVX2</strong>. :new:<strong>+RLE</strong></li>
<li>Outstanding compression/speed. More efficient than <strong>ANY</strong> other fast &quot;integer compression&quot; scheme.</li>
<li>Compress 70 times faster and decompress up to 4 times faster than OptPFD</li>
<li><strong>Bit Packing</strong></li>
<li>Fastest and most efficient <strong>&quot;SIMD Bit Packing&quot;</strong> <strong>10 Billions integers/sec (40Gb/s!)</strong></li>
<li>Scalar <strong>&quot;Bit Packing&quot;</strong> decoding nearly as fast as SIMD-Packing in realistic (No &quot;pure cache&quot;) scenarios</li>
<li><strong>Direct/Random Access</strong> : Access any single bit packed entry with <strong>zero decompression</strong></li>
<li><strong>Variable byte</strong></li>
<li>Scalar <strong>&quot;Variable Byte&quot;</strong> faster than <strong>ANY</strong> other (incl. SIMD) implementation</li>
<li><strong>Simple family</strong></li>
<li><strong>Novel</strong> <strong>&quot;Variable Simple&quot;</strong> (incl. <strong>RLE</strong>) faster and more efficient than simple16, simple-8b</li>
<li><strong>Elias fano</strong></li>
<li>Fastest <strong>&quot;Elias Fano&quot;</strong> implementation w/ or w/o SIMD/AVX2</li>
<li><strong>Transform</strong></li>
<li>Scalar &amp; SIMD Transform: Delta, Zigzag, Zigzag of delta, XOR, Transpose/Shuffle,</li>
<li>:new: <strong>lossy</strong> floating point compression with <em>TurboPFor</em> or <a href="https://github.com/powturbo/TurboTranspose">TurboTranspose</a>+lz77</li>
<li><strong>Floating Point Compression</strong></li>
<li>Delta/Zigzag + improved gorilla style + (Differential) Finite Context Method FCM/DFCM floating point compression</li>
<li>Using <strong>TurboPFor</strong>, unsurpassed compression and more than 5 GB/s throughput</li>
<li>:new: Error bound <strong>lossy</strong> floating point compression</li>
<li>:new: <strong>Time Series Compression</strong></li>
<li><strong>Fastest Gorilla</strong> 16/32/64 bits style compression (:new: <strong>zigzag of delta</strong> + <strong>RLE</strong>).</li>
<li>can compress times series to only 0.01%. Speed &gt; 10 GB/s compression and &gt; 13 GB/s decompress.</li>
<li><strong>Inverted Index ...do less, go fast!</strong></li>
<li>Direct Access to compressed <em>frequency</em> and <em>position</em> data w/ zero decompression</li>
<li><strong>Novel</strong> <strong>&quot;Intersection w/ skip intervals&quot;</strong>, decompress the minimum necessary blocks (<strong>~10-15%)!</strong>.</li>
<li><strong>Novel</strong> Implicit skips with zero extra overhead</li>
<li><strong>Novel</strong> Efficient <strong>Bidirectional</strong> Inverted Index Architecture (forward/backwards traversal) incl. &quot;integer compression&quot;.</li>
<li>more than <strong>2000! queries per second</strong> on GOV2 dataset (25 millions documents) on a <strong>SINGLE</strong> core</li>
<li>:sparkles: Revolutionary Parallel Query Processing on Multicores <strong>&gt; 7000!!! queries/sec</strong> on a simple quad core PC.<br> <strong>...forget</strong> <del>Map Reduce, Hadoop, multi-node clusters,</del> ...</li>
</ul>
<h3 id="integer-compression-benchmark">Integer Compression Benchmark:</h3>
<ul>
<li>:new: Download <a href="https://sites.google.com/site/powturbo/downloads">IcApp</a> a new benchmark for TurboPFor<br> for testing allmost all integer and floating point file types.</li>
<li>Practical (No <strong>PURE</strong> cache) &quot;integer compression&quot; benchmark w/ <strong>large</strong> arrays.</li>
<li>CPU: Skylake i7-6700 3.4GHz gcc 7.2 <strong>single</strong> thread</li>
</ul>
<h5 id="synthetic-data">- Synthetic data:</h5>
<ul>
<li><p>Generate and test (zipfian) skewed distribution (100.000.000 integers, Block size=128/256)<br> Note: Unlike general purpose compression, a small fixed size (ex. 128 integers) is in general used in &quot;integer compression&quot;. Large blocks involved, while processing queries (inverted index, search engines, databases, graphs, in memory computing,...) need to be entirely decoded.</p>
<pre><code>./icbench -a1.5 -m0 -M255 -n100M ZIPF</code></pre></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="right">C Size</th>
<th align="right">ratio%</th>
<th align="right">Bits/Integer</th>
<th align="right">C MB/s</th>
<th align="right">D MB/s</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">62,939,886</td>
<td align="right">15.7</td>
<td align="right">5.04</td>
<td align="right"><strong>1588</strong></td>
<td align="right"><strong>9400</strong></td>
<td><strong>TurboPFor256</strong></td>
</tr>
<tr class="even">
<td align="right">63,392,759</td>
<td align="right">15.8</td>
<td align="right">5.07</td>
<td align="right">1320</td>
<td align="right">6432</td>
<td><strong>TurboPFor</strong></td>
</tr>
<tr class="odd">
<td align="right">63,392,801</td>
<td align="right">15.8</td>
<td align="right">5.07</td>
<td align="right">1328</td>
<td align="right">924</td>
<td><strong>TurboPForDA</strong></td>
</tr>
<tr class="even">
<td align="right">65,060,504</td>
<td align="right">16.3</td>
<td align="right">5.20</td>
<td align="right">60</td>
<td align="right">2748</td>
<td><a href="#FastPFor">FP_SIMDOptPFor</a></td>
</tr>
<tr class="odd">
<td align="right">65,359,916</td>
<td align="right">16.3</td>
<td align="right">5.23</td>
<td align="right">32</td>
<td align="right">2436</td>
<td>PC_OptPFD</td>
</tr>
<tr class="even">
<td align="right">73,477,088</td>
<td align="right">18.4</td>
<td align="right">5.88</td>
<td align="right">408</td>
<td align="right">2484</td>
<td>PC_Simple16</td>
</tr>
<tr class="odd">
<td align="right">73,481,096</td>
<td align="right">18.4</td>
<td align="right">5.88</td>
<td align="right">624</td>
<td align="right">8748</td>
<td><a href="#FastPFor">FP_SimdFastPFor</a> 64Ki *</td>
</tr>
<tr class="even">
<td align="right">76,345,136</td>
<td align="right">19.1</td>
<td align="right">6.11</td>
<td align="right">980</td>
<td align="right">2612</td>
<td><strong>VSimple</strong></td>
</tr>
<tr class="odd">
<td align="right">91,947,533</td>
<td align="right">23.0</td>
<td align="right">7.36</td>
<td align="right">284</td>
<td align="right">11737</td>
<td><a href="#QMX">QMX</a> 64k *</td>
</tr>
<tr class="even">
<td align="right">93,285,864</td>
<td align="right">23.3</td>
<td align="right">7.46</td>
<td align="right">1568</td>
<td align="right">10232</td>
<td><a href="#FastPFor">FP_GroupSimple</a> 64Ki *</td>
</tr>
<tr class="odd">
<td align="right">95,915,096</td>
<td align="right">24.0</td>
<td align="right">7.67</td>
<td align="right">848</td>
<td align="right">3832</td>
<td>Simple-8b</td>
</tr>
<tr class="even">
<td align="right">99,910,930</td>
<td align="right">25.0</td>
<td align="right">7.99</td>
<td align="right"><strong>13976</strong></td>
<td align="right"><strong>11872</strong></td>
<td><strong>TurboPackV</strong></td>
</tr>
<tr class="odd">
<td align="right">99,910,930</td>
<td align="right">25.0</td>
<td align="right">7.99</td>
<td align="right">9468</td>
<td align="right">9404</td>
<td><strong>TurboPack</strong></td>
</tr>
<tr class="even">
<td align="right">99,910,930</td>
<td align="right">25.0</td>
<td align="right">7.99</td>
<td align="right">8420</td>
<td align="right">8876</td>
<td><strong>TurboFor</strong></td>
</tr>
<tr class="odd">
<td align="right">100,332,929</td>
<td align="right">25.1</td>
<td align="right">8.03</td>
<td align="right"><strong>14320</strong></td>
<td align="right"><strong>12124</strong></td>
<td><strong>TurboPack256V</strong></td>
</tr>
<tr class="even">
<td align="right">101,015,650</td>
<td align="right">25.3</td>
<td align="right">8.08</td>
<td align="right">9520</td>
<td align="right">9484</td>
<td><strong>TurboVByte</strong></td>
</tr>
<tr class="odd">
<td align="right">102,074,663</td>
<td align="right">25.5</td>
<td align="right">8.17</td>
<td align="right">5712</td>
<td align="right">7916</td>
<td><a href="#MaskedVByte">MaskedVByte</a></td>
</tr>
<tr class="even">
<td align="right">102,074,663</td>
<td align="right">25.5</td>
<td align="right">8.17</td>
<td align="right">2260</td>
<td align="right">4208</td>
<td><a href="#PolyCom">PC_Vbyte</a></td>
</tr>
<tr class="odd">
<td align="right">102,083,036</td>
<td align="right">25.5</td>
<td align="right">8.17</td>
<td align="right">5200</td>
<td align="right">4268</td>
<td><a href="#FastPFor">FP_VByte</a></td>
</tr>
<tr class="even">
<td align="right">112,500,000</td>
<td align="right">28.1</td>
<td align="right">9.00</td>
<td align="right">1528</td>
<td align="right"><strong>12140</strong></td>
<td><a href="#VarintG8IU">VarintG8IU</a></td>
</tr>
<tr class="odd">
<td align="right">125,000,000</td>
<td align="right">31.2</td>
<td align="right">10.00</td>
<td align="right">4788</td>
<td align="right">11288</td>
<td><a href="#StreamVByte">StreamVbyte</a></td>
</tr>
<tr class="even">
<td align="right">400,000,000</td>
<td align="right">100.00</td>
<td align="right">32.00</td>
<td align="right">8960</td>
<td align="right">8948</td>
<td>Copy</td>
</tr>
<tr class="odd">
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right">N/A</td>
<td align="right">N/A</td>
<td>EliasFano</td>
</tr>
</tbody>
</table>
<p>(*) codecs inefficient for small block sizes are tested with 64Ki integers/block.</p>
<ul>
<li>MB/s: 1.000.000 bytes/second. <strong>1000 MB/s = 1 GB/s</strong><br></li>
<li><strong>#BOLD</strong> = pareto frontier.<br></li>
<li>FP=FastPFor SC:simdcomp PC:Polycom<br></li>
<li>TurboPForDA,TurboForDA: Direct Access is normally used when accessing few individual values.<br></li>
<li><h2 id="eliasfano-can-be-directly-used-only-for-increasing-sequences">Eliasfano can be directly used only for increasing sequences</h2>
<h5 id="data-files">- Data files:</h5></li>
<li><p>gov2.sorted from <a href="#DocId">DocId data set</a> Block size=128/Delta coding</p>
<pre><code>./icbench -fS -r gov2.sorted</code></pre></li>
</ul>
<div class="figure">
<img src="ext/gov2.png" title="Speed/Ratio: Decompression" alt="Speed/Ratio" />
<p class="caption">Speed/Ratio</p>
</div>
<table>
<thead>
<tr class="header">
<th align="right">Size</th>
<th align="right">Ratio %</th>
<th align="right">Bits/Integer</th>
<th align="right">C Time MB/s</th>
<th align="right">D Time MB/s</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">3,321,663,893</td>
<td align="right">13.9</td>
<td align="right">4.44</td>
<td align="right"><strong>1320</strong></td>
<td align="right"><strong>6088</strong></td>
<td><strong>TurboPFor</strong></td>
</tr>
<tr class="even">
<td align="right">3,339,730,557</td>
<td align="right">14.0</td>
<td align="right">4.47</td>
<td align="right">32</td>
<td align="right">2144</td>
<td>PC.OptPFD</td>
</tr>
<tr class="odd">
<td align="right">3,350,717,959</td>
<td align="right">14.0</td>
<td align="right">4.48</td>
<td align="right"><strong>1536</strong></td>
<td align="right"><strong>7128</strong></td>
<td><strong>TurboPFor256</strong></td>
</tr>
<tr class="even">
<td align="right">3,501,671,314</td>
<td align="right">14.6</td>
<td align="right">4.68</td>
<td align="right">56</td>
<td align="right">2840</td>
<td><strong>VSimple</strong></td>
</tr>
<tr class="odd">
<td align="right">3,768,146,467</td>
<td align="right">15.8</td>
<td align="right">5.04</td>
<td align="right"><strong>3228</strong></td>
<td align="right">3652</td>
<td><strong>EliasFanoV</strong></td>
</tr>
<tr class="even">
<td align="right">3,822,161,885</td>
<td align="right">16.0</td>
<td align="right">5.11</td>
<td align="right">572</td>
<td align="right">2444</td>
<td>PC_Simple16</td>
</tr>
<tr class="odd">
<td align="right">4,521,326,518</td>
<td align="right">18.9</td>
<td align="right">6.05</td>
<td align="right">836</td>
<td align="right">3296</td>
<td>Simple-8b</td>
</tr>
<tr class="even">
<td align="right">4,649,671,427</td>
<td align="right">19.4</td>
<td align="right">6.22</td>
<td align="right">3084</td>
<td align="right">3848</td>
<td><strong>TurboVbyte</strong></td>
</tr>
<tr class="odd">
<td align="right">4,955,740,045</td>
<td align="right">20.7</td>
<td align="right">6.63</td>
<td align="right"><strong>7064</strong></td>
<td align="right"><strong>10268</strong></td>
<td><strong>TurboPackV</strong></td>
</tr>
<tr class="even">
<td align="right">4,955,740,045</td>
<td align="right">20.7</td>
<td align="right">6.63</td>
<td align="right">5724</td>
<td align="right">8020</td>
<td><strong>TurboPack</strong></td>
</tr>
<tr class="odd">
<td align="right">5,205,324,760</td>
<td align="right">21.8</td>
<td align="right">6.96</td>
<td align="right">6952</td>
<td align="right">9488</td>
<td>SC_SIMDPack128</td>
</tr>
<tr class="even">
<td align="right">5,393,769,503</td>
<td align="right">22.5</td>
<td align="right">7.21</td>
<td align="right"><strong>9912</strong></td>
<td align="right"><strong>11588</strong></td>
<td><strong>TurboPackV256</strong></td>
</tr>
<tr class="odd">
<td align="right">6,221,886,390</td>
<td align="right">26.0</td>
<td align="right">8.32</td>
<td align="right">6668</td>
<td align="right">6952</td>
<td><strong>TurboFor</strong></td>
</tr>
<tr class="even">
<td align="right">6,221,886,390</td>
<td align="right">26.0</td>
<td align="right">8.32</td>
<td align="right">6644</td>
<td align="right">2260</td>
<td><strong>TurboForDA</strong></td>
</tr>
<tr class="odd">
<td align="right">6,699,519,000</td>
<td align="right">28.0</td>
<td align="right">8.96</td>
<td align="right">1888</td>
<td align="right">1980</td>
<td>FP_Vbyte</td>
</tr>
<tr class="even">
<td align="right">6,700,989,563</td>
<td align="right">28.0</td>
<td align="right">8.96</td>
<td align="right">2740</td>
<td align="right">3384</td>
<td>MaskedVByte</td>
</tr>
<tr class="odd">
<td align="right">7,622,896,878</td>
<td align="right">31.9</td>
<td align="right">10.20</td>
<td align="right">836</td>
<td align="right">4792</td>
<td>VarintG8IU</td>
</tr>
<tr class="even">
<td align="right">8,060,125,035</td>
<td align="right">33.7</td>
<td align="right">11.50</td>
<td align="right">3536</td>
<td align="right">8684</td>
<td>Streamvbyte</td>
</tr>
<tr class="odd">
<td align="right">8,594,342,216</td>
<td align="right">35.9</td>
<td align="right">11.50</td>
<td align="right">5228</td>
<td align="right">6376</td>
<td>libfor</td>
</tr>
<tr class="even">
<td align="right">23,918,861,764</td>
<td align="right">100.0</td>
<td align="right">32.00</td>
<td align="right">5824</td>
<td align="right">5924</td>
<td>Copy</td>
</tr>
</tbody>
</table>
<p>Block size: 64Ki = 256k bytes. Ki=1024 Integers</p>
<table>
<thead>
<tr class="header">
<th align="right">Size</th>
<th align="right">Ratio %</th>
<th align="right">Bits/Integer</th>
<th align="right">C Time MB/s</th>
<th align="right">D Time MB/s</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">3,164,940,562</td>
<td align="right">13.2</td>
<td align="right"><strong>4.23</strong></td>
<td align="right"><strong>1344</strong></td>
<td align="right"><strong>6004</strong></td>
<td><strong>TurboPFor 64Ki</strong></td>
</tr>
<tr class="even">
<td align="right">3,273,213,464</td>
<td align="right">13.7</td>
<td align="right">4.38</td>
<td align="right"><strong>1496</strong></td>
<td align="right"><strong>7008</strong></td>
<td><strong>TurboPFor256 64Ki</strong></td>
</tr>
<tr class="odd">
<td align="right">3,965,982,954</td>
<td align="right">16.6</td>
<td align="right">5.30</td>
<td align="right"><strong>1520</strong></td>
<td align="right">2452</td>
<td><a href="#lz4">lz4</a>+DT 64Ki</td>
</tr>
<tr class="even">
<td align="right">4,234,154,427</td>
<td align="right">17.7</td>
<td align="right">5.66</td>
<td align="right">436</td>
<td align="right">5672</td>
<td>qmx 64Ki</td>
</tr>
<tr class="odd">
<td align="right">6,074,995,117</td>
<td align="right">25.4</td>
<td align="right">8.13</td>
<td align="right">1976</td>
<td align="right">2916</td>
<td><a href="#blosc">blosc_lz4</a> 64Ki</td>
</tr>
<tr class="even">
<td align="right">8,773,150,644</td>
<td align="right">36.7</td>
<td align="right">11.74</td>
<td align="right">2548</td>
<td align="right">5204</td>
<td>blosc_lz 64Ki</td>
</tr>
</tbody>
</table>
<p>&quot;lz4+DT 64Ki&quot; = Delta+Transpose from TurboPFor + lz4<br> &quot;blosc_lz4&quot; internal lz4 compressor+vectorized shuffle</p>
<h5 id="time-series">- Time Series:</h5>
<ul>
<li><p>Test file <a href="https://github.com/zhenjl/encoding/tree/master/benchmark/data">Timestamps: ts.txt(sorted)</a></p>
<pre><code>./icapp -Ft ts.txt -I15 -J15</code></pre></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th align="right">C MB/s</th>
<th align="right">size</th>
<th align="right">ratio%</th>
<th align="right">D MB/s</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bvzenc32</td>
<td align="right"><strong>10632</strong></td>
<td align="right">45,909</td>
<td align="right">0.008</td>
<td align="right"><strong>12823</strong></td>
<td>ZigZag</td>
</tr>
<tr class="even">
<td>bvzzenc32</td>
<td align="right"><strong>8914</strong></td>
<td align="right">56,713</td>
<td align="right">0.010</td>
<td align="right"><strong>13499</strong></td>
<td>ZigZag Delta of delta</td>
</tr>
<tr class="odd">
<td>vsenc32</td>
<td align="right"><strong>12294</strong></td>
<td align="right">140,400</td>
<td align="right">0.024</td>
<td align="right">12877</td>
<td>Variable Simple</td>
</tr>
<tr class="even">
<td>p4nzenc256v32</td>
<td align="right">1932</td>
<td align="right">596,018</td>
<td align="right">0.10</td>
<td align="right">13326</td>
<td>TurboPFor256 ZigZag</td>
</tr>
<tr class="odd">
<td>p4ndenc256v32</td>
<td align="right">1961</td>
<td align="right">596,018</td>
<td align="right">0.10</td>
<td align="right">13339</td>
<td>TurboPFor256 Delta</td>
</tr>
<tr class="even">
<td>bitndpack256v32</td>
<td align="right"><strong>12564</strong></td>
<td align="right">909,189</td>
<td align="right">0.16</td>
<td align="right">13505</td>
<td>TurboPackV256 Delta</td>
</tr>
<tr class="odd">
<td>p4nzenc32</td>
<td align="right">1810</td>
<td align="right">1,159,633</td>
<td align="right">0.20</td>
<td align="right">8502</td>
<td>TurboPFor ZigZag</td>
</tr>
<tr class="even">
<td>p4nzenc128v32</td>
<td align="right">1795</td>
<td align="right">1,159,633</td>
<td align="right">0.20</td>
<td align="right">13338</td>
<td>TurboPFor ZigZag</td>
</tr>
<tr class="odd">
<td>bitnzpack256v32</td>
<td align="right">9651</td>
<td align="right">1,254,757</td>
<td align="right">0.22</td>
<td align="right"><strong>13503</strong></td>
<td>TurboPackV256 ZigZag</td>
</tr>
<tr class="even">
<td>bitnzpack128v32</td>
<td align="right">10155</td>
<td align="right">1,472,804</td>
<td align="right">0.26</td>
<td align="right">13380</td>
<td>TurboPackV ZigZag</td>
</tr>
<tr class="odd">
<td>vbddenc32</td>
<td align="right">6198</td>
<td align="right">18,057,296</td>
<td align="right">3.13</td>
<td align="right">10982</td>
<td>TurboVByte Delta of delta</td>
</tr>
<tr class="even">
<td>memcpy</td>
<td align="right">13397</td>
<td align="right">577,141,992</td>
<td align="right">100.00</td>
<td align="right"></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="transposeshuffle-no-compression">- Transpose/Shuffle (no compression)</h5>
<pre><code>    ./icbench -eTRANSFORM ZIPF</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">Size</th>
<th align="right">C Time MB/s</th>
<th align="right">D Time MB/s</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">100,000,000</td>
<td align="right"><strong>9400</strong></td>
<td align="right"><strong>9132</strong></td>
<td><strong>TPbyte 4</strong> TurboPFor Byte Transpose/shuffle AVX2</td>
</tr>
<tr class="even">
<td align="right">100,000,000</td>
<td align="right">8784</td>
<td align="right">8860</td>
<td><strong>TPbyte 4</strong> TurboPFor Byte Transpose/shuffle SSE</td>
</tr>
<tr class="odd">
<td align="right">100,000,000</td>
<td align="right">7688</td>
<td align="right">7656</td>
<td>Blosc_Shuffle AVX2</td>
</tr>
<tr class="even">
<td align="right">100,000,000</td>
<td align="right"><strong>5204</strong></td>
<td align="right"><strong>7460</strong></td>
<td><strong>TPnibble 4</strong> TurboPFor Nibble Transpose/shuffle SSE</td>
</tr>
<tr class="odd">
<td align="right">100,000,000</td>
<td align="right">6620</td>
<td align="right">6284</td>
<td>Blosc shuffle SSE</td>
</tr>
<tr class="even">
<td align="right">100,000,000</td>
<td align="right">3156</td>
<td align="right">3372</td>
<td>Bitshuffle AVX2</td>
</tr>
<tr class="odd">
<td align="right">100,000,000</td>
<td align="right">2100</td>
<td align="right">2176</td>
<td>Bitshuffle SSE</td>
</tr>
</tbody>
</table>
<h5 id="lossy-floating-point-compression">- (Lossy) Floating point compression:</h5>
<pre><code>    ./icapp -Fd file          &quot; 64 bits floating point raw file 
    ./icapp -Ff file          &quot; 32 bits floating point raw file 
    ./icapp -Fcf file         &quot; text file with miltiple entries (ex.  8.657,56.8,4.5 ...)
    ./icapp -Ftf file         &quot; text file (1 entry per line)
    ./icapp -Ftf file -v5     &quot; + display the first entries read
    ./icapp -Ftf file.csv -K3 &quot; but 3th column in a csv file (ex. number,Text,456.5 -&gt; 456.5
    ./icapp -Ftf file -g.001  &quot; lossy compression with allowed error 0.001</code></pre>
<ul>
<li>see also <a href="https://github.com/powturbo/TurboTranspose">TurboTranspose</a></li>
</ul>
<h5 id="compressed-inverted-index-intersections-with-gov2">- Compressed Inverted Index Intersections with GOV2<br /></h5>
<p>GOV2: 426GB, 25 Millions documents, average doc. size=18k.</p>
<ul>
<li><p>Aol query log: 18.000 queries<br /> <strong>~1300</strong> queries per second (single core)<br /> <strong>~5000</strong> queries per second (quad core)<br /> Ratio = 14.37% Decoded/Total Integers.</p></li>
<li><p>TREC Million Query Track (1MQT):<br /> <strong>~1100</strong> queries per second (Single core)<br /> <strong>~4500</strong> queries per second (Quad core CPU)<br /> Ratio = 11.59% Decoded/Total Integers.</p></li>
<li><p>Benchmarking intersections (Single core, AOL query log)</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="right">max.docid/q</th>
<th align="right">Time s</th>
<th align="right">q/s</th>
<th align="right">ms/q</th>
<th align="right">% docid found</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1.000</td>
<td align="right">7.88</td>
<td align="right">2283.1</td>
<td align="right">0.438</td>
<td align="right">81</td>
</tr>
<tr class="even">
<td align="right">10.000</td>
<td align="right">10.54</td>
<td align="right">1708.5</td>
<td align="right">0.585</td>
<td align="right">84</td>
</tr>
<tr class="odd">
<td align="right">ALL</td>
<td align="right">13.96</td>
<td align="right">1289.0</td>
<td align="right">0.776</td>
<td align="right">100</td>
</tr>
</tbody>
</table>
<p>q/s: queries/second, ms/q:milliseconds/query</p>
<ul>
<li>Benchmarking Parallel Query Processing (Quad core, AOL query log)</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="right">max.docid/q</th>
<th align="right">Time s</th>
<th align="right">q/s</th>
<th align="right">ms/q</th>
<th align="right">% docids found</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1.000</td>
<td align="right">2.66</td>
<td align="right">6772.6</td>
<td align="right">0.148</td>
<td align="right">81</td>
</tr>
<tr class="even">
<td align="right">10.000</td>
<td align="right">3.39</td>
<td align="right">5307.5</td>
<td align="right">0.188</td>
<td align="right">84</td>
</tr>
<tr class="odd">
<td align="right">ALL</td>
<td align="right">3.57</td>
<td align="right">5036.5</td>
<td align="right">0.199</td>
<td align="right">100</td>
</tr>
</tbody>
</table>
<h6 id="notes">Notes:</h6>
<ul>
<li>Search engines are spending 90% of the time in intersections when processing queries.</li>
<li>Most search engines are using pruning strategies, caching popular queries,... to reduce the time for intersections and query processing.</li>
<li>As indication, google is processing <a href="http://www.internetlivestats.com/google-search-statistics/">40.000 Queries per seconds</a>, using <a href="https://www.cloudyn.com/blog/10-facts-didnt-know-server-farms/">900.000 multicore servers</a> for searching <a href="http://searchenginewatch.com/sew/study/2063479/coincidentally-googles-index-size-jumps">8 billions web pages</a> (320 X size of GOV2).</li>
<li>Recent &quot;integer compression&quot; GOV2 experiments (best paper at ECIR 2014) <a href="http://www.dcs.gla.ac.uk/~craigm/publications/catena14compression.pdf">On Inverted Index Compression for Search Engine Efficiency</a> using 8-core Xeon PC are reporting 1.2 seconds per query (for 1.000 Top-k docids).</li>
</ul>
<h3 id="compile">Compile:</h3>
<pre><code>    Download or clone TurboPFor
    git clone git://github.com/powturbo/TurboPFor.git
    cd TurboPFor
    
    To benchmark external libraries:
    git clone --recursive git://github.com/powturbo/TurboPFor.git
    cd TurboPFor</code></pre>
<h6 id="linux-windows-mingw-clang...-see-also-makefile">Linux, Windows (MingW), Clang,... (see also makefile)</h6>
<pre><code>    make
    or
    make AVX2=1

    Include external libs
    make CODEC1=1 CODEC2=1 

    Disable SIMD
    make NSIMD=1
  </code></pre>
<h6 id="windows-visual-c">Windows visual c++</h6>
<pre><code>    nmake /f makefile.vs</code></pre>
<h3 id="testing">Testing:</h3>
<h5 id="synthetic-data-use-zipf-parameter">- Synthetic data (use ZIPF parameter):</h5>
<ul>
<li><p>benchmark groups of &quot;integer compression&quot; functions <br /></p>
<pre><code>./icbench -eBENCH -a1.2 -m0 -M255 -n100M ZIPF
./icbench -eBITPACK/VBYTE -a1.2 -m0 -M255 -n100M ZIPF</code></pre></li>
</ul>
<blockquote>
<p><em>Type &quot;icbench -l1&quot; for a list</em></p>
</blockquote>
<blockquote>
<p><em>-zipfian distribution alpha = 1.2 (Ex. -a1.0=uniform -a1.5=skewed distribution)<br /> -number of integers = 100.000.000<br /> -integer range from 0 to 255<br /></em></p>
</blockquote>
<ul>
<li><p>Unsorted lists: individual function test (ex. Copy TurboPack TurboPFor)<br /></p>
<pre><code>./icbench -a1.5 -m0 -M255 -ecopy/turbopack/turbopfor/turbopack256v ZIPF</code></pre></li>
<li><p>Unsorted lists: Zigzag encoding w/ option <strong>-fz</strong> or FOR encoding<br /></p>
<pre><code>./icbench -fz -eturbovbyte/turbopfor/turbopackv ZIPF
./icbench -eturboforv ZIPF</code></pre></li>
<li><p>Sorted lists: differential coding w/ option <strong>-fs</strong> (increasing) or <strong>-fS</strong> (strictly increasing)<br /></p>
<pre><code>./icbench -fs -eturbopack/turbopfor/turbopfor256v ZIPF</code></pre></li>
<li><p>Generate interactive &quot;file.html&quot; plot for browsing</p>
<pre><code>./icbench -p2 -S2 -Q3 file.tbb</code></pre></li>
<li><p>Unit test: test function from bit size 0 to 32</p>
<pre><code>./icbench -m0 -M32 -eturbpfor 
./icbench -m0 -M8 -eturbopack -fs -n1M </code></pre></li>
</ul>
<h5 id="data-files-1">- Data files:</h5>
<ul>
<li><p>Raw 32 bits binary data file <a href="https://github.com/ot/partitioned_elias_fano/tree/master/test/test_data">Test data</a></p>
<pre><code>./icbench file
./icapp file           
./icapp -Fs file         &quot;16 bits binary file
./icapp -Fu file         &quot;32 bits binary file
./icapp -Fl file         &quot;64 bits binary file
./icapp -Ff file         &quot;32 bits floating point binary file
./icapp -Fd file         &quot;64 bits floating point binary file</code></pre></li>
<li><p>Text file: 1 entry per line. <a href="https://github.com/zhenjl/encoding/tree/master/benchmark/data">Test data: ts.txt(sorted) and lat.txt(unsorted)</a>)</p>
<pre><code>./icbench -eBENCH -fts ts.txt
./icbench -eBENCH -ft  lat.txt

./icapp -Fts data.txt            &quot;text file, one 16 bits integer per line
./icapp -Ftu ts.txt              &quot;text file, one 32 bits integer per line
./icapp -Ftl ts.txt              &quot;text file, one 64 bits integer per line
./icapp -Ftf file                &quot;text file, one 32 bits floating point (ex. 8.32456) per line
./icapp -Ftd file                &quot;text file, one 64 bits floating point (ex. 8.324567789) per line
./icapp -Ftd file -v5            &quot;like prev., display the first 100 values read
./icapp -Ftd file -v5 -g.00001   &quot;like prev., error bound lossy floating point compression
./icapp -Ftt file                &quot;text file, timestamp in seconds iso-8601 -&gt; 32 bits integer (ex. 2018-03-12T04:31:06)
./icapp -FtT file                &quot;text file, timestamp in milliseconds iso-8601 -&gt; 64 bits integer (ex. 2018-03-12T04:31:06.345)
./icapp -Ftl -D2 -H file         &quot;skip 1th line, convert numbers with 2 decimal digits to 64 bits integers (ex. 456.23 -&gt; 45623)
./icapp -Ftl -D2 -H -K3 file.csv  &quot;like prev., use the 3th number in the line (ex. label=3245, text=99 usage=456.23 -&gt; 456.23 )
./icapp -Ftl -D2 -H -K3 -k| file.csv &quot;like prev., use &#39;|&#39; as separator</code></pre></li>
<li><p>Text file: multiple numbers separated by non-digits (0..9,-,.) characters (ex. 134534,-45678,98788,4345, )</p>
<pre><code>./icapp -Fc data.txt         &quot;text file, 32 bits integers (ex. 56789,3245,23,678 ) 
./icapp -Fcd data.txt        &quot;text file, 64 bits floting-point numbers (ex. 34.7689,5.20,45.789 )</code></pre></li>
<li><p>Multiblocks of 32 bits binary file. (Example gov2 from <a href="#DocId">DocId data set</a>)<br /> Block format: [n1: #of Ids][Id1] [Id2]...[IdN] [n2: #of Ids][Id1][Id2]...[IdN]...</p>
<pre><code>./icbench -fS -r gov2.sorted</code></pre></li>
</ul>
<h5 id="intersections">- Intersections:</h5>
<p>1 - Download Gov2 (or ClueWeb09) + query files (Ex. &quot;1mq.txt&quot;) from <a href="#DocId">DocId data set</a><br /> 8GB RAM required (16GB recommended for benchmarking &quot;clueweb09&quot; files).</p>
<p>2 - Create index file</p>
<pre><code>    ./idxcr gov2.sorted .</code></pre>
<blockquote>
<p><em>create inverted index file &quot;gov2.sorted.i&quot; in the current directory</em></p>
</blockquote>
<p>3 - Test intersections</p>
<pre><code>    ./idxqry gov2.sorted.i 1mq.txt</code></pre>
<blockquote>
<p><em>run queries in file &quot;1mq.txt&quot; over the index of gov2 file</em></p>
</blockquote>
<h5 id="parallel-query-processing">- Parallel Query Processing:</h5>
<p>1 - Create partitions</p>
<pre><code>    ./idxseg gov2.sorted . -26m -s8</code></pre>
<blockquote>
<p><em>create 8 (CPU hardware threads) partitions for a total of ~26 millions document ids</em></p>
</blockquote>
<p>2 - Create index file for each partition</p>
<pre><code>  ./idxcr gov2.sorted.s*</code></pre>
<blockquote>
<p><em>create inverted index file for all partitions &quot;gov2.sorted.s00 - gov2.sorted.s07&quot; in the current directory</em></p>
</blockquote>
<p>3 - Intersections:</p>
<p>delete &quot;idxqry.o&quot; file and then type &quot;make para&quot; to compile &quot;idxqry&quot; w. multithreading</p>
<pre><code>  ./idxqry gov2.sorted.s*.i 1mq.txt</code></pre>
<blockquote>
<p><em>run queries in file &quot;1mq.txt&quot; over the index of all gov2 partitions &quot;gov2.sorted.s00.i - gov2.sorted.s07.i&quot;.</em></p>
</blockquote>
<h3 id="function-usage">Function usage:</h3>
<p>See benchmark &quot;icbench&quot; program for &quot;integer compression&quot; usage examples. In general encoding/decoding functions are of the form:</p>
<blockquote>
<p>**char <em>endptr = encode( unsigned </em>in, unsigned n, char *out, [unsigned start], [int b])**<br /> endptr : set by encode to the next character in &quot;out&quot; after the encoded buffer<br /> in : input integer array<br /> n : number of elements<br /> out : pointer to output buffer<br /> b : number of bits. Only for bit packing functions<br /> start : previous value. Only for integrated delta encoding functions</p>
</blockquote>
<blockquote>
<p>**char <em>endptr = decode( char </em>in, unsigned n, unsigned *out, [unsigned start], [int b])**<br /> endptr : set by decode to the next character in &quot;in&quot; after the decoded buffer<br /> in : pointer to input buffer<br /> n : number of elements<br /> out : output integer array<br /> b : number of bits. Only for bit unpacking functions<br /> start : previous value. Only for integrated delta decoding functions</p>
</blockquote>
<p><strong>Simple high level functions:</strong> &gt;<strong>size_t compressed_size = encode( unsigned <em>in, size_t n, char </em>out)</strong><br /> compressed_size : number of bytes written into compressed output buffer out<br /></p>
<blockquote>
<p><strong>size_t compressed_size = decode( char <em>in, size_t n, unsigned </em>out)</strong><br /> compressed_size : number of bytes read from compressed input buffer in<br /></p>
</blockquote>
<h3 id="function-syntax">Function syntax:</h3>
<ul>
<li>{vb | p4 | bit | vs}[d | d1 | f | fm | z ]{enc/dec | pack/unpack}[| 128V | 256V][8 | 16 | 32 | 64]:<br /> vb: variable byte<br /> p4: turbopfor<br /> vs: variable simple<br /> bit: bit packing<br /></li>
</ul>
<p>d: delta encoding for increasing integer lists (sorted w/ duplicate)<br /> d1: delta encoding for strictly increasing integer lists (sorted unique)<br /> f : FOR encoding for sorted integer lists<br /> fm: FOR encoding for unsorted integer lists<br /> z: ZigZag encoding for unsorted integer lists<br /></p>
<p>enc/pack: encode<br /> dec/unpack:decode<br /> XX : integer size (8/16/32/64)<br /></p>
<p>header files to use with documentation:<br /></p>
<table style="width:85%;">
<colgroup>
<col width="18%" />
<col width="41%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th>c/c++ header file</th>
<th>Integer Compression functions</th>
<th>examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>vint.h</td>
<td>variable byte</td>
<td>vbenc32/vbdec32 vbdenc32/vbddec32 vbzenc32/vbzdec32</td>
</tr>
<tr class="even">
<td>vsimple.h</td>
<td>variable simple</td>
<td>vsenc64/vsdec64</td>
</tr>
<tr class="odd">
<td>vp4.h</td>
<td>TurboPFor</td>
<td>p4enc32/p4dec32 p4denc32/p4ddec32 p4zenc32/p4zdec32</td>
</tr>
<tr class="even">
<td>bitpack.h</td>
<td>Bit Packing, For, +Direct Access</td>
<td>bitpack256v32/bitunpack256v32 bitforenc64/bitfordec64</td>
</tr>
<tr class="odd">
<td>eliasfano.h</td>
<td>Elias Fano</td>
<td>efanoenc256v32/efanoc256v32</td>
</tr>
</tbody>
</table>
<h3 id="environment">Environment:</h3>
<h6 id="oscompiler-64-bits">OS/Compiler (64 bits):</h6>
<ul>
<li>Linux: GNU GCC (&gt;=4.6)</li>
<li>clang (&gt;=3.2)</li>
<li>Windows: MinGW-w64 (no parallel query processing demo app)</li>
<li>Visual c++ (VS2008-VS2017)</li>
</ul>
<h6 id="multithreading">Multithreading:</h6>
<ul>
<li>All TurboPFor integer compression functions are thread safe</li>
</ul>
<h3 id="references">References:</h3>
<ul>
<li><strong>Benchmark references:</strong></li>
<li><a name="FastPFor"></a><a href="https://github.com/lemire/FastPFor">FastPFor</a> + <a href="https://github.com/lemire/simdcomp">Simdcomp</a>: SIMDPack FPF, Vbyte FPF, VarintG8IU, StreamVbyte, GroupSimple</li>
<li><a name="OptPFD"></a><a name="Simple16"></a><a href="http://jinruhe.com">Optimized Pfor-delta compression code</a>: OptPFD/OptP4, Simple16 (limited to 28 bits integers)</li>
<li><a name="MaskedVByte"></a><a href="http://maskedvbyte.org/">MaskedVByte</a>. See also: <a href="http://engineering.indeed.com/blog/2015/03/vectorized-vbyte-decoding-high-performance-vector-instructions/">Vectorized VByte Decoding</a></li>
<li><a name="Streamvbyte"></a><a href="https://github.com/lemire/streamvbyte">Streamvbyte</a>.</li>
<li><a name="Simple-8b"></a><a href="http://people.eng.unimelb.edu.au/ammoffat/abstracts/am10spe.html">Index Compression Using 64-Bit Words</a>: Simple-8b (speed optimized version tested)</li>
<li><a name="libfor"></a><a href="https://github.com/cruppstahl/for">libfor</a></li>
<li><a name="QMX"></a><a href="http://www.cs.otago.ac.nz/homepages/andrew/papers/">Compression, SIMD, and Postings Lists</a> QMX integer compression from the &quot;simple family&quot;</li>
<li><a name="lz4"></a><a href="https://github.com/Cyan4973/lz4">lz4</a>. included w. block size 64K as indication. Tested after preprocessing w. delta+transpose</li>
<li><a name="blosc"></a><a href="https://github.com/Blosc/c-blosc">blosc</a>. blosc is like transpose/shuffle+lz77. Tested blosc+lz4 and blosclz incl. vectorizeed shuffle.<br></li>
<li><p><a name="DocId"></a><a href="http://lemire.me/data/integercompression2014.html">Document identifier data set</a></p></li>
<li><strong>Integer compression publications:</strong></li>
<li>:green_book:<a href="http://dl.acm.org/citation.cfm?id=3015023">In Vacuo and In Situ Evaluation of SIMD Codecs (TurboPackV,TurboPFor/QMX)</a> + <a href="http://www.cs.otago.ac.nz/homepages/andrew/papers/">paper</a></li>
<li>:green_book:<a href="http://arxiv.org/abs/1401.6399">SIMD Compression and the Intersection of Sorted Integers</a></li>
<li>:green_book:<a href="http://www.di.unipi.it/~ottavian/files/elias_fano_sigir14.pdf">Partitioned Elias-Fano Indexes</a></li>
<li>:green_book:<a href="http://www.dcs.gla.ac.uk/~craigm/publications/catena14compression.pdf">On Inverted Index Compression for Search Engine Efficiency</a></li>
<li>:green_book:<a href="http://static.googleusercontent.com/media/research.google.com/de//people/jeff/WSDM09-keynote.pdf">Google's Group Varint Encoding</a></li>
<li>:green_book:<a href="https://twitter.com/search?q=%23integercompression&amp;src=typd">Integer Compression tweets</a></li>
<li>:green_book:<a href="https://www.jstage.jst.go.jp/article/jsces/2017/0/2017_20170002/_article">Efficient Compression of Scientific Floating-Point Data and An Application in Structural Analysis</a></li>
<li><p>:green_book:<a href="http://cs.txstate.edu/~burtscher/research/SPDPcompressor/">SPDP is a compression/decompression algorithm for binary IEEE 754 32/64 bits floating-point data</a><br /> :green_book:<a href="http://cs.txstate.edu/~mb92/papers/dcc18.pdf">SPDP - An Automatically Synthesized Lossless Compression Algorithm for Floating-Point Data</a> + <a href="http://www.cs.brandeis.edu//~dcc/Programs/Program2018.pdf">DCC 2018</a></p></li>
<li><strong>Applications:</strong></li>
<li><a href="https://github.com/julianromera/graph500">Graph500</a></li>
<li><a href="https://arxiv.org/abs/1509.05505">Small Polygon Compression</a> + <a href="http://abhinavjauhri.me/publications/dcc_poster_2016.pdf">Poster</a> + <a href="https://github.com/ajauhri/bignum_compression">code</a></li>
<li><p><a href="http://www.cs.rpi.edu/~slotag/classes/FA16/">Parallel Graph Analysis (Lecture 18)</a> + <a href="http://www.cs.rpi.edu/~slotag/classes/FA16/handson/lec18-comp2.cpp">code</a></p></li>
</ul>
<p>Last update: 09 Nov 2018</p>
