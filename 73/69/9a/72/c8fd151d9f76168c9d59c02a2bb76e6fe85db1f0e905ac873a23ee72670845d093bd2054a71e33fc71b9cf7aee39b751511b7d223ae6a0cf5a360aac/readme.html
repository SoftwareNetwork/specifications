<h1 id="cpp-std-fwd">cpp-std-fwd</h1>
<p>Forward declarations for most useful runtime classes of the C++ 17 standard library.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>TL;DR: adding <code>#include &lt;stdfwd.hh&gt;</code> adds about 3 ms per translation unit.</p>
<table>
<thead>
<tr class="header">
<th>file</th>
<th align="right">clang-6</th>
<th align="right">clang-7</th>
<th align="right">gcc-7</th>
<th align="right">gcc-8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>empty</td>
<td align="right">12.6 ms</td>
<td align="right">13.9 ms</td>
<td align="right">5.5 ms</td>
<td align="right">5.5 ms</td>
</tr>
<tr class="even">
<td><strong><code>&lt;stdfwd.hh&gt;</code></strong></td>
<td align="right"><strong>15.6 ms</strong></td>
<td align="right"><strong>17.2 ms</strong></td>
<td align="right"><strong>8.3 ms</strong></td>
<td align="right"><strong>7.7 ms</strong></td>
</tr>
<tr class="odd">
<td><code>&lt;type_traits&gt;</code></td>
<td align="right">22.5 ms</td>
<td align="right">24.5 ms</td>
<td align="right">13.9 ms</td>
<td align="right">12.7 ms</td>
</tr>
<tr class="even">
<td><code>&lt;utility&gt;</code></td>
<td align="right">26.7 ms</td>
<td align="right">28.4 ms</td>
<td align="right">17.1 ms</td>
<td align="right">15.4 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;string_view&gt;</code></td>
<td align="right">52.0 ms</td>
<td align="right">56.0 ms</td>
<td align="right">41.9 ms</td>
<td align="right">36.4 ms</td>
</tr>
<tr class="even">
<td><code>&lt;vector&gt;</code></td>
<td align="right">56.7 ms</td>
<td align="right">61.3 ms</td>
<td align="right">46.5 ms</td>
<td align="right">40.8 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;string&gt;</code></td>
<td align="right">105.7 ms</td>
<td align="right">113.1 ms</td>
<td align="right">95.8 ms</td>
<td align="right">85.3 ms</td>
</tr>
<tr class="even">
<td><code>&lt;array&gt;</code></td>
<td align="right">108.5 ms</td>
<td align="right">116.3 ms</td>
<td align="right">99.3 ms</td>
<td align="right">88.6 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;optional&gt;</code></td>
<td align="right">112.7 ms</td>
<td align="right">121.0 ms</td>
<td align="right">103.1 ms</td>
<td align="right">92.9 ms</td>
</tr>
<tr class="even">
<td><code>&lt;map&gt;</code></td>
<td align="right">139.8 ms</td>
<td align="right">149.9 ms</td>
<td align="right">128.8 ms</td>
<td align="right">114.9 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;memory&gt;</code></td>
<td align="right">140.1 ms</td>
<td align="right">149.2 ms</td>
<td align="right">130.3 ms</td>
<td align="right">115.4 ms</td>
</tr>
<tr class="even">
<td><code>&lt;iostream&gt;</code></td>
<td align="right">150.0 ms</td>
<td align="right">158.7 ms</td>
<td align="right">145.1 ms</td>
<td align="right">127.4 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;unordered_map&gt;</code></td>
<td align="right">155.0 ms</td>
<td align="right">162.9 ms</td>
<td align="right">141.1 ms</td>
<td align="right">131.5 ms</td>
</tr>
<tr class="even">
<td><code>&lt;functional&gt;</code></td>
<td align="right">192.7 ms</td>
<td align="right">205.2 ms</td>
<td align="right">178.2 ms</td>
<td align="right">162.3 ms</td>
</tr>
<tr class="odd">
<td><code>&lt;regex&gt;</code></td>
<td align="right">310.4 ms</td>
<td align="right">326.0 ms</td>
<td align="right">308.6 ms</td>
<td align="right">268.4 ms</td>
</tr>
</tbody>
</table>
<p>Just compiling a single source including the specified file (<code>compiler -std=c++17 -O0 -c /tmp/file.cc -o /tmp/file.o</code>), best out of 10 compilations.</p>
<p>(system: intel i9-9900k 5 GHz, samsung 970 1TB pro nvme ssd, linux mint 19.1 tessa, kernel 4.15.0)</p>
<h2 id="usage">Usage</h2>
<p>Use forward declarations where possible in the header:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;stdfwd.hh&gt;</span>

stdfwd::string get_string();
stdfwd::vector&lt;<span class="dt">int</span>&gt; get_vector();
stdfwd::deque&lt;<span class="dt">int</span>&gt; get_deque();
stdfwd::list&lt;<span class="dt">int</span>&gt; get_list();
stdfwd::stack&lt;<span class="dt">int</span>&gt; get_stack();
stdfwd::forward_list&lt;<span class="dt">int</span>&gt; get_forward_list();
stdfwd::shared_ptr&lt;<span class="dt">int</span>&gt; get_shared_ptr();
stdfwd::unique_ptr&lt;<span class="dt">int</span>&gt; get_unique_ptr();
stdfwd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; get_array();
stdfwd::function&lt;<span class="dt">int</span>()&gt; get_function();
stdfwd::bitset&lt;<span class="dv">3</span>&gt; get_bitset();
stdfwd::pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; get_pair();
stdfwd::map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; get_map();
stdfwd::set&lt;<span class="dt">int</span>&gt; get_set();
stdfwd::unordered_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; get_unordered_map();
stdfwd::unordered_set&lt;<span class="dt">int</span>&gt; get_unordered_set();
...</code></pre></div>
<p>And in the <code>.cc</code> just <code>#include &lt;header&gt;</code> and define the functions using the normal <code>std</code> type (all declarations inside <code>stdfwd</code> are typedefs into <code>std</code>).</p>
<p><code>std::</code> forward declarations can also be used but won't have default template arguments (e.g. <code>std::vector&lt;int&gt;</code> does not work and <code>std::vector&lt;int, std::allocator&lt;int&gt;&gt;</code> or <code>stdfwd::vector&lt;int&gt;</code> must be used).</p>
<p>Adding support for <code>map</code> and <code>unordered_map</code> for custom data types:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;stdfwd.hh&gt;</span>

<span class="kw">struct</span> foo
{
    <span class="dt">int</span> v;

    <span class="dt">bool</span> <span class="kw">operator</span>==(foo <span class="at">const</span>&amp; r) <span class="at">const</span> { <span class="cf">return</span> v == r.v; }
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">struct</span> <span class="bu">std::</span>hash&lt;foo&gt;
{
    <span class="dt">size_t</span> <span class="kw">operator</span>()(foo <span class="at">const</span>&amp; f) <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> f.v; }
};

<span class="kw">template</span> &lt;&gt;
<span class="kw">struct</span> <span class="bu">std::</span>less&lt;foo&gt;
{
    <span class="dt">bool</span> <span class="kw">operator</span>()(foo <span class="at">const</span>&amp; a, foo <span class="at">const</span>&amp; b) <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> a.v &lt; b.v; }
};</code></pre></div>
<h2 id="cmake">CMake</h2>
<p>If the <code>CMakeLists.txt</code> is included, an interface library <code>std-fwd</code> is created:</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="co"># if set, force-includes &quot;stdfwd.hh&quot; in every translation unit</span>
<span class="co"># this is optional and low-cost (see benchmarks)</span>
<span class="co"># set(STDFWD_FORCE_INCLUDE ON CACHE BOOL &quot;&quot; FORCE)</span>

<span class="kw">add_subdirectory</span>(path/to/cpp-std-fwd)

<span class="kw">target_link_libraries</span>(<span class="va">${PROJECT_NAME}</span> <span class="ot">PUBLIC</span> std-fwd)</code></pre></div>
<h2 id="faq">FAQ</h2>
<ul>
<li>Why?</li>
</ul>
<p>Each non-trivial <code>std</code> header adds 50-200 ms compile time just by including them. <code>#include &lt;stdfwd.hh&gt;</code> is virtually free.</p>
<ul>
<li>Isn't adding declarations to <code>std</code> undefined behavior?</li>
</ul>
<p>Yes. This project is meant as a proof-of-concept for a proposal to standardize a forward declaration header for <code>std</code>.</p>
<ul>
<li>Why the namespace <code>stdfwd</code>?</li>
</ul>
<p>Some classes like <code>std::vector</code> have default template arguments which must only appear on a declaration once. If they appear on the definition then they cannot appear on the forward declaration. Thus, all forward declarations in <code>std</code> are without default arguments and <code>stdfwd</code> adds typedefs with the appropriate defaults.</p>
<ul>
<li>Why are some classes like <code>std::integer_sequence</code> missing?</li>
</ul>
<p>I omitted classes that are intended for compile-time programming because there seems to be little reason to forward declare them.</p>
<ul>
<li>What are the use cases?</li>
</ul>
<p>Many functions defined in a header but implemented elsewhere don't require complete definitions of their arguments or return types. <code>std::vector&lt;int&gt; foo();</code> can be defined without including <code>&lt;vector&gt;</code> given forward declarations.</p>
<p>Furthermore, many data types might want to specialize <code>std::less</code> or <code>std::hash</code> so that their users can use them inside <code>std::map</code> or <code>std::unordered_map</code>. Currently this requires including <code>&lt;functional&gt;</code> (one of the most expensive <code>std</code> headers to include) even if the data type itself uses nothing from that header. With a forward declaration, <code>less</code> and <code>hash</code> can be specialized without including the full header.</p>
<ul>
<li>Won't this be obsolete with modules?</li>
</ul>
<p>Yes and no. In C++20, <code>std</code> itself is not yet modularized. Additionally, it is not clear if all code bases can be immediately migrated to modules. This <code>std</code> forward header is a small and easy-to-implement non-intrusive change with big payoffs for many code bases.</p>
<ul>
<li>Why is <code>iosfwd</code> not used internally?</li>
</ul>
<p>This header should be as fast as possible. <code>iosfwd</code> includes more than forward declaration. It also fully defines the <code>postypes</code> at least in libstdc++.</p>
<h2 id="related-work">Related Work</h2>
<ul>
<li>https://blog.magnum.graphics/backstage/forward-declaring-stl-container-types/</li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li>add support for <code>libc++</code></li>
<li>make <code>msvc</code> benchmark</li>
</ul>
