<p>Mar 2019</p>
<h3 id="overview">Overview</h3>
<p>&quot;SaferCPlusPlus&quot; is essentially a collection of safe data types intended to facilitate memory and data race safe C++ programming. This library is intended to work with and be complimentary to the Core Guidelines lifetime checker over its various stages of development and availability. (Including situations where the lifetime checker is not available at all.)</p>
<p>The library's elements are designed, as much as possible, to seamlessly integrate with all manner of existing and future C++ code. It includes things like:</p>
<ul>
<li><p>Drop-in replacements for <a href="#vector"><code>std::vector&lt;&gt;</code></a>, <a href="#array"><code>std::array&lt;&gt;</code></a> and <a href="#string"><code>std::string</code></a>.</p></li>
<li><p>Replacements for <a href="#nrp_string_view"><code>std::string_view</code></a> and <a href="#txscopeanyrandomaccesssection-txscopeanyrandomaccessconstsection-tanyrandomaccesssection-tanyrandomaccessconstsection"><code>std::span</code></a>.</p></li>
<li><p>Drop-in <a href="#primitives">replacements</a> for <code>int</code>, <code>size_t</code> and <code>bool</code> that ensure against the use of uninitialized values and address the &quot;signed-unsigned mismatch&quot; issues.</p></li>
<li><p>Data types for safe <a href="#asynchronously-shared-objects">sharing</a> of objects among concurrently executing threads.</p></li>
<li><p>Replacements for native pointers/references with various flexibility and performance trade-offs.</p></li>
</ul>
<p>Historically, C++ has been (famously) not a memory-safe language. The key vexing issue being &quot;use-after-free&quot; (or &quot;dangling reference&quot;) bugs. The lifetime checker aims to eliminate these bugs by restricting the ways C++ reference types can be used to those that can, in general, be verified to be safe at compile-time. At the time of this writing (Aug 2018) the lifetime checker still has a <a href="https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/lifetime%20checker%20observations%20-%20Jun%202018.md">ways to go</a> before achieving its goal of memory safety without unnecessary false positives. In the meantime you can replace your potentially unsafe C++ elements with corresponding substitutes in this library to achieve memory safety in a manner designed to be future-compatible with an eventually completed lifetime checker.</p>
<p>Besides zero-overhead pointers that enforce some of the necessary restrictions not yet (at the time of writing) implemented in the lifetime checker, the library provides a reference counting pointer that's smaller and faster than <code>std::shared_ptr&lt;&gt;</code>, and an unrestricted pointer that ensures memory safety via run-time checks. The latter two being not (yet) provided by the Guidelines Support Library, but valuable in the context of having to work around the somewhat <a href="https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/implications%20of%20the%20lifetime%20checker%20restrictions.md">draconian restrictions</a> imposed by the (eventual completed) lifetime checker.</p>
<p>And the library also addresses the data race issue, where the Core Guidelines don't (yet) offer anything substantial.</p>
<p>To see the library in action, you can check out some <a href="https://github.com/duneroadrunner/SaferCPlusPlus-BenchmarksGame">benchmark code</a>. There you can compare traditional C++ and (high-performance) SaferCPlusPlus implementations of the same algorithms. Also, the <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp">msetl_example.cpp</a> and <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example2.cpp">msetl_example2.cpp</a> files contain usage examples of the library's elements. But at this point, there are a lot of them, so it might be more effective to peruse the documentation first, then search those files for the element(s) your interested in.</p>
<p>Tested with msvc2017(v15.9.0), g++7.3 &amp; 5.4 and clang++6.0 &amp; 3.8. Support for versions of g++ prior to version 5 was dropped on Mar 21, 2016. Note that parts of the library documentation were written before it was clear that a viable lifetime checker might be forthcoming and should be interpreted accordingly.</p>
<h3 id="table-of-contents">Table of contents</h3>
<ol style="list-style-type: decimal">
<li><a href="#overview">Overview</a></li>
<li><a href="#use-cases">Use cases</a></li>
<li><a href="#setup-and-dependencies">Setup and dependencies</a></li>
<li>Comparisons
<ol style="list-style-type: decimal">
<li><a href="#safercplusplus-versus-clangllvm-sanitizers">SaferCPlusPlus versus Clang/LLVM Sanitizers</a></li>
<li><a href="#safercplusplus-versus-rust">SaferCPlusPlus versus Rust</a></li>
<li><a href="#safercplusplus-versus-checked-c">SaferCPlusPlus versus Checked C</a></li>
</ol></li>
<li><a href="#getting-started-on-safening-existing-code">Getting started on safening existing code</a></li>
<li><a href="#registered-pointers">Registered pointers</a>
<ol style="list-style-type: decimal">
<li><a href="#tregisteredpointer">TRegisteredPointer</a>
<ol style="list-style-type: decimal">
<li><a href="#tregisterednotnullpointer">TRegisteredNotNullPointer</a></li>
<li><a href="#tregisteredfixedpointer">TRegisteredFixedPointer</a></li>
<li><a href="#tregisteredconstpointer-tregisterednotnullconstpointer-tregisteredfixedconstpointer">TRegisteredConstPointer</a></li>
<li><a href="#tregisteredrefwrapper">TRegisteredRefWrapper</a></li>
</ol></li>
<li><a href="#tcregisteredpointer">TCRegisteredPointer</a></li>
<li><a href="#tndregisteredpointer-tndcregisteredpointer">TNDRegisteredPointer, TNDCRegisteredPointer</a></li>
</ol></li>
<li><a href="#norad-pointers">Norad pointers</a>
<ol style="list-style-type: decimal">
<li><a href="#tnoradpointer">TNoradPointer</a></li>
</ol></li>
<li><a href="#simple-benchmarks">Simple benchmarks</a></li>
<li><a href="#reference-counting-pointers">Reference counting pointers</a>
<ol style="list-style-type: decimal">
<li><a href="#trefcountingpointer">TRefCountingPointer</a>
<ol style="list-style-type: decimal">
<li><a href="#trefcountingnotnullpointer">TRefCountingNotNullPointer</a></li>
<li><a href="#trefcountingfixedpointer">TRefCountingFixedPointer</a></li>
<li><a href="#trefcountingconstpointer-trefcountingnotnullconstpointer-trefcountingfixedconstpointer">TRefCountingConstPointer</a></li>
</ol></li>
<li><a href="#using-registered-pointers-as-weak-pointers-with-reference-counting-pointers">Using registered pointers as weak pointers</a></li>
</ol></li>
<li><a href="#scope-pointers">Scope pointers</a>
<ol style="list-style-type: decimal">
<li><a href="#txscopeitemfixedpointer">TXScopeItemFixedPointer</a></li>
<li><a href="#txscopeownerpointer">TXScopeOwnerPointer</a></li>
<li><a href="#make_xscope_strong_pointer_store">make_xscope_strong_pointer_store()</a></li>
<li><a href="#xscope_ifptr_to">xscope_ifptr_to()</a></li>
<li><a href="#xscope_chosen">xscope_chosen()</a></li>
<li><a href="#as_a_returnable_fparam">as_a_returnable_fparam()</a></li>
<li><a href="#as_an_fparam">as_an_fparam()</a></li>
<li><a href="#conformance-helpers">Conformance helpers</a>
<ol style="list-style-type: decimal">
<li><a href="#return_value">return_value()</a></li>
<li><a href="#tmemberobj">TMemberObj</a></li>
</ol></li>
</ol></li>
<li><a href="#make_pointer_to_member_v2">make_pointer_to_member_v2()</a></li>
<li><a href="#poly-pointers">Poly pointers</a>
<ol style="list-style-type: decimal">
<li><a href="#txscopepolypointer-txscopepolyconstpointer">TXScopePolyPointer</a></li>
<li><a href="#tpolypointer-tpolyconstpointer">TPolyPointer</a></li>
<li><a href="#txscopeanypointer-txscopeanyconstpointer-tanypointer-tanyconstpointer">TAnyPointer</a></li>
<li><a href="#txscopeanyrandomaccessiterator-txscopeanyrandomaccessconstiterator-tanyrandomaccessiterator-tanyrandomaccessconstiterator">TAnyRandomAccessIterator</a></li>
<li><a href="#txscopeanyrandomaccesssection-txscopeanyrandomaccessconstsection-tanyrandomaccesssection-tanyrandomaccessconstsection">TAnyRandomAccessSection</a></li>
<li><a href="#txscopeanystringsection-txscopeanystringconstsection-tanystringsection-tanystringconstsection">TAnyStringSection</a></li>
<li><a href="#txscopeanynrpstringsection-txscopeanynrpstringconstsection-tanynrpstringsection-tanynrpstringconstsection">TAnyNRPStringSection</a></li>
</ol></li>
<li><a href="#pointer_to">pointer_to()</a></li>
<li><a href="#safely-passing-parameters-by-reference">Safely passing parameters by reference</a></li>
<li><a href="#multithreading">Multithreading</a>
<ol style="list-style-type: decimal">
<li><a href="#tuserdeclaredasyncpassableobj">TUserDeclaredAsyncPassableObj</a></li>
<li><a href="#thread">thread</a></li>
<li><a href="#async">async()</a></li>
<li><a href="#asynchronously-shared-objects">Asynchronously shared objects</a>
<ol style="list-style-type: decimal">
<li><a href="#tuserdeclaredasyncshareableobj">TUserDeclaredAsyncShareableObj</a></li>
<li><a href="#tuserdeclaredasyncshareableandpassableobj">TUserDeclaredAsyncShareableAndPassableObj</a></li>
<li><a href="#tasyncsharedv2readwriteaccessrequester">TAsyncSharedV2ReadWriteAccessRequester</a></li>
<li><a href="#tasyncsharedv2readonlyaccessrequester">TAsyncSharedV2ReadOnlyAccessRequester</a></li>
<li><a href="#tasyncsharedv2immutablefixedpointer">TAsyncSharedV2ImmutableFixedPointer</a></li>
<li><a href="#tasyncsharedv2atomicfixedpointer">TAsyncSharedV2AtomicFixedPointer</a></li>
<li><a href="#tasyncrasectionsplitter">TAsyncRASectionSplitter</a></li>
</ol></li>
<li><a href="#scope-threads">Scope threads</a>
<ol style="list-style-type: decimal">
<li><a href="#access-controlled-objects">access controlled objects</a></li>
<li><a href="#xscope_thread_carrier">xscope_thread_carrier</a></li>
<li><a href="#xscope_future_carrier">xscope_future_carrier</a></li>
<li><a href="#make_xscope_asyncsharedv2acoreadwrite">make_xscope_asyncsharedv2acoreadwrite()</a></li>
<li><a href="#make_xscope_aco_locker_for_sharing">make_xscope_aco_locker_for_sharing()</a></li>
<li><a href="#make_xscope_exclusive_strong_pointer_store_for_sharing">make_xscope_exclusive_strong_pointer_store_for_sharing()</a></li>
<li><a href="#txscopeexclusivestrongpointerstoreforaccesscontrol">TXScopeExclusiveStrongPointerStoreForAccessControl</a></li>
<li><a href="#exclusive-writer-objects">exclusive writer objects</a></li>
<li><a href="#scope-atomics">scope atomics</a></li>
<li><a href="#txscopeacorasectionsplitter-and-txscopeasyncacorasectionsplitter">TXScopeACORASectionSplitter and TXScopeAsyncACORASectionSplitter</a></li>
</ol></li>
<li><a href="#static-and-global-variables">static and global variables</a>
<ol style="list-style-type: decimal">
<li><a href="#static-immutables">static immutables</a></li>
<li><a href="#static-atomics">static atomics</a></li>
<li><a href="#static-access-controlled-objects-and-access-requesters">static access controlled objects and access requesters</a></li>
</ol></li>
</ol></li>
<li><a href="#primitives">Primitives</a>
<ol style="list-style-type: decimal">
<li><a href="#cint-csize_t-and-cbool">CInt, CSize_t and CBool</a></li>
<li><a href="#cndint-cndsize_t-and-cndbool">CNDInt, CNDSize_t and CNDBool</a></li>
<li><a href="#quarantined-types">Quarantined types</a></li>
</ol></li>
<li><a href="#vectors">Vectors</a>
<ol style="list-style-type: decimal">
<li><a href="#vector">mstd::vector</a></li>
<li><a href="#nii_vector">nii_vector</a></li>
<li><a href="#msevector">msevector</a></li>
<li><a href="#ivector">ivector</a></li>
<li><a href="#make_xscope_vector_size_change_lock_guard">make_xscope_vector_size_change_lock_guard()</a>
<ol style="list-style-type: decimal">
<li><a href="#stnii_vector">stnii_vector</a></li>
<li><a href="#mtnii_vector">mtnii_vector</a></li>
</ol></li>
</ol></li>
<li><a href="#arrays">Arrays</a>
<ol style="list-style-type: decimal">
<li><a href="#array">mstd::array</a></li>
<li><a href="#nii_array">nii_array</a></li>
<li><a href="#msearray">msearray</a></li>
<li><a href="#xscope_iterator">xscope_iterator</a></li>
<li><a href="#xscope_pointer_to_array_element">xscope_pointer_to_array_element()</a></li>
</ol></li>
<li><a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">TRandomAccessSection</a></li>
<li><a href="#strings">Strings</a>
<ol style="list-style-type: decimal">
<li><a href="#string">mstd::string</a></li>
<li><a href="#nii_string">nii_string</a></li>
<li><a href="#txscopestringsection-txscopestringconstsection-tstringsection-tstringconstsection">TStringSection</a></li>
<li><a href="#txscopenrpstringsection-txscopenrpstringconstsection-tnrpstringsection-tnrpstringconstsection">TNRPStringSection</a></li>
<li><a href="#string_view">mstd::string_view</a></li>
<li><a href="#nrp_string_view">nrp_string_view</a></li>
</ol></li>
<li><a href="#optional-xscope_optional">optional</a></li>
<li><a href="#tuple-xscope_tuple">tuple</a></li>
<li><a href="#algorithms">Algorithms</a>
<ol style="list-style-type: decimal">
<li><a href="#for_each_ptr">for_each_ptr()</a></li>
<li><a href="#find_if_ptr">find_if_ptr()</a></li>
</ol></li>
<li><a href="#thread_local">thread_local</a></li>
<li><a href="#practical-limitations">Practical limitations</a></li>
<li><a href="#questions-and-comments">Questions and comments</a></li>
</ol>
<h3 id="use-cases">Use cases</h3>
<p>The library was designed to help reduce or eliminate the potential for invalid memory accesses and data races in general C++ code. The general strategy is simply to substitute potentially unsafe C++ elements with compatible safe replacements from the library. The library does not impose any particular paradigm or code structure. (Though more modern coding styles that de-emphasize explicit use of iterators may result in better performance.)</p>
<p>When a completed lifetime checker is/becomes available, some of the most used elements of the library (namely the &quot;scope&quot; pointer elements) will be rendered redundant. At the time of this writing (Aug 2018), it seems that it may still be some time before we arrive at that point. But when the time comes, code using the pointer/reference types in this library should, unlike &quot;regular&quot; C++ code, already be compliant with the restrictions that will be imposed by a completed lifetime checker. So you can think of the use of this library as a method of &quot;future-proofing&quot; your code for a time when it may become standard practice to automatically reject C++ code that isn't approved by the lifetime checker.</p>
<p>While using the library can incur a modest performance penalty, because the library elements are largely compatible with their native counterparts, they can be easily &quot;disabled&quot; (automatically replaced with their native counterparts) with a compile-time directive, allowing them, for example, to be used to help catch bugs in debug/test/beta builds while incurring no overhead in release builds.</p>
<p>And note that the safe components of this library can be adopted completely incrementally. New code written with these safe elements will play nicely with existing code, and native C++ elements can be replaced selectively without breaking the existing code. So there is really no excuse for not using the library in pretty much any situation.</p>
<p>Though for real time embedded applications, note the dependence on the standard library. You may also want to override the default behavior (of throwing an exception) upon invalid memory operations (using <code>MSE_CUSTOM_THROW_DEFINITION(x)</code>).</p>
<h3 id="setup-and-dependencies">Setup and dependencies</h3>
<p>Using this (header-only) library generally involves copying the include files you want to use into your project, and that's it. Outside of the standard library, there are no other dependencies.</p>
<p>Building the example: For those using msvc, project and solution files are included. Otherwise, just create a new project and add all the <code>.cpp</code> and <code>.h</code> files.</p>
<p>A couple of notes about compiling: With g++ and clang++, you'll need to enable thread support (-pthread). With 64-bit builds in msvc you may get a &quot;<a href="https://msdn.microsoft.com/en-us/library/8578y171(v=vs.140).aspx">fatal error C1128: number of sections exceeded object file format limit: compile with /bigobj</a>&quot;. Just <a href="https://msdn.microsoft.com/en-us/library/ms173499.aspx">add</a> the &quot;/bigobj&quot; compile flag. For more help you can try the <a href="#questions-and-comments">questions and comments</a> section. Also related: <a href="README2.md#versioning-and-deployment-philosophy">Versioning and deployment philosophy</a>.</p>
<h3 id="safercplusplus-versus-clangllvm-sanitizers">SaferCPlusPlus versus Clang/LLVM Sanitizers</h3>
<p>The Clang/LLVM compiler provides a set of &quot;sanitizers&quot; (adopted by gcc) that address C/C++ &quot;code safety&quot; issues. While they address many of the same bugs, the solutions provided by the SaferCPlusPlus library and the Clang/LLVM sanitizers differ in significant ways. Namely (as of Sep 2016):</p>
<ul>
<li>The Clang/LLVM sanitizers require modifications to the build process, not the code, whereas with SaferCPlusPlus it's the other way around.</li>
<li>SaferCPlusPlus can <a href="https://en.wikipedia.org/wiki/AddressSanitizer#Limitations">more completely</a> solve the problem of invalid memory access, but in doing so does not support certain potentially dangerous language features (like pointer arithmetic).</li>
<li>When encountering an invalid memory operation at run-time, the Clang/LLVM sanitizers terminate the executable, where SaferCPlusPlus, by default, throws a (catchable) exception, but supports any user-defined action, including program termination.</li>
<li>SaferCPlusPlus is portable C++ code that works on any platform, whereas Clang/LLVM sanitizers are available/maintained on a finite (but at the moment, ample) set of OS-architecture combinations.</li>
<li>The Clang/LLVM sanitizers cost more in terms of run-time performance. <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerPerformanceNumbers">~2x slowdown</a> for the AddressSanitizer, for example. SaferCPlusPlus generally has substantially <a href="https://github.com/duneroadrunner/SaferCPlusPlus-BenchmarksGame">lower performance costs</a>, mainly because the Clang/LLVM sanitizers cannot assume any cooperation from the source code, so they have to instrument pretty much every allocated piece of memory and check pretty well every pointer dereference.</li>
<li>SaferCPlusPlus supports the mixing of &quot;safe&quot; and (high-performance) &quot;unsafe&quot; code at a granular level, where Clang/LLVM Sanitizers apply to entire modules, or as in the case of the MemorySanitizer, all modules, requiring recompilation of any linked libraries.</li>
<li>Clang's ThreadSanitizer tries to detect data race bugs, while SaferCPlusPlus provides <a href="#asynchronously-shared-objects">data types</a> that eliminate the possibility of data race bugs (and a superset we call &quot;object race&quot; bugs).</li>
</ul>
<p>Clang/LLVM Sanitizers are intended for debugging purposes, not to be used in deployed executables. As such, by design, some of their debugging convenience features themselves introduce <a href="http://seclists.org/oss-sec/2016/q1/363">opportunities</a> for malicious exploitation. SaferCPlusPlus on the other hand, is designed to be used in deployed executables, as well as for debugging and testing. And that's reflected in its performance, security and &quot;completeness of solution&quot;. So it's not really SaferCPlusPlus &quot;versus&quot; Clang/LLVM Sanitizers. They are not incompatible, and there's no reason you couldn't use both simultaneously, although there would be significant redundancies.</p>
<h3 id="safercplusplus-versus-rust">SaferCPlusPlus versus Rust</h3>
<p>C++ and Rust differ significantly in many ways, but SaferCPlusPlus is primarily concerned with addressing memory safety so here we'll consider only that aspect. Given that, what's most notable is the similarities between SaferCPlusPlus and Rust, considering they were developed independently.</p>
<p>Probably the main issue when it comes to memory safety is the relationship between pointers/references and object deallocation. So it's notable that Rust and SaferCPlusPlus decided on roughly corresponding sets of (safe) pointer/reference types:</p>
<table>
<thead>
<tr class="header">
<th>Rust</th>
<th>SaferCPlusPlus</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>non-reassignable reference</td>
<td>scope pointer</td>
</tr>
<tr class="even">
<td>reassignable (mut) reference</td>
<td>registered pointer</td>
</tr>
<tr class="odd">
<td>Box&lt;&gt;</td>
<td>scope owner pointer</td>
</tr>
<tr class="even">
<td>Rc&lt;&gt;</td>
<td>reference counting pointer</td>
</tr>
<tr class="odd">
<td>Arc&lt;&gt;</td>
<td>shared immutable pointer</td>
</tr>
<tr class="even">
<td>Arc&lt; RwLock&lt;&gt; &gt;</td>
<td>access requester</td>
</tr>
</tbody>
</table>
<p>Indeed, if you are a Rust programmer you might be more comfortable using SaferCPlusPlus than traditional C++.</p>
<p>The most commonly used reference type, the non-reassignable (non-mut) reference in Rust and the scope pointer in SaferCPlusPlus, incurs no run-time overhead in both cases, which is a primary reason for the excellent performance of both solutions.</p>
<p>Reassignable (mut) references occur much less frequently, but still have no run-time overhead in Rust. Since SaferCPlusPlus does not (yet) have a &quot;borrow checker&quot;, it has to resort to run-time checks to ensure memory safety in this case. But in exchange for the overhead, SaferCPlusPlus' registered pointers get essentially all the flexibility of native pointers (minus pointer arithmetic).</p>
<p>Probably the biggest difference though, is that SaferCPlusPlus does not (universally) restrict the number and type of references to an object that can exist at one time (i.e. the &quot;exclusivity of mutable references&quot;) the way Rust does. With respect to memory safety, the benefit of this restriction is that it ensures that objects with &quot;arbitrary lifespan&quot; (like an element in a (resizable) vector) are not deallocated while other references to that object still exist. But most objects do not have &quot;arbitrary lifespan&quot; (both Rust and SaferCPlusPlus encourage most objects to have &quot;scope lifespan&quot;), so most of the time, from a memory safety perspective, this restriction is not necessary. So SaferCPlusPlus (and the lifetime checker too) are more selective about what restrictions are applied and when.</p>
<p>There are situations where restrictions on object accessibility can be beneficial or essential for reasons other than (single-threaded) memory safety. (To help ensure data race safety of asynchronously shared objects, for example.) For those cases, the library does provide facilities for the enforcement of &quot;access control&quot; restrictions, including essentially the <a href="#exclusive-writer-objects">equivalent</a> of Rust's <code>RefCell</code> wrapper.</p>
<p>Another difference is the available options for dealing with scope lifetime restrictions. For example, let's say that instead of a list (or whatever container) of objects, you have a list of references to existing objects. And let's say that at some point you want to insert a reference to local variable (allocated on the stack) (as with the C++ example <a href="https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/implications%20of%20the%20lifetime%20checker%20restrictions.md#snippet-4">here</a>). Unfortunately, Rust only allows you to (safely) do so in cases where the variable is &quot;structurally&quot; guaranteed to outlive the list container itself. This is understandable, as otherwise you could end up with the list containing a reference that is no longer valid.</p>
<p>But you could imagine scenarios where you might want to temporarily insert a reference to a (stack allocated) local variable that does not outlive the container. In order to (safely) support this you'd need a reference type that can safely handle the potential disappearance of its target object. In Rust, the <code>Weak</code> reference is the only one that has this property. But <code>Weak</code> references cannot target (stack allocated) local variables, so we're kind of out of luck. SaferCPlusPlus' registered pointers, on the other hand, safely handle the potential disappearance of their target and are able to target (stack allocated) local variables. Registered pointers do have a run-time cost, but that is often outweighed by the benefit of allowing the target object to be a (stack allocated) local variable, rather than, say, a (heap allocated) &quot;reference counted&quot; object.</p>
<p>Overall though, there's probably more commonality than difference between the Rust and the SaferCPlusPlus memory safety strategies. At least compared to other current languages. So, perhaps as expected, you could think of the comparison between SaferCPlusPlus and Rust as essentially the comparison between C++ and Rust, with diminished discrepancies in memory safety and performance.</p>
<h3 id="safercplusplus-versus-checked-c">SaferCPlusPlus versus Checked C</h3>
<p>&quot;Checked C&quot;, like SaferCPlusPlus, takes the approach of extending the language with safer elements that can directly substitute for unsafe native elements. In chapter 9 of their <a href="https://github.com/Microsoft/checkedc/releases/download/v0.5-final/checkedc-v0.5.pdf">spec</a>, there is an extensive survey of existing (and historical) efforts to address C/C++ memory safety. There they make the argument for the (heretofore neglected) &quot;language extension&quot; approach (basically citing performance, compatibility and the support for granular mixing of safe and unsafe code), that applies to SaferCPlusPlus as well.</p>
<p>Checked C and SaferCPlusPlus are more complementary than competitive. Checked C targets low-level system C code and basically only addresses the array bounds checking issue, including pointer arithmetic, where SaferCPlusPlus skews more toward C++ code and legacy code that would benefit from being converted to modern C++. It seems that Checked C is not yet ready for deployment (as of Sep 2016), but one could imagine both solutions being used, with little contention, in projects that have both low-level system type code and higher-level application type code.</p>
<h3 id="getting-started-on-safening-existing-code">Getting started on safening existing code</h3>
<p>The elements in this library are straightforward enough that a separate tutorial, beyond the examples given in the documentation, is probably not necessary. But if you're wondering how best to start, probably the easiest and most effective thing to do is to replace the vectors and arrays in your code (that aren't being shared between threads) with <a href="#vector"><code>mse::mstd::vector&lt;&gt;</code></a> and <a href="#array"><code>mse::mstd::array&lt;&gt;</code></a>. Update for C++17: <code>std::string_view</code> seems to be quite <a href="https://github.com/isocpp/CppCoreGuidelines/issues/1038">prone</a> to use-after-free bugs. You can substitute them with <a href="#nrp_string_view"><code>mse::nrp_string_view</code></a>, and your <code>std::string</code>s with <a href="#string"><code>mse::mstd::string</code></a>.</p>
<p>Statistically speaking, doing this should already catch a significant chunk of potential memory bugs. By default, an exception will be thrown upon any attempt to access invalid memory. If your project is not using C++ exceptions, you'll probably want to override the default exception behavior by defining the <code>MSE_CUSTOM_THROW_DEFINITION()</code> preprocessor macro prior to inclusion of the header files. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#define MSE_CUSTOM_THROW_DEFINITION(x) std::cerr &lt;&lt; std::endl &lt;&lt; x.what(); exit(-11)</span></code></pre></div>
<p>will cause the error description to be written to stderr before program termination.</p>
<p>The next most effective thing to do, in terms of improving memory safety, is probably to replace calls to <code>new</code>/<code>malloc</code> and <code>delete</code>/<code>free</code>. The direct substitutes provided in the library (for items not shared between threads) are <code>mse::registered_new()</code> and <code>mse::registered_delete()</code>. The pointer type returned by <code>mse::registered_new()</code> is an <a href="#tregisteredpointer"><code>mse::TRegisteredPointer&lt;&gt;</code></a>. If you need this pointer to interact with legacy interfaces, it can be explicitly cast to a corresponding native pointer. But ultimately you're going to want to minimize the amount of casting to (unsafe) native pointers by updating your (function) interfaces to accomodate these safe pointers directly. (See the &quot;<a href="#safely-passing-parameters-by-reference">Safely passing parameters by reference</a>&quot; section.)</p>
<p>Based on reported vulnerabilities, these two things alone should catch most memory bugs.</p>
<p>While the library provides these direct substitutes for <code>new</code>/<code>malloc</code> and <code>delete</code>/<code>free</code>, they are usually not the optimal solution. In most cases, you can instead use <a href="#txscopeownerpointer"><code>mse::TXScopeOwnerPointer&lt;&gt;</code></a> or <a href="#trefcountingnotnullpointer"><code>TRefCountingNotNullPointer&lt;&gt;</code></a>, which are faster and automatically deallocate the item for you.</p>
<p>For items shared between asynchronous threads, use one of the <a href="#asynchronously-shared-objects">data types designed for safe asynchronous sharing</a>.</p>
<p>After that, it's just a matter of replacing the remaining unsafe elements in your code (generally native pointers and references) with the safer substitute that works best. You might want to leave C++ references for last, because a) they seem to be empirically (if not theoretically) less prone to bugs than pointers, and b) the library does not provide a directly compatible substitute (although <a href="#tregisteredrefwrapper"><code>TRegisteredRefWrapper&lt;&gt;</code></a> can be used in some situations), so references generally have to be substituted with pointers, which involves the extra bit of work of changing your dots to arrows.</p>
<p>And if at some point you feel that these new elements involve a lot of typing, note that many of the elements have short aliases that can be used instead. Just search for &quot;shorter aliases&quot; in the header files. Or, of course, you can create your own to suit your preferences.</p>
<h3 id="registered-pointers">Registered pointers</h3>
<p>&quot;Registered&quot; pointers are intended to behave much like native C++ pointers, except that their value is (automatically) set to nullptr when the target object is destroyed. And by default they will throw an exception upon any attempt to dereference a nullptr. Because they don't take ownership like some other smart pointers, they can point to objects allocated on the stack as well as the heap. Safe, flexible pointers like these can be handy in situations that are not amenable to the confining restrictions of the lifetime checker. They may be particularly useful when updating legacy code (to be safer). And they can be explicitly cast to the corresponding native pointer when needed.</p>
<p>Two types of registered pointers are provided - <a href="#tregisteredpointer"><code>TRegisteredPointer&lt;&gt;</code></a> and <a href="#tcregisteredpointer"><code>TCRegisteredPointer&lt;&gt;</code></a>. They are functionally equivalent, but <code>TRegisteredPointer&lt;&gt;</code> is optimized for better average performance, while <code>TCRegisteredPointer&lt;&gt;</code> is a little more optimized for better &quot;worst-case&quot; performance. (Specifically, the operation of retargeting (or &quot;detargeting&quot;) a <code>TRegisteredPointer&lt;&gt;</code> in the worst case is <em>O(n)</em>, where <em>n</em> is the number of other pointers targeting the same original target object. With <code>TCRegisteredPointer&lt;&gt;</code> it's always <em>O(1)</em>.)</p>
<p>Note that these registered pointers cannot target some types that cannot act as base classes. The primitive types like int, bool, etc. cannot act as base classes. The library provides safer <a href="#cndint-cndsize_t-and-cndbool">substitutes</a> for <code>int</code>, <code>bool</code> and <code>size_t</code> that can act as base classes. Also note that these registered pointers are not thread safe. When you need to share objects between asynchronous threads, you can use the <a href="#asynchronously-shared-objects">safe sharing data types</a> in this library.</p>
<p>Although registered pointers are more general and flexible, it's expected that <a href="#scope-pointers">scope pointers</a> will actually be more commonly used. At least in cases where performance is important. While more restricted than registered pointers, by default they have no run-time overhead. In fact, even when registered pointers are used, rather than using them to access the target object directly, you may find it often preferable to use the registered pointer to obtain a scope pointer to the object and use the scope pointer instead. Though for the sake of simplicity, we don't use scope pointers in the registered pointer usage examples.</p>
<h3 id="tregisteredpointer">TRegisteredPointer</h3>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> CA {
        <span class="kw">public</span>:
            CA(<span class="dt">int</span> x) : <span class="va">m_x</span>(x) {}
            <span class="dt">int</span> <span class="va">m_x</span>;
        };
    
        mse::TRegisteredPointer&lt;CA&gt; a_regptr;
        CA a2_obj(<span class="dv">2</span>);
        {
            <span class="co">// mse::TRegisteredObj&lt;CA&gt; is a class publicly derived from CA</span>
    
            mse::TRegisteredObj&lt;CA&gt; a_regobj(<span class="dv">1</span>); <span class="co">// a_regobj is entirely on the stack</span>
    
            a_regptr = &amp;a_regobj;
            a2_obj = (*a_regptr);
        }
        <span class="cf">if</span> (a_regptr) {
            assert(<span class="kw">false</span>);
        } <span class="cf">else</span> {
            <span class="cf">try</span> {
                a2_obj = (*a_regptr);
            }
            <span class="cf">catch</span> (...) {
                <span class="co">// expected exception</span>
            }
        }
    
        a_regptr = mse::registered_new&lt;CA&gt;(<span class="dv">3</span>); <span class="co">// heap allocation</span>
        mse::registered_delete&lt;CA&gt;(a_regptr);
    
        <span class="co">/* You can also use the make_registered() function to obtain a registered object from a given value. */</span>
        <span class="kw">auto</span> a3_regobj = mse::make_registered(CA(<span class="dv">5</span>));
    }</code></pre></div>
<p>Note that using <code>mse::registered_delete()</code> to delete an object through a base class pointer will result in a failed assert / thrown exception. In such cases use (the not quite as safe) <code>mse::us::registered_delete()</code> instead.</p>
<h3 id="tregisterednotnullpointer">TRegisteredNotNullPointer</h3>
<p><code>TRegisteredNotNullPointer&lt;&gt;</code> is a version of <code>TRegisteredPointer&lt;&gt;</code> that cannot be constructed to a null value. Note that <code>TRegisteredPointer&lt;&gt;</code> does not implicitly convert to <code>TRegisteredNotNullPointer&lt;&gt;</code>. When needed, the conversion can be done with the <code>mse::not_null_from_nullable()</code> function.</p>
<h3 id="tregisteredfixedpointer">TRegisteredFixedPointer</h3>
<p><code>TRegisteredFixedPointer&lt;&gt;</code> is a version of <code>TRegisteredNotNullPointer&lt;&gt;</code> that cannot be retargeted after construction (basically a &quot;<code>const TRegisteredNotNullPointer&lt;&gt;</code>&quot;). It is essentially a functional equivalent of a C++ reference.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> CA {
        <span class="kw">public</span>:
            CA(<span class="bu">std::</span>string str) : <span class="va">m_str</span>(str) {}
            <span class="bu">std::</span>string <span class="va">m_str</span>;
        };
    
        <span class="kw">class</span> CB {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">void</span> foo(mse::TRegisteredFixedConstPointer&lt;CA&gt; input1_fc_ptr, mse::TRegisteredFixedConstPointer&lt;CA&gt; 
                input2_fc_ptr, mse::TRegisteredFixedPointer&lt;CA&gt; output_f_ptr) {
                output_f_ptr-&gt;<span class="va">m_str</span> = <span class="st">&quot;output from &quot;</span> + input1_fc_ptr-&gt;<span class="va">m_str</span> + <span class="st">&quot; and &quot;</span> + input2_fc_ptr-&gt;<span class="va">m_str</span>;
                <span class="cf">return</span>;
            }
        };
    
        mse::TRegisteredObj&lt;CA&gt; in1_regobj(<span class="st">&quot;input1&quot;</span>);
        mse::TRegisteredPointer&lt;CA&gt; in2_regptr = mse::registered_new&lt;CA&gt;(<span class="st">&quot;input2&quot;</span>);
        <span class="kw">auto</span> out_regobj = mse::make_registered(CA(<span class="st">&quot;&quot;</span>)); <span class="co">/* Alternative way to make a registered object. */</span>
    
        CB::foo(&amp;in1_regobj, &amp;(*in2_regptr), &amp;out_regobj);
    
        mse::registered_delete&lt;CA&gt;(in2_regptr);
    }</code></pre></div>
<h3 id="tregisteredconstpointer-tregisterednotnullconstpointer-tregisteredfixedconstpointer">TRegisteredConstPointer, TRegisteredNotNullConstPointer, TRegisteredFixedConstPointer</h3>
<p><code>TRegisteredPointer&lt;X&gt;</code> does implicitly convert to <code>TRegisteredPointer&lt;const X&gt;</code>. But some prefer to think of the pointer giving &quot;const&quot; access to the object rather than giving access to a &quot;const object&quot;.</p>
<h3 id="tregisteredrefwrapper">TRegisteredRefWrapper</h3>
<p>Just a registered version of <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"><code>std::reference_wrapper&lt;&gt;</code></a>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mseprimitives.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>

    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="co">/* This example originally comes from http://www.cplusplus.com/reference/functional/reference_wrapper/. */</span>
        mse::TRegisteredObj&lt;mse::CInt&gt; a(<span class="dv">10</span>), b(<span class="dv">20</span>), c(<span class="dv">30</span>);
        <span class="co">// an array of &quot;references&quot;:</span>
        mse::TRegisteredRefWrapper&lt;mse::CInt&gt; refs[] = { a,b,c };
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;refs:&quot;</span>;
        <span class="cf">for</span> (mse::CInt&amp; x : refs) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&#39; &#39;</span> &lt;&lt; x;
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
    
        mse::TRegisteredObj&lt;mse::CInt&gt; foo(<span class="dv">10</span>);
        <span class="kw">auto</span> bar = mse::registered_ref(foo);
        ++(mse::CInt&amp;)bar;
        <span class="bu">std::</span>cout &lt;&lt; foo &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>;
    }</code></pre></div>
<h3 id="tcregisteredpointer">TCRegisteredPointer</h3>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msecregistered.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        
        <span class="kw">class</span> C;
    
        <span class="kw">class</span> D {
        <span class="kw">public</span>:
            <span class="kw">virtual</span> ~D() {}
            mse::TCRegisteredPointer&lt;C&gt; <span class="va">m_c_ptr</span>;
        };
    
        <span class="kw">class</span> C {
        <span class="kw">public</span>:
            mse::TCRegisteredPointer&lt;D&gt; <span class="va">m_d_ptr</span>;
        };
    
        mse::TCRegisteredObj&lt;C&gt; regobjfl_c;
        mse::TCRegisteredPointer&lt;D&gt; d_ptr = mse::cregistered_new&lt;D&gt;();
    
        regobjfl_c.<span class="va">m_d_ptr</span> = d_ptr;
        d_ptr-&gt;<span class="va">m_c_ptr</span> = &amp;regobjfl_c;
    
        mse::cregistered_delete&lt;D&gt;(d_ptr);
    }</code></pre></div>
<p>As with <a href="#tregisteredpointer"><code>TRegisteredPointer&lt;&gt;</code></a>, if deleting a cregistered object via a pointer to its base class you'll need to use the <code>mse::us::cregistered_delete&lt;&gt;()</code> function instead.</p>
<h4 id="tcregisterednotnullpointer">TCRegisteredNotNullPointer</h4>
<h4 id="tcregisteredfixedpointer">TCRegisteredFixedPointer</h4>
<h4 id="tcregisteredconstpointer-tcregisterednotnullconstpointer-tcregisteredfixedconstpointer">TCRegisteredConstPointer, TCRegisteredNotNullConstPointer, TCRegisteredFixedConstPointer</h4>
<h3 id="tndregisteredpointer-tndcregisteredpointer">TNDRegisteredPointer, TNDCRegisteredPointer</h3>
<p>When pointing to a valid object, <a href="#registered-pointers"><code>TRegisteredPointer&lt;&gt;</code> and <code>TCRegisteredPointer&lt;&gt;</code></a> essentially behave like raw pointers. So when in &quot;disabled&quot; mode, they are just aliased to raw pointers. However, in cases when their target object becomes invalid (i.e. is destroyed), the behavior of registered pointers is not the same as raw pointers. Specifically, registered pointers are automatically set to null when their target object is destroyed. So any code that relies on this behavior might not work properly when the registered pointers are substituted with raw pointers.</p>
<p>So for those cases, <code>TNDRegisteredPointer&lt;&gt;</code> and <code>TNDCRegisteredPointer</code> are just versions of registered pointers that are not aliased to raw pointers in &quot;disabled&quot; mode. In fact, when not in &quot;disabled&quot; mode, <code>TRegisteredPointer&lt;&gt;</code> and <code>TCRegisteredPointer&lt;&gt;</code> are just aliases for <code>TNDRegisteredPointer&lt;&gt;</code> and <code>TNDCRegisteredPointer</code>.</p>
<h3 id="norad-pointers">Norad pointers</h3>
<p>&quot;Norad&quot; pointers, like <a href="#registered-pointers">registered pointers</a>, behave similar to native pointers. But where registered pointers are automatically set to <code>nullptr</code> when their target is destroyed, the destruction of an object while a &quot;norad&quot; pointer is still targeting it results in program termination. This drastic consequence allows norad pointers' run-time safety mechanism to be even more lightweight than registered pointers. And unlike registered pointers, you can obtain a <a href="#scope-pointers">scope pointer</a> from any norad pointer (using the <a href="#make_xscope_strong_pointer_store"><code>make_xscope_strong_pointer_store()</code></a> function).</p>
<h3 id="tnoradpointer">TNoradPointer</h3>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msenorad.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="kw">class</span> C;

        <span class="kw">class</span> D {
        <span class="kw">public</span>:
            <span class="kw">virtual</span> ~D() {}
            mse::TNoradPointer&lt;C&gt; <span class="va">m_c_ptr</span>;
        };

        <span class="kw">class</span> C {
        <span class="kw">public</span>:
            mse::TNoradPointer&lt;D&gt; <span class="va">m_d_ptr</span>;
        };

        mse::TNoradObj&lt;C&gt; noradobj_c;
        mse::TNoradPointer&lt;D&gt; d_ptr = mse::norad_new&lt;D&gt;();

        noradobj_c.<span class="va">m_d_ptr</span> = d_ptr;
        d_ptr-&gt;<span class="va">m_c_ptr</span> = &amp;noradobj_c;

        <span class="co">/* We must make sure that there are no other references to the target of d_ptr before deleting it. Registered pointers don&#39;t</span>
<span class="co">        have the same requirement. */</span>
        noradobj_c.<span class="va">m_d_ptr</span> = <span class="kw">nullptr</span>;

        mse::norad_delete&lt;D&gt;(d_ptr);

        <span class="co">/* You can also use the make_norad() function to obtain a norad object from a given value. */</span>
        <span class="kw">auto</span> noradobj_c2 = mse::make_norad(C());
    }</code></pre></div>
<h3 id="tnoradnotnullpointer">TNoradNotNullPointer</h3>
<p><code>TNoradNotNullPointer&lt;&gt;</code> is a version of <code>TNoradPointer&lt;&gt;</code> that cannot be constructed to or assigned a null value. Because a <code>TNoradNotNullPointer&lt;&gt;</code> cannot outlive its target, it should be always safe to assume that it points to a validly allocated object. Note that <code>TNoradPointer&lt;&gt;</code> does not implicitly convert to <code>TNoradNotNullPointer&lt;&gt;</code>. When needed, the conversion can be done with the <code>mse::not_null_from_nullable()</code> function.</p>
<h4 id="tnoradfixedpointer">TNoradFixedPointer</h4>
<h4 id="tnoradconstpointer-tnoradnotnullconstpointer-tnoradfixedconstpointer-tndnoradpointer">TNoradConstPointer, TNoradNotNullConstPointer, TNoradFixedConstPointer, TNDNoradPointer</h4>
<h3 id="simple-benchmarks">Simple benchmarks</h3>
<p>Just some simple microbenchmarks of the pointers. (Some less &quot;micro&quot; benchmarks of the library in general can be found <a href="https://github.com/duneroadrunner/SaferCPlusPlus-BenchmarksGame">here</a>.) The source code for these benchmarks can be found in the file <a href="https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/msetl_example.cpp">msetl_example.cpp</a>. (Search for &quot;benchmark&quot; in the file.)</p>
<h5 id="platform-msvc2017default-optimizationsx64windows7haswell-sep-2018">platform: msvc2017/default optimizations/x64/Windows7/Haswell (Sep 2018):</h5>
<h4 id="target-object-allocation-and-deallocation">Target object allocation and deallocation:</h4>
<table>
<thead>
<tr class="header">
<th>Pointer Type</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>native pointer (stack)</td>
<td>0.049 seconds</td>
</tr>
<tr class="even">
<td><a href="#tcregisteredpointer">mse::TCRegisteredPointer</a> (stack)</td>
<td>0.057 seconds</td>
</tr>
<tr class="odd">
<td><a href="#tregisteredpointer">mse::TRegisteredPointer</a> (stack)</td>
<td>0.058 seconds</td>
</tr>
<tr class="even">
<td><a href="#tnoradpointer">mse::TNoradPointer</a> (stack)</td>
<td>0.059 seconds</td>
</tr>
<tr class="odd">
<td>native pointer (heap)</td>
<td>0.384 seconds</td>
</tr>
<tr class="even">
<td>mse::TNoradPointer (heap)</td>
<td>0.394 seconds</td>
</tr>
<tr class="odd">
<td><a href="#trefcountingpointer">mse::TRefCountingPointer</a> (heap)</td>
<td>0.402 seconds</td>
</tr>
<tr class="even">
<td>mse::TCRegisteredPointer (heap)</td>
<td>0.414 seconds</td>
</tr>
<tr class="odd">
<td>mse::TRegisteredPointer (heap)</td>
<td>0.417 seconds</td>
</tr>
<tr class="even">
<td>std::shared_ptr (heap)</td>
<td>0.524 seconds</td>
</tr>
</tbody>
</table>
<h4 id="pointer-declaration-copy-and-assignment">Pointer declaration, copy and assignment:</h4>
<table>
<thead>
<tr class="header">
<th>Pointer Type</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>native pointer</td>
<td>0.046 seconds</td>
</tr>
<tr class="even">
<td>mse::TRefCountingPointer</td>
<td>0.090 seconds</td>
</tr>
<tr class="odd">
<td>mse::TNoradPointer</td>
<td>0.119 seconds</td>
</tr>
<tr class="even">
<td>mse::TRegisteredPointer</td>
<td>0.145 seconds</td>
</tr>
<tr class="odd">
<td>mse::TCRegisteredPointer</td>
<td>0.160 seconds</td>
</tr>
<tr class="even">
<td>std::shared_ptr</td>
<td>0.284 seconds</td>
</tr>
</tbody>
</table>
<h4 id="dereferencing">Dereferencing:</h4>
<table>
<thead>
<tr class="header">
<th>Pointer Type</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>native pointer</td>
<td>0.106 seconds</td>
</tr>
<tr class="even">
<td>native pointer + nullptr check</td>
<td>0.107 seconds</td>
</tr>
<tr class="odd">
<td>mse::TNoradPointer</td>
<td>0.160 seconds</td>
</tr>
<tr class="even">
<td>mse::TCRegisteredPointer</td>
<td>0.162 seconds</td>
</tr>
<tr class="odd">
<td>mse::TRefCountingPointer</td>
<td>0.220 seconds</td>
</tr>
<tr class="even">
<td>std::weak_ptr</td>
<td>1.364 seconds</td>
</tr>
</tbody>
</table>
<p>Take these results with a grain of salt. The benchmarks were run on a noisy machine, and anyway don't represent realistic usage scenarios. But they give you a rough idea of the relative performances.</p>
<p>You can see that the library's safe pointers are quite fast compared to, say, <code>std::shared_ptr</code>/<code>std::weak_ptr</code>. But in some sense, as long as it's not egregiously bad, their performance is kind of moot because performance sensitive programs would generally stick to using <a href="#scope-pointers">scope pointers</a> in critical inner loops. And by default, scope pointers have identical performance to native pointers.</p>
<h3 id="reference-counting-pointers">Reference counting pointers</h3>
<p>If you're going to use pointers, then to ensure they won't be used to access invalid memory you basically have two options - detect any attempt to do so and throw an exception, or, alternatively, ensure that the pointer targets a validly allocated object. Registered pointers rely on the former, and so-called &quot;reference counting&quot; pointers can be used to achieve the latter. The most famous reference counting pointer is <code>std::shared_ptr&lt;&gt;</code>, which is notable for its thread-safe reference counting that can be handy when you're sharing an object among asynchronous threads, but is unnecessarily costly when you aren't. So we provide fast reference counting pointers that forego any thread safety mechanisms. In addition to being substantially faster (and smaller) than <code>std::shared_ptr&lt;&gt;</code>, they are a bit more safety oriented in that they they don't support construction from raw pointers. (Use <code>mse::make_refcounting&lt;&gt;()</code> instead.) &quot;Const&quot;, &quot;not null&quot; and &quot;fixed&quot; (non-retargetable) flavors are also provided with proper conversions between them.</p>
<h3 id="trefcountingpointer">TRefCountingPointer</h3>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mserefcounting.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A() {}
            A(<span class="at">const</span> A&amp; _X) : b(_X.b) {}
            <span class="kw">virtual</span> ~A() {
                <span class="dt">int</span> q = <span class="dv">3</span>; <span class="co">/* just so you can place a breakpoint if you want */</span>
            }
            A&amp; <span class="kw">operator</span>=(<span class="at">const</span> A&amp; _X) { b = _X.b; <span class="cf">return</span> (*<span class="kw">this</span>); }

            <span class="dt">int</span> b = <span class="dv">3</span>;
        };
        <span class="kw">typedef</span> <span class="bu">std::</span>vector&lt;mse::TRefCountingFixedPointer&lt;A&gt;&gt; CRCFPVector;
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">int</span> foo1(mse::TRefCountingPointer&lt;A&gt; A_refcounting_ptr, CRCFPVector&amp; rcfpvector_ref) {
                rcfpvector_ref.clear();
                <span class="dt">int</span> retval = A_refcounting_ptr-&gt;b;
                A_refcounting_ptr = <span class="kw">nullptr</span>; <span class="co">/* Target object is destroyed here. */</span>
                <span class="cf">return</span> retval;
            }
        <span class="kw">protected</span>:
            ~B() {}
        };

        {
            CRCFPVector rcfpvector;
            {
                mse::TRefCountingFixedPointer&lt;A&gt; A_refcountingfixed_ptr1 = mse::make_refcounting&lt;A&gt;();
                rcfpvector.push_back(A_refcountingfixed_ptr1);

                <span class="co">/* Just to demonstrate conversion between refcounting pointer types. */</span>
                mse::TRefCountingConstPointer&lt;A&gt; A_refcountingconst_ptr1 = A_refcountingfixed_ptr1;
            }
            B::foo1(rcfpvector.front(), rcfpvector);
        }
    }</code></pre></div>
<h3 id="trefcountingnotnullpointer">TRefCountingNotNullPointer</h3>
<p>Same as <code>TRefCountingPointer&lt;&gt;</code>, but cannot be constructed to or assigned a null value. Because <code>TRefCountingNotNullPointer&lt;&gt;</code> controls the lifetime of its target, it should be always safe to assume that it points to a validly allocated object. Note that <code>TRefCountingPointer&lt;&gt;</code> does not implicitly convert to <code>TRefCountingNotNullPointer&lt;&gt;</code>. When needed, the conversion can be done with the <code>mse::not_null_from_nullable()</code> function.</p>
<p>And also note that the <code>mse::make_refcounting&lt;&gt;()</code> function actually returns a <code>TRefCountingNotNullPointer&lt;&gt;</code>. When you want a regular <code>TRefCountingPointer&lt;&gt;</code>, you can use the <code>mse::make_nullable_refcounting&lt;&gt;()</code> function instead.</p>
<h3 id="trefcountingfixedpointer">TRefCountingFixedPointer</h3>
<p>Same as <code>TRefCountingNotNullPointer&lt;&gt;</code>, but cannot be retargeted after construction (basically a &quot;<code>const TRefCountingNotNullPointer&lt;&gt;</code>&quot;).</p>
<h3 id="trefcountingconstpointer-trefcountingnotnullconstpointer-trefcountingfixedconstpointer">TRefCountingConstPointer, TRefCountingNotNullConstPointer, TRefCountingFixedConstPointer</h3>
<p><code>TRefCountingPointer&lt;X&gt;</code> actually does implicitly convert to <code>TRefCountingPointer&lt;const X&gt;</code>. But some prefer to think of the pointer giving &quot;const&quot; access to the object rather than giving access to a &quot;const object&quot;.</p>
<h3 id="using-registered-pointers-as-weak-pointers-with-reference-counting-pointers">Using registered pointers as weak pointers with reference counting pointers</h3>
<p><code>TRefCountingPointer&lt;&gt;</code> does not have a specific associated weak pointer like <code>std::shared_ptr&lt;&gt;</code> does. But registered pointers can be thought of as sort of independent, universal weak pointers. Note that we're talking about targeting objects &quot;in&quot; the same thread here. Sharing objects between threads is done through the library's <a href="#asynchronously-shared-objects">data types for asynchronous sharing</a>.</p>
<p>Generally you're going to want to obtain a &quot;strong&quot; pointer from the weak pointer, so rather than targeting the registered pointer directly at the object of interest, you'd target a/the strong owning pointer of the object.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mserefcounting.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    <span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

        <span class="kw">typedef</span> mse::TRefCountingFixedPointer&lt;<span class="bu">std::</span>string&gt; <span class="dt">str_rc_ptr_t</span>; <span class="co">// owning pointer of a string</span>
        <span class="kw">typedef</span> mse::TNDRegisteredObj&lt;<span class="dt">str_rc_ptr_t</span>&gt; <span class="dt">str_rc_ptr_regobj_t</span>; <span class="co">// registered version of above so that you can obtain a (weak)</span>
                                                                       <span class="co">// registered pointer to it</span>

         <span class="co">/* str_rc_rc_ptr1 is a &quot;shared&quot; owner of an owning pointer of a string  */</span>
        <span class="kw">auto</span> str_rc_rc_ptr1 = mse::make_nullable_refcounting&lt;<span class="dt">str_rc_ptr_regobj_t</span>&gt;(<span class="dt">str_rc_ptr_regobj_t</span>(mse::make_refcounting&lt;<span class="bu">std::</span>string&gt;(<span class="st">&quot;some text&quot;</span>)));
        <span class="co">/* You need to double dereference it to access the string value. */</span>
        <span class="bu">std::</span>cout &lt;&lt; **str_rc_rc_ptr1 &lt;&lt; <span class="bu">std::</span>endl;

        <span class="co">/* Here we&#39;re obtaining a (weak) registered pointer to the owning pointer of the string. */</span>
        <span class="kw">auto</span> str_rc_reg_ptr1 = &amp;(*str_rc_rc_ptr1);
        <span class="co">/* Here you also need to double dereference it to access the string value. */</span>
        <span class="bu">std::</span>cout &lt;&lt; **str_rc_reg_ptr1 &lt;&lt; <span class="bu">std::</span>endl;

        {
            <span class="co">/* We can obtain a (strong) owning pointer of the string from the (weak) registered pointer. */</span>
            <span class="kw">auto</span> str_rc_ptr2 = *str_rc_reg_ptr1;

            <span class="bu">std::</span>cout &lt;&lt; *str_rc_ptr2 &lt;&lt; <span class="bu">std::</span>endl;
        }

        assert(str_rc_reg_ptr1); <span class="co">// just asserting the str_rc_reg_ptr1 is not null here</span>

        <span class="co">/* Here we&#39;re releasing ownership of the string owning pointer. Since this was its only owner, the string owning</span>
<span class="co">        pointer (and consequently the string) will be destroyed. */</span>
        str_rc_rc_ptr1 = <span class="kw">nullptr</span>;

        assert(!str_rc_reg_ptr1); <span class="co">// here we&#39;re asserting that str_rc_reg_ptr1 has been (automatically) set to null</span>
    }</code></pre></div>
<p>This next example demonstrates using <code>TNDCRegisteredPointer&lt;&gt;</code> as a safe &quot;weak_ptr&quot; to prevent cyclic references from becoming memory leaks. This isn't much different from using <code>std::weak_ptr&lt;&gt;</code> in terms of functionality, but there can be performance and safety advantages.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mserefcounting.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msecregistered.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

        <span class="kw">class</span> CRCNode;

        <span class="kw">typedef</span> mse::TRefCountingFixedPointer&lt;CRCNode&gt; <span class="dt">rcnode_strongptr_t</span>;            <span class="co">// owning pointer of a CRCNode</span>
        <span class="kw">typedef</span> mse::TNDRegisteredObj&lt;<span class="dt">rcnode_strongptr_t</span>&gt; <span class="dt">rcnode_strongptr_regobj_t</span>; <span class="co">// registered version of above so that you can obtain a (weak)</span>
                                                                                    <span class="co">// registered pointer to it</span>
        <span class="kw">typedef</span> mse::TNDRegisteredPointer&lt;<span class="dt">rcnode_strongptr_t</span>&gt; <span class="dt">rcnode_strongptr_weakptr_t</span>; <span class="co">// (weak) registered pointer to owning pointer of a CRCNode</span>

        <span class="kw">class</span> CRCNode {
        <span class="kw">public</span>:
            CRCNode(mse::TRegisteredPointer&lt;mse::CInt&gt; node_count_ptr
                , <span class="dt">rcnode_strongptr_weakptr_t</span> root_ptr_ptr) : <span class="va">m_node_count_ptr</span>(node_count_ptr), <span class="va">m_root_ptr_ptr</span>(root_ptr_ptr) {
                (*node_count_ptr) += <span class="dv">1</span>;
            }
            CRCNode(mse::TRegisteredPointer&lt;mse::CInt&gt; node_count_ptr) : <span class="va">m_node_count_ptr</span>(node_count_ptr) {
                (*node_count_ptr) += <span class="dv">1</span>;
            }
            <span class="kw">virtual</span> ~CRCNode() {
                (*<span class="va">m_node_count_ptr</span>) -= <span class="dv">1</span>;
            }
            <span class="at">static</span> <span class="dt">rcnode_strongptr_regobj_t</span> MakeRoot(mse::TRegisteredPointer&lt;mse::CInt&gt; node_count_ptr) {
                <span class="kw">auto</span> retval = <span class="dt">rcnode_strongptr_regobj_t</span>{ mse::make_refcounting&lt;CRCNode&gt;(node_count_ptr) };
                (*retval).<span class="va">m_root_ptr_ptr</span> = &amp;retval;
                <span class="cf">return</span> retval;
            }
            <span class="kw">auto</span> MaybeStrongChildPtr() <span class="at">const</span> { <span class="cf">return</span> <span class="va">m_maybe_child_ptr</span>; }
            <span class="dt">rcnode_strongptr_regobj_t</span> MakeChild() {
                <span class="va">m_maybe_child_ptr</span>.emplace(<span class="dt">rcnode_strongptr_regobj_t</span>{ mse::make_refcounting&lt;CRCNode&gt;(<span class="va">m_node_count_ptr</span>, <span class="va">m_root_ptr_ptr</span>) });
                <span class="cf">return</span> <span class="va">m_maybe_child_ptr</span>.value();
            }
            <span class="dt">void</span> DisposeOfChild() {
                <span class="va">m_maybe_child_ptr</span>.reset();
            }

        <span class="kw">private</span>:
            mse::TRegisteredPointer&lt;mse::CInt&gt; <span class="va">m_node_count_ptr</span>;
            mse::mstd::optional&lt;<span class="dt">rcnode_strongptr_regobj_t</span>&gt; <span class="va">m_maybe_child_ptr</span>;
            <span class="dt">rcnode_strongptr_weakptr_t</span> <span class="va">m_root_ptr_ptr</span>;
        };

        mse::TRegisteredObj&lt;mse::CInt&gt; node_counter = <span class="dv">0</span>;
        {
            <span class="kw">auto</span> root_owner_ptr = CRCNode::MakeRoot(&amp;node_counter);
            <span class="kw">auto</span> kid1 = root_owner_ptr-&gt;MakeChild();
            {
                <span class="kw">auto</span> kid2 = kid1-&gt;MakeChild();
                <span class="kw">auto</span> kid3 = kid2-&gt;MakeChild();
            }
            assert(<span class="dv">4</span> == node_counter);
            kid1-&gt;DisposeOfChild();
            assert(<span class="dv">2</span> == node_counter);
        }
        assert(<span class="dv">0</span> == node_counter);
    }</code></pre></div>
<h3 id="scope-pointers">Scope pointers</h3>
<p>Scope pointers are pointers that live (only) to the end of the scope in which they (or their owners) are declared, and that point (only) to objects that live at least that long. Because scope pointers are only allowed to target objects that are known, at compile-time, to outlive them, they should be memory safe without need of any run-time overhead.</p>
<p>Scope pointers generally satisfy the restrictions the lifetime checker would impose on raw pointers, and could be considered as basically a stand-in for raw pointers for situations where a complete lifetime checker is not available. When a lifetime checker is/becomes available, scope pointers can be &quot;disabled&quot;, i.e. aliased to their corresponding raw pointers, by simply defining the <code>MSE_SCOPEPOINTER_DISABLED</code> preprocessor symbol.</p>
<p>Indeed, unlike other pointers in this library, the safety of scope pointers is not fully enforced at compile-time currently, so if even a partially functioning lifetime checker is available, you'd probably want to use it on your code to augment scope pointers' existing compile-time safety features.</p>
<p>In lieu of full compile-time enforcement, run-time checking is used in debug builds to catch any unsafe misuses of scope pointers. Defining the <code>MSE_SCOPEPOINTER_RUNTIME_CHECKS_ENABLED</code> preprocessor symbol will enable run-time checking in non-debug builds as well.</p>
<p>Scope pointers usually point to scope objects. Scope objects are objects that live to the end of the scope in which they are declared. You can designate pretty much any type to be a scope object type by wrapping it in the <code>mse::TXScopeObj&lt;&gt;</code> (transparent) wrapper template. As with registered objects, this wrapper does not support some types that cannot act as a base class. For <code>int</code>, <code>bool</code> and <code>size_t</code> use the safer <a href="#cndint-cndsize_t-and-cndbool">substitutes</a> that can act as base classes.</p>
<p>The rules for using scope pointers and objects are essentially as follows:</p>
<ul>
<li>Objects of scope type (types whose name starts with &quot;TXScope&quot; or &quot;xscope&quot;) must be local (<a href="#thread_local">non</a>-<a href="#static-and-global-variables">static</a>) automatic variables.
<ul>
<li>Basically allocated on the stack.</li>
</ul></li>
<li>Note that scope pointers are themselves scope objects and must adhere to the same restrictions.</li>
<li>Do not use scope types as members of classes or structs.
<ul>
<li>Note that you can use the <a href="#make_pointer_to_member_v2"><code>mse::make_xscope_pointer_to_member_v2()</code></a> function to obtain a scope pointer to a member of a scope object. So it's generally not necessary for any class/struct member to be declared as a scope object.</li>
<li>In the uncommon cases that you really want to use a scope type as a member of a class or struct, that class or struct must itself be a scope type. User defined scope types must adhere to the <a href="#defining-your-own-scope-types">rules</a> of scope types.</li>
</ul></li>
<li>Do not use scope types as base classes.
<ul>
<li>There probably isn't much motivation to do this anyway.</li>
<li>In the uncommon cases that you really want to use a scope type as a base class/struct, the derived class/struct must itself be a scope type. User defined scope types must adhere to the <a href="#defining-your-own-scope-types">rules</a> of scope types.</li>
</ul></li>
<li>Do not use scope types as function return types.
<ul>
<li>In the uncommon cases that you really want to use a scope type as a function return type, it must be wrapped in the <a href="#return_value"><code>mse::TXScopeReturnValue&lt;&gt;</code></a> transparent template wrapper.</li>
<li><code>mse::TXScopeReturnValue&lt;&gt;</code> will not accept non-owning scope pointer types. Pretty much the only time you would legitimately want to return a non-owning pointer to a scope object is when that pointer is one of the function's input parameters. In those cases you can use the <a href="#xscope_chosen"><code>xscope_chosen()</code></a> function.</li>
</ul></li>
</ul>
<p>Again, currently, most, but not all, inadvertent misuses of scope objects should result in compile errors. At some point the restrictions will be fully enforced at compile-time (either by the lifetime checker or a separate tool), but for now hopefully these rules are intuitive enough that adherence should be fairly natural. Just remember that the safety of scope pointers is premised on the fact that scope objects are never deallocated before the end of the scope in which they are declared, and (non-owning) scope pointers (and any copies of them) never survive beyond the scope in which they are declared, so that a scope pointer cannot outlive its target scope object.</p>
<p>Generally, there are two types of scope pointers you might use, <a href="#txscopeownerpointer"><code>TXScopeOwnerPointer&lt;&gt;</code></a> and <a href="#txscopeitemfixedpointer"><code>TXScopeItemFixedPointer&lt;&gt;</code></a>. <code>TXScopeOwnerPointer&lt;&gt;</code> is similar to <code>boost::scoped_ptr&lt;&gt;</code> in functionality (but more limited in intended use). It creates an instance of a given class on the heap and destroys that instance in its destructor. (We use &quot;scope&quot; to mean &quot;execution scope&quot;, where in boost it seems to also include &quot;declaration scope&quot;.) <code>TXScopeItemFixedPointer&lt;&gt;</code> is a &quot;non-owning&quot; pointer to scope objects. It is (intentionally) limited in its functionality, and is primarily intended for the purpose of passing scope objects by reference as function arguments.</p>
<h3 id="txscopeitemfixedpointer">TXScopeItemFixedPointer</h3>
<p><code>TXScopeItemFixedPointer&lt;&gt;</code> is primarily intended to be used to pass scope objects by reference as function arguments. It may not be used as a function return type (as enforced by the <a href="#return_value"><code>return_value()</code></a> function wrapper). And as with any other scope object, it may not be used as a member of any class or struct that is not itself a scope object. (Attempting to do so would generally produce a compile error).</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A(<span class="dt">int</span> x) : b(x) {}
            A(<span class="at">const</span> A&amp; _X) : b(_X.b) {}
            <span class="kw">virtual</span> ~A() {}
            A&amp; <span class="kw">operator</span>=(<span class="at">const</span> A&amp; _X) { b = _X.b; <span class="cf">return</span> (*<span class="kw">this</span>); }

            <span class="dt">int</span> b = <span class="dv">3</span>;
        };
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">int</span> foo2(mse::TXScopeItemFixedPointer&lt;A&gt; A_scpifptr) { <span class="cf">return</span> A_scpifptr-&gt;b; }
            <span class="at">static</span> <span class="dt">int</span> foo3(mse::TXScopeItemFixedConstPointer&lt;A&gt; A_scpifcptr) { <span class="cf">return</span> A_scpifcptr-&gt;b; }
        <span class="kw">protected</span>:
            ~B() {}
        };
    
        mse::TXScopeObj&lt;A&gt; a_scpobj(<span class="dv">5</span>);
        <span class="co">/* note that the &#39;&amp;&#39; (&quot;ampersand&quot;) operator is overloaded to return a mse::TXScopeFixedPointer&lt;&gt;  */</span>
        <span class="dt">int</span> res1 = (&amp;a_scpobj)-&gt;b;
        <span class="dt">int</span> res2 = B::foo2(&amp;a_scpobj);
        <span class="dt">int</span> res3 = B::foo3(&amp;a_scpobj);

        <span class="co">/* You can also use the make_xscope() function to obtain a scope object from a given value. */</span>
        <span class="kw">auto</span> a2_scpobj = mse::make_xscope(A(<span class="dv">7</span>));
    }</code></pre></div>
<h4 id="txscopeitemfixedconstpointer">TXScopeItemFixedConstPointer</h4>
<h3 id="txscopeownerpointer">TXScopeOwnerPointer</h3>
<p><code>TXScopeOwnerPointer&lt;&gt;</code> is similar to <code>boost::scoped_ptr&lt;&gt;</code> in functionality, but more limited in intended use. In particular, as a scope object, <code>TXScopeOwnerPointer&lt;&gt;</code> should not be used as a member of any class or struct that is not itself a scope object. Use it when you want to give scope lifetime to objects that are too large to be declared directly on the stack. Also, instead of its constructor taking a native pointer pointing to the already allocated object, it allocates the object itself and passes its construction arguments to the object's constructor.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A(<span class="dt">int</span> x) : b(x) {}
            A(<span class="at">const</span> A&amp; _X) : b(_X.b) {}
            <span class="kw">virtual</span> ~A() {}
            A&amp; <span class="kw">operator</span>=(<span class="at">const</span> A&amp; _X) { b = _X.b; <span class="cf">return</span> (*<span class="kw">this</span>); }

            <span class="dt">int</span> b = <span class="dv">3</span>;
        };
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">int</span> foo2(mse::TXScopeItemFixedPointer&lt;A&gt; A_scpfptr) { <span class="cf">return</span> A_scpfptr-&gt;b; }
            <span class="at">static</span> <span class="dt">int</span> foo3(mse::TXScopeItemFixedConstPointer&lt;A&gt; A_scpfcptr) { <span class="cf">return</span> A_scpfcptr-&gt;b; }
        <span class="kw">protected</span>:
            ~B() {}
        };
    
        mse::TXScopeOwnerPointer&lt;A&gt; xscp_a_ownerptr(<span class="dv">7</span>);
        <span class="dt">int</span> res4 = B::foo2(xscp_a_ownerptr);
        <span class="dt">int</span> res4b = B::foo2(&amp;(*xscp_a_ownerptr));
    }</code></pre></div>
<h3 id="txscopefixedpointer">TXScopeFixedPointer</h3>
<p><code>TXScopeFixedPointer&lt;&gt;</code> is the actual type of the pointer value returned by the <code>&amp;</code> (ampersand) operator of an object declared as a &quot;scope&quot; object (by virtue of being wrapped in the <code>TXScopeObj&lt;&gt;</code> transparent wrapper template). Generally, you don't need to use this type directly. <code>TXScopeFixedPointer&lt;&gt;</code> implicitly converts to a <code>TXScopeItemFixedPointer&lt;&gt;</code>, which can point to both explicitly declared and implicit scope objects. So generally you would just use the latter.</p>
<h4 id="txscopefixedconstpointer">TXScopeFixedConstPointer</h4>
<h3 id="make_xscope_strong_pointer_store">make_xscope_strong_pointer_store()</h3>
<p><code>make_xscope_strong_pointer_store()</code> returns a scope object that holds a copy of the given strong pointer and allows you to obtain a corresponding scope pointer. Supported strong pointers include ones like <a href="#reference-counting-pointers">reference counting pointers</a>, <a href="#norad-pointers">norad pointers</a> and pointers to <a href="#asynchronously-shared-objects">asynchronously shared objects</a> (and scope pointers themselves for the sake of completeness).</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mserefcounting.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A(<span class="dt">int</span> x) : b(x) {}
            A(<span class="at">const</span> A&amp; _X) : b(_X.b) {}
            <span class="kw">virtual</span> ~A() {}
            A&amp; <span class="kw">operator</span>=(<span class="at">const</span> A&amp; _X) { b = _X.b; <span class="cf">return</span> (*<span class="kw">this</span>); }

            <span class="dt">int</span> b = <span class="dv">3</span>;
        };
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">int</span> foo2(mse::TXScopeItemFixedPointer&lt;A&gt; A_scpfptr) { <span class="cf">return</span> A_scpfptr-&gt;b; }
            <span class="at">static</span> <span class="dt">int</span> foo3(mse::TXScopeItemFixedConstPointer&lt;A&gt; A_scpfcptr) { <span class="cf">return</span> A_scpfcptr-&gt;b; }
        <span class="kw">protected</span>:
            ~B() {}
        };
    
        <span class="co">/* Using mse::make_xscope_strong_pointer_store(), you can obtain a scope pointer from a refcounting pointer. */</span>
        <span class="co">/* Let&#39;s make it a const refcounting pointer, just for variety. */</span>
        mse::TRefCountingFixedConstPointer&lt;A&gt; refc_cptr1 = mse::make_refcounting&lt;A&gt;(<span class="dv">11</span>);
        <span class="kw">auto</span> xscp_refc_cstore = mse::make_xscope_strong_pointer_store(refc_cptr1);
        <span class="kw">auto</span> xscp_cptr1 = xscp_refc_cstore.xscope_ptr();
        <span class="dt">int</span> res6 = B::foo3(xscp_cptr1);
        mse::TXScopeItemFixedConstPointer&lt;A&gt; xscp_cptr2 = xscp_cptr1;
        A res7 = *xscp_cptr2;
    }</code></pre></div>
<h3 id="xscope_ifptr_to">xscope_ifptr_to()</h3>
<p>Scope pointers cannot (currently) be retargeted after construction. If you need a pointer that will point to multiple different scope objects over its lifespan, you can use a registered pointer. This means that the target objects will also need to be registered objects. If the object is a registered scope object, then the <code>&amp;</code> operator will will return a registered pointer. But at some point we're going to need a scope pointer to the base scope object. A convenient way to get one is to use the xscope_ifptr_to() function.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="kw">typedef</span> mse::TXScopeObj&lt;mse::nii_string&gt; <span class="dt">xscp_nstring_t</span>;
        <span class="kw">typedef</span> mse::TXScopeItemFixedPointer&lt;mse::nii_string&gt; <span class="dt">xscp_nstring_ptr_t</span>;
        <span class="kw">class</span> CB {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">void</span> foo1(<span class="dt">xscp_nstring_ptr_t</span> xscope_ptr1) {
                <span class="bu">std::</span>cout &lt;&lt; *xscope_ptr1;
            }
        };
        <span class="kw">typedef</span> mse::TRegisteredObj&lt; <span class="dt">xscp_nstring_t</span> &gt; <span class="dt">regxscp_nstring_t</span>;
        <span class="kw">typedef</span> mse::TRegisteredPointer&lt; <span class="dt">xscp_nstring_t</span> &gt; <span class="dt">regxscp_nstring_ptr_t</span>;
        <span class="dt">regxscp_nstring_t</span> regxscp_nstring1(<span class="st">&quot;some text&quot;</span>);
        <span class="dt">regxscp_nstring_ptr_t</span> registered_ptr1 = &amp;regxscp_nstring1;

        <span class="kw">auto</span> xscope_ptr1 = mse::xscope_ifptr_to(*registered_ptr1);
        CB::foo1(xscope_ptr1);

        <span class="dt">regxscp_nstring_t</span> regxscp_nstring2(<span class="st">&quot;some other text&quot;</span>);
        registered_ptr1 = &amp;regxscp_nstring2;
        CB::foo1(mse::xscope_ifptr_to(*registered_ptr1));

        {
            <span class="dt">regxscp_nstring_t</span> regxscp_nstring3(<span class="st">&quot;other text&quot;</span>);
            registered_ptr1 = &amp;regxscp_nstring3;
            CB::foo1(mse::xscope_ifptr_to(*registered_ptr1));
        }
        <span class="co">/* Attempting to dereference registered_ptr1 here would result in an exception. */</span>
        <span class="co">//*registered_ptr1;</span>
    }</code></pre></div>
<h3 id="xscope_chosen">xscope_chosen()</h3>
<p>[<em>provisional</em>]</p>
<p>For safety reasons, non-owning scope pointers (or any objects containing a scope reference) are not permitted to be used as function return values. (The <a href="#return_value"><code>return_value()</code></a> function wrapper enforces this.) Pretty much the only time you'd legitimately want to do this is when the returned pointer is one of the input parameters. An example might be a <code>min(a, b)</code> function which takes two objects by reference and returns the reference to the lesser of the two objects. For these cases you could use the <code>xscope_chosen()</code> function which takes two objects of the same type (in this case it will be two scope pointers) and returns one of the objects (scope pointers), which one depending on the value of a given &quot;decider&quot; function. You could use this function to implement the equivalent of a <code>min(a, b)</code> function like so:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A(<span class="dt">int</span> x) : b(x) {}
            A(<span class="at">const</span> A&amp; _X) : b(_X.b) {}
            <span class="kw">virtual</span> ~A() {}
            <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> A&amp; _X) <span class="at">const</span> { <span class="cf">return</span> (b &lt; _X.b); }

            <span class="dt">int</span> b = <span class="dv">3</span>;
        };
    
        mse::TXScopeObj&lt;A&gt; a_scpobj(<span class="dv">5</span>);
        mse::TXScopeOwnerPointer&lt;A&gt; xscp_a_ownerptr(<span class="dv">7</span>);
    
        <span class="kw">auto</span> xscp_a_ptr5 = &amp;a_scpobj;
        <span class="kw">auto</span> xscp_a_ptr6 = &amp;(*xscp_a_ownerptr);
        <span class="at">const</span> <span class="kw">auto</span> second_arg_is_smaller_fn = [](<span class="at">const</span> <span class="kw">auto</span> xscp_a_ptr1, <span class="at">const</span> <span class="kw">auto</span> xscp_a_ptr2) { <span class="cf">return</span> (*xscp_a_ptr2) &lt; (*xscp_a_ptr1); };
        <span class="kw">auto</span> xscp_min_ptr1 = mse::xscope_chosen(second_arg_is_smaller_fn, xscp_a_ptr5, xscp_a_ptr6);
    <span class="co">/* xscp_min_ptr1 should be a copy of xscp_a_ptr5 */</span>
        assert(<span class="dv">5</span> == xscp_min_ptr1-&gt;b);
    }</code></pre></div>
<h3 id="as_a_returnable_fparam">as_a_returnable_fparam()</h3>
<p>[<em>provisional</em>]</p>
<p>Another alternative if you want to return a scope pointer (or any object containing a scope reference) input parameter from a function is to wrap the parameter type with the <code>rsv::TXScopeReturnableFParam&lt;&gt;</code> transparent template wrapper when declaring the parameter.</p>
<p>Normally the <a href="#return_value"><code>return_value()</code></a> function wrapper will reject (with a compile error) scope pointers as unsafe return values. But if the scope pointer type is wrapped in the <code>rsv::TXScopeReturnableFParam&lt;&gt;</code> transparent template wrapper, then it will be accepted as a safe return value. Because it's generally safe to return a reference to an object if that reference was passed as an input parameter. Well, as long as the object is not a temporary one. So unlike with <a href="#as_an_fparam"><code>rsv::TXScopeFParam&lt;&gt;</code></a>, scope reference types wrapped with <code>rsv::TXScopeReturnableFParam&lt;&gt;</code> will not enable support for (scope) references to temporaries, as returning a (scope) reference to a temporary could be unsafe even if the reference was passed as a function parameter. So for scope reference parameters you have to choose between being able to use it as a return value, or supporting references to temporaries. (Or neither.)</p>
<p>In the case of function templates, sometimes you want the parameter types to be auto-deduced, and use of the <code>rsv::TXScopeReturnableFParam&lt;&gt;</code> wrapper can interfere with that. In those cases you can instead convert parameters to their wrapped type after-the-fact using the <code>rsv::xscope_as_a_returnable_fparam()</code> function. Note that using this function (or the <code>rsv::TXScopeReturnableFParam&lt;&gt;</code> wrapper) on anything other than function parameters is unsafe, and currently there is no compile-time enforcement of this restriction.</p>
<p><code>rsv::TReturnableFParam&lt;&gt;</code> and <code>rsv::as_a_returnable_fparam()</code> can be used for situations when the type of the input parameter is itself a template parameter and not necessarily always a scope type or treated as a scope type.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
    
<span class="kw">class</span> H {
<span class="kw">public</span>:
    <span class="co">/* This function will be used to demonstrate using rsv::as_a_returnable_fparam() to enable template functions to return</span>
<span class="co">    one of their function parameters, potentially of the scope reference variety which would otherwise be rejected (with a</span>
<span class="co">    compile error) as an unsafe return value. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TPointer1, <span class="kw">class</span> _TPointer2&gt;
    <span class="at">static</span> <span class="kw">auto</span> longest(<span class="at">const</span> _TPointer1&amp; string1_xscpptr, <span class="at">const</span> _TPointer2&amp; string2_xscpptr) {
        <span class="kw">auto</span> l_string1_xscpptr = mse::rsv::as_a_returnable_fparam(string1_xscpptr);
        <span class="kw">auto</span> l_string2_xscpptr = mse::rsv::as_a_returnable_fparam(string2_xscpptr);
        <span class="cf">if</span> (l_string1_xscpptr-&gt;length() &gt; l_string2_xscpptr-&gt;length()) {
            <span class="co">/* If string1_xscpptr were a regular TXScopeItemFixedPointer&lt;mse::nii_string&gt; and we tried to return it</span>
<span class="co">            directly instead of l_string1_xscpptr, it would have induced a compile error. */</span>
            <span class="cf">return</span> mse::return_value(l_string1_xscpptr);
        }
        <span class="cf">else</span> {
            <span class="co">/* mse::return_value() usually returns its input argument unmolested, but in this case it will return</span>
<span class="co">            a type different from the input type. This is to prevent any function that receives this return value</span>
<span class="co">            from, in turn, returning the value, as that might be unsafe. */</span>
            <span class="cf">return</span> mse::return_value(l_string2_xscpptr);
        }
    }
};
    
<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    <span class="kw">class</span> CD {
    <span class="kw">public</span>:
        <span class="at">static</span> <span class="kw">auto</span> longest(mse::rsv::TXScopeReturnableFParam&lt;mse::TXScopeItemFixedPointer&lt;mse::nii_string&gt; &gt; string<span class="dv">1_xscpptr</span>
            , mse::rsv::TXScopeReturnableFParam&lt;mse::TXScopeItemFixedPointer&lt;mse::nii_string&gt; &gt; string2_xscpptr) {
            <span class="cf">if</span> (string1_xscpptr-&gt;length() &gt; string2_xscpptr-&gt;length()) {
                <span class="co">/* If string1_xscpptr were a regular TXScopeItemFixedPointer&lt;mse::nii_string&gt; the next line would have</span>
<span class="co">                induced a compile error. */</span>
                <span class="cf">return</span> mse::return_value(string1_xscpptr);
            }
            <span class="cf">else</span> {
                <span class="co">/* mse::return_value() usually returns its input argument unmolested, but in this case it will return</span>
<span class="co">                a type (slightly) different from the input type. This is to prevent any function that receives this</span>
<span class="co">                return value from, in turn, returning the value, as that might be unsafe. */</span>
                <span class="cf">return</span> mse::return_value(string2_xscpptr);
            }
        }
    };
    mse::TXScopeObj&lt;mse::nii_string&gt; xscope_string1 = <span class="st">&quot;abc&quot;</span>;
    mse::TXScopeObj&lt;mse::nii_string&gt; xscope_string2 = <span class="st">&quot;abcd&quot;</span>;
    <span class="kw">auto</span> longer_string_xscpptr = CD::longest(&amp;xscope_string1, &amp;xscope_string2);
    <span class="kw">auto</span> copy_of_longer_string = *longer_string_xscpptr;

    <span class="kw">auto</span> longer_string2_xscpptr = H::longest(&amp;xscope_string1, &amp;xscope_string2);

    <span class="kw">class</span> CE {
    <span class="kw">public</span>:
        <span class="at">static</span> <span class="kw">auto</span> xscope_string_const_section_to_member(mse::rsv::TXScopeReturnableFParam&lt;mse::TXScopeItemFixedConstPointer&lt;CE&gt; &gt; returnable_this_cpointer) {
            <span class="co">/* &quot;Pointers to members&quot; based on returnable pointers inherit the &quot;returnability&quot;. */</span>
            <span class="kw">auto</span> returnable_cpointer_to_member = mse::make_xscope_const_pointer_to_member_v2(returnable_this_cpointer, &amp;CE::<span class="va">m_string1</span>);
            <span class="co">/* &quot;scope nrp string const sections&quot; based on returnable pointers (or iterators) inherit the &quot;returnability&quot;. */</span>
            <span class="kw">auto</span> returnable_string_const_section = mse::make_xscope_nrp_string_const_section(returnable_cpointer_to_member);
            <span class="co">/* Subsections of returnable sections inherit the &quot;returnability&quot;. */</span>
            <span class="kw">auto</span> returnable_string_const_section2 = returnable_string_const_section.xscope_subsection(<span class="dv">1</span>, <span class="dv">3</span>);
            <span class="cf">return</span> mse::return_value(returnable_string_const_section2);
        }
    <span class="kw">private</span>:
        mse::nii_string <span class="va">m_string1</span> = <span class="st">&quot;abcde&quot;</span>;
    };

    mse::TXScopeObj&lt;CE&gt; e_xscpobj;
    <span class="kw">auto</span> xscope_string_const_section1 = mse::TXScopeObj&lt;CE&gt;::xscope_string_const_section_to_member(&amp;e_xscpobj);
    assert(xscope_string_const_section1 == <span class="st">&quot;bcd&quot;</span>);
}</code></pre></div>
<h3 id="as_an_fparam">as_an_fparam()</h3>
<p>[<em>provisional</em>]</p>
<p><code>rsv::TFParam&lt;&gt;</code> is just a transparent template wrapper for function parameter declarations. In most cases use of this wrapper is not necessary, but in some cases it enables functionality only available to variables that are function parameters. Specifically, it allows functions to support arguments that are scope pointer/references to temporary objects. For safety reasons, by default, scope pointer/references to temporaries are actually &quot;functionally disabled&quot; types distinct from regular scope pointer/reference types. Because it's safe to do so in the case of function parameters, the <code>rsv::TFParam&lt;&gt;</code> wrapper enables certain scope pointer/reference types (like <code>TXScopeItemFixedConstPointer&lt;&gt;</code>, and &quot;<a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">random access const sections</a>&quot; scope types) to be constructed from their &quot;functionally disabled&quot; counterparts.</p>
<p>In the case of function templates, sometimes you want the parameter types to be auto-deduced, and use of the <code>mse::rsv::TFParam&lt;&gt;</code> wrapper can interfere with that. In those cases you can instead convert parameters to their wrapped type after-the-fact using the <code>rsv::as_an_fparam()</code> function. Note that using this function (or the <code>rsv::TFParam&lt;&gt;</code> wrapper) on anything other than function parameters is unsafe, and currently there is no compile-time enforcement of this restriction.</p>
<p><code>rsv::TXScopeFParam&lt;&gt;</code> and <code>rsv::xscope_as_an_fparam()</code> can be used for situations when the types are necessarily scope types.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span>
    
<span class="kw">class</span> H {
<span class="kw">public</span>:
    <span class="co">/* This function will be used to demonstrate using rsv::as_an_fparam() to enable template functions to accept scope </span>
<span class="co">    pointers to temporary objects. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TPointer1, <span class="kw">class</span> _TPointer2&gt;
    <span class="at">static</span> <span class="dt">bool</span> second_is_longer(<span class="at">const</span> _TPointer1&amp; string1_xscpptr, <span class="at">const</span> _TPointer2&amp; string2_xscpptr) {
        <span class="kw">auto</span> l_string1_xscpptr = mse::rsv::as_an_fparam(string1_xscpptr);
        <span class="kw">auto</span> l_string2_xscpptr = mse::rsv::as_an_fparam(string2_xscpptr);
        <span class="cf">return</span> (l_string1_xscpptr-&gt;length() &gt; l_string2_xscpptr-&gt;length()) ? <span class="kw">false</span> : <span class="kw">true</span>;
    }
};
    
<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    <span class="kw">class</span> CD {
    <span class="kw">public</span>:
        <span class="at">static</span> <span class="dt">bool</span> second_is_longer(mse::rsv::TXScopeFParam&lt;mse::TXScopeItemFixedConstPointer&lt;mse::nii_string&gt; &gt; string<span class="dv">1_xscpptr</span>
            , mse::rsv::TXScopeFParam&lt;mse::TXScopeItemFixedConstPointer&lt;mse::nii_string&gt; &gt; string2_xscpptr) {

            <span class="cf">return</span> (string1_xscpptr-&gt;length() &gt; string2_xscpptr-&gt;length()) ? <span class="kw">false</span> : <span class="kw">true</span>;
        }

        <span class="at">static</span> <span class="dt">bool</span> second_is_longer_any(mse::rsv::TXScopeFParam&lt;mse::TXScopeAnyConstPointer&lt;mse::nii_string&gt; &gt; string<span class="dv">1_xscpptr</span>
            , mse::rsv::TXScopeFParam&lt;mse::TXScopeAnyConstPointer&lt;mse::nii_string&gt; &gt; string2_xscpptr) {
            <span class="cf">return</span> (string1_xscpptr-&gt;length() &gt; string2_xscpptr-&gt;length()) ? <span class="kw">false</span> : <span class="kw">true</span>;
        }

        <span class="at">static</span> <span class="dt">bool</span> second_is_longer_poly(mse::rsv::TXScopeFParam&lt;mse::TXScopePolyConstPointer&lt;mse::nii_string&gt; &gt; string<span class="dv">1_xscpptr</span>
            , mse::rsv::TXScopeFParam&lt;mse::TXScopePolyConstPointer&lt;mse::nii_string&gt; &gt; string2_xscpptr) {
            <span class="cf">return</span> (string1_xscpptr-&gt;length() &gt; string2_xscpptr-&gt;length()) ? <span class="kw">false</span> : <span class="kw">true</span>;
        }
    };

    mse::TXScopeObj&lt;mse::nii_string&gt; xscope_string1 = <span class="st">&quot;abc&quot;</span>;
    <span class="co">/* Here we&#39;re using the pointer_to() function to obtain a (&quot;caged&quot;) pointer to the temporary scope object. The &#39;&amp;&#39;</span>
<span class="co">    (ampersand) operator would also work, but would not correspond to valid native C++, as C++ does not support taking</span>
<span class="co">    the address of an r-value. */</span>
    <span class="kw">auto</span> res1 = CD::second_is_longer(&amp;xscope_string1, mse::pointer_to(mse::TXScopeObj&lt;mse::nii_string&gt;(xscope_string1 + <span class="st">&quot;de&quot;</span>)));
    <span class="kw">auto</span> res2 = H::second_is_longer(&amp;xscope_string1, mse::pointer_to(mse::TXScopeObj&lt;mse::nii_string&gt;(xscope_string1 + <span class="st">&quot;de&quot;</span>)));
    <span class="kw">auto</span> res3 = CD::second_is_longer_any(&amp;xscope_string1, mse::pointer_to(mse::TXScopeObj&lt;mse::nii_string&gt;(xscope_string1 + <span class="st">&quot;de&quot;</span>)));
    <span class="kw">auto</span> res4 = CD::second_is_longer_poly(&amp;xscope_string1, mse::pointer_to(mse::TXScopeObj&lt;mse::nii_string&gt;(xscope_string1 + <span class="st">&quot;de&quot;</span>)));
}</code></pre></div>
<h3 id="conformance-helpers">Conformance helpers</h3>
<p>As mentioned, in the future we expect that there will be a &quot;compile helper tool&quot; to verify that scope objects are not misused (even if it ends up just being the completed lifetime checker). Until then, a couple of &quot;conformance helpers&quot; are provided that can be used to help catch inadvertent misuse.</p>
<h3 id="return_value">return_value()</h3>
<p>The safety of non-owning scope pointers is premised on the fact that they will not outlive the scope in which they are declared. So returning a non-owning scope pointer, or any object that contains or owns a non-owning scope pointer, from a function would be potentially unsafe. However, it could be safe to return a scope object if that object does not contain or own any non-owning scope pointers.</p>
<p>The <code>return_value()</code> function just returns its argument and verifies that it is of a type that is safe to return from a function (basically, doesn't contain any scope pointers). If not it will induce a compile error. Functions that do or could return scope types should wrap their return value with this function.</p>
<p><code>TReturnValue&lt;&gt;</code> is a transparent template wrapper that verifies that the type is safe to use as a function return type. If not it will induce a compile error. Functions that do or could return scope types and explicitly specify their return types (rather than just using the <code>auto</code> return type) should wrap their return type with this template. Alternatively, you can use <code>TXScopeReturnValue&lt;&gt;</code> which additionally ensures that the return type is a scope type.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseoptional.h&quot;</span>
    
    <span class="kw">class</span> J {
    <span class="kw">public</span>:
        <span class="kw">template</span>&lt;<span class="kw">typename</span> _TParam&gt;
        <span class="at">static</span> <span class="kw">auto</span> foo10(_TParam param) {
            <span class="kw">auto</span> l_obj = param;
            <span class="co">/* Functions that could return a scope type need to wrap their return value with the return_value() function. */</span>
            <span class="cf">return</span> mse::return_value(mse::pointer_to(l_obj));
        }
    };
    
    <span class="dt">void</span> main() {
        <span class="kw">class</span> CB {
        <span class="kw">public</span>:
            <span class="co">/* It&#39;s generally not necessary for a function return type to be a scope type. Even if the return value</span>
<span class="co">            is of a scope type, you can usually just use the underlying (non-scope) type of the scope object as the</span>
<span class="co">            return type. */</span>
            <span class="at">static</span> mse::mstd::string foo1() {
                mse::TXScopeObj&lt;mse::mstd::string&gt; xscp_string1(<span class="st">&quot;some text&quot;</span>);
                <span class="cf">return</span> mse::return_value(xscp_string1);
            }
    
            <span class="co">/* In the less common case where the scope type doesn&#39;t have an underlying non-scope type, it may be safe</span>
<span class="co">            to return the scope object. But in order to use a scope type as a function return value, it must be</span>
<span class="co">            wrapped in the transparent mse::TReturnValue&lt;&gt; or mse::TXScopeReturnValue&lt;&gt; wrapper template, which will</span>
<span class="co">            induce a compile error if it deems the scope type potentially unsafe to use as a return type. */</span>
            <span class="at">static</span> mse::TXScopeReturnValue&lt;mse::xscope_optional&lt;mse::mstd::string&gt; &gt; foo2() {
                mse::xscope_optional&lt;mse::mstd::string&gt; xscp_returnable_obj1(mse::mstd::string(<span class="st">&quot;some text&quot;</span>));
                <span class="cf">return</span> mse::return_value(xscp_returnable_obj1);
            }
    
            <span class="co">/* &quot;auto&quot; return types don&#39;t need to be wrapped, but the return value needs to be wrapped with the</span>
<span class="co">            return_value() function. */</span>
            <span class="at">static</span> <span class="kw">auto</span> foo3() {
                mse::xscope_optional&lt;mse::mstd::string&gt; xscp_returnable_obj1(mse::mstd::string(<span class="st">&quot;some text&quot;</span>));
                <span class="cf">return</span> mse::return_value(xscp_returnable_obj1);
            }
        };
    
        mse::TXScopeObj&lt;mse::mstd::string&gt; xscp_res1(CB::foo1());
        mse::xscope_optional&lt;mse::mstd::string&gt; xscp_res2(CB::foo2());
    
        <span class="kw">typedef</span> mse::TXScopeObj&lt;mse::mstd::string&gt; <span class="dt">xscope_string_t</span>;
        <span class="dt">xscope_string_t</span> xscp_str1 = <span class="st">&quot;some text&quot;</span>;
        <span class="co">/* TXScopeReturnValue&lt;&gt; deems xscope_string_t to be an acceptable return type because it doesn&#39;t contain</span>
<span class="co">        any scope pointers. */</span>
        mse::TXScopeReturnValue&lt;<span class="dt">xscope_string_t</span>&gt; xscpr_str1(<span class="st">&quot;some text&quot;</span>);
        <span class="kw">auto</span> xscp_rstr1 = mse::return_value(xscp_str1);
    
        <span class="kw">typedef</span> <span class="kw">decltype</span>(&amp;xscp_str1) <span class="dt">xscope_string_ptr_t</span>;
        <span class="co">/* TXScopeReturnValue&lt;&gt; deems xscope_string_ptr_t to be an unsafe return type because it is (or contains)</span>
<span class="co">        a scope pointer. So the next line would result in a compile error. */</span>
        <span class="co">//mse::TXScopeReturnValue&lt;xscope_string_ptr_t&gt; xscpr_sfptr1 = &amp;xscp_str1;</span>
        <span class="co">//auto xscp_rstr_ptr1 = mse::return_value(&amp;xscp_str1);</span>
    
        mse::TRegisteredObj&lt;mse::mstd::string&gt; reg_str1 = <span class="st">&quot;some text&quot;</span>;
        <span class="kw">auto</span> reg_ptr_res1 = J::foo10(reg_str1);
        <span class="co">//auto xscp_ptr_res1 = J::foo10(xscp_str1); // &lt;-- would induce a compile error inside J::foo10() </span>
    }</code></pre></div>
<h3 id="tmemberobj">TMemberObj</h3>
<p>Scope types have built in protection that prevents them from being allocated dynamically. But those protections are circumvented if a scope type is used as a member of a class or struct. So <code>TMemberObj&lt;&gt;</code> is a transparent wrapper that can be used to wrap class/struct member types to ensure that they are not scope types. This is particularly relevant in cases when the member type is, or is derived from, a template parameter.</p>
<h3 id="defining-your-own-scope-types">Defining your own scope types</h3>
<p>example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;mseoptional.h&quot;</span>

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

        <span class="co">/* Defining your own scope types. */</span>

        <span class="co">/* It is (intended to be) uncommon to need to define your own scope types. In general, if you want to use a</span>
<span class="co">        type as a scope type, you can just wrap it with the mse::TXScopeObj&lt;&gt; template. */</span>

        <span class="co">/* But in cases where you&#39;re going to use a scope type as a member of a class or struct, that class or</span>
<span class="co">        struct must itself be a scope type. Improperly defining a scope type could result in unsafe code. */</span>

        <span class="co">/* Scope types need to publicly inherit from mse::XScopeTagBase. And by convention, be named with a prefix</span>
<span class="co">        indicating that it&#39;s a scope type. */</span>
        <span class="kw">class</span> xscope_my_type1 : <span class="kw">public</span> mse::XScopeTagBase {
        <span class="kw">public</span>:
            xscope_my_type1(<span class="at">const</span> mse::xscope_optional&lt;mse::mstd::string&gt;&amp; xscp_maybe_string)
                : <span class="va">m_xscp_maybe_string1</span>(xscp_maybe_string) {}

            <span class="co">/* If your scope type does not contain any non-owning scope pointers, then it should be safe to use</span>
<span class="co">            as a function return type. You can &quot;mark&quot; it as such by adding the following member function. If the</span>
<span class="co">            type does contain non-owning scope pointers, then doing so could result in unsafe code. */</span>
            <span class="dt">void</span> xscope_returnable_tag() <span class="at">const</span> {} <span class="co">/* Indication that this type is can be used as a function return value. */</span>

            mse::xscope_optional&lt;mse::mstd::string&gt; <span class="va">m_xscp_maybe_string1</span>;
        };

        <span class="co">/* If your type contains or owns any non-owning scope pointers, then it must also publicly inherit</span>
<span class="co">        from mse::ContainsNonOwningScopeReferenceTagBase. If your type contains or owns any item that can be</span>
<span class="co">        independently targeted by scope pointers (i.e. basically has a &#39;&amp;&#39; (&quot;address of&quot; operator) that yeilds</span>
<span class="co">        a scope pointer), then it must also publicly inherit from mse::ReferenceableByScopePointerTagBase.</span>
<span class="co">        Failure to do so could result in unsafe code. */</span>
        <span class="kw">class</span> xscope_my_type2 : <span class="kw">public</span> mse::XScopeTagBase, <span class="kw">public</span> mse::ContainsNonOwningScopeReferenceTagBase
            , <span class="kw">public</span> mse::ReferenceableByScopePointerTagBase
        {
        <span class="kw">public</span>:
            <span class="kw">typedef</span> mse::TXScopeItemFixedConstPointer&lt;mse::mstd::string&gt; <span class="dt">xscope_string_ptr_t</span>;

            xscope_my_type2(<span class="at">const</span> mse::xscope_optional&lt;<span class="dt">xscope_string_ptr_t</span>&gt;&amp; xscp_maybe_string_ptr) : <span class="va">m_xscp_maybe_string_ptr</span>(xscp_maybe_string_ptr) {}

            <span class="co">/* This item (potentially) contains a non-owning scope pointer. */</span>
            mse::xscope_optional&lt;<span class="dt">xscope_string_ptr_t</span>&gt; <span class="va">m_xscp_maybe_string_ptr</span>;

            <span class="co">/* This item owns an object that can be independently targeted by scope pointers. That is,</span>
<span class="co">            &amp;(*m_xscp_string_owner_ptr) yields a scope pointer. */</span>
            mse::TXScopeOwnerPointer&lt;mse::mstd::string&gt; <span class="va">m_xscp_string_owner_ptr</span>;
        };
}</code></pre></div>
<h3 id="make_pointer_to_member_v2">make_pointer_to_member_v2()</h3>
<p>If you need a safe pointer to a member of a class/struct, you could declare the member itself to be a registered object (or a reference counting pointer). But often a preferable option is to use <code>make_pointer_to_member_v2()</code>. This function takes a safe pointer to the containing class/struct and a &quot;<a href="http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_members">pointer-to-member</a>&quot; indicating the member you want to target, and combines them to create a safe pointer to the member. The actual type of the returned pointer varies depending on the types of the parameters passed.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="co">/* Including &quot;msepoly.h&quot; is not required to use mse::make_pointer_to_member_v2(). It just happens to include all the</span>
<span class="co">    other include files used by this example. */</span>
    <span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span>
    
    <span class="kw">class</span> H {
    <span class="kw">public</span>:
        <span class="co">/* A member function that provides a safe pointer/reference to a class/struct member is going to need to</span>
<span class="co">        take a safe version of the &quot;this&quot; pointer as a parameter. */</span>
        <span class="kw">template</span>&lt;<span class="kw">class</span> <span class="dt">this_type</span>&gt;
        <span class="at">static</span> <span class="kw">auto</span> safe_pointer_to_member_string1(<span class="dt">this_type</span> safe_this) {
            <span class="cf">return</span> mse::make_pointer_to_member_v2(safe_this, &amp;H::<span class="va">m_string1</span>);
        }
    
        mse::nii_string <span class="va">m_string1</span> = <span class="st">&quot;initial text&quot;</span>;
    };
    
    <span class="dt">void</span> main() {
        <span class="co">/* To demonstrate, first we&#39;ll declare some objects such that we can obtain safe pointers to those</span>
<span class="co">        objects. For better or worse, this library provides a bunch of different safe pointers types. */</span>
        mse::TXScopeObj&lt;H&gt; h_scpobj;
        <span class="kw">auto</span> h_refcptr = mse::make_refcounting&lt;H&gt;();
        mse::TRegisteredObj&lt;H&gt; h_regobj;
        mse::TCRegisteredObj&lt;H&gt; h_rlxregobj;
    
        <span class="co">/* Safe iterators are a type of safe pointer too. */</span>
        mse::mstd::vector&lt;H&gt; h_mstdvec;
        h_mstdvec.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> h_mstdvec_iter = h_mstdvec.begin();
        mse::us::msevector&lt;H&gt; h_msevec;
        h_msevec.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> h_msevec_ipointer = h_msevec.ibegin();
        <span class="kw">auto</span> h_msevec_ssiter = h_msevec.ss_begin();
    
        <span class="co">/* And don&#39;t forget the safe async sharing pointers. */</span>
        <span class="kw">auto</span> h_access_requester = mse::make_asyncsharedv2readwrite&lt;ShareableH&gt;();
        <span class="kw">auto</span> h_writelock_ptr = h_access_requester.writelock_ptr();
        <span class="kw">auto</span> h_stdshared_const_ptr = mse::make_stdsharedimmutable&lt;H&gt;();
    
        {
            <span class="co">/* So here&#39;s how you get a safe pointer to a member of the object using mse::make_pointer_to_member_v2(). */</span>
            <span class="kw">auto</span> h_string1_scpptr = mse::make_xscope_pointer_to_member_v2(&amp;h_scpobj, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_scpptr) = <span class="st">&quot;some new text&quot;</span>;
            <span class="kw">auto</span> h_string1_scp_const_ptr = mse::make_xscope_const_pointer_to_member_v2(&amp;h_scpobj, &amp;H::<span class="va">m_string1</span>);
    
            <span class="kw">auto</span> h_string1_refcptr = mse::make_pointer_to_member_v2(h_refcptr, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_refcptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_regptr = mse::make_pointer_to_member_v2(&amp;h_regobj, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_regptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_rlxregptr = mse::make_pointer_to_member_v2(&amp;h_rlxregobj, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_rlxregptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_mstdvec_iter = mse::make_pointer_to_member_v2(h_mstdvec_iter, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_mstdvec_iter) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_msevec_ipointer = mse::make_pointer_to_member_v2(h_msevec_ipointer, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_msevec_ipointer) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_msevec_ssiter = mse::make_pointer_to_member_v2(h_msevec_ssiter, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_msevec_ssiter) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_writelock_ptr = mse::make_pointer_to_member_v2(h_writelock_ptr, &amp;H::<span class="va">m_string1</span>);
            (*h_string1_writelock_ptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_stdshared_const_ptr = mse::make_pointer_to_member_v2(h_stdshared_const_ptr, &amp;H::<span class="va">m_string1</span>);
            <span class="co">//(*h_string1_stdshared_const_ptr) = &quot;some new text&quot;;</span>
        }
    
        {
            <span class="co">/* Though the type of the safe pointer to the object member varies depending on how the object was</span>
<span class="co">            declared, you can make a (templated) accessor function that will return a safe pointer of the</span>
<span class="co">            appropriate type. */</span>
            <span class="kw">auto</span> h_string1_scpptr = H::safe_pointer_to_member_string1(&amp;h_scpobj);
            (*h_string1_scpptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_refcptr = H::safe_pointer_to_member_string1(h_refcptr);
            (*h_string1_refcptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_regptr = H::safe_pointer_to_member_string1(&amp;h_regobj);
            (*h_string1_regptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_rlxregptr = H::safe_pointer_to_member_string1(&amp;h_rlxregobj);
            (*h_string1_rlxregptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_mstdvec_iter = H::safe_pointer_to_member_string1(h_mstdvec_iter);
            (*h_string1_mstdvec_iter) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_msevec_ipointer = H::safe_pointer_to_member_string1(h_msevec_ipointer);
            (*h_string1_msevec_ipointer) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_msevec_ssiter = H::safe_pointer_to_member_string1(h_msevec_ssiter);
            (*h_string1_msevec_ssiter) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_writelock_ptr = H::safe_pointer_to_member_string1(h_writelock_ptr);
            (*h_string1_writelock_ptr) = <span class="st">&quot;some new text&quot;</span>;
    
            <span class="kw">auto</span> h_string1_stdshared_const_ptr = H::safe_pointer_to_member_string1(h_stdshared_const_ptr);
            <span class="co">//(*h_string1_stdshared_const_ptr) = &quot;some new text&quot;;</span>
        }
    }</code></pre></div>
<h3 id="poly-pointers">Poly pointers</h3>
<p>Poly pointers are &quot;chameleon&quot; (type-erased) pointers that can be constructed from, and retain the safety features of many of the pointer types in this library. If you're writing a function and you'd like it to be able to accept different types of safe pointer parameters, you can &quot;templatize&quot; your function. Alternatively, you can declare your pointer parameters as poly pointers.</p>
<p>Note that poly pointers support only basic facilities common to all the covered pointer and iterator types, providing essentially the functionality of a C++ reference. For example, this means no assignment operator, and no <code>operator bool()</code>. Where null pointer values are desired you might consider using <a href="#optional-xscope_optional"><code>mse::mstd::optional&lt;&gt;</code></a> or <code>std::optional&lt;&gt;</code> instead.</p>
<h3 id="txscopepolypointer-txscopepolyconstpointer">TXScopePolyPointer, TXScopePolyConstPointer</h3>
<p>Scope poly pointers are primarily intended to be used in function parameter declarations. In particular, as they can be constructed from a scope pointer (<code>TXScopeFixedPointer&lt;&gt;</code> or <code>TXScopeFixedConstPointer&lt;&gt;</code>), they must observe the same usage restrictions.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span>
    
    <span class="dt">void</span> main() {
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A() {}
            A(<span class="bu">std::</span>string x) : b(x) {}
            <span class="kw">virtual</span> ~A() {}

            <span class="bu">std::</span>string b = <span class="st">&quot;some text &quot;</span>;
        };
        <span class="kw">class</span> D : <span class="kw">public</span> A {
        <span class="kw">public</span>:
            D(<span class="bu">std::</span>string x) : A(x) {}
        };
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="bu">std::</span>string foo1(mse::TXScopePolyPointer&lt;A&gt; ptr) {
                <span class="bu">std::</span>string retval = ptr-&gt;b;
                <span class="cf">return</span> retval;
            }
            <span class="at">static</span> <span class="bu">std::</span>string foo2(mse::TXScopePolyConstPointer&lt;A&gt; ptr) {
                <span class="bu">std::</span>string retval = ptr-&gt;b;
                <span class="cf">return</span> retval;
            }
            <span class="at">static</span> <span class="bu">std::</span>string foo3(mse::TXScopePolyPointer&lt;<span class="bu">std::</span>string&gt; ptr) {
                <span class="bu">std::</span>string retval = (*ptr) + (*ptr);
                <span class="cf">return</span> retval;
            }
            <span class="at">static</span> <span class="bu">std::</span>string foo4(mse::TXScopePolyConstPointer&lt;<span class="bu">std::</span>string&gt; ptr) {
                <span class="bu">std::</span>string retval = (*ptr) + (*ptr);
                <span class="cf">return</span> retval;
            }
        <span class="kw">protected</span>:
            ~B() {}
        };
    
        <span class="co">/* To demonstrate, first we&#39;ll declare some objects such that we can obtain safe pointers to those</span>
<span class="co">        objects. For better or worse, this library provides a bunch of different safe pointers types. */</span>
        mse::TXScopeObj&lt;A&gt; a_scpobj;
        <span class="kw">auto</span> a_refcptr = mse::make_refcounting&lt;A&gt;();
        mse::TRegisteredObj&lt;A&gt; a_regobj;
        mse::TCRegisteredObj&lt;A&gt; a_rlxregobj;
    
        <span class="co">/* Safe iterators are a type of safe pointer too. */</span>
        mse::mstd::vector&lt;A&gt; a_mstdvec;
        a_mstdvec.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> a_mstdvec_iter = a_mstdvec.begin();
        mse::us::msevector&lt;A&gt; a_msevec;
        a_msevec.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> a_msevec_ipointer = a_msevec.ibegin();
        <span class="kw">auto</span> a_msevec_ssiter = a_msevec.ss_begin();
    
        <span class="co">/* And don&#39;t forget the safe async sharing pointers. */</span>
        <span class="kw">auto</span> a_access_requester = mse::make_asyncsharedreadwrite&lt;A&gt;();
        <span class="kw">auto</span> a_writelock_ptr = a_access_requester.writelock_ptr();
        <span class="kw">auto</span> a_stdshared_const_ptr = mse::make_stdsharedimmutable&lt;A&gt;();
    
        <span class="co">/* And note that safe pointers to member elements need to be wrapped in an mse::TXScopeAnyPointer&lt;&gt; for</span>
<span class="co">        mse::TXScopePolyPointer&lt;&gt; to accept them. */</span>
        <span class="kw">auto</span> b_member_a_refc_anyptr = mse::TXScopeAnyPointer&lt;<span class="bu">std::</span>string&gt;(mse::make_pointer_to_member_v2(a_refcptr, &amp;A::b));
        <span class="kw">auto</span> b_member_a_reg_anyptr = mse::TXScopeAnyPointer&lt;<span class="bu">std::</span>string&gt;(mse::make_pointer_to_member_v2(&amp;a_regobj, &amp;A::b));
        <span class="kw">auto</span> b_member_a_mstdvec_iter_anyptr = mse::TXScopeAnyPointer&lt;<span class="bu">std::</span>string&gt;(mse::make_pointer_to_member_v2(a_mstdvec_iter, &amp;A::b));
    
        {
            <span class="co">/* All of these safe pointer types happily convert to an mse::TXScopePolyPointer&lt;&gt;. */</span>
            <span class="kw">auto</span> res_using_scpptr = B::foo1(&amp;a_scpobj);
            <span class="kw">auto</span> res_using_refcptr = B::foo1(a_refcptr);
            <span class="kw">auto</span> res_using_regptr = B::foo1(&amp;a_regobj);
            <span class="kw">auto</span> res_using_rlxregptr = B::foo1(&amp;a_rlxregobj);
            <span class="kw">auto</span> res_using_mstdvec_iter = B::foo1(a_mstdvec_iter);
            <span class="kw">auto</span> res_using_msevec_ipointer = B::foo1(a_msevec_ipointer);
            <span class="kw">auto</span> res_using_msevec_ssiter = B::foo1(a_msevec_ssiter);
            <span class="kw">auto</span> res_using_writelock_ptr = B::foo1(a_writelock_ptr);
            <span class="kw">auto</span> res_using_member_refc_anyptr = B::foo3(b_member_a_refc_anyptr);
            <span class="kw">auto</span> res_using_member_reg_anyptr = B::foo3(b_member_a_reg_anyptr);
            <span class="kw">auto</span> res_using_member_mstdvec_iter_anyptr = B::foo3(b_member_a_mstdvec_iter_anyptr);
    
            <span class="co">/* Or an mse::TXScopePolyConstPointer&lt;&gt;. */</span>
            <span class="kw">auto</span> res_using_scpptr_via_const_poly = B::foo2(&amp;a_scpobj);
            <span class="kw">auto</span> res_using_refcptr_via_const_poly = B::foo2(a_refcptr);
            <span class="kw">auto</span> res_using_regptr_via_const_poly = B::foo2(&amp;a_regobj);
            <span class="kw">auto</span> res_using_rlxregptr_via_const_poly = B::foo2(&amp;a_rlxregobj);
            <span class="kw">auto</span> res_using_mstdvec_iter_via_const_poly = B::foo2(a_mstdvec_iter);
            <span class="kw">auto</span> res_using_msevec_ipointer_via_const_poly = B::foo2(a_msevec_ipointer);
            <span class="kw">auto</span> res_using_msevec_ssiter_via_const_poly = B::foo2(a_msevec_ssiter);
            <span class="kw">auto</span> res_using_writelock_ptr_via_const_poly = B::foo2(a_writelock_ptr);
            <span class="kw">auto</span> res_using_stdshared_const_ptr_via_const_poly = B::foo2(a_stdshared_const_ptr);
            <span class="kw">auto</span> res_using_member_refc_anyptr_via_const_poly = B::foo4(b_member_a_refc_anyptr);
            <span class="kw">auto</span> res_using_member_reg_anyptr_via_const_poly = B::foo4(b_member_a_reg_anyptr);
            <span class="kw">auto</span> res_using_member_mstdvec_iter_anyptr_via_const_poly = B::foo4(b_member_a_mstdvec_iter_anyptr);
        }
    }</code></pre></div>
<h3 id="tpolypointer-tpolyconstpointer">TPolyPointer, TPolyConstPointer</h3>
<p>These poly pointers do not support construction from scope pointers, and thus are not bound by the same usage restrictions. For example, these poly pointers may be used as a member of a class or struct.</p>
<h3 id="txscopeanypointer-txscopeanyconstpointer-tanypointer-tanyconstpointer">TXScopeAnyPointer, TXScopeAnyConstPointer, TAnyPointer, TAnyConstPointer</h3>
<p>&quot;Any&quot; pointers are also “chameleon” (type-erased) pointers that behave similarly to poly pointers. One difference is that unlike poly pointers which can only be directly constructed from a finite set of pointer types, &quot;any&quot; pointers can be constructed from almost any kind of pointer. But poly pointers can be constructed from &quot;any&quot; pointers, so indirectly, via &quot;any&quot; pointers, pretty much any type of pointer converts to a poly pointer too. In particular, if you wanted to pass a pointer generated by <a href="#make_pointer_to_member_v2"><code>make_pointer_to_member_v2()</code></a> to a function that takes a poly pointer, you would first need to wrap it an &quot;any&quot; pointer. This is demonstrated in the <a href="#txscopepolypointer-txscopepolyconstpointer">scope poly pointer</a> usage example.</p>
<p>&quot;Any&quot; pointers can also be used as function arguments. The choice between using poly pointers versus &quot;any&quot; pointers is similar to the choice between <a href="http://www.boost.org/doc/libs/1_63_0/doc/html/variant/misc.html#variant.versus-any"><code>std::variant</code> and <code>std::any</code></a>.</p>
<h3 id="txscopeanyrandomaccessiterator-txscopeanyrandomaccessconstiterator-tanyrandomaccessiterator-tanyrandomaccessconstiterator">TXScopeAnyRandomAccessIterator, TXScopeAnyRandomAccessConstIterator, TAnyRandomAccessIterator, TAnyRandomAccessConstIterator</h3>
<p>In modern C++ (and SaferCPlusPlus), arrays of different sizes are actually different types, with incompatible iterators. So, for example, if you wanted to make a function that accepts the iterators of arrays of varying size, you would generally do that by &quot;templatizing&quot; the function. Alternatively, you could use an &quot;any random access iterator&quot; which is a &quot;chameleon&quot; (type-erased) iterator that can be constructed from basically any iterator that supports <code>operator[]</code> (the &quot;square bracket&quot; operator).</p>
<h3 id="txscopeanyrandomaccesssection-txscopeanyrandomaccessconstsection-tanyrandomaccesssection-tanyrandomaccessconstsection">TXScopeAnyRandomAccessSection, TXScopeAnyRandomAccessConstSection, TAnyRandomAccessSection, TAnyRandomAccessConstSection</h3>
<p><code>TAnyRandomAccessSection&lt;_Ty&gt;</code> is essentially just an alias for <code>TRandomAccessSection&lt;TAnyRandomAccessIterator&lt;_Ty&gt; &gt;</code>. Analogous to <a href="#txscopeanyrandomaccessiterator-txscopeanyrandomaccessconstiterator-tanyrandomaccessiterator-tanyrandomaccessconstiterator"><code>TAnyRandomAccessIterator&lt;&gt;</code></a>, it can be used to enable a function to accept, as a parameter, any type of &quot;<a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">random access section</a>&quot;.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">4</span>&gt; array1 { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
        mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; array2 { <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span> };
        mse::mstd::vector&lt;<span class="dt">int</span>&gt; vec1 { <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span> };
        <span class="kw">class</span> B {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">void</span> foo1(mse::TXScopeAnyRandomAccessIterator&lt;<span class="dt">int</span>&gt; ra_iter1) {
                ra_iter1[<span class="dv">1</span>] = <span class="dv">15</span>;
            }
            <span class="at">static</span> <span class="dt">int</span> foo2(mse::TXScopeAnyRandomAccessConstIterator&lt;<span class="dt">int</span>&gt; const_ra_iter1) {
                const_ra_iter1 += <span class="dv">2</span>;
                --const_ra_iter1;
                const_ra_iter1--;
                <span class="cf">return</span> const_ra_iter1[<span class="dv">2</span>];
            }
            <span class="at">static</span> <span class="dt">void</span> foo3(mse::TXScopeAnyRandomAccessSection&lt;<span class="dt">int</span>&gt; ra_section) {
                <span class="cf">for</span> (mse::TXScopeAnyRandomAccessSection&lt;<span class="dt">int</span>&gt;::<span class="dt">size_type</span> i = <span class="dv">0</span>; i &lt; ra_section.size(); i += <span class="dv">1</span>) {
                    ra_section[i] = <span class="dv">0</span>;
                }
            }
            <span class="at">static</span> <span class="dt">int</span> foo4(mse::TXScopeAnyRandomAccessConstSection&lt;<span class="dt">int</span>&gt; const_ra_section) {
                <span class="dt">int</span> retval = <span class="dv">0</span>;
                <span class="cf">for</span> (mse::TXScopeAnyRandomAccessSection&lt;<span class="dt">int</span>&gt;::<span class="dt">size_type</span> i = <span class="dv">0</span>; i &lt; const_ra_section.size(); i += <span class="dv">1</span>) {
                    retval += const_ra_section[i];
                }
                <span class="cf">return</span> retval;
            }
            <span class="at">static</span> <span class="dt">int</span> foo5(mse::TXScopeAnyRandomAccessConstSection&lt;<span class="dt">int</span>&gt; const_ra_section) {
                <span class="dt">int</span> retval = <span class="dv">0</span>;
                <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; const_item : const_ra_section) {
                    retval += const_item;
                }
                <span class="cf">return</span> retval;
            }
        };
    
        <span class="kw">auto</span> array_iter1 = array1.begin();
        array_iter1++;
        <span class="kw">auto</span> res1 = B::foo2(array_iter1);
        B::foo1(array_iter1);
    
        <span class="kw">auto</span> array_const_iter2 = array2.cbegin();
        array_const_iter2 += <span class="dv">2</span>;
        <span class="kw">auto</span> res2 = B::foo2(array_const_iter2);
    
        <span class="kw">auto</span> res3 = B::foo2(vec1.cbegin());
        B::foo1(++vec1.begin());
        <span class="kw">auto</span> res4 = B::foo2(vec1.begin());
    
        mse::TXScopeAnyRandomAccessSection&lt;<span class="dt">int</span>&gt; ra_section1(array_iter1, <span class="dv">2</span>);
        B::foo3(ra_section1);
    
        mse::TXScopeAnyRandomAccessSection&lt;<span class="dt">int</span>&gt; ra_section2(++vec1.begin(), <span class="dv">3</span>);
        <span class="kw">auto</span> res5 = B::foo5(ra_section2);
        B::foo3(ra_section2);
        <span class="kw">auto</span> res6 = B::foo4(ra_section2);
    }</code></pre></div>
<h3 id="txscopeanystringsection-txscopeanystringconstsection-tanystringsection-tanystringconstsection">TXScopeAnyStringSection, TXScopeAnyStringConstSection, TAnyStringSection, TAnyStringConstSection</h3>
<p><code>TAnyStringSection&lt;_Ty&gt;</code> is essentially just an alias for <code>TStringSection&lt;TAnyRandomAccessIterator&lt;_Ty&gt; &gt;</code>. Like <a href="#txscopeanyrandomaccesssection-txscopeanyrandomaccessconstsection-tanyrandomaccesssection-tanyrandomaccessconstsection"><code>TAnyRandomAccessSection&lt;_Ty&gt;</code></a>, it can be used to enable a function to accept, as a parameter, any type of &quot;<a href="#txscopestringsection-txscopestringconstsection-tstringsection-tstringconstsection">string section</a>&quot;.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span><span class="pp"> </span><span class="co">// TAnyStringSection&lt;&gt; is defined in this header</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* &quot;Any&quot; string sections are basically polymorphic string sections that can hold the value of any string</span>
<span class="co">        section type. They can be used as function parameter types to enable functions to accept any type of string</span>
<span class="co">        section. */</span>
    
        mse::mstd::string mstring1(<span class="st">&quot;some text&quot;</span>);
        mse::TAnyStringSection&lt;<span class="dt">char</span>&gt; any_string_section1(mstring1.begin()<span class="dv">+5</span>, <span class="dv">3</span>);
    
        <span class="kw">auto</span> string_literal = <span class="st">&quot;some text&quot;</span>;
        mse::TAnyStringConstSection&lt;<span class="dt">char</span>&gt; any_string_const_section2(string_literal<span class="dv">+5</span>, <span class="dv">3</span>);
    
        <span class="kw">typedef</span> mse::TRegisteredObj&lt;mse::nii_string&gt; <span class="dt">reg_nii_string_t</span>;
        <span class="dt">reg_nii_string_t</span> reg_nii_string3(<span class="st">&quot;some other text&quot;</span>);
        <span class="co">/* This is a different type of (safe) iterator to a different type of string. */</span>
        <span class="kw">auto</span> iter = <span class="dt">reg_nii_string_t</span>::ss_begin(&amp;reg_nii_string3);
    
        <span class="co">/* Resulting in a different type of string section. */</span>
        <span class="kw">auto</span> string_section3 = mse::make_string_section(iter<span class="dv">+11</span>, <span class="dv">3</span>);
    
        mse::TAnyStringSection&lt;<span class="dt">char</span>&gt; any_string_section3 = string_section3;
        assert(any_string_section1 == any_string_section3);
        assert(any_string_section1.front() == <span class="st">&#39;t&#39;</span>);
        assert(any_string_section1.back() == <span class="st">&#39;x&#39;</span>);
        any_string_section1 = string_section3;
        any_string_section1[<span class="dv">1</span>] = <span class="st">&#39;E&#39;</span>;
    }</code></pre></div>
<h3 id="txscopeanynrpstringsection-txscopeanynrpstringconstsection-tanynrpstringsection-tanynrpstringconstsection">TXScopeAnyNRPStringSection, TXScopeAnyNRPStringConstSection, TAnyNRPStringSection, TAnyNRPStringConstSection</h3>
<p><code>TAnyNRPStringSection&lt;&gt;</code> is just a version of <a href="#txscopeanystringsection-txscopeanystringconstsection-tanystringsection-tanystringconstsection"><code>TAnyStringSection&lt;&gt;</code></a> that, for enhanced safety, doesn't support construction from unsafe raw pointer iterators or (unsafe) <code>std::string</code> iterators.</p>
<h3 id="pointer_to">pointer_to()</h3>
<p><code>pointer_to(X)</code> simply returns <code>&amp;X</code>, unless the type of <code>&amp;X</code> is a native pointer (and the library's safe pointers have not been disabled). In that case a compiler error will be induced. It can be used in place of the <code>&amp;</code> operator to help avoid inadvertent use of native pointers.</p>
<h3 id="safely-passing-parameters-by-reference">Safely passing parameters by reference</h3>
<p>This library provides a number of safe pointer types. So the question arises as to how and whether functions with pointer/reference parameters should accomodate all these pointer types. Well, an effective option is to &quot;templatize&quot; functions with pointer/reference parameters (that is, make them function templates), so that they can accept any pointer types.</p>
<p>But some would prefer not to templatize all their functions, in which case a more conventional option is to require that reference parameters be passed using <a href="#txscopeitemfixedpointer">(non-owning) scope pointers</a>. This approach, by default, has no more run-time overhead than using native pointers/references. And note that scope pointers can be obtained from <a href="#reference-counting-pointers">reference counting pointers</a>, <a href="#norad-pointers">norad pointers</a>, and pointers to <a href="#asynchronously-shared-objects">shared objects</a> using <a href="#make_xscope_strong_pointer_store"><code>make_xscope_strong_pointer_store()</code></a>, and <a href="#registered-pointers">registered pointers</a> when they are pointing to scope objects (or scope pointers). And, if necessary, the <code>mse::us::unsafe_make_xscope_pointer_to()</code> function can be used to obtain a (potentially unsafe) scope pointer to any object.</p>
<p>Scope pointers will only work for cases where you are not intending for the function to receive any type of ownership or store the reference beyond the duration of the function. For those cases we recommend sticking with the function template approach.</p>
<p>A third option is to use <a href="#poly-pointers">poly pointers</a>. They can also enable your function to accept a variety of reference types, without &quot;templatizing&quot; your function, but with a small run-time overhead.</p>
<p>And of course the library remains perfectly compatible with (potentially unsafe) traditional C++ references if you prefer.</p>
<h3 id="multithreading">Multithreading</h3>
<p>The library requires and enforces that objects shared or passed between threads may only be of types identified as safe for such operations.</p>
<h3 id="tuserdeclaredasyncpassableobj">TUserDeclaredAsyncPassableObj</h3>
<p>When passing an argument to a function that will be executed in another thread using the library, the argument must be of a type identified as being safe to do so. If not, a compiler error will be induced. The library knows which of its own types and the standard types are and aren't safely passable to another thread, but can't automatically deduce whether or not a user-defined type is safe to pass. So in order to pass a user-defined type, you need to &quot;declare&quot; that it is safely passable by wrapping it with the transparent <code>us::TUserDeclaredAsyncPassableObj&lt;&gt;</code> template. Otherwise you'll get a compile error. A type that is safe to pass should contain no indirect objects (i.e. pointers, references, etc.) that are not known to be safe to pass between threads. (Mis)using <code>us::TUserDeclaredAsyncPassableObj&lt;&gt;</code> to indicate that a user-defined type is safely passable when that type does not meet these criteria could result in unsafe code.</p>
<h3 id="thread">thread</h3>
<p><code>mstd::thread</code> is just an implementation of <code>std::thread</code> that verifies that the arguments passed are of a type that is designated (i.e. recognized or declared) as safe to pass between threads. Note that this includes the passed function object. &quot;Regular, concrete&quot; functions and non-capture lambdas are automatically recognized as safely passable, but functors, capture-lambdas and generic lambdas would need to be explicitly declared as &quot;passable&quot;.</p>
<p>usage example: (used in the example for <a href="#tasyncrasectionsplitter">TAsyncRASectionSplitter</a>)</p>
<h3 id="async">async()</h3>
<p><code>mstd::async()</code> is just an implementation of <code>std::async()</code> that verifies that the arguments and return value passed are of a type that is designated as safe to pass between threads.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h3 id="asynchronously-shared-objects">Asynchronously shared objects</h3>
<p>One situation where safety mechanisms are particularly important is when sharing objects between asynchronous threads. In particular, while one thread is modifying an object, you want to ensure that no other thread accesses it. But you also want to do it in a way that allows for maximum utilization of the shared object. To this end the library provides &quot;access requesters&quot;. Access requesters provide &quot;lock pointers&quot; on demand that are used to safely access the shared object.</p>
<p>In cases where the object you want to share is &quot;immutable&quot; (i.e. not modifiable), no access control is necessary. For these cases the library provides &quot;immutable fixed pointers&quot;, which can be thought of as sort of a safer version of <code>std::shared_ptr&lt;&gt;</code>.</p>
<p>In order to ensure safety, shared objects can only be accessed through lock pointers or immutable fixed pointers. If you have an existing object that you only want to share part of the time, you can swap (using <code>std::swap()</code> for example) the object with a shared object when it's time to share it, and swap it back when you're done sharing.</p>
<p>Note that not all types are safe to share between threads. For example, because of its iterators, <code>mstd::vector&lt;int&gt;</code> is not safe to share between threads. (And neither is <code>std::vector&lt;int&gt;</code>.) <a href="#nii_vector"><code>nii_vector&lt;int&gt;</code></a> on the other hand is. Trying to share the former using access requesters or immutable fixed pointers would result in a compile error.</p>
<h3 id="tuserdeclaredasyncshareableobj">TUserDeclaredAsyncShareableObj</h3>
<p>As with <a href="#tuserdeclaredasyncpassableobj">passing</a> objects between threads, when using the library to share an object among threads, the object must be of a type identified as being safe to do so. If not, a compiler error will be induced. The library knows which of its own types and the standard types are and aren't safely shareable, but can't automatically deduce whether or not a user-defined type is safe to share. So in order to share a user-defined type, you need to &quot;declare&quot; that it is safely shareable by wrapping it with the transparent <code>us::TUserDeclaredAsyncShareableObj&lt;&gt;</code> template.</p>
<p>A type that is safe to share should contain no indirect objects (i.e. pointers, references, etc.) that are not known to be safe to share among threads, and should not provide any facilities for obtaining such indirect objects. Note that this would disqualify, for example, container types that have a (non-static) <code>begin()</code> member function that returns an iterator (which is an indirect/reference object). (The library provides containers such as <a href="#nii_array"><code>nii_array&lt;&gt;</code></a> that are more appropriate for sharing among threads.)</p>
<p>Technically it would also disqualify pretty much any object with a functioning (non-static) <code>&amp;</code> operator, but the (ubiquitous) default <code>&amp;</code> operator returns a raw pointer, and for pragmatic reasons, we more precisely identify the <em>declaration</em> of a raw pointer object (that receives the returned raw pointer value) to be unsafe, rather than the mere presence of the (hopefully unused) <code>&amp;</code> operator that potentially generates it. Objects with custom (non-static) <code>&amp;</code> operators that return something other than a raw pointer (such as registered objects whose <code>&amp;</code> operator yields a <a href="#registered-pointers">registered pointer</a>), however, would be disqualified.</p>
<p>Types declared as shareable should also not have any <code>mutable</code> qualified members that are not protected by a thread-safety mechanism.</p>
<p>(Mis)using <code>us::TUserDeclaredAsyncShareableObj&lt;&gt;</code> to indicate that a user-defined type is safely shareable when that type does not meet these criteria could result in unsafe code.</p>
<h3 id="tuserdeclaredasyncshareableandpassableobj">TUserDeclaredAsyncShareableAndPassableObj</h3>
<p>Many objects that qualify as safely <a href="#tuserdeclaredasyncshareableobj">shareable</a> or <a href="#tuserdeclaredasyncpassableobj">passable</a> between threads qualify as both.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h3 id="tasyncsharedv2readwriteaccessrequester">TAsyncSharedV2ReadWriteAccessRequester</h3>
<p>Use the <code>writelock_ptr()</code> and <code>readlock_ptr()</code> member functions to obtain pointers to the shared object. Those functions will block until they can obtain the needed lock on the shared object. The obtained pointers will hold on to their lock for as long as they exist. Their locks are released when the pointers are destroyed. (Generally when they go out of scope).</p>
<p>Use the <code>mse::make_asyncsharedv2readwrite&lt;&gt;()</code> function to obtain a <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code>. <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code> can be copied and passed-by-value as a parameter (to another thread, generally).</p>
<p>Non-blocking <code>try_writelock_ptr()</code> and <code>try_readlock_ptr()</code> member functions are also available. As are the limited-blocking <code>try_writelock_ptr_for()</code>, <code>try_readlock_ptr_for()</code>, <code>try_writelock_ptr_until()</code> and <code>try_readlock_ptr_until()</code>.</p>
<p>Note that while a &quot;write-lock&quot; pointer will not simultaneously co-exist with any lock pointer to the same shared object in any other thread, it can co-exist with (read- and/or write-) lock pointers in the same thread. This means that lock pointers have <a href="http://www.boost.org/doc/libs/1_65_1/doc/html/thread/synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable">&quot;upgrade lock&quot;</a> functionality. That is, for example, a thread that holds a read lock on a shared object (via read-lock pointer) can, at some later point, additionally obtain a write lock (via write-lock pointer) without surrendering the original read lock. It can then release the write lock (by allowing the write-lock pointer to go out of scope), again without surrendering the original read lock. Systems based on traditional &quot;readers-writer&quot; locks would require you to surrender the read lock before attempting to obtain a write lock, allowing another thread to potentially (and undesirably) obtain a write lock in between.</p>
<p>One caveat is that this introduces a new possible deadlock scenario where two threads hold read locks and both are blocked indefinitely waiting for write locks. The access requesters detect these situations, and will throw an exception (or whatever user-specified behavior) when they occur.</p>
<p>Just as <code>std::weak_ptr&lt;&gt;</code> is the &quot;weak&quot; counterpart of <code>std::shared_ptr&lt;&gt;</code>, <code>TAsyncSharedV2WeakReadWriteAccessRequester&lt;&gt;</code> is the weak counter part of <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code>. Its constructor takes a <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code>, and its <code>try_strong_access_requester()</code> member function returns an <code>optional</code> value containing the associated <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code> if available.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h3 id="tasyncsharedv2readonlyaccessrequester">TAsyncSharedV2ReadOnlyAccessRequester</h3>
<p>Same as <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code>, but only supports <code>readlock_ptr()</code>, not <code>writelock_ptr()</code>. You can use the <code>mse::make_asyncsharedv2readonly&lt;&gt;()</code> function to obtain a <code>TAsyncSharedV2ReadOnlyAccessRequester&lt;&gt;</code>. <code>TAsyncSharedV2ReadOnlyAccessRequester&lt;&gt;</code> can also be copy constructed from a <code>TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</code>.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h3 id="tasyncsharedv2immutablefixedpointer">TAsyncSharedV2ImmutableFixedPointer</h3>
<p>In cases where the object you want to share is &quot;immutable&quot; (i.e. not modifiable), no access control is necessary. For these cases you can use <code>TAsyncSharedV2ImmutableFixedPointer&lt;&gt;</code>, which can be thought of as sort of a safer version of <code>std::shared_ptr&lt;&gt;</code>. Use the <code>mse::make_asyncsharedv2immutable&lt;&gt;()</code> function to obtain a <code>TAsyncSharedV2ImmutableFixedPointer&lt;&gt;</code>.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h3 id="tasyncsharedv2atomicfixedpointer">TAsyncSharedV2AtomicFixedPointer</h3>
<p>Atomic objects also don't require access control. Use the <code>make_asyncsharedv2atomic&lt;&gt;()</code> function to obtain a <code>TAsyncSharedV2AtomicFixedPointer&lt;&gt;</code>.</p>
<p>usage example: (<a href="#async-aggregate-usage-example">see below</a>)</p>
<h4 id="async-aggregate-usage-example">async aggregate usage example:</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;ctime&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ratio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;chrono&gt;</span>
<span class="pp">#include </span><span class="im">&lt;future&gt;</span>

<span class="kw">class</span> H {
<span class="kw">public</span>:
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TAsyncSharedReadWriteAccessRequester&gt;
    <span class="at">static</span> <span class="dt">double</span> foo7(_TAsyncSharedReadWriteAccessRequester A_ashar) {
        <span class="kw">auto</span> t1 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
        <span class="co">/* A_ashar.readlock_ptr() will block until it can obtain a read lock. */</span>
        <span class="kw">auto</span> ptr1 = A_ashar.readlock_ptr(); <span class="co">// while ptr1 exists it holds a (read) lock on the shared object</span>
        <span class="kw">auto</span> t2 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
        <span class="kw">auto</span> time_span = <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt;<span class="bu">std::</span>chrono<span class="bu">::</span>duration&lt;<span class="dt">double</span>&gt;&gt;(t2 - t1);
        <span class="kw">auto</span> timespan_in_seconds = time_span.count();
        <span class="kw">auto</span> thread_id = <span class="bu">std::</span>this_thread<span class="bu">::</span>get_id();
        <span class="cf">return</span> timespan_in_seconds;
    }
<span class="kw">protected</span>:
    ~H() {}
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    <span class="co">/* The TAsyncShared data types are used to safely share objects between asynchronous threads. */</span>

    <span class="kw">class</span> A {
    <span class="kw">public</span>:
        A(<span class="dt">int</span> x) : b(x) {}
        <span class="kw">virtual</span> ~A() {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
        mse::nii_string s = <span class="st">&quot;some text &quot;</span>;
    };
    <span class="co">/* User-defined classes need to be declared as (safely) shareable in order to be accepted by the access requesters. */</span>
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; ShareableA;

    <span class="kw">class</span> B {
    <span class="kw">public</span>:
        <span class="at">static</span> <span class="dt">double</span> foo1(mse::TAsyncSharedV2ReadWriteAccessRequester&lt;ShareableA&gt; A_ashar) {
            <span class="kw">auto</span> t1 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
            <span class="co">/* mse::TAsyncSharedV2ReadWriteAccessRequester&lt;ShareableA&gt;::writelock_ptr() will block until it can obtain a write lock. */</span>
            <span class="kw">auto</span> ptr1 = A_ashar.writelock_ptr(); <span class="co">// while ptr1 exists it holds a (write) lock on the shared object</span>
            <span class="kw">auto</span> t2 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
            <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
            <span class="kw">auto</span> time_span = <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt;<span class="bu">std::</span>chrono<span class="bu">::</span>duration&lt;<span class="dt">double</span>&gt;&gt;(t2 - t1);
            <span class="kw">auto</span> timespan_in_seconds = time_span.count();
            <span class="kw">auto</span> thread_id = <span class="bu">std::</span>this_thread<span class="bu">::</span>get_id();
            <span class="co">//std::cout &lt;&lt; &quot;thread_id: &quot; &lt;&lt; thread_id &lt;&lt; &quot;, time to acquire write pointer: &quot; &lt;&lt; timespan_in_seconds &lt;&lt; &quot; seconds.&quot;;</span>
            <span class="co">//std::cout &lt;&lt; std::endl;</span>

            ptr1-&gt;s = <span class="bu">std::</span>to_string(timespan_in_seconds);
            <span class="cf">return</span> timespan_in_seconds;
        }
        <span class="at">static</span> <span class="dt">int</span> foo2(mse::TAsyncSharedV2ImmutableFixedPointer&lt;ShareableA&gt; A_immptr) {
            <span class="cf">return</span> A_immptr-&gt;b;
        }
        <span class="at">static</span> <span class="dt">int</span> foo3(mse::TAsyncSharedV2AtomicFixedPointer&lt;<span class="dt">int</span>&gt; int_atomic_ptr) {
            (*int_atomic_ptr) += <span class="dv">1</span>;
            <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
            <span class="cf">return</span> *int_atomic_ptr;
        }
    <span class="kw">protected</span>:
        ~B() {}
    };

    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;AsyncSharedV2 test output:&quot;</span>;
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;

    {
        <span class="co">/* This block contains a simple example demonstrating the use of mse::TAsyncSharedV2ReadWriteAccessRequester</span>
<span class="co">        to safely share an object between threads. */</span>

        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TAsyncSharedV2ReadWriteAccessRequester:&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
        <span class="kw">auto</span> ash_access_requester = mse::make_asyncsharedv2readwrite&lt;ShareableA&gt;(<span class="dv">7</span>);
        ash_access_requester.writelock_ptr()-&gt;b = <span class="dv">11</span>;
        <span class="dt">int</span> res1 = ash_access_requester.readlock_ptr()-&gt;b;

        {
            <span class="kw">auto</span> ptr3 = ash_access_requester.readlock_ptr();
            <span class="kw">auto</span> ptr1 = ash_access_requester.writelock_ptr();
            <span class="kw">auto</span> ptr2 = ash_access_requester.writelock_ptr();
        }

        <span class="bu">std::</span>list&lt;mse::mstd::future&lt;<span class="dt">double</span>&gt;&gt; futures;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i += <span class="dv">1</span>) {
            futures.emplace_back(mse::mstd::async(B::foo1, ash_access_requester));
        }
        <span class="dt">int</span> count = <span class="dv">1</span>;
        <span class="cf">for</span> (<span class="kw">auto</span> it = futures.begin(); futures.end() != it; it++, count++) {
            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;thread: &quot;</span> &lt;&lt; count &lt;&lt; <span class="st">&quot;, time to acquire read pointer: &quot;</span> &lt;&lt; (*it).get() &lt;&lt; <span class="st">&quot; seconds.&quot;</span>;
            <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
        }
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
    }
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TAsyncSharedV2ReadOnlyAccessRequester:&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
        <span class="kw">auto</span> ash_access_requester = mse::make_asyncsharedv2readonly&lt;ShareableA&gt;(<span class="dv">7</span>);
        <span class="dt">int</span> res1 = ash_access_requester.readlock_ptr()-&gt;b;

        <span class="bu">std::</span>list&lt;mse::mstd::future&lt;<span class="dt">double</span>&gt;&gt; futures;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i += <span class="dv">1</span>) {
            futures.emplace_back(mse::mstd::async(J::foo7&lt;mse::TAsyncSharedV2ReadOnlyAccessRequester&lt;ShareableA&gt;&gt;, ash_access_requester));
        }
        <span class="dt">int</span> count = <span class="dv">1</span>;
        <span class="cf">for</span> (<span class="kw">auto</span> it = futures.begin(); futures.end() != it; it++, count++) {
            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;thread: &quot;</span> &lt;&lt; count &lt;&lt; <span class="st">&quot;, time to acquire read pointer: &quot;</span> &lt;&lt; (*it).get() &lt;&lt; <span class="st">&quot; seconds.&quot;</span>;
            <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
        }
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
    }
    {
        <span class="co">/* Just demonstrating the existence of the &quot;try&quot; versions. */</span>
        <span class="kw">auto</span> access_requester = mse::make_asyncsharedv2readwrite&lt;mse::nii_string&gt;(<span class="st">&quot;some text&quot;</span>);
        <span class="kw">auto</span> writelock_ptr1 = access_requester.try_writelock_ptr();
        <span class="cf">if</span> (writelock_ptr1) {
            <span class="co">// lock request succeeded</span>
            <span class="dt">int</span> q = <span class="dv">5</span>;
        }
        <span class="kw">auto</span> readlock_ptr2 = access_requester.try_readlock_ptr_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
        <span class="kw">auto</span> writelock_ptr3 = access_requester.try_writelock_ptr_until(<span class="bu">std::</span>chrono<span class="bu">::</span>steady_clock<span class="bu">::</span>now() + <span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
    }
    {
        <span class="co">/* TAsyncSharedV2WeakReadWriteAccessRequester&lt;&gt; is the weak counterpart to TAsyncSharedV2ReadWriteAccessRequester&lt;&gt;</span>
<span class="co">        analogous to how std::weak_ptr&lt;&gt; is the weak counterpart to std::shared_ptr&lt;&gt;. */</span>

        <span class="kw">typedef</span> <span class="kw">decltype</span>(mse::make_asyncsharedv2readwrite&lt;mse::nii_string&gt;(<span class="st">&quot;abc&quot;</span>)) <span class="dt">access_requester_t</span>;
        <span class="kw">auto</span> vec1 = mse::mstd::vector&lt;<span class="dt">access_requester_t</span>&gt;();
        vec1.push_back(mse::make_asyncsharedv2readwrite&lt;mse::nii_string&gt;(<span class="st">&quot;abc&quot;</span>));

        mse::TAsyncSharedV2WeakReadWriteAccessRequester&lt;mse::nii_string&gt; weak_ar1(vec1.at(<span class="dv">0</span>));

        <span class="co">/* Here we&#39;re obtaining a (strong) access requester from the weak access requester, then appending it the</span>
<span class="co">        vector of access requesters. */</span>
        vec1.push_back(weak_ar1.try_strong_access_requester().value());

        assert((*(vec1.at(<span class="dv">1</span>).readlock_ptr())) == <span class="st">&quot;abc&quot;</span>);

        vec1.clear();

        <span class="co">/* All the (strong) access requesters have just been destroyed so attempting to obtain a (strong) access requester</span>
<span class="co">        from our weak one will result in an empty optional being returned. */</span>
        assert(!(weak_ar1.try_strong_access_requester().has_value()));
    }
    {
        <span class="co">/* For scenarios where the shared object is immutable (i.e. is never modified), you can get away without using locks</span>
<span class="co">        or access requesters. */</span>
        <span class="kw">auto</span> A_immptr = mse::make_asyncsharedv2immutable&lt;ShareableA&gt;(<span class="dv">5</span>);
        <span class="dt">int</span> res1 = A_immptr-&gt;b;
        <span class="bu">std::</span>shared_ptr&lt;<span class="at">const</span> ShareableA&gt; A_shptr(A_immptr);

        <span class="bu">std::</span>list&lt;mse::mstd::future&lt;<span class="dt">int</span>&gt;&gt; futures;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i += <span class="dv">1</span>) {
            futures.emplace_back(mse::mstd::async(B::foo2, A_immptr));
        }
        <span class="dt">int</span> count = <span class="dv">1</span>;
        <span class="cf">for</span> (<span class="kw">auto</span> it = futures.begin(); futures.end() != it; it++, count++) {
            <span class="dt">int</span> res2 = (*it).get();
        }

        <span class="kw">auto</span> A_b_safe_cptr = mse::make_const_pointer_to_member(A_immptr-&gt;b, A_immptr);
    }
    {
        <span class="co">/* For scenarios where the shared object is atomic, you can get away without using locks</span>
<span class="co">        or access requesters. */</span>
        <span class="kw">auto</span> int_atomic_ptr = mse::make_asyncsharedv2atomic&lt;<span class="dt">int</span>&gt;(<span class="dv">5</span>);
        <span class="dt">int</span> res1 = (*int_atomic_ptr);

        <span class="bu">std::</span>list&lt;mse::mstd::future&lt;<span class="dt">int</span>&gt;&gt; futures;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i += <span class="dv">1</span>) {
            futures.emplace_back(mse::mstd::async(B::foo3, int_atomic_ptr));
        }
        <span class="dt">int</span> count = <span class="dv">1</span>;
        <span class="cf">for</span> (<span class="kw">auto</span> it = futures.begin(); futures.end() != it; it++, count++) {
            <span class="dt">int</span> res2 = (*it).get();
        }
    }
    {
        <span class="co">/* mse::TAsyncSharedV2ReadWriteAccessRequester&#39;s flexibilty in allowing coexisting read and write lock</span>
<span class="co">        pointers in the same thread introduces new ways to produce logical deadlocks. This block (likely)</span>
<span class="co">        demonstrates the access requester&#39;s ability to detect these potential deadlocks (and throw an exception</span>
<span class="co">        when they would occur). */</span>

        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;TAsyncSharedV2ReadWriteAccessRequester deadlock detection:&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;

        <span class="kw">class</span> CC {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">void</span> foo1(mse::TAsyncSharedV2ReadWriteAccessRequester&lt;ShareableA&gt; A_ashar, <span class="dt">int</span> id) {
                <span class="kw">auto</span> readlock_ptr = A_ashar.readlock_ptr();
                <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
                <span class="cf">try</span> {
                    <span class="kw">auto</span> writelock_ptr = A_ashar.writelock_ptr();
                    <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
                }
                <span class="cf">catch</span> (...) {
                    <span class="co">// likely exception due to potential deadlock</span>
                    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;deadlock detected &quot;</span>;
                    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
                }
            }
        };

        <span class="kw">auto</span> ash_access_requester = mse::make_asyncsharedv2readwrite&lt;ShareableA&gt;(<span class="dv">7</span>);

        {
            <span class="kw">auto</span> thread1 = mse::mstd::thread(CC::foo1, ash_access_requester, <span class="dv">1</span>);
            <span class="kw">auto</span> thread2 = mse::mstd::thread(CC::foo1, ash_access_requester, <span class="dv">2</span>);
            thread1.join();
            thread2.join();
        }

        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
    }
}</code></pre></div>
<h3 id="tasyncrasectionsplitter">TAsyncRASectionSplitter</h3>
<p><code>TAsyncRASectionSplitter&lt;&gt;</code> is used for situations where you want to allow multiple threads to concurrently access and/or modify different parts of an array or vector. You specify how you want the array/vector partitioned, and the <code>TAsyncRASectionSplitter&lt;&gt;</code> will provide a set of access requesters used to obtain access to each partition. Instead of the usual &quot;lock pointers&quot;, these access requesters return &quot;lock <a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">random access section</a>s&quot;.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>

<span class="kw">class</span> J {
<span class="kw">public</span>:
    <span class="co">/* This function takes a &quot;random access section&quot; (which is like an &quot;array_view&quot; or gsl::span) as its parameter. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TStringRASection&gt;
    <span class="at">static</span> <span class="dt">void</span> foo8(_TStringRASection ra_section) {
        <span class="dt">size_t</span> delay_in_milliseconds = <span class="dv">3000</span><span class="co">/*arbitrary*/</span>;
        <span class="cf">if</span> (<span class="dv">1</span> &lt;= ra_section.size()) {
            delay_in_milliseconds /= ra_section.size();
        }
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; ra_section.size(); i += <span class="dv">1</span>) {
            <span class="kw">auto</span> now1 = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now();
            <span class="kw">auto</span> tt = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>to_time_t(now1);

            <span class="co">/* Just trying to obtain a string with the current time and date. The standard library doesn&#39;t yet</span>
<span class="co">            seem to provide a safe, portable way to do this. */</span>
<span class="pp">#ifdef _MSC_VER</span>
            <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> buffer_size = <span class="dv">64</span>;
            <span class="dt">char</span> buffer[buffer_size];
            buffer[<span class="dv">0</span>] = <span class="st">&#39;</span><span class="sc">\0</span><span class="st">&#39;</span>;
            ctime_s(buffer, buffer_size, &amp;tt);
<span class="pp">#else </span><span class="co">/*_MSC_VER*/</span>
            <span class="kw">auto</span> buffer = ctime(&amp;tt);
<span class="pp">#endif </span><span class="co">/*_MSC_VER*/</span>

            <span class="bu">std::</span>string now_str(buffer);
            ra_section[i] = now_str;

            <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(delay_in_milliseconds));
        }
    }

    <span class="co">/* This function just obtains a writelock_ra_section from the given &quot;splitter access requester&quot; and calls the given</span>
<span class="co">    function with the writelock_ra_section as the first argument. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TAsyncSplitterRASectionReadWriteAccessRequester, <span class="kw">class</span> _TFunction, <span class="kw">class</span>... Args&gt;
    <span class="at">static</span> <span class="dt">void</span> invoke_with_writelock_ra_section1(_TAsyncSplitterRASectionReadWriteAccessRequester ar, _TFunction function1, Args&amp;&amp;... args) {
        function1(ar.writelock_ra_section(), args...);
    }
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    <span class="co">/* This block demonstrates safely allowing different threads to (simultaneously) modify different</span>
<span class="co">    sections of a vector. (We use vectors in this example, but it works just as well with arrays.) */</span>

    <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> num_sections = <span class="dv">10</span>;
    <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> section_size = <span class="dv">5</span>;
    <span class="at">const</span> <span class="dt">size_t</span> num_elements = num_sections * section_size;

    <span class="kw">typedef</span> mse::nii_vector&lt;mse::nii_string&gt; <span class="dt">async_shareable_vector1_t</span>;
    <span class="kw">typedef</span> mse::mstd::vector&lt;mse::nii_string&gt; <span class="dt">nonshareable_vector1_t</span>;
    <span class="co">/* Let&#39;s say we have a vector. */</span>
    <span class="dt">nonshareable_vector1_t</span> vector1;
    vector1.resize(num_elements);
    {
        <span class="dt">size_t</span> count = <span class="dv">0</span>;
        <span class="cf">for</span> (<span class="kw">auto</span>&amp; item_ref : vector1) {
            count += <span class="dv">1</span>;
            item_ref = <span class="st">&quot;text&quot;</span> + <span class="bu">std::</span>to_string(count);
        }
    }

    <span class="co">/* Only access controlled objects can be shared with other threads, so we&#39;ll make an access controlled vector and</span>
<span class="co">    (temporarily) swap it with our original one. */</span>
    <span class="kw">auto</span> ash_access_requester = mse::make_asyncsharedv2readwrite&lt;<span class="dt">async_shareable_vector1_t</span>&gt;();
    <span class="bu">std::</span>swap(vector1, (*(ash_access_requester.writelock_ptr())));

    {
        <span class="co">/* Now, we&#39;re going to use the access requester to obtain two new access requesters that provide access to</span>
<span class="co">        (newly created) &quot;random access section&quot; objects which are used to access (disjoint) sections of the vector.</span>
<span class="co">        We need to specify the position where we want to split the vector. Here we specify that it be split at index</span>
<span class="co">        &quot;num_elements / 2&quot;, right down the middle. */</span>
        mse::TAsyncRASectionSplitter&lt;<span class="kw">decltype</span>(ash_access_requester)&gt; ra_section_split1(ash_access_requester, num_elements / <span class="dv">2</span>);
        <span class="kw">auto</span> ar1 = ra_rection_split1.first_ra_section_access_requester();
        <span class="kw">auto</span> ar2 = ra_rection_split1.second_ra_section_access_requester();

        <span class="co">/* The J::foo8 template function is just an example function that operates on containers of strings. In our case the</span>
<span class="co">        containers will be the random access sections we just created. We&#39;ll create an instance of the function here. */</span>
        <span class="kw">auto</span> my_foo8_function = J::foo8&lt;<span class="kw">decltype</span>(ar1.writelock_ra_section())&gt;;

        <span class="co">/* We want to execute the my_foo8 function in a separate thread. The function takes a &quot;random access section&quot;</span>
<span class="co">        as an argument. But as we&#39;re not allowed to pass random access sections between threads, we must pass an</span>
<span class="co">        access requester instead. The &quot;J::invoke_with_writelock_ra_section1&quot; template function is just a helper</span>
<span class="co">        function that will obtain a (writelock) random access section from the access requester, then call the given</span>
<span class="co">        function, in this case my_foo8, with that random access section. So here we&#39;ll use it to create a proxy</span>
<span class="co">        function that we can execute directly in a separate thread and will accept an access requester as a</span>
<span class="co">        parameter. */</span>
        <span class="kw">auto</span> my_foo8_proxy_function = J::invoke_with_writelock_ra_section1&lt;<span class="kw">decltype</span>(ar1), <span class="kw">decltype</span>(my_foo8_function)&gt;;

        <span class="bu">std::</span>list&lt;mse::mstd::thread&gt; threads;
        <span class="co">/* So this thread will modify the first section of the vector. */</span>
        threads.emplace_back(mse::mstd::thread(my_foo8_proxy_function, ar1, my_foo8_proxy_function));
        <span class="co">/* While this thread modifies the other section. */</span>
        threads.emplace_back(mse::mstd::thread(my_foo8_proxy_function, ar2, my_foo8_proxy_function));

        {
            <span class="dt">int</span> count = <span class="dv">1</span>;
            <span class="cf">for</span> (<span class="kw">auto</span> it = threads.begin(); threads.end() != it; it++, count++) {
                (*it).join();
            }
        }
    }
    {
        <span class="co">/* Ok, now let&#39;s do it again, but instead of splitting the vector into two sections, let&#39;s split it into more sections: */</span>
        <span class="co">/* First we create a list of a the sizes of each section. We&#39;ll use a vector here, but any iteratable container will work. */</span>
        mse::mstd::vector&lt;<span class="dt">size_t</span>&gt; section_sizes;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; num_sections; i += <span class="dv">1</span>) {
            section_sizes.push_back(section_size);
        }

        <span class="co">/* Just as before, TAsyncRASectionSplitter&lt;&gt; will generate a new access requester for each section. */</span>
        mse::TAsyncRASectionSplitter&lt;<span class="kw">decltype</span>(ash_access_requester)&gt; ra_section_split1(ash_access_requester, section_sizes);
        <span class="kw">auto</span> ar0 = ra_rection_split1.ra_section_access_requester(<span class="dv">0</span>);

        <span class="kw">auto</span> my_foo8_function = J::foo8&lt;<span class="kw">decltype</span>(ar1.writelock_ra_section())&gt;;
        <span class="kw">auto</span> my_foo8_proxy_function = J::invoke_with_writelock_ra_section1&lt;<span class="kw">decltype</span>(ar1), <span class="kw">decltype</span>(my_foo8_function)&gt;;

        <span class="bu">std::</span>list&lt;mse::mstd::thread&gt; threads;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; num_sections; i += <span class="dv">1</span>) {
            <span class="kw">auto</span> ar = ra_rection_split1.ra_section_access_requester(i);
            threads.emplace_back(mse::mstd::thread(my_foo8_proxy_function, ar, my_foo8_proxy_function));
        }

        {
            <span class="dt">int</span> count = <span class="dv">1</span>;
            <span class="cf">for</span> (<span class="kw">auto</span> it = threads.begin(); threads.end() != it; it++, count++) {
                (*it).join();
            }
        }
    }

    <span class="co">/* Now that we&#39;re done sharing the (controlled access) vector, we can swap it back to our original vector. */</span>
    <span class="bu">std::</span>swap(vector1, (*(ash_access_requester.writelock_ptr())));
    <span class="kw">auto</span> first_element_value = vector1[<span class="dv">0</span>];
    <span class="kw">auto</span> last_element_value = vector1.back();
}</code></pre></div>
<h3 id="scope-threads">Scope threads</h3>
<p><code>xscope_thread</code> is the scope counterpart to <a href="#thread"><code>mstd::thread</code></a>. <code>xscope_thread</code> ensures that the actual associated thread doesn't outlive it (and therefore doesn't outlive the scope), blocking in its destructor if necessary. Note that objects shared with an <code>mstd::thread</code> generally have dynamic allocation (i.e. are allocated on the heap), whereas objects shared with a scope thread can themselves be scope objects (i.e. allocated on the stack). Which would generally be the primary reason for using scope threads over non-scope threads.</p>
<p>Any data type that qualifies as &quot;<a href="#tuserdeclaredasyncshareableobj">shareable</a>&quot; (or &quot;<a href="#tuserdeclaredasyncpassableobj">passable</a>&quot;) with non-scope threads also qualifies as shareable (or passable) with scope threads. (But not necessarily the other way around.)</p>
<h4 id="access-controlled-objects">access controlled objects</h4>
<p>But in order to share an existing scope object, that object also has to be an &quot;access controlled&quot; object. You make a type &quot;access controlled&quot; by wrapping it with the <code>mse::TXScopeAccessControlledObj&lt;&gt;</code> template wrapper.</p>
<p><code>mse::TXScopeAccessControlledObj&lt;&gt;</code> provides <code>xscope_pointer()</code>, <code>xscope_const_pointer()</code> and <code>xscope_exclusive_pointer()</code> member functions which you use to obtain (scope) pointers to the contained object. Note that a pointer obtained via <code>xscope_exclusive_pointer()</code> may not coexist with any other pointer to the same object. Attempting to violate this rule will result in an exception.</p>
<h4 id="xscope_thread_carrier">xscope_thread_carrier</h4>
<p>Ok, so getting back to scope threads, it would generally not be very common that you would use <code>xscope_thread</code>s directly. More often you would use them indirectly via an <code>xscope_thread_carrier</code>, which is just a simple container for creating and managing a set of <code>xscope_thread</code>s.</p>
<h4 id="xscope_future_carrier">xscope_future_carrier</h4>
<p>Like <code>xscope_thread</code>, <code>xscope_future</code> and <code>xscope_async()</code> are the scope versions of their non-scope counterparts. And similarly, rather than using them directly you would more often use them via an <code>xscope_future_carrier</code>, which is just a simple container for creating and managing a set of <code>xscope_future</code>s and their associated <code>xscope_async()</code> functions.</p>
<h4 id="make_xscope_asyncsharedv2acoreadwrite">make_xscope_asyncsharedv2acoreadwrite()</h4>
<p>And finally, the function used to obtain a (scope) <a href="#tasyncsharedv2readwriteaccessrequester">access requester</a> to an access controlled scope object is <code>make_xscope_asyncsharedv2acoreadwrite()</code>. Note that it takes as its argument a scope pointer to the access controlled object, not a scope pointer to the contained object. Btw, scope access requesters are an example of an object type that can be passed to other scope threads, but does not qualify (i.e. would induce a compile error) to be passed to non-scope threads.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ctime&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ratio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;chrono&gt;</span>
<span class="pp">#include </span><span class="im">&lt;list&gt;</span>

<span class="kw">class</span> J {
<span class="kw">public</span>:
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TAsyncSharedReadWriteAccessRequester&gt;
    <span class="at">static</span> <span class="dt">double</span> foo7(_TAsyncSharedReadWriteAccessRequester A_ashar) {
        <span class="kw">auto</span> t1 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
        <span class="co">/* A_ashar.readlock_ptr() will block until it can obtain a read lock. */</span>
        <span class="kw">auto</span> ptr1 = A_ashar.readlock_ptr(); <span class="co">// while ptr1 exists it holds a (read) lock on the shared object</span>
        <span class="kw">auto</span> t2 = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>seconds(<span class="dv">1</span>));
        <span class="kw">auto</span> time_span = <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt;<span class="bu">std::</span>chrono<span class="bu">::</span>duration&lt;<span class="dt">double</span>&gt;&gt;(t2 - t1);
        <span class="kw">auto</span> timespan_in_seconds = time_span.count();
        <span class="kw">auto</span> thread_id = <span class="bu">std::</span>this_thread<span class="bu">::</span>get_id();
        <span class="co">//std::cout &lt;&lt; &quot;thread_id: &quot; &lt;&lt; thread_id &lt;&lt; &quot;, time to acquire read pointer: &quot; &lt;&lt; timespan_in_seconds &lt;&lt; &quot; seconds.&quot;;</span>
        <span class="co">//std::cout &lt;&lt; std::endl;</span>
        <span class="cf">return</span> timespan_in_seconds;
    }
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="co">/* Here we demonstrate safely sharing an existing stack allocated object among threads. */</span>

    <span class="kw">class</span> A {
    <span class="kw">public</span>:
        A(<span class="dt">int</span> x) : b(x) {}
        <span class="kw">virtual</span> ~A() {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
        mse::nii_string s = <span class="st">&quot;some text &quot;</span>;
    };
    <span class="co">/* User-defined classes need to be declared as (safely) shareable in order to be accepted by the access requesters. */</span>
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; ShareableA;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;: xscope_future_carrier&lt;&gt;&quot;</span>;
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;

    <span class="co">/* (Mutable) objects can be shared between threads only if they are &quot;access controlled&quot;. You can make an</span>
<span class="co">    object &quot;access controlled&quot; by wrapping its type with the mse::TXScopeAccessControlledObj&lt;&gt; template wrapper. */</span>
    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;ShareableA&gt; &gt; a_xscpacobj(<span class="dv">7</span>);

    <span class="co">/* Here we obtain a scope access requester for the access controlled object. */</span>
    <span class="kw">auto</span> xscope_access_requester = mse::make_xscope_asyncsharedv2acoreadwrite(&amp;a_xscpacobj);

    <span class="co">/* xscope_future_carrier&lt;&gt; is just a container that holds and manages scope futures. */</span>
    mse::xscope_future_carrier&lt;<span class="dt">double</span>&gt; xscope_futures;

    <span class="bu">std::</span>list&lt;mse::xscope_future_carrier&lt;<span class="dt">double</span>&gt;::<span class="dt">handle_t</span>&gt; future_handles;
    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i += <span class="dv">1</span>) {
        <span class="co">/* You add a future by specifying the async() function and parameters that will return the future value. */</span>
        <span class="kw">auto</span> handle = xscope_futures.new_future(J::foo7&lt;<span class="kw">decltype</span>(xscope_access_requester)&gt;, xscope_access_requester);

        <span class="co">/* You need to store the handle of the added future in order to later retrieve its value. */</span>
        future_handles.emplace_back(handle);
    }
    <span class="dt">int</span> count = <span class="dv">1</span>;
    <span class="cf">for</span> (<span class="kw">auto</span> it = future_handles.begin(); future_handles.end() != it; it++, count++) {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;thread: &quot;</span> &lt;&lt; count &lt;&lt; <span class="st">&quot;, time to acquire read pointer: &quot;</span> &lt;&lt; xscope_futures.xscope_ptr_at(*it)-&gt;get() &lt;&lt; <span class="st">&quot; seconds.&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
    }
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;
}</code></pre></div>
<h4 id="make_xscope_aco_locker_for_sharing">make_xscope_aco_locker_for_sharing()</h4>
<p>The <code>mse::make_xscope_aco_locker_for_sharing()</code> function takes a scope pointer to an &quot;<a href="#access-controlled-objects">access controlled object</a>&quot; and returns a &quot;locker&quot; object which holds an exclusive reference to the given access controlled object. From this locker object, you can obtain either one &quot;scope passable&quot; (non-const) pointer, or any number of &quot;scope passable&quot; const pointers. These scope passable pointers can then be safely passed directly as arguments to scope threads. This is a (little) more cumbersome, more restrictive way of sharing an object than, say, using the library's &quot;<a href="#make_xscope_asyncsharedv2acoreadwrite">access requesters</a>&quot;. But you might choose to do it this way in certain cases where performance is critical. When using access requesters, each thread obtains the desired lock on a thread-safe mutex. When using <code>mse::make_xscope_aco_locker_for_sharing()</code>, the lock is obtained before launching the thread(s), so the mutex does not need to be thread-safe, thus saving a little overhead.</p>
<h4 id="make_xscope_exclusive_strong_pointer_store_for_sharing">make_xscope_exclusive_strong_pointer_store_for_sharing()</h4>
<p>The <code>mse::make_xscope_exclusive_strong_pointer_store_for_sharing()</code> function returns the same kind of &quot;locker&quot; object that <code>mse::make_xscope_aco_locker_for_sharing()</code> does, but instead of taking a scope pointer to an &quot;access controlled object&quot;, it accepts any recognized &quot;exclusive&quot; pointer. That is, a pointer that, while it exists, holds exclusive access to its target object.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ratio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;chrono&gt;</span>

<span class="kw">class</span> J {
<span class="kw">public</span>:
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TAPointer&gt;
    <span class="at">static</span> <span class="dt">void</span> foo17b(_TAPointer a_ptr) {
        <span class="at">static</span> <span class="dt">int</span> <span class="va">s_count</span> = <span class="dv">0</span>;
        <span class="va">s_count</span> += <span class="dv">1</span>;
        a_ptr-&gt;s = <span class="bu">std::</span>to_string(<span class="va">s_count</span>);

        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
    }

    <span class="kw">template</span>&lt;<span class="kw">class</span> _TConstPointer, <span class="kw">class</span> _TPointer&gt;
    <span class="at">static</span> <span class="dt">void</span> foo18(_TConstPointer src_ptr, _TPointer dst_ptr) {
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
        dst_ptr-&gt;s = src_ptr-&gt;s;
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
    }
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="kw">class</span> A {
    <span class="kw">public</span>:
        A(<span class="dt">int</span> x) : b(x) {}
        <span class="kw">virtual</span> ~A() {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
        mse::nii_string s = <span class="st">&quot;some text &quot;</span>;
    };
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; ShareableA;

    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;ShareableA&gt; &gt; a_xscpacobj1(<span class="dv">3</span>);
    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;ShareableA&gt; &gt; a_xscpacobj2(<span class="dv">5</span>);
    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;ShareableA&gt; &gt; a_xscpacobj3(<span class="dv">7</span>);

    {
        <span class="kw">auto</span> xscope_aco_locker1 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj1);

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker1.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;
        mse::xscope_thread xscp_thread1(J::foo17b&lt;<span class="dt">passable_exclusive_pointer_t</span>&gt;, xscope_aco_locker1.xscope_passable_pointer());
    }
    {
        <span class="kw">auto</span> xscope_aco_locker1 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj1);
        <span class="kw">auto</span> xscope_aco_locker2 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj2);
        <span class="kw">auto</span> xscope_aco_locker3 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj3);

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker1.xscope_passable_const_pointer()) <span class="dt">passable_const_pointer_t</span>;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker2.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;

        mse::xscope_thread xscp_thread1(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_aco_locker1.xscope_passable_const_pointer()
            , xscope_aco_locker2.xscope_passable_pointer());

        mse::xscope_thread xscp_thread2(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_aco_locker1.xscope_passable_const_pointer()
            , xscope_aco_locker3.xscope_passable_pointer());
    }
    {
        <span class="kw">auto</span> xscope_aco_locker1 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj1);

        <span class="co">/* Here we&#39;re using a (non-const) &quot;xscope_passable_pointer&quot; as the argument. The &quot;const&quot; version</span>
<span class="co">        wouldn&#39;t be accepted because an &quot;xscope_passable_const_pointer&quot; is not an exclusive pointer. That is, </span>
<span class="co">        it doesn&#39;t hold exclusive access to its target object. We could, for example, have instead used an </span>
<span class="co">        exclusive pointer obtained directly from the &quot;access controlled&quot; object, a_xscpacobj1. */</span>

        <span class="kw">auto</span> xscope_xstrong_ptr_store1 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(xscope_aco_locker1.xscope_passable_pointer());

        <span class="kw">auto</span> xscope_aco_locker2 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj2);
        <span class="kw">auto</span> xscope_aco_locker3 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj3);

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker1.xscope_passable_const_pointer()) <span class="dt">passable_const_pointer_t</span>;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker2.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;

        mse::xscope_thread xscp_thread1(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_xstrong_ptr_store1.xscope_passable_const_pointer()
            , xscope_aco_locker2.xscope_passable_pointer());

        mse::xscope_thread xscp_thread2(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_xstrong_ptr_store1.xscope_passable_const_pointer()
            , xscope_aco_locker3.xscope_passable_pointer());
    }
}</code></pre></div>
<h4 id="txscopeexclusivestrongpointerstoreforaccesscontrol">TXScopeExclusiveStrongPointerStoreForAccessControl</h4>
<p>You can use <a href="#make_xscope_exclusive_strong_pointer_store_for_sharing"><code>make_xscope_exclusive_strong_pointer_store_for_sharing()</code></a> to obtain, from an exclusive pointer of, for example, an <a href="#access-controlled-objects">access controlled object</a>, pointers that can be passed to other threads. Occassionally, you may want to do the reverse. That is, obtain access controlled object pointers from an exclusive pointer that was passed to a thread. You can do this by declaring the parameter that receives the passed pointer as a <code>TXScopeExclusiveStrongPointerStoreForAccessControl&lt;passable_exclusive_pointer_t&gt;</code>, replacing <code>passable_exclusive_pointer_t</code> with the type of the passed pointer. From this parameter object you can obtain pointers in the same manner as with regular access controlled objects.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="kw">class</span> A {
    <span class="kw">public</span>:
        A(<span class="dt">int</span> x) : b(x) {}
        <span class="kw">virtual</span> ~A() {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
        mse::nii_string s = <span class="st">&quot;some text &quot;</span>;
    };
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; ShareableA;

    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;ShareableA&gt; &gt; a_xscpacobj1(<span class="dv">3</span>);

    {
        <span class="co">/* In this block we demonstrate obtaining various types of (const and non-const) pointers you might need from</span>
<span class="co">        an exclusive pointer that might be passed to a thread. */</span>

        a_xscpacobj1.pointer()-&gt;s = <span class="st">&quot;&quot;</span>;

        <span class="kw">auto</span> xscope_aco_locker1 = mse::make_xscope_aco_locker_for_sharing(&amp;a_xscpacobj1);

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker1.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_aco_locker1.xscope_passable_const_pointer()) <span class="dt">passable_const_pointer_t</span>;

        <span class="kw">class</span> CD {
        <span class="kw">public</span>:
            <span class="at">static</span> <span class="dt">void</span> foo1(mse::TXScopeExclusiveStrongPointerStoreForAccessControl&lt;<span class="dt">passable_exclusive_pointer_t</span>&gt; xscope_store, <span class="dt">int</span> count) {
                {
                    <span class="kw">auto</span> xsptr = xscope_store.xscope_pointer();
                    xsptr-&gt;s.append(<span class="bu">std::</span>to_string(count));
                }
                {
                    <span class="co">/* Here, from the exclusive (non-const) pointer passed to this function, we&#39;re going to obtain a couple</span>
<span class="co">                    of const pointers that we can pass to different (scope) threads. */</span>
                    <span class="kw">auto</span> xscope_xstrong_ptr_store1 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(xscope_store.xscope_exclusive_pointer());

                    mse::xscope_thread xscp_thread1(CD::foo2, xscope_xstrong_ptr_store1.xscope_passable_const_pointer());
                    mse::xscope_thread xscp_thread2(CD::foo2, xscope_xstrong_ptr_store1.xscope_passable_const_pointer());
                }
                <span class="cf">if</span> (<span class="dv">1</span> &lt;= count) {
                    <span class="co">/* And here we&#39;re going to (re)obtain an exclusive strong pointer like the one that was passed to this</span>
<span class="co">                    function, then we&#39;re going to use it to recursively call this function again in another (scope) thread. */</span>
                    <span class="kw">auto</span> xscope_xstrong_ptr_store1 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(xscope_store.xscope_exclusive_pointer());
                    mse::xscope_thread xscp_thread1(CD::foo1, xscope_xstrong_ptr_store1.xscope_passable_pointer(), count - <span class="dv">1</span>);
                }
            }
            <span class="at">static</span> <span class="dt">void</span> foo2(<span class="dt">passable_const_pointer_t</span> xscope_A_cptr) {
                <span class="bu">std::</span>cout &lt;&lt; xscope_A_cptr-&gt;s &lt;&lt; <span class="bu">std::</span>endl;
            }
        };

        mse::xscope_thread xscp_thread1(CD::foo1, xscope_aco_locker1.xscope_passable_pointer(), <span class="dv">3</span>);
    }
}</code></pre></div>
<h4 id="exclusive-writer-objects">exclusive writer objects</h4>
<p>&quot;Exclusive writer objects&quot; are a specialization of <a href="#access-controlled-objects">access controlled objects</a> for which all non-const pointers are exclusive. That is, when a non-const pointer of an exclusive writer object exists, no other pointer of that object may exist.</p>
<p>A bit of extra functionality that exclusive writer objects have over access controlled objects is that, from a const pointer of an exclusive writer object, you can obtain a const pointer that can be passed to other threads (using the <code>make_xscope_exclusive_write_obj_const_pointer_store_for_sharing()</code> function).</p>
<p><code>TXScopeExclusiveStrongPointerStoreForExclusiveWriterAccess&lt;&gt;</code> is the corresponding specialization of <a href="#txscopeexclusivestrongpointerstoreforaccesscontrol"><code>TXScopeExclusiveStrongPointerStoreForAccessControl&lt;&gt;</code></a>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ratio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;chrono&gt;</span>

<span class="kw">class</span> J {
<span class="kw">public</span>:
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TAPointer&gt;
    <span class="at">static</span> <span class="dt">void</span> foo17b(_TAPointer a_ptr) {
        <span class="at">static</span> <span class="dt">int</span> <span class="va">s_count</span> = <span class="dv">0</span>;
        <span class="va">s_count</span> += <span class="dv">1</span>;
        a_ptr-&gt;s = <span class="bu">std::</span>to_string(<span class="va">s_count</span>);

        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
    }

    <span class="kw">template</span>&lt;<span class="kw">class</span> _TConstPointer, <span class="kw">class</span> _TPointer&gt;
    <span class="at">static</span> <span class="dt">void</span> foo18(_TConstPointer src_ptr, _TPointer dst_ptr) {
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
        dst_ptr-&gt;s = src_ptr-&gt;s;
        <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
    }
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="kw">class</span> A {
    <span class="kw">public</span>:
        A(<span class="dt">int</span> x) : b(x) {}
        <span class="kw">virtual</span> ~A() {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
        mse::nii_string s = <span class="st">&quot;some text &quot;</span>;
    };
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; ShareableA;

    mse::TXScopeObj&lt;mse::TExclusiveWriterObj&lt;ShareableA&gt; &gt; a_xscpxwobj1(<span class="dv">3</span>);
    mse::TXScopeObj&lt;mse::TExclusiveWriterObj&lt;ShareableA&gt; &gt; a_xscpxwobj2(<span class="dv">5</span>);
    mse::TXScopeObj&lt;mse::TExclusiveWriterObj&lt;ShareableA&gt; &gt; a_xscpxwobj3(<span class="dv">7</span>);

    {
        <span class="co">/* A (non-const) pointer of an &quot;exclusive writer object&quot; qualifies as an &quot;exclusive strong&quot; pointer, and</span>
<span class="co">        thus you can obtain an xscope shareable pointer from it in the standard way. */</span>
        <span class="kw">auto</span> xscope_xwo_pointer_store1 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(a_xscpxwobj1.pointer());

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_xwo_pointer_store1.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;
        mse::xscope_thread xscp_thread1(J::foo17b&lt;<span class="dt">passable_exclusive_pointer_t</span>&gt;, xscope_xwo_pointer_store1.xscope_passable_pointer());
    }
    {
        <span class="co">/* But uniquely, you can obtain an xscope shareable const pointer from a (non-exclusive) const pointer of an</span>
<span class="co">        &quot;exclusive writer object&quot;. There is a special function for this purpose: */</span>
        <span class="kw">auto</span> xscope_xwo_const_pointer_store1 = mse::make_xscope_exclusive_write_obj_const_pointer_store_for_sharing(a_xscpxwobj1.const_pointer());

        <span class="kw">auto</span> xscope_xwo_pointer_store2 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(a_xscpxwobj2.pointer());
        <span class="kw">auto</span> xscope_xwo_pointer_store3 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(a_xscpxwobj3.pointer());

        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_xwo_const_pointer_store1.xscope_passable_const_pointer()) <span class="dt">passable_const_pointer_t</span>;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(xscope_xwo_pointer_store2.xscope_passable_pointer()) <span class="dt">passable_exclusive_pointer_t</span>;

        mse::xscope_thread xscp_thread1(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_xwo_const_pointer_store1.xscope_passable_const_pointer()
            , xscope_xwo_pointer_store2.xscope_passable_pointer());

        mse::xscope_thread xscp_thread2(J::foo18&lt;<span class="dt">passable_const_pointer_t</span>, <span class="dt">passable_exclusive_pointer_t</span>&gt;
            , xscope_xwo_const_pointer_store1.xscope_passable_const_pointer()
            , xscope_xwo_pointer_store3.xscope_passable_pointer());
    }
}</code></pre></div>
<h4 id="scope-atomics">scope atomics</h4>
<p>Atomic objects don't require access control.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescopeatomic.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;ratio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;chrono&gt;</span>


<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="co">/* trivially copyable class */</span>
    <span class="kw">class</span> D {
    <span class="kw">public</span>:
        D(<span class="dt">int</span> x) : b(x) {}

        <span class="dt">int</span> b = <span class="dv">3</span>;
    };
    <span class="co">/* User-defined classes need to be declared as (safely) shareable in order to be used with the atomic templates. */</span>
    <span class="kw">typedef</span> mse::us::TUserDeclaredAsyncShareableAndPassableObj&lt;D&gt; ShareableD;

    <span class="kw">class</span> B {
    <span class="kw">public</span>:
        <span class="at">static</span> <span class="dt">int</span> foo4(mse::TXScopeAtomicFixedPointer&lt;ShareableD&gt; xs_D_atomic_ptr) {
            <span class="kw">auto</span> d = (*xs_D_atomic_ptr).load();
            d.b += <span class="dv">1</span>;
            (*xs_D_atomic_ptr).store(d);
            <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(<span class="dv">10</span>));
            <span class="cf">return</span> (*xs_D_atomic_ptr).load().b;
        }
    };

    {
        <span class="co">/* For scenarios where the shared object is atomic, you can get away without using locks</span>
<span class="co">        or access requesters. */</span>

        mse::TXScopeAtomicObj&lt;ShareableD&gt; xscope_D_atomic_obj(<span class="dv">7</span>);
        <span class="dt">int</span> res1 = xscope_D_atomic_obj.load().b;

        <span class="kw">auto</span> xscope_D_atomic_ptr = &amp;xscope_D_atomic_obj;

        mse::xscope_thread xscp_thread1(B::foo4, xscope_D_atomic_ptr);
        mse::xscope_thread xscp_thread2(B::foo4, xscope_D_atomic_ptr);

        <span class="dt">int</span> res2 = (*xscope_D_atomic_ptr).load().b;
    }
}</code></pre></div>
<h4 id="txscopeacorasectionsplitter-and-txscopeasyncacorasectionsplitter">TXScopeACORASectionSplitter and TXScopeAsyncACORASectionSplitter</h4>
<p><code>TXScopeAsyncACORASectionSplitter&lt;&gt;</code> is the scope version of <a href="#tasyncrasectionsplitter"><code>TAsyncRASectionSplitter&lt;&gt;</code></a>, which enables multiple threads to safely access disjoint sections of an array or vector simultaneously. Instead of passing an access requester to its constructor, it takes a scope pointer to an existing <a href="#access-controlled-objects">access controlled</a> array or vector.</p>
<p>Where <code>TXScopeAsyncACORASectionSplitter&lt;&gt;</code> provides an <a href="#make_xscope_asyncsharedv2acoreadwrite">access requester</a> for each section, <code>TXScopeACORASectionSplitter&lt;&gt;</code> provides each section as an <a href="#access-controlled-objects">access controlled object</a>. From each of these access controlled sections, as with all access controlled objects, you can obtain pointers to them (using <a href="#make_xscope_aco_locker_for_sharing"><code>make_xscope_aco_locker_for_sharing()</code></a>, for example) that can be safely passed to other threads.</p>
<p>One reason you might choose to use <code>TXScopeACORASectionSplitter&lt;&gt;</code> over <code>TXScopeAsyncACORASectionSplitter&lt;&gt;</code> is that it does not involve any (costly) thread safe locks. The trade-off being that it doesn't support dynamically locking and unlocking sections (to maximize the availability of each section).</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsearray.h&quot;</span>

<span class="kw">class</span> J {
<span class="kw">public</span>:
    <span class="co">/* This function takes a &quot;random access section&quot; (which is like an &quot;array_view&quot; or gsl::span) as its parameter. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> _TStringRASection&gt;
    <span class="at">static</span> <span class="dt">void</span> foo8(_TStringRASection ra_section) {
        <span class="dt">size_t</span> delay_in_milliseconds = <span class="dv">3000</span><span class="co">/*arbitrary*/</span>;
        <span class="cf">if</span> (<span class="dv">1</span> &lt;= ra_section.size()) {
            delay_in_milliseconds /= mse::<span class="dt">as_a_size_t</span>(ra_section.size());
        }
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; ra_section.size(); i += <span class="dv">1</span>) {
            <span class="kw">auto</span> now1 = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now();
            <span class="kw">auto</span> tt = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>to_time_t(now1);

            <span class="co">/* Just trying to obtain a string with the current time and date. The standard library doesn&#39;t yet</span>
<span class="co">            seem to provide a safe, portable way to do this. */</span>
<span class="pp">#ifdef _MSC_VER</span>
            <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> buffer_size = <span class="dv">64</span>;
            <span class="dt">char</span> buffer[buffer_size];
            buffer[<span class="dv">0</span>] = <span class="st">&#39;</span><span class="sc">\0</span><span class="st">&#39;</span>;
            ctime_s(buffer, buffer_size, &amp;tt);
<span class="pp">#else </span><span class="co">/*_MSC_VER*/</span>
            <span class="kw">auto</span> buffer = ctime(&amp;tt);
<span class="pp">#endif </span><span class="co">/*_MSC_VER*/</span>

            <span class="bu">std::</span>string now_str(buffer);
            ra_section[i] = now_str;

            <span class="bu">std::</span>this_thread<span class="bu">::</span>sleep_for(<span class="bu">std::</span>chrono<span class="bu">::</span>milliseconds(delay_in_milliseconds));
        }
    }

    <span class="co">/* This function just obtains a writelock_ra_section from the given &quot;splitter access requester&quot; and calls the given</span>
<span class="co">    function with the writelock_ra_section as the first argument. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> TAsyncSplitterRASectionReadWriteAccessRequester, <span class="kw">class</span> TFunction, <span class="kw">class</span>... Args&gt;
    <span class="at">static</span> <span class="dt">void</span> invoke_with_writelock_ra_section1(TAsyncSplitterRASectionReadWriteAccessRequester ar, TFunction function1, Args&amp;&amp;... args) {
        function1(ar.writelock_ra_section(), args...);
    }

    <span class="co">/* This function just obtains an xscope_random_access_section from the given access controlled pointer and calls the given</span>
<span class="co">    function with the xscope_random_access_section as the first argument. */</span>
    <span class="kw">template</span>&lt;<span class="kw">class</span> Ty, <span class="kw">class</span> TFunction, <span class="kw">class</span>... Args&gt;
    <span class="at">static</span> <span class="dt">void</span> invoke_with_ra_section(mse::TXScopeExclusiveStrongPointerStoreForAccessControl&lt;Ty&gt; xs_ac_store, TFunction function1, Args&amp;&amp;... args) {
        <span class="kw">auto</span> xscope_ra_section = mse::make_xscope_random_access_section(xs_ac_store.xscope_pointer());
        function1(xscope_ra_section, args...);
    }
};

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    <span class="co">/* This block demonstrates safely allowing different threads to (simultaneously)</span>
<span class="co">    modify different sections of an existing vector declared as a local variable. */</span>

    <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> num_sections = <span class="dv">10</span>;
    <span class="at">static</span> <span class="at">const</span> <span class="dt">size_t</span> section_size = <span class="dv">5</span>;
    <span class="at">const</span> <span class="dt">size_t</span> num_elements = num_sections * section_size;

    <span class="kw">typedef</span> mse::nii_vector&lt;mse::nii_string&gt; <span class="dt">async_shareable_vector1_t</span>;
    <span class="kw">typedef</span> mse::mstd::vector&lt;mse::nii_string&gt; <span class="dt">nonshareable_vector1_t</span>;
    <span class="co">/* Let&#39;s say we have a vector. */</span>
    <span class="dt">nonshareable_vector1_t</span> vector1;
    vector1.resize(num_elements);
    {
        <span class="dt">size_t</span> count = <span class="dv">0</span>;
        <span class="cf">for</span> (<span class="kw">auto</span>&amp; item_ref : vector1) {
            count += <span class="dv">1</span>;
            item_ref = <span class="st">&quot;text&quot;</span> + <span class="bu">std::</span>to_string(count);
        }
    }

    <span class="co">/* Only access controlled objects can be shared with other threads, so we&#39;ll make an access controlled vector and</span>
<span class="co">    (temporarily) swap it with our original one. */</span>
    mse::TXScopeObj&lt;mse::TXScopeAccessControlledObj&lt;<span class="dt">async_shareable_vector1_t</span>&gt; &gt; xscope_acobj;
    <span class="bu">std::</span>swap(vector1, *(xscope_acobj.xscope_pointer()));

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mse::TXScopeACORASectionSplitter&lt;&gt;: &quot;</span> &lt;&lt; <span class="bu">std::</span>endl;

    {
        <span class="co">/* From the access controlled vector we&#39;re going to obtain scope pointers to two access controlled</span>
<span class="co">        &quot;random access section&quot; objects which are used to access (disjoint) sections of the vector. Then we&#39;re</span>
<span class="co">        going to use &quot;locker&quot; objects to obtain pointers that are designated as safe to pass to other threads.</span>
<span class="co">        We need to specify the position  where we want to split the vector. Here we specify that it be split</span>
<span class="co">        at index &quot;num_elements / 2&quot;, right down the middle. */</span>
        mse::TXScopeACORASectionSplitter&lt;<span class="dt">async_shareable_vector1_t</span>&gt; xscope_ra_section_split2(&amp;xscope_acobj, num_elements / <span class="dv">2</span>);

        <span class="co">/* Here we obtain scope pointers to the access controlled sections. */</span>
        <span class="kw">auto</span> first_ra_section_aco_xsptr = xscope_ra_section_split2.xscope_ptr_to_first_ra_section_aco();
        <span class="kw">auto</span> second_ra_section_aco_xsptr = xscope_ra_section_split2.xscope_ptr_to_second_ra_section_aco();

        <span class="co">/* Access controlled object pointers aren&#39;t themselves passable to other threads, but we can obtain</span>
<span class="co">        corresponding pointers that are passable via a &quot;locker&quot; object that takes exclusive control over</span>
<span class="co">        the access controlled object. */</span>
<span class="pp">#ifndef _MSC_VER</span>
        <span class="kw">auto</span> xscope_section_access_owner1 = mse::make_xscope_aco_locker_for_sharing(first_ra_section_aco_xsptr);
        <span class="kw">auto</span> xscope_section_access_owner2 = mse::make_xscope_aco_locker_for_sharing(second_ra_section_aco_xsptr);
<span class="pp">#else </span><span class="co">// !_MSC_VER</span>
        <span class="co">/* An apparent bug in msvc2017 and msvc2019preview (March 2019) prevents the other branch from compiling.</span>
<span class="co">        This presents an opportunity to demonstrate an alternative solution. Instead of a &quot;locker&quot; object that</span>
<span class="co">        takes a scope pointer to the access controlled object, we can use an &quot;exclusive strong pointer store&quot;</span>
<span class="co">        which takes any recognized exclusive pointer. */</span>
        <span class="kw">auto</span> xscope_section_access_owner1 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(
            (*first_ra_section_aco_xsptr).xscope_exclusive_pointer());
        <span class="kw">auto</span> xscope_section_access_owner2 = mse::make_xscope_exclusive_strong_pointer_store_for_sharing(
            (*second_ra_section_aco_xsptr).xscope_exclusive_pointer());
<span class="pp">#endif </span><span class="co">// !_MSC_VER</span>

        <span class="co">/* The J::foo8 template function is just an example function that operates on containers of strings. In this case the</span>
<span class="co">        containers will be the random access sections we just created. We&#39;ll create an instance of the function here. */</span>
        <span class="kw">auto</span> my_foo8_function = J::foo8&lt;mse::TXScopeAnyRandomAccessSection&lt;mse::nii_string&gt; &gt;;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(my_foo8_function) <span class="dt">my_foo8_function_type</span>;

        mse::xscope_thread_carrier threads;
        <span class="co">/* So this thread will modify the first section of the vector. */</span>
        threads.new_thread(J::invoke_with_ra_section&lt;<span class="kw">decltype</span>(xscope_section_access_owner1.xscope_passable_pointer()), <span class="dt">my_foo8_function_type</span>&gt;
            , xscope_section_access_owner1.xscope_passable_pointer(), my_foo8_function);
        <span class="co">/* While this thread modifies the other section. */</span>
        threads.new_thread(J::invoke_with_ra_section&lt;<span class="kw">decltype</span>(xscope_section_access_owner2.xscope_passable_pointer()), <span class="dt">my_foo8_function_type</span>&gt;
            , xscope_section_access_owner2.xscope_passable_pointer(), my_foo8_function);

        <span class="co">/* Note that in this particular scenario we didn&#39;t need to use any access requesters (or (thread safe) locks). */</span>
    }

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mse::TXScopeAsyncACORASectionSplitter&lt;&gt;: &quot;</span> &lt;&lt; <span class="bu">std::</span>endl;

    {
        <span class="co">/* Ok, now let&#39;s do it again, but instead of splitting the vector into two sections, let&#39;s split it into more sections: */</span>
        <span class="co">/* First we create a list of a the sizes of each section. We&#39;ll use a vector here, but any iteratable container will work. */</span>
        mse::mstd::vector&lt;<span class="dt">size_t</span>&gt; section_sizes;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; num_sections; i += <span class="dv">1</span>) {
            section_sizes.push_back(section_size);
        }

        <span class="co">/* This time (for demonstration purposes) we&#39;ll use TXScopeAsyncACORASectionSplitter&lt;&gt; to generate a new</span>
<span class="co">        access requester for each section. */</span>
        mse::TXScopeAsyncACORASectionSplitter&lt;<span class="dt">async_shareable_vector1_t</span>&gt; xscope_ra_section_split1(&amp;xscope_acobj, section_sizes);
        <span class="kw">auto</span> ar0 = xscope_ra_section_split1.ra_section_access_requester(<span class="dv">0</span>);

        <span class="kw">auto</span> my_foo8_function = J::foo8&lt;<span class="kw">decltype</span>(ar0.writelock_ra_section())&gt;;
        <span class="kw">typedef</span> <span class="kw">decltype</span>(my_foo8_function) <span class="dt">my_foo8_function_type</span>;
        <span class="kw">auto</span> my_foo8_proxy_function = J::invoke_with_writelock_ra_section1&lt;<span class="kw">decltype</span>(ar0), <span class="dt">my_foo8_function_type</span>&gt;;

        {
            mse::xscope_thread_carrier xscope_threads;
            <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; num_sections; i += <span class="dv">1</span>) {
                <span class="kw">auto</span> ar = xscope_ra_section_split1.ra_section_access_requester(i);
                xscope_threads.new_thread(my_foo8_proxy_function, ar, my_foo8_function);
            }
            <span class="co">/* The scope will not end until all the scope threads have finished executing. */</span>
        }
    }

    <span class="co">/* Now that we&#39;re done sharing the (controlled access) vector, we can swap it back to our original vector. */</span>
    <span class="bu">std::</span>swap(vector1, *(xscope_acobj.xscope_pointer()));
    <span class="kw">auto</span> first_element_value = vector1[<span class="dv">0</span>];
    <span class="kw">auto</span> last_element_value = vector1.back();
}</code></pre></div>
<h3 id="static-and-global-variables">static and global variables</h3>
<p>[<em>provisional</em>]</p>
<p>While not encouraging the use of <code>static</code> or (non-<a href="#thread_local"><code>thread_local</code></a>) global variables, the library does provide some facilities for their use. Note that because <code>static</code> and non-<code>thread_local</code> global variables can be accessible from multiple threads, their type must be one that is <a href="#tuserdeclaredasyncshareableobj">recognized or declared</a> as safely shareable.</p>
<h4 id="static-immutables">static immutables</h4>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msestaticimmutable.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

MSE_RSV_DECLARE_GLOBAL_IMMUTABLE(mse::nii_string) gimm_string1 = <span class="st">&quot;some text&quot;</span>;

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    {
        <span class="kw">auto</span> gimm_ptr1 = &amp;gimm_string1;
        <span class="kw">auto</span> xs_gimm_store1 = mse::make_xscope_strong_pointer_store(gimm_ptr1);
        <span class="kw">auto</span> xs_ptr1 = xs_gimm_store1.xscope_ptr();
        <span class="bu">std::</span>cout &lt;&lt; *xs_ptr1 &lt;&lt; <span class="bu">std::</span>endl;

        MSE_DECLARE_STATIC_IMMUTABLE(mse::nii_string) simm_string2 = <span class="st">&quot;abc&quot;</span>;
        <span class="kw">auto</span> simm_ptr2 = &amp;simm_string2;
        <span class="kw">auto</span> xs_simm_store2 = mse::make_xscope_strong_pointer_store(simm_ptr2);
        <span class="kw">auto</span> xs_ptr2 = xs_simm_store2.xscope_ptr();
        <span class="bu">std::</span>cout &lt;&lt; *xs_ptr2 &lt;&lt; <span class="bu">std::</span>endl;

        <span class="kw">class</span> CA {
        <span class="kw">public</span>:
            <span class="kw">auto</span> foo1() <span class="at">const</span> {
                MSE_DECLARE_STATIC_IMMUTABLE(mse::nii_string) simm_string = <span class="st">&quot;abc&quot;</span>;
                <span class="co">/* mse::return_value() just returns its argument and ensures that it&#39;s of a (pointer) type that&#39;s safe to return. */</span>
                <span class="cf">return</span> mse::return_value(&amp;simm_string);
            }
        };
        <span class="kw">auto</span> simm_ptr3 = CA().foo1();
        <span class="kw">auto</span> xs_simm_store3 = mse::make_xscope_strong_pointer_store(simm_ptr3);
        <span class="kw">auto</span> xs_cptr3 = xs_simm_store3.xscope_ptr();
        <span class="bu">std::</span>cout &lt;&lt; *xs_cptr3 &lt;&lt; <span class="bu">std::</span>endl;
    }
}</code></pre></div>
<p>Note that proper use of the <code>MSE_RSV_DECLARE_GLOBAL_IMMUTABLE()</code> macro is not currently fully enforced at compile-time. In debug builds any unsafe use will be caught at run-time. You can enable the run-time checking in non-debug builds by defining the <code>MSE_STATICIMMUTABLEPOINTER_RUNTIME_CHECKS_ENABLED</code> preprocessor symbol.</p>
<h4 id="static-atomics">static atomics</h4>
<p>Not yet available. Atomics declared <code>static</code> (or global) in traditional C++ should be fairly safe. Just make sure your object doesn't contain any indirect elements (i.e. pointers/references).</p>
<h4 id="static-access-controlled-objects-and-access-requesters">static access controlled objects and access requesters</h4>
<p>Not yet available. <a href="#tasyncsharedv2readwriteaccessrequester">Access requesters</a> declared <code>static</code> (or global) would be safe.</p>
<h3 id="primitives">Primitives</h3>
<h3 id="cint-csize_t-and-cbool">CInt, CSize_t and CBool</h3>
<p>These classes are meant to behave like, and be compatible with their native counterparts. In debug mode, they check for &quot;use before initialization&quot;, and in release mode, they use default initialization to help ensure deterministic behavior. Upon value assignment involving a narrowing conversion, <code>CInt</code> and <code>CSize_t</code> will check to ensure that the value fits within the type's range. They check for division by zero and <code>CSize_t</code>'s <code>-=</code> operator checks that the operation evaluates to a non-negative value. And unlike its native counterpart, arithmetic operations involving <code>CSize_t</code> that could evaluate to a negative number are returned as a (signed) <code>CInt</code>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mseprimitives.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        mse::CInt i = <span class="dv">5</span>;
        i -= <span class="dv">17</span>;
        mse::<span class="dt">CSize_t</span> szt = <span class="dv">5</span>;
        szt += <span class="dv">3</span>;
        <span class="kw">auto</span> i2 = szt + i;
        mse::CBool b = <span class="kw">false</span>;
        <span class="cf">if</span> (<span class="dv">-4</span> == i2) {
            b = <span class="kw">true</span>;
        }
        <span class="cf">if</span> (b) {
            <span class="cf">try</span> {
                szt -= <span class="dv">20</span>; <span class="co">// out of range result - this is going to throw an exception</span>
            }
            <span class="cf">catch</span> (...) {
                <span class="co">// expected exception</span>
            }
        }
    }</code></pre></div>
<p>Note that while <code>CInt</code> and <code>CSize_t</code> have no problem interacting with native signed integers, they do not implicitly play well with <code>size_t</code> or native unsigned integers. We'd be generally wary of using native unsigned integer types due to the (unintuitive) implicit conversion/promotion rules between signed and unsigned native integers. But if you need to obtain a <code>size_t</code> from a <code>CSize_t</code>, you can do so explicitly using the <code>mse::as_a_size_t()</code> function.</p>
<p>Btw, <code>CInt</code> is actually just an alias for a specific instantiation of the <code>TInt&lt;&gt;</code> template, which can be used to make a safe version of any given integer type. (Eg. <code>typedef mse::TInt&lt;signed char&gt; my_safe_small_int;</code>)</p>
<h3 id="cndint-cndsize_t-and-cndbool">CNDInt, CNDSize_t and CNDBool</h3>
<p><a href="#cint-csize_t-and-cbool"><code>CInt</code>, <code>CSize_t</code> and <code>CBool</code></a> are intended to be compatible replacements for their native counterparts, and in &quot;disabled&quot; mode they are just aliased to their corresponding native counterparts. There are however, some functional differences between these elements and their native counterparts. For example, they can be used as base classes where their (scalar) native counterparts cannot. So any code that relies on such additional properties might not work properly when the elements are substituted with their native counterparts.</p>
<p>So for those cases <code>CNDInt</code>, <code>CNDSize_t</code> and <code>CNDBool</code> are just versions that are not aliased to their native counterparts in &quot;disabled&quot; mode. In fact, when not in &quot;disabled&quot; mode, <code>CInt</code>, <code>CSize_t</code> and <code>CBool</code> are just aliases for <code>CNDInt</code>, <code>CNDSize_t</code> and <code>CNDBool</code>.</p>
<h3 id="quarantined-types">Quarantined types</h3>
<p>Quarantined types are meant to hold values that are obtained from user input or some other untrusted source (like a media file for example). These are not yet available in the library, but are an important concept with respect to safe programming. Values obtained from untrusted sources are the main attack vector of malicious actors and should be handled with special care. For example, the so-called &quot;stagefright&quot; vulnerability in the Android OS is the result of a specially crafted media file causing the sum of integers to overflow.</p>
<p>It is intended that these types will appropriately handle &quot;extreme&quot; values (at some run-time cost if necessary), and ensure that their values are in an appropriate range when converted to their (high-performance) native counterparts.</p>
<h3 id="cquarantinedint-cquarantinedsize_t-cquarantinedvector-cquarantinedstring">CQuarantinedInt, CQuarantinedSize_t, CQuarantinedVector, CQuarantinedString</h3>
<p>Not yet available.</p>
<p>Integer types with more comprehensive range checking can be found here: https://github.com/robertramey/safe_numerics.</p>
<h3 id="vectors">Vectors</h3>
<p>The library provides a number of vector types. Probably the two most essential are <a href="#vector"><code>mstd::vector&lt;&gt;</code></a> and <a href="#nii_vector"><code>nii_vector&lt;&gt;</code></a>. <code>mstd::vector&lt;&gt;</code> is simply a memory-safe drop-in replacement for <code>std::vector&lt;&gt;</code>. Due to their iterators, vectors are not, in general, safe to share among threads. <code>nii_vector&lt;&gt;</code> is designed for safe sharing among asynchronous threads.</p>
<p>The standard library vector iterators are designed so that they can be (unsafely) implemented as just pointers. But this makes them prone to being invalidated as a side effect of insertion, deletion and resize operations on the vector. This also means that they behave differently from list iterators, so algorithms that work on lists won't necessarily work on vectors. So the library includes <a href="#ivector"><code>ivector&lt;&gt;</code></a>, whose iterators behave like list iterators. That is, they don't get invalidated by insert/delete/resize vector operations unless the element they were pointing to is deleted, and after any such operation, they will continue to point to the same item, which may then be in a different position in the vector.</p>
<p>And finally, for those whose are willing to sacrifice some safety for performance there is <a href="#msevector"><code>us::msevector&lt;&gt;</code></a>. This vector is not memory-safe in the way that the other vectors are. It may be useful in cases where you want more control over the safety-performance trade-off. It supports a variety of iterator types - the traditional (unsafe) iterators, a bounds-checked version of the traditional iterator, and iterators that, like <code>ivector&lt;&gt;</code>'s iterators, behave like list iterators.</p>
<p>The vectors also support scope iterators which have the same syntax and behavior as the arrays' <a href="#xscope_iterator">scope iterators</a>. And remember that you can use <a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection"><code>TRandomAccessSection&lt;&gt;</code></a> to provide access to a subsection of any vector or array.</p>
<h3 id="vector">vector</h3>
<p><code>mstd::vector&lt;&gt;</code> is a memory-safe drop-in replacement for <code>std::vector&lt;&gt;</code>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    <span class="pp">#include </span><span class="im">&lt;vector&gt;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        mse::mstd::vector&lt;<span class="dt">int</span>&gt; mv;
        <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; sv;
        <span class="co">/* These two vectors should be completely interchangeable. The difference being that mv should throw</span>
<span class="co">        an exception on any attempt to access invalid memory. */</span>
        
        
        <span class="co">/* mse::us::msevector is not quite as safe as mse::mstd::vector in the following way: */</span>
        
        <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::iterator sv1_it;
        mse::us::msevector&lt;<span class="dt">int</span>&gt;::<span class="dt">ss_iterator_type</span> msev1_it; <span class="co">// bounds checked iterator just like mse::mstd::vector&lt;int&gt;::iterator</span>
        mse::mstd::vector&lt;<span class="dt">int</span>&gt;::iterator mv1_it;
        {
            <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; sv1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            sv1_it = sv1.begin();
            
            mse::us::msevector&lt;<span class="dt">int</span>&gt; msev1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            msev1_it = msev1.ss_begin();
            
            mse::mstd::vector&lt;<span class="dt">int</span>&gt; mv1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            mv1_it = mv1.begin();
        }
        
        <span class="co">// (*sv1_it) = 4; // not good</span>
        <span class="co">// (*msev1_it) = 4; // not good</span>
        
        <span class="cf">try</span> {
            <span class="co">/* At this point, mv1&#39;s data has not actually been deallocated/destructed yet because it &quot;knows&quot; that there</span>
<span class="co">        is an iterator, namely mv1_it, that is still referencing it. It will be deallocated when there are no more</span>
<span class="co">        iterators referencing it. */</span>
        
            (*mv1_it) = <span class="dv">4</span>; <span class="co">// In debug mode this will fail an assert. In non-debug mode it&#39;ll just work (safely). </span>
        } <span class="cf">catch</span>(...) {
            <span class="co">/* At present, no exception will be thrown. With future library implementations, maybe. */</span>
        }
    }</code></pre></div>
<h3 id="nii_vector">nii_vector</h3>
<p>Due to their iterators, vectors are not, in general, safe to share among threads. <code>nii_vector&lt;&gt;</code> is a &quot;stripped down&quot; vector that does not support &quot;implicit&quot; iterators, allowing it to be safely shareable between asynchronous threads. &quot;Explicit&quot; iterators are supported. That is, in order to obtain an iterator, you must explicitly provide a (safe) pointer to the <code>nii_vector&lt;&gt;</code>. So for example, instead of a <code>begin()</code> member function (that takes no parameters), you can obtain an iterator using the (generic) <code>make_begin_iterator(...)</code> function that takes as an argument a (safe) pointer to the vector.</p>
<p>Note that in cases when you only need the vector to be shared between threads part of the time, you can swap between, for example, (non-shareable) <code>mstd::vector&lt;&gt;</code>s and (shareable) <code>nii_vector&lt;&gt;</code>s when you need.</p>
<p>Also note that an <code>nii_vector&lt;&gt;</code> will be (automatically) marked as <a href="#asynchronously-shared-objects">safely shareable</a> only if its element type is known or declared to be safely shareable.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemsevector.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseregistered.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* nii_vector&lt;&gt; is a safe vector designed for safe sharing between asynchronous threads. */</span>
    
        <span class="kw">typedef</span> mse::nii_vector&lt;mse::nii_string&gt; <span class="dt">nii_vector1_t</span>;
    
        mse::TRegisteredObj&lt;<span class="dt">nii_vector1_t</span>&gt; rg_vo1;
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i += <span class="dv">1</span>) {
            rg_vo1.push_back(<span class="st">&quot;some text&quot;</span>);
        }
        mse::TRegisteredPointer&lt;<span class="dt">nii_vector1_t</span>&gt; vo1_regptr1 = &amp;rg_vo1;
    
        <span class="co">/* nii_vector&lt;&gt; does not have a begin() member function that returns an &quot;implicit&quot; iterator. You can obtain an</span>
<span class="co">        iterator using the make_begin_iterator() et al. functions, which take a (safe) pointer to the container. */</span>
        <span class="kw">auto</span> iter1 = mse::make_begin_iterator(vo1_regptr1);
        <span class="kw">auto</span> citer1 = mse::make_end_const_iterator(vo1_regptr1);
        citer1 = iter1;
        rg_vo1.emplace(citer1, <span class="st">&quot;some other text&quot;</span>);
        rg_vo1.insert(citer1, <span class="st">&quot;some other text&quot;</span>);
        mse::nii_string str1 = <span class="st">&quot;some other text&quot;</span>;
        rg_vo1.insert(citer1, str1);
    
        <span class="kw">class</span> A {
        <span class="kw">public</span>:
            A() {}
            <span class="dt">int</span> <span class="va">m_i</span>;
        };
        <span class="co">/* Here we&#39;re declaring that A can be safely shared between asynchronous threads. */</span>
        <span class="kw">typedef</span> mse::TUserDeclaredAsyncShareableAndPassableObj&lt;A&gt; <span class="dt">shareable_A_t</span>;
    
        <span class="co">/* When the element type of an nii_vector&lt;&gt; is marked as &quot;async shareable&quot;, the nii_vector&lt;&gt; itself is</span>
<span class="co">        (automatically) marked as async shareable as well and can be safely shared between asynchronous threads</span>
<span class="co">        using &quot;access requesters&quot;. */</span>
        <span class="kw">auto</span> access_requester1 = mse::make_asyncsharedv2readwrite&lt;mse::nii_vector&lt;<span class="dt">shareable_A_t</span>&gt;&gt;();
        <span class="kw">auto</span> access_requester2 = mse::make_asyncsharedv2readwrite&lt;<span class="dt">nii_vector1_t</span>&gt;();
    
        <span class="co">/* If the element type of an nii_vector&lt;&gt; is not marked as &quot;async shareable&quot;, then neither is the</span>
<span class="co">        nii_vector&lt;&gt; itself. So attempting to create an &quot;access requester&quot; using it would result in a compile</span>
<span class="co">        error. */</span>
        <span class="co">//auto access_requester3 = mse::make_asyncsharedv2readwrite&lt;mse::nii_vector&lt;A&gt;&gt;();</span>
        <span class="co">//auto access_requester4 = mse::make_asyncsharedv2readwrite&lt;mse::nii_vector&lt;mse::mstd::string&gt;&gt;();</span>
    
        <span class="kw">typedef</span> mse::mstd::vector&lt;mse::nii_string&gt; <span class="dt">vector1_t</span>;
        <span class="dt">vector1_t</span> vo2 = { <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span> };
        <span class="co">/* mstd::vector&lt;&gt;s, for example, are not safely shareable between threads. But if its element type is</span>
<span class="co">        safely shareable, then the contents of the mse::mstd::vector&lt;&gt;, can be swapped with a corresponding</span>
<span class="co">        shareable nii_vector&lt;&gt;. Note that vector swaps are intrinsically fast operations. */</span>
        vo2.swap(*(access_requester2.writelock_ptr()));
    }</code></pre></div>
<h3 id="msevector">msevector</h3>
<p><code>us::msevector&lt;&gt;</code> is not memory-safe in the way that the other vectors are. It can be used in cases where you want more control over the safety-performance trade-off.</p>
<p>In addition to the (high performance) standard vector iterator, <code>us::msevector&lt;&gt;</code> also supports a new kind of iterator, called <code>ipointer</code>, that acts more like a list iterator in the sense that it points to an item rather than a position, and like a list iterator, it is not invalidated by insertions or deletions occurring elsewhere in the container, even if a &quot;reallocation&quot; occurs. Algorithms that work when applied to list iterators will work when applied to ipointers. This can be useful as Bjarne famously <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">points out</a>, for cache-coherency reasons, in most cases vectors should be used in place of lists, even when lists are conceptually more appropriate. You can read a short article comparing ipointers with some existing alternatives <a href="http://www.codeproject.com/Articles/1087021/Stable-Iterators-for-Cplusplus-Vectors-and-Why-You">here</a>.</p>
<p><code>us::msevector&lt;&gt;</code> also provides a safer bounds-checked version of the standard vector iterator. Note that none of these iterators are safe against the situation where the vector is deleted before an iterator is finished using it.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemsevector.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        
        mse::us::msevector&lt;<span class="dt">int</span>&gt; v1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
        mse::us::msevector&lt;<span class="dt">int</span>&gt; v = v1;
        {
            mse::us::msevector&lt;<span class="dt">int</span>&gt;::ipointer ip1 = v.ibegin();
            ip1 += <span class="dv">2</span>;
            assert(<span class="dv">3</span> == (*ip1));
            <span class="kw">auto</span> ip2 = v.ibegin(); <span class="co">/* ibegin() returns an ipointer */</span>
            v.erase(ip2); <span class="co">/* remove the first item */</span>
            assert(<span class="dv">3</span> == (*ip1)); <span class="co">/* ip1 continues to point to the same item, not the same position */</span>
            ip1--;
            assert(<span class="dv">2</span> == (*ip1));
            <span class="cf">for</span> (mse::us::msevector&lt;<span class="dt">int</span>&gt;::cipointer cip = v.cibegin(); v.ciend() != cip; cip++) {
                <span class="co">/* You might imagine what would happen if cip were a regular vector iterator. */</span>
                v.insert(v.ibegin(), (*cip));
            }
        }
        v = v1;
        {
            <span class="co">/* This code block is equivalent to the previous code block, but uses ipointer&#39;s more &quot;readable&quot; interface</span>
<span class="co">            that might make the code a little more clear to those less familiar with C++ syntax. */</span>
            mse::us::msevector&lt;<span class="dt">int</span>&gt;::ipointer ip_vit1 = v.ibegin();
            ip_vit1.advance(<span class="dv">2</span>);
            assert(<span class="dv">3</span> == ip_vit1.item());
            <span class="kw">auto</span> ip_vit2 = v.ibegin();
            v.erase(ip_vit2);
            assert(<span class="dv">3</span> == ip_vit1.item());
            ip_vit1.set_to_previous();
            assert(<span class="dv">2</span> == ip_vit1.item());
            mse::us::msevector&lt;<span class="dt">int</span>&gt;::cipointer cip(v);
            <span class="cf">for</span> (cip.set_to_beginning(); cip.points_to_an_item(); cip.set_to_next()) {
                v.insert_before(v.ibegin(), (*cip));
            }
        }
    
        <span class="co">/* Btw, ipointers are compatible with stl algorithms, like any other stl iterators. */</span>
        <span class="bu">std::</span>sort(v.ibegin(), v.iend());
    
        <span class="co">/* And just to be clear, mse::us::msevector&lt;&gt; retains its original (high performance) stl vector iterators. */</span>
        <span class="bu">std::</span>sort(v.begin(), v.end());
    
        <span class="co">/* mse::us::msevector&lt;&gt; also provides &quot;safe&quot; (bounds checked) versions of the original stl vector iterators. */</span>
        <span class="bu">std::</span>sort(v.ss_begin(), v.ss_end());
    }</code></pre></div>
<p><code>ipointer</code>s support all the standard iterator operators, but also have member functions with &quot;friendlier&quot; names including:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">bool</span> points_to_an_item() <span class="at">const</span>;
    <span class="dt">bool</span> points_to_end_marker() <span class="at">const</span>;
    <span class="dt">bool</span> points_to_beginning() <span class="at">const</span>;
    <span class="co">/* has_next_item_or_end_marker() is just an alias for points_to_an_item(). */</span>
    <span class="dt">bool</span> has_next_item_or_end_marker() <span class="at">const</span>;
    <span class="co">/* has_next() is just an alias for points_to_an_item() that may be familiar to java programmers. */</span>
    <span class="dt">bool</span> has_next() <span class="at">const</span>;
    <span class="dt">bool</span> has_previous() <span class="at">const</span>;
    <span class="dt">void</span> set_to_beginning();
    <span class="dt">void</span> set_to_end_marker();
    <span class="dt">void</span> set_to_next();
    <span class="dt">void</span> set_to_previous();
    <span class="dt">void</span> advance(<span class="dt">difference_type</span> n);
    <span class="dt">void</span> regress(<span class="dt">difference_type</span> n);
    reference item() <span class="at">const</span> { <span class="cf">return</span> <span class="kw">operator</span>*(); }
    reference previous_item() <span class="at">const</span>;
    <span class="dt">CSize_t</span> position() <span class="at">const</span>;
    <span class="dt">void</span> reset();</code></pre></div>
<h3 id="ivector">ivector</h3>
<p><code>ivector&lt;&gt;</code> is for cases when safety and correctness are higher priorities than compatibility and performance. <code>ivector&lt;&gt;</code> drops support for the (problematic) standard vector iterator, replacing it with <a href="#msevector"><code>ipointer</code></a>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;mseivector.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        mse::ivector&lt;<span class="dt">int</span>&gt; iv = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
        <span class="bu">std::</span>sort(iv.begin(), iv.end());
        mse::ivector&lt;<span class="dt">int</span>&gt;::ipointer ivip = iv.begin();
    }</code></pre></div>
<h3 id="make_xscope_vector_size_change_lock_guard">make_xscope_vector_size_change_lock_guard()</h3>
<p>The <code>make_xscope_vector_size_change_lock_guard()</code> function is used, indirectly, to obtain a scope pointer to a vector element. The challenge with scope pointers to vector elements is that any operation that resizes or increases the capacity of the vector could cause the scope pointer to become invalid. So before obtaining a scope pointer, the vector needs to be &quot;locked&quot; to ensure that no such operation occurs. To this end, you can use the <code>make_xscope_vector_size_change_lock_guard()</code> function to create an <code>xscope_structure_change_lock_guard</code> object. You can obtain scope pointers to elements in the corresponding vector via its <code>xscope_ptr_to_element()</code> member function. While the object exists, any attempt to execute an operation that would cause the size of the vector to change (or capacity to increase) will cause an exception. All the library's vectors (<code>mstd::vector&lt;&gt;</code>, <code>nii_vector&lt;&gt;</code>, <code>ivector&lt;&gt;</code> and <code>us::msevector&lt;&gt;</code>) can be locked, though when locking <code>nii_vector&lt;&gt;</code>s via scope pointers, the supplied pointer must be non-const.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* Here we&#39;re declaring an vector as a scope object. */</span>
        mse::TXScopeObj&lt;mse::mstd::vector&lt;<span class="dt">int</span>&gt;&gt; vector1_scpobj = mse::mstd::vector&lt;<span class="dt">int</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
        
        {
            <span class="co">/* In order to obtain a direct scope pointer to a vector element, you first need to instantiate a &quot;structure lock&quot;</span>
<span class="co">            object, which &quot;locks&quot; the vector to ensure that no resize (or reserve) operation that might cause a scope pointer</span>
<span class="co">            to become invalid is performed. */</span>
            <span class="kw">auto</span> xscp_vector1_change_lock_guard = mse::mstd::make_xscope_vector_size_change_lock_guard(&amp;vector1_scpobj);
            <span class="kw">auto</span> scp_ptr1 = xscp_vector1_change_lock_guard.xscope_ptr_to_element(<span class="dv">2</span>);
            <span class="kw">auto</span> res4 = *scp_ptr1;
        }
        <span class="co">// the vector is no longer &quot;size change locked&quot;</span>
        vector1_scpobj.push_back(<span class="dv">4</span>);
    }</code></pre></div>
<p>The reason you can't lock an <code>nii_vector&lt;&gt;</code> via a scope const pointer, is that locking a vector via scope pointer is an operation that actually modifies the vector, and since <code>nii_vector&lt;&gt;</code>s can be shared among threads, it would not be safe to modify it when simultaneous reads could be occurring. There are a couple of ways to work around this restriction. First, if you make the <code>nii_vector&lt;&gt;</code> an &quot;<a href="#exclusive-writer-objects">exclusive writer object</a>&quot;, then you can lock the <code>nii_vector&lt;&gt;</code> via an &quot;exclusive writer&quot; const pointer (an operation which doesn't require modifying the vector), like so:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsevector.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* Unfortunately, you cannot obtain a direct scope const pointer to an nii_vector&lt;&gt; element from a scope const</span>
<span class="co">        pointer to the nii_vector&lt;&gt;. (nii_vector&lt;&gt; is the only one of the library&#39;s vectors that has this shortcoming.)</span>
<span class="co">        However, for vectors that are access controlled with an &quot;exclusive writer&quot; access policy, you can use an</span>
<span class="co">        &quot;exclusive writer&quot; const pointer to obtain a direct scope const pointer to a vector element. */</span>
    
        mse::TXScopeObj&lt;mse::TExclusiveWriterObj&lt;mse::nii_vector&lt;<span class="dt">int</span>&gt; &gt; &gt; vector2_ewxsobj = mse::nii_vector&lt;<span class="dt">int</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
        {
            <span class="kw">auto</span> xxscp_vector1_change_lock_guard = mse::make_xscope_vector_size_change_lock_guard(vector2_ewxsobj.const_pointer());
            <span class="kw">auto</span> xscp_ptr1 = xxscp_vector1_change_lock_guard.xscope_ptr_to_element(<span class="dv">2</span>);
            <span class="kw">auto</span> res4 = *xscp_ptr1;
        }
        vector2_ewxsobj.pointer()-&gt;push_back(<span class="dv">4</span>);
    }</code></pre></div>
<p>If you're not sharing the vector among threads, you can instead use</p>
<h3 id="stnii_vector">stnii_vector</h3>
<p><code>stnii_vector&lt;&gt;</code> is simply a version of <code>nii_vector&lt;&gt;</code> that supports being locked via scope const pointer, but is not eligible to be shared among threads. The reason you might use <code>stnii_vector&lt;&gt;</code> instead of <code>mstd::vector&lt;&gt;</code> is that <code>stnii_vector&lt;&gt;</code> has less overhead.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsevector.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* stnii_vector&lt;&gt; is just a version of nii_vector&lt;&gt; that is not eligible to be shared between threads. */</span>

        mse::TXScopeObj&lt;mse::stnii_vector&lt;<span class="dt">int</span>&gt; &gt; vector1_xscpobj = mse::stnii_vector&lt;<span class="dt">int</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };

        {
            <span class="co">/* The only advantage stnii_vector&lt;&gt; has over nii_vector&lt;&gt; is that you can obtain (const) scope</span>
<span class="co">            pointers to its elements from a const scope pointer to vector (whereas with nii_vector&lt;&gt; the pointer</span>
<span class="co">            must be non-const). */</span>
            mse::TXScopeItemFixedConstPointer&lt;mse::stnii_vector&lt;<span class="dt">int</span>&gt; &gt; xscptr = &amp;vector1_xscpobj;
            <span class="kw">auto</span> xxscp_vector1_change_lock_guard = mse::make_xscope_vector_size_change_lock_guard(xscptr);
            <span class="kw">auto</span> xscp_ptr1 = xxscp_vector1_change_lock_guard.xscope_ptr_to_element(<span class="dv">2</span>);
            <span class="kw">auto</span> res4 = *xscp_ptr1;
        }
        vector1_xscpobj.push_back(<span class="dv">4</span>);

        <span class="co">/* And of course stnii_vector&lt;&gt;s can be (efficiently) swapped with nii_vector&lt;&gt;s. */</span>
        <span class="kw">auto</span> niiv1 = mse::nii_vector&lt;<span class="dt">int</span>&gt;();
        <span class="bu">std::</span>swap(vector1_xscpobj, niiv1);
        <span class="co">/* Or mstd::vector&lt;&gt;s. */</span>
        <span class="kw">auto</span> mstdv1 = mse::mstd::vector&lt;<span class="dt">int</span>&gt;();
        <span class="bu">std::</span>swap(vector1_xscpobj, mstdv1);
    }</code></pre></div>
<h3 id="mtnii_vector">mtnii_vector</h3>
<p>Like <code>stnii_vector&lt;&gt;</code>, <code>mtnii_vector&lt;&gt;</code> is a version of <code>nii_vector&lt;&gt;</code> that supports being locked via scope const pointer, but unlike <code>stnii_vector&lt;&gt;</code>, <code>mtnii_vector&lt;&gt;</code> is eligible to be shared among threads. To safely accomplish this, <code>mtnii_vector&lt;&gt;</code> has a thread safe / atomic locking mechanism that adds a little bit of overhead to operations that modify the size or capacity of the vector.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsevector.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;mseasyncshared.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* mtnii_vector&lt;&gt; is just a version of nii_vector&lt;&gt; that supports obtaining scope pointers to its elements from</span>
<span class="co">        const scope pointers to the vector. Unlike stnii_vector&lt;&gt;, mtnii_vector&lt;&gt; is eligible to be shared among threads.</span>
<span class="co">        This requires a (partially) thread safe mutex that adds a little bit of overhead to operations that modify the</span>
<span class="co">        size/structure of the vector. */</span>

        <span class="kw">typedef</span> mse::mtnii_vector&lt;mse::nii_string&gt; <span class="dt">mtnii_vector1_t</span>;
        <span class="kw">auto</span> access_requester1 = mse::make_asyncsharedv2readwrite&lt;<span class="dt">mtnii_vector1_t</span>&gt;(<span class="dt">mtnii_vector1_t</span>{ <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span> });

        {
            <span class="co">/* Here we&#39;re obtaining a scope const pointer to the vector from a readlock pointer to the vector. */</span>
            <span class="kw">auto</span> xs_strong_pointer_store = mse::make_xscope_strong_pointer_store(access_requester1.readlock_ptr());
            <span class="kw">auto</span> vector_xscope_const_ptr = xs_strong_pointer_store.xscope_ptr();

            <span class="co">/* The only advantage mtnii_vector&lt;&gt; has over nii_vector&lt;&gt; is that you can obtain (const) scope</span>
<span class="co">            pointers to its elements from a const scope pointer to vector (whereas with nii_vector&lt;&gt; the pointer</span>
<span class="co">            must be non-const). */</span>
            <span class="kw">auto</span> xs_size_change_lock_guard = mse::make_xscope_vector_size_change_lock_guard(vector_xscope_const_ptr);
            <span class="kw">auto</span> element1_xscope_const_ptr = xs_size_change_lock_guard.xscope_ptr_to_element(<span class="dv">1</span>);

            assert((*element1_xscope_const_ptr) == <span class="st">&quot;def&quot;</span>);
        }

        <span class="co">/* And of course stnii_vector&lt;&gt;s can be (efficiently) swapped with nii_vector&lt;&gt;s. */</span>
        <span class="kw">auto</span> niiv1 = mse::nii_vector&lt;mse::nii_string&gt;();
        <span class="bu">std::</span>swap(*(access_requester1.writelock_ptr()), niiv1);
        <span class="co">/* Or mstd::vector&lt;&gt;s. */</span>
        <span class="kw">auto</span> mstdv1 = mse::mstd::vector&lt;mse::nii_string&gt;();
        <span class="bu">std::</span>swap(*(access_requester1.writelock_ptr()), mstdv1);
    }</code></pre></div>
<h3 id="arrays">Arrays</h3>
<p>The library provides a few array types - <a href="#array"><code>mstd::array&lt;&gt;</code></a>, <a href="#nii_array"><code>nii_array&lt;&gt;</code></a> and <a href="#msearray"><code>us::msearray&lt;&gt;</code></a> - which have properties similar to their corresponding <a href="#vectors">vector</a> types. <code>mstd::array&lt;&gt;</code> is simply a memory-safe drop-in replacement for <code>std::array&lt;&gt;</code>. <code>nii_array&lt;&gt;</code> is designed to be safely shared between asynchronous threads. And <code>us::msearray&lt;&gt;</code> is not memory-safe in the way the other arrays are, and is provided for cases where more control over the safety-performance trade-off is desired.</p>
<p>Note that these arrays currently do not support using <a href="#scope-pointers">scope</a> types as the element type even when the array itself is declared as a scope object. It's expected that this will be supported in the future. The (few) cases where this would be an issue is when you want the element type to be a scope pointer or a type with scope pointer members. In those cases, you might use registered and/or refcounting pointers instead.</p>
<p>And remember that you can use <a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection"><code>TRandomAccessSection&lt;&gt;</code></a> to provide access to a subsection of any vector or array.</p>
<h3 id="array">array</h3>
<p><code>mstd::array&lt;&gt;</code> is a memory-safe drop-in replacement for <code>std::array&lt;&gt;</code>. Note that the current implementation requires &quot;<code>mseregistered.h</code>&quot;.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemsearray.h&quot;</span>
    <span class="pp">#include </span><span class="im">&lt;array&gt;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; ma;
        <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; sa;
        <span class="co">/* These two arrays should be completely interchangeable. The difference being that ma should throw</span>
<span class="co">        an exception on any attempt to access invalid memory. */</span>
    
    
        <span class="co">/* mse::msearray is not quite as safe as mse::mstd::array in the following way: */</span>
    
        <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;::iterator sa1_it;
        mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;::<span class="dt">ss_iterator_type</span> msea1_it; <span class="co">// bounds checked iterator just like mse::mstd::array::iterator</span>
        mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;::iterator ma1_it;
        {
            <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; sa1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            sa1_it = sa1.begin();
    
            mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; msea1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            msea1_it = msea1.ss_begin();
    
            mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; ma1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            ma1_it = ma1.begin();
        }
    
        <span class="co">// (*sa1_it) = 4; // not good - undefined behavior</span>
        <span class="co">// (*msea1_it) = 4; // not good - undefined behavior</span>
    
        <span class="cf">try</span> {
            (*ma1_it) = <span class="dv">4</span>; <span class="co">// not undefined behavior - will throw an exception</span>
        } <span class="cf">catch</span>(...) {
            <span class="co">// expected exception</span>
        }
    }</code></pre></div>
<h3 id="nii_array">nii_array</h3>
<p><code>nii_array&lt;&gt;</code> is just the corresponding array version of <a href="#nii_vector"><code>nii_vector&lt;&gt;</code></a>. It is designed such that it can be safely shared between asynchronous threads.</p>
<h3 id="msearray">msearray</h3>
<p><code>us::msearray&lt;&gt;</code>, like <code>us::msevector&lt;&gt;</code>, is not memory-safe in the way that the other arrays are. And like <code>us::msevector&lt;&gt;</code>, <code>us::msearray&lt;&gt;</code> provides a safer iterator, in addition to the (high performance) standard iterator. Like <code>us::msevector&lt;&gt;</code>, <code>us::msearray&lt;&gt;</code>'s safe iterator also supports the more &quot;readable&quot; interface. In cases where the msearray is declared as a scope object, you can also use a &quot;scope&quot; version of the safe iterator. The restrictions on when and how scope iterators can be used ensure that they won't be used to access the array after it's been deallocated.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemsearray.h&quot;</span>
    <span class="pp">#include </span><span class="im">&lt;array&gt;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; a1 = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
        mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; a2 = { <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span> };
        
        <span class="co">//bool bres1 = (a1.begin() == a2.end());</span>
        <span class="co">/* The previous commented out line would result in &quot;undefined behavior. */</span>
        
        <span class="cf">try</span> {
            <span class="co">/* The behavior of the next line is not &quot;undefined&quot;. It&#39;s going to throw an exception. */</span>
            <span class="dt">bool</span> bres2 = (a1.ss_begin() == a2.ss_end());
        }
        <span class="cf">catch</span> (...) {
            <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;expected exception&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;
        }
        
        <span class="kw">auto</span> ss_cit1 = a1.ss_cbegin();
        <span class="co">/* These safe iterators support traditional and &quot;friendly&quot; iterator operation syntax. */</span>
        ss_cit1++;
        ss_cit1.set_to_next(); <span class="co">/*same as previous line*/</span>
        ss_cit1.set_to_beginning();
        <span class="dt">bool</span> bres3 = ss_cit1.has_previous();
        ss_cit1.set_to_end_marker();
        <span class="dt">bool</span> bres4 = ss_cit1.points_to_an_item();
    
        {
            <span class="co">/* A &quot;scope&quot; version of the safe iterators can be used when the array is declared as a scope</span>
<span class="co">            object. There are limitations on when thay can be used, but unlike the other msearray iterators,</span>
<span class="co">            those restrictions ensure that they won&#39;t be used to access the array after it&#39;s been deallocated. */</span>
            
            mse::TXScopeObj&lt;mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;&gt; array1_scpobj = mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
            
            <span class="kw">auto</span> scp_ss_iter1 = mse::make_xscope_begin_iterator(&amp;array1_scpobj);
            <span class="kw">auto</span> scp_ss_iter2 = mse::make_xscope_end_iterator(&amp;array1_scpobj);
            
            <span class="bu">std::</span>sort(scp_ss_iter1, scp_ss_iter2);
            
            <span class="kw">auto</span> scp_ss_citer3 = mse::make_xscope_begin_const_iterator(&amp;array1_scpobj);
            scp_ss_citer3 = scp_ss_iter1;
            scp_ss_citer3 = mse::make_xscope_begin_const_iterator(&amp;array1_scpobj);
            scp_ss_citer3 += <span class="dv">2</span>;
            <span class="kw">auto</span> res1 = *scp_ss_citer3;
            <span class="kw">auto</span> res2 = scp_ss_citer3[<span class="dv">0</span>];
            
            <span class="co">/* Here we demonstrate the case where the array is a member of a class/struct declared as a</span>
<span class="co">            scope object. */</span>
            <span class="kw">class</span> CContainer1 {
            <span class="kw">public</span>:
                CContainer1() : <span class="va">m_array</span>({ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> }) {}
                
                mse::us::msearray&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; <span class="va">m_array</span>;
            };
            mse::TXScopeObj&lt;CContainer1&gt; container1_scpobj;
            <span class="kw">auto</span> container1_m_array_scpptr = mse::make_xscope_pointer_to_member_v2(&amp;container1_scpobj, &amp;CContainer1::<span class="va">m_array</span>);
            <span class="kw">auto</span> scp_ss_citer4 = mse::make_xscope_begin_iterator(container1_m_array_scpptr);
            scp_ss_citer4++;
            <span class="kw">auto</span> res3 = *scp_ss_citer4;
        }
    }</code></pre></div>
<h3 id="xscope_iterator">xscope_iterator</h3>
<p>The implementation of, for example, <code>mstd::array&lt;&gt;</code> iterators uses <a href="#registered-pointers">registered pointers</a> to ensure that iterators are not used to access array elements after the array has been deallocated. This incurs a slight run-time cost. So just as the library provides <a href="#scope-pointers">scope pointers</a> without run-time cost, scope iterators for arrays are also provided. Scope iterators have usage restrictions similar to scope pointers. For example, they can only target arrays declared as scope objects, and may not be used as a member of any class or struct that is not itself a scope object, and may not be used as a function return value. <code>mstd::array&lt;&gt;</code>, <code>nii_array&lt;&gt;</code> and <code>us::msearray&lt;&gt;</code> all support scope iterators.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        <span class="co">/* If the array is declared as a &quot;scope&quot; object (which basically indicates that it is declared</span>
<span class="co">        on the stack), then you can use &quot;scope&quot; iterators. While there are limitations on when they can</span>
<span class="co">        be used, scope iterators would be the preferred iterator type where performance is a priority</span>
<span class="co">        as they don&#39;t require extra run time overhead to ensure that the array has not been deallocated. */</span>
        
        <span class="co">/* Here we&#39;re declaring an array as a scope object. */</span>
        mse::TXScopeObj&lt;mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;&gt; array1_scpobj = mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
        
        <span class="co">/* Here we&#39;re obtaining a scope iterator to the array. */</span>
        <span class="kw">auto</span> scp_array_iter1 = mse::mstd::make_xscope_begin_iterator(&amp;array1_scpobj);
        <span class="kw">auto</span> scp_array_iter2 = mse::mstd::make_xscope_end_iterator(&amp;array1_scpobj);
        
        <span class="bu">std::</span>sort(scp_array_iter1, scp_array_iter2);
        
        <span class="kw">auto</span> scp_array_citer3 = mse::mstd::make_xscope_begin_const_iterator(&amp;array1_scpobj);
        scp_array_citer3 = scp_array_iter1;
        scp_array_citer3 = mse::mstd::make_xscope_begin_const_iterator(&amp;array1_scpobj);
        scp_array_citer3 += <span class="dv">2</span>;
        <span class="kw">auto</span> res1 = *scp_array_citer3;
        <span class="kw">auto</span> res2 = scp_array_citer3[<span class="dv">0</span>];
        
        <span class="co">/* Here we demonstrate the case where the array is a member of a class/struct declared as a</span>
<span class="co">        scope object. */</span>
        <span class="kw">class</span> CContainer1 {
        <span class="kw">public</span>:
            CContainer1() : <span class="va">m_vector</span>({ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> }) {}
            mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; <span class="va">m_array</span>;
        };
        mse::TXScopeObj&lt;CContainer1&gt; container1_scpobj;
        <span class="kw">auto</span> container1_m_array_scpptr = mse::make_xscope_pointer_to_member_v2(&amp;container1_scpobj, &amp;CContainer1::<span class="va">m_array</span>);
        <span class="kw">auto</span> scp_iter4 = mse::mstd::make_xscope_begin_iterator(container1_m_array_scpptr);
        scp_iter4++;
        <span class="kw">auto</span> res3 = *scp_iter4;
    }</code></pre></div>
<h3 id="xscope_pointer_to_array_element">xscope_pointer_to_array_element()</h3>
<p>You can use this function to obtain a scope pointer to an array element. You can pass it ethier an xscope_iterator or a scope pointer to an array and an index. <code>mstd::array&lt;&gt;</code>, <code>nii_array&lt;&gt;</code> and <code>us::msearray&lt;&gt;</code> are supported.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* Here we&#39;re declaring an array as a scope object. */</span>
        mse::TXScopeObj&lt;mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;&gt; array1_scpobj = mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
        
        <span class="co">/* Here we&#39;re obtaining a scope iterator to the array. */</span>
        <span class="kw">auto</span> scp_array_iter1 = mse::mstd::make_xscope_begin_iterator(&amp;array1_scpobj);
        
        <span class="co">/* You can also obtain a corresponding scope pointer from a scope iterator. */</span>
        <span class="kw">auto</span> scp_ptr1 = mse::mstd::xscope_pointer_to_array_element&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;(scp_array_iter1);
        <span class="kw">auto</span> res1 = *scp_ptr1;
        <span class="co">/* Or with a scope pointer to the array and an index. */</span>
        <span class="kw">auto</span> scp_cptr2 = mse::mstd::xscope_const_pointer_to_array_element&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;(&amp;array1_scpobj, <span class="dv">2</span><span class="co">/*element index*/</span>);
        <span class="kw">auto</span> res2 = *scp_cptr2;
    }</code></pre></div>
<h3 id="txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">TXScopeRandomAccessSection, TXScopeRandomAccessConstSection, TRandomAccessSection, TRandomAccessConstSection</h3>
<p>A &quot;random access section&quot; is basically a convenient interface to access a (contiguous) subsection of an existing array or vector. (Essentially an &quot;array view&quot; or &quot;span&quot; if you're familiar with those.) You construct them, using the <code>make_random_access_section()</code> functions, by specifying an iterator to the start of the section, and the length of the section. Random access sections support most of the member functions and operators that <a href="http://en.cppreference.com/w/cpp/string/basic_string_view">std::basic_string_view</a> does, except that the &quot;<a href="http://en.cppreference.com/w/cpp/string/basic_string_view/substr">substr()</a>&quot; member function is named &quot;subsection()&quot;.</p>
<p>Note that for convenience, random access sections can be constructed from just a (safe) pointer to a supported container object, but in some cases the exact type of the resulting random access section may not be obvious. Constructing instead from a specified iterator and length should avoid any ambiguity.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemsearray.h&quot;</span><span class="pp"> </span><span class="co">//random access sections are defined in this file</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
    <span class="kw">class</span> J {
    <span class="kw">public</span>:
        <span class="kw">template</span>&lt;<span class="kw">class</span> _TRASection&gt;
        <span class="at">static</span> <span class="dt">void</span> foo13(_TRASection ra_section) {
            <span class="cf">for</span> (_TRASection::<span class="dt">size_type</span> i = <span class="dv">0</span>; i &lt; ra_section.size(); i += <span class="dv">1</span>) {
                ra_section[i] = <span class="dv">0</span>;
            }
        }
        <span class="kw">template</span>&lt;<span class="kw">class</span> _TRAConstSection&gt;
        <span class="at">static</span> <span class="dt">int</span> foo14(_TRAConstSection const_ra_section) {
            <span class="dt">int</span> retval = <span class="dv">0</span>;
            <span class="cf">for</span> (_TRAConstSection::<span class="dt">size_type</span> i = <span class="dv">0</span>; i &lt; const_ra_section.size(); i += <span class="dv">1</span>) {
                retval += const_ra_section[i];
            }
            <span class="cf">return</span> retval;
        }
        <span class="kw">template</span>&lt;<span class="kw">class</span> _TRAConstSection&gt;
        <span class="at">static</span> <span class="dt">int</span> foo15(_TRAConstSection const_ra_section) {
            <span class="dt">int</span> retval = <span class="dv">0</span>;
            <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; const_item : const_ra_section) {
                retval += const_item;
            }
            <span class="cf">return</span> retval;
        }
    };

    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
        mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">4</span>&gt; mstd_array1{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span> };
        mse::mstd::vector&lt;<span class="dt">int</span>&gt; mstd_vec1{ <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span> };

        <span class="kw">auto</span> xscp_ra_section1 = mse::make_xscope_random_access_section(mstd_array1.begin(), <span class="dv">2</span>);
        J::foo13(xscp_ra_section1);

        <span class="kw">auto</span> ra_const_section2 = mse::make_random_access_const_section(++mstd_vec1.begin(), <span class="dv">3</span>);
        <span class="kw">auto</span> res6 = J::foo15(ra_const_section2);
        <span class="kw">auto</span> res7 = J::foo14(ra_const_section2);

        <span class="kw">auto</span> xscp_ra_section1_xscp_iter1 = xscp_ra_section1.xscope_begin();
        <span class="kw">auto</span> xscp_ra_section1_xscp_iter2 = xscp_ra_section1.xscope_end();
        <span class="kw">auto</span> res8 = xscp_ra_section1_xscp_iter2 - xscp_ra_section1_xscp_iter1;
        <span class="dt">bool</span> res9 = (xscp_ra_section1_xscp_iter1 &lt; xscp_ra_section1_xscp_iter2);
        
        <span class="co">/* Like non-owning scope pointers, scope sections may not be used as a function return value. (The return_value()</span>
<span class="co">        function wrapper enforces this.) Pretty much the only time you&#39;d legitimately want to do this is when the</span>
<span class="co">        returned section is constructed from one of the input parameters. Let&#39;s consider a simple example of a</span>
<span class="co">        &quot;first_half()&quot; function that takes a scope section and returns a scope section spanning the first half of the</span>
<span class="co">        section. The library provides the random_access_subsection() function which takes a random access section and a</span>
<span class="co">        tuple containing a start index and a length and returns a random access section spanning the indicated</span>
<span class="co">        subsection. You could use this function to implement the equivalent of a &quot;first_half()&quot; function like so: */</span>
        
        <span class="kw">auto</span> xscp_ra_section3 = mse::random_access_subsection(xscp_ra_section1, <span class="bu">std::</span>make_tuple(<span class="dv">0</span>, xscp_ra_section1.length()/<span class="dv">2</span>));
        assert(xscp_ra_section3.length() == <span class="dv">1</span>);
    }</code></pre></div>
<h3 id="strings">Strings</h3>
<p>From an interface perspective, you might think of strings roughly as glorified vectors of characters, and thus they are given similar treatment in the library. A couple of string types are provided that correspond to their <a href="#vectors">vector</a> counterparts. <a href="#string"><code>mstd::string</code></a> is simply a memory-safe drop-in replacement for std::string. Due to their iterators, strings are not, in general, safe to share among threads. <a href="#nii_string"><code>nii_string</code></a> is designed for safe sharing among asynchronous threads.</p>
<h3 id="string">string</h3>
<p><code>mstd::string</code> is a memory-safe drop-in replacement for <code>std::string</code>. As with the standard library, <code>mstd::string</code> is defined as an alias for <code>mstd::basic_string&lt;char&gt;</code>. The <code>mstd::wstring</code>, <code>mstd::u16string</code> and <code>mstd::u32string</code> aliases are also present.</p>
<h3 id="nii_string">nii_string</h3>
<p><code>nii_string</code> is a string type designed to be safely shareable between asynchronous threads. See the corresponding <a href="#nii_vector"><code>nii_vector&lt;&gt;</code></a> for more information. Like <code>mstd::string</code>, <code>nii_string</code> is defined as an alias of <code>nii_basic_string&lt;char&gt;</code>. The <code>nii_wstring</code>, <code>nii_u16string</code> and <code>nii_u32string</code> aliases are also present.</p>
<p>And <code>stnii_basic_string&lt;&gt;</code> and <code>mtnii_basic_string&lt;&gt;</code> are string counterparts of <a href="#stnii_vector"><code>stnii_vector&lt;&gt;</code></a> and <a href="#mtnii_vector"><code>mtnii_vector&lt;&gt;</code></a>.</p>
<h3 id="txscopestringsection-txscopestringconstsection-tstringsection-tstringconstsection">TXScopeStringSection, TXScopeStringConstSection, TStringSection, TStringConstSection</h3>
<p>&quot;String sections&quot; are string specialized versions of &quot;<a href="#txscoperandomaccesssection-txscoperandomaccessconstsection-trandomaccesssection-trandomaccessconstsection">random access sections</a>&quot;.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msemsestring.h&quot;</span><span class="pp"> </span><span class="co">// make_string_section() is defined in this header</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

        <span class="co">/* &quot;String sections&quot; are the string specialized versions of &quot;random access sections&quot;, basically providing the</span>
<span class="co">        functionality of std::string_view but supporting construction from any (safe) iterator type, not just raw</span>
<span class="co">        pointer iterators. */</span>
    
        mse::mstd::string mstring1(<span class="st">&quot;some text&quot;</span>);
        <span class="kw">auto</span> string_section1 = mse::make_string_section(mstring1.begin() + <span class="dv">1</span>, <span class="dv">7</span>);
        <span class="kw">auto</span> string_section2 = string_section1.substr(<span class="dv">4</span>, <span class="dv">3</span>);
        assert(string_section2.front() == <span class="st">&#39;t&#39;</span>);
        assert(string_section2.back() == <span class="st">&#39;x&#39;</span>);
    
        <span class="co">/* Unlike std::string_view, string sections are available in &quot;non-const&quot; versions. */</span>
        string_section2[<span class="dv">0</span>] = <span class="st">&#39;T&#39;</span>;
        <span class="bu">std::</span>cout &lt;&lt; string_section2;
        assert(mstring1 == <span class="st">&quot;some Text&quot;</span>);
    }</code></pre></div>
<h3 id="txscopenrpstringsection-txscopenrpstringconstsection-tnrpstringsection-tnrpstringconstsection">TXScopeNRPStringSection, TXScopeNRPStringConstSection, TNRPStringSection, TNRPStringConstSection</h3>
<p><code>TNRPStringSection&lt;&gt;</code> is just a version of <a href="#txscopestringsection-txscopestringconstsection-tstringsection-tstringconstsection"><code>TStringSection&lt;&gt;</code></a> that, for enhanced safety, does not support construction from unsafe raw pointer iterators or (unsafe) <code>std::string</code> iterators. Use the <code>make_nrp_string_section()</code> functions to create them.</p>
<h3 id="string_view">string_view</h3>
<p><code>std::string_view</code> is, in a way, a problematic addition to the standard library in the sense that it has an intrinsically unsafe interface. That is, its constructors support only (unsafe) raw pointer iterator parameters. In contrast, the standard library generally uses iterator types which allow for the option of a memory safe implementation. So to enable memory safe use, this library's version, <code>mstd::string_view</code>, generalizes the interface to support construction from safe iterator types. So while technically <code>mstd::string_view</code> can act as a drop-in replacement for <code>std::string_view</code>, it is designed to be used with safe iterator types, not unsafe raw pointer iterators.</p>
<p>Like <code>std::string_view</code>, <code>mstd::string_view</code> is defined as an alias for <code>mstd::basic_string_view&lt;char&gt;</code>. The <code>mstd::wstring_view</code>, <code>mstd::u16string_view</code> and <code>mstd::u32string_view</code> aliases are also present. Note that <code>mstd::basic_string_view&lt;&gt;</code> is in fact just a slightly augmented version of <a href="#txscopeanystringsection-txscopeanystringconstsection-tanystringsection-tanystringconstsection"><code>TAnyStringConstSection&lt;&gt;</code></a>.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msepoly.h&quot;</span><span class="pp"> </span><span class="co">// mstd::string_view is defined in this header</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>
    
    <span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    
        <span class="co">/* std::string_view stores an (unsafe) pointer iterator into its target string. mse::mstd::string_view can</span>
<span class="co">        instead store any type of string iterator, including memory safe iterators. So for example, when assigned</span>
<span class="co">        from an mse::mstd::string, mse::mstd::string_view will hold one of mse::mstd::string&#39;s safe (strong) iterators</span>
<span class="co">        (obtained with a call to the string&#39;s cbegin() member function). Consequently, the mse::mstd::string_view will</span>
<span class="co">        be safe against &quot;use-after-free&quot; bugs to which std::string_view is so prone. */</span>
    
        mse::mstd::string_view msv1;
        {
            mse::mstd::string mstring1(<span class="st">&quot;some text&quot;</span>);
            msv1 = mstring1;
        }
        <span class="cf">try</span> {
            <span class="co">/* This is not undefined (or unsafe) behavior. */</span>
            <span class="kw">auto</span> ch1 = msv1[<span class="dv">3</span>]; <span class="co">/* In debug mode this will fail an assert. In non-debug mode it&#39;ll just work (safely). */</span>
            assert(<span class="st">&#39;e&#39;</span> == ch1);
        }
        <span class="cf">catch</span> (...) {
            <span class="co">/* At present, no exception will be thrown. Instead, the lifespan of the string data is extended to match</span>
<span class="co">            that of the mstd::string_view. It&#39;s possible that in future library implementations, an exception may be thrown. */</span>
        }
    
        mse::mstd::string mstring2(<span class="st">&quot;some other text&quot;</span>);
        <span class="co">/* With std::string_view, you specify a string subrange with a raw pointer iterator and a length. With</span>
<span class="co">        mse::mstd::string_view you are not restricted to (unsafe) raw pointer iterators. You can use memory safe</span>
<span class="co">        iterators like those provided by mse::mstd::string. */</span>
        <span class="kw">auto</span> msv2 = mse::mstd::string_view(mstring2.cbegin()<span class="dv">+5</span>, <span class="dv">7</span>);
        assert(msv2 == <span class="st">&quot;other t&quot;</span>);
    }</code></pre></div>
<h3 id="nrp_string_view">nrp_string_view</h3>
<p><code>mse::nrp_string_view</code> is just a version of <a href="#string_view"><code>mse::mstd::string_view</code></a> that, for enhanced safety, does not support construction from unsafe raw pointer iterators or (unsafe) <code>std::string</code> iterators.</p>
<h3 id="optional-xscope_optional">optional, xscope_optional</h3>
<p><code>mse::mstd::optional&lt;&gt;</code> is simply a safe implementation of <code>std::optional&lt;&gt;</code>. <code>mse::xscope_optional&lt;&gt;</code> is the scope version which is subject to the restrictions of all scope objects. The (uncommon) reason you might need to use <code>mse::xscope_optional&lt;&gt;</code> rather than just <code>mse::TXScopeObj&lt;mse::mstd::optional&lt;&gt; &gt;</code> is that <code>mse::xscope_optional&lt;&gt;</code> supports using scope types (including scope pointer types) as its element type.</p>
<h3 id="tuple-xscope_tuple">tuple, xscope_tuple</h3>
<p><code>mse::mstd::tuple&lt;&gt;</code> is simply a drop-in replacement for <code>std::tuple&lt;&gt;</code>. <code>mse::xscope_tuple&lt;&gt;</code> is the scope version which is subject to the restrictions of all scope objects. The (uncommon) reason you might need to use <code>mse::xscope_tuple&lt;&gt;</code> rather than just <code>mse::TXScopeObj&lt;mse::mstd::tuple&lt;&gt; &gt;</code> is that <code>mse::xscope_tuple&lt;&gt;</code> supports using scope types (including scope pointer types) among its element types.</p>
<h3 id="algorithms">Algorithms</h3>
<p>The library's safe iterators work just fine with the standard library algorithms. But some of the algorithms, like <code>std::for_each()</code>, take a function object parameter and pass to the function object a (native) reference to an element. If you want to avoid using native references, the library provides versions of some of these algorithms that pass to the function object a (safe) pointer to the element instead of a native reference to the element.</p>
<h4 id="for_each_ptr">for_each_ptr()</h4>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msealgorithm.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    mse::TXScopeObj&lt;mse::nii_array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; &gt; xscope_na1 = mse::nii_array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
    <span class="kw">auto</span> xscope_na1_begin_citer = mse::make_xscope_begin_const_iterator(&amp;xscope_na1);
    <span class="kw">auto</span> xscope_na1_end_citer = mse::make_xscope_end_const_iterator(&amp;xscope_na1);

    mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; ma1{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };

    mse::TXScopeObj&lt;mse::nii_vector&lt;<span class="dt">int</span>&gt; &gt; xscope_nv1 = mse::nii_vector&lt;<span class="dt">int</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
    <span class="kw">auto</span> xscope_nv1_begin_iter = mse::make_xscope_begin_iterator(&amp;xscope_nv1);
    <span class="kw">auto</span> xscope_nv1_end_iter = mse::make_xscope_end_iterator(&amp;xscope_nv1);

    {
        <span class="co">/*  mse::for_each_ptr() is like std:::for_each() but instead of passing, to the given function, a reference</span>
<span class="co">        to each item it passes a (safe) pointer to each item. The actual type of the pointer varies depending on the</span>
<span class="co">        type of the given iterators. */</span>
        <span class="kw">typedef</span> mse::<span class="dt">for_each_ptr_type</span>&lt;<span class="kw">decltype</span>(ma1.begin())&gt; <span class="dt">item_ptr_t</span>;
        mse::for_each_ptr(ma1.begin(), ma1.end(), [](<span class="dt">item_ptr_t</span> x_ptr) { <span class="bu">std::</span>cout &lt;&lt; *x_ptr &lt;&lt; <span class="bu">std::</span>endl; });

        mse::for_each_ptr(xscope_na1_begin_citer, xscope_na1_end_citer, [](<span class="kw">auto</span> x_ptr) { <span class="bu">std::</span>cout &lt;&lt; *x_ptr &lt;&lt; <span class="bu">std::</span>endl; });

        <span class="co">/* A &quot;scope range&quot; version is also available that bypasses the use of iterators. As well as often being more</span>
<span class="co">        convenient, it can theoretically be little more performance optimal. */</span>
        <span class="kw">typedef</span> mse::<span class="dt">xscope_range_for_each_ptr_type</span>&lt;<span class="kw">decltype</span>(&amp;xscope_na1)&gt; <span class="dt">range_item_ptr_t</span>;
        mse::xscope_range_for_each_ptr(&amp;xscope_na1, [](<span class="dt">range_item_ptr_t</span> x_ptr) { <span class="bu">std::</span>cout &lt;&lt; *x_ptr &lt;&lt; <span class="bu">std::</span>endl; });

        <span class="co">/* Note that for performance (and safety) reasons, vectors may be &quot;structure locked&quot; for the duration of the loop.</span>
<span class="co">        That is, any attempt to modify the size of the vector during the loop may result in an exception. */</span>
        mse::for_each_ptr(xscope_nv1_begin_iter, xscope_nv1_end_iter, [](<span class="kw">auto</span> x_ptr) { <span class="bu">std::</span>cout &lt;&lt; *x_ptr &lt;&lt; <span class="bu">std::</span>endl; });
        mse::xscope_range_for_each_ptr(&amp;xscope_nv1, [](<span class="kw">auto</span> x_ptr) { <span class="bu">std::</span>cout &lt;&lt; *x_ptr &lt;&lt; <span class="bu">std::</span>endl; });
    }
}</code></pre></div>
<h4 id="find_if_ptr">find_if_ptr()</h4>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msealgorithm.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdarray.h&quot;</span>
    
<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {

    mse::TXScopeObj&lt;mse::nii_array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; &gt; xscope_na1 = mse::nii_array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt;{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };
    <span class="kw">auto</span> xscope_na1_begin_citer = mse::make_xscope_begin_const_iterator(&amp;xscope_na1);
    <span class="kw">auto</span> xscope_na1_end_citer = mse::make_xscope_end_const_iterator(&amp;xscope_na1);

    mse::mstd::array&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; ma1{ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };

    {
        <span class="kw">typedef</span> mse::<span class="dt">find_if_ptr_type</span>&lt;<span class="kw">decltype</span>(xscope_na1_begin_citer)&gt; <span class="dt">item_ptr_t</span>;
        <span class="kw">auto</span> found_citer1 = mse::find_if_ptr(xscope_na1_begin_citer, xscope_na1_end_citer, [](<span class="dt">item_ptr_t</span> x_ptr) { <span class="cf">return</span> <span class="dv">2</span> == *x_ptr; });
        <span class="kw">auto</span> res1 = *found_citer1;

        <span class="kw">auto</span> found_citer3 = mse::find_if_ptr(ma1.cbegin(), ma1.cend(), [](<span class="kw">auto</span> x_ptr) { <span class="cf">return</span> <span class="dv">2</span> == *x_ptr; });

        <span class="co">/* This version returns an optional scope pointer to the found item rather than an iterator. */</span>
        <span class="kw">typedef</span> mse::<span class="dt">xscope_range_get_ref_if_ptr_type</span>&lt;<span class="kw">decltype</span>(&amp;xscope_na1)&gt; <span class="dt">range_item_ptr_t</span>;
        <span class="kw">auto</span> xscope_optional_xscpptr4 = mse::xscope_range_get_ref_if_ptr(&amp;xscope_na1, [](<span class="dt">range_item_ptr_t</span> x_ptr) { <span class="cf">return</span> <span class="dv">2</span> == *x_ptr; });
        <span class="kw">auto</span> res4 = xscope_optional_xscpptr4.value();

        <span class="co">/* This version returns a scope pointer to the found item or throws an exception if an appropriate item isn&#39;t</span>
<span class="co">        found. */</span>
        <span class="kw">auto</span> xscope_pointer5 = mse::xscope_range_get_ref_to_element_known_to_be_present_ptr(&amp;xscope_na1, [](<span class="kw">auto</span> x_ptr) { <span class="cf">return</span> <span class="dv">2</span> == *x_ptr; });
        <span class="kw">auto</span> res5 = *xscope_pointer5;
    }
}</code></pre></div>
<h3 id="thread_local">thread_local</h3>
<p>[<em>provisional</em>]</p>
<p>While not encouraging the use of <code>thread_local</code> variables, the library does provide facilities for their use.</p>
<p>usage example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msethreadlocal.h&quot;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

MSE_DECLARE_THREAD_LOCAL_GLOBAL(mse::mstd::string) tlg_string1 = <span class="st">&quot;some text&quot;</span>;

<span class="dt">void</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) {
    {
        <span class="kw">auto</span> tlg_ptr1 = &amp;tlg_string1;
        <span class="kw">auto</span> xs_tlg_store1 = mse::make_xscope_strong_pointer_store(tlg_ptr1);
        <span class="kw">auto</span> xs_ptr1 = xs_tlg_store1.xscope_ptr();
        *xs_ptr1 += <span class="st">&quot;...&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; *xs_ptr1 &lt;&lt; <span class="bu">std::</span>endl;

        MSE_DECLARE_THREAD_LOCAL_CONST(mse::mstd::string) tlc_string2 = <span class="st">&quot;abc&quot;</span>;
        <span class="kw">auto</span> tlc_ptr2 = &amp;tlc_string2;
        <span class="kw">auto</span> xs_tlc_store2 = mse::make_xscope_strong_pointer_store(tlc_ptr2);
        <span class="kw">auto</span> xs_cptr2 = xs_tlc_store2.xscope_ptr();
        <span class="bu">std::</span>cout &lt;&lt; *xs_cptr2 &lt;&lt; <span class="bu">std::</span>endl;

        <span class="kw">class</span> CA {
        <span class="kw">public</span>:
            <span class="kw">auto</span> foo1() <span class="at">const</span> {
                MSE_DECLARE_THREAD_LOCAL(mse::mstd::string) tl_string = <span class="st">&quot;abc&quot;</span>;
                <span class="co">/* mse::return_value() just returns its argument and ensures that it&#39;s of a (pointer) type that&#39;s safe to return. */</span>
                <span class="cf">return</span> mse::return_value(&amp;tl_string);
            }
        };
        <span class="kw">auto</span> tl_ptr3 = CA().foo1();
        <span class="kw">auto</span> xs_tl_store3 = mse::make_xscope_strong_pointer_store(tl_ptr3);
        <span class="kw">auto</span> xs_cptr3 = xs_tl_store3.xscope_ptr();
        *xs_cptr3 += <span class="st">&quot;def&quot;</span>;
        <span class="bu">std::</span>cout &lt;&lt; *xs_cptr3 &lt;&lt; <span class="bu">std::</span>endl;
    }

}</code></pre></div>
<h3 id="practical-limitations">Practical limitations</h3>
<p>In situations where a lifetime checker, or equivalent static analyzer, is not available, the degree of memory safety that can be achieved is a function of the degree to which use of C++'s (memory) unsafe elements is avoided.</p>
<p>Note that one of C++'s more subtle unsafe elements is the implicit <code>this</code> pointer when accessing member variables from member functions. Consider this example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
    <span class="kw">class</span> CI {
    <span class="kw">public</span>:
        <span class="kw">template</span>&lt;<span class="kw">class</span> <span class="dt">safe_vector_pointer_type</span>&gt;
        <span class="dt">void</span> foo1(<span class="dt">safe_vector_pointer_type</span> vec_ptr) {
            vec_ptr-&gt;clear();
    
            <span class="co">/* These next two lines are equivalent and technically unsafe. */</span>
            <span class="va">m_i</span> += <span class="dv">1</span>;
            <span class="kw">this</span>-&gt;<span class="va">m_i</span> += <span class="dv">1</span>;
        }
    
        <span class="dt">int</span> <span class="va">m_i</span> = <span class="dv">0</span>;
    };
    
    <span class="dt">void</span> main() {
        mse::TXScopeObj&lt;mse::mstd::vector&lt;CI&gt;&gt; vec1;
        vec1.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> iter = vec1.begin();
        iter-&gt;foo1(&amp;vec1);
    }</code></pre></div>
<p>The above example contains unchecked accesses to deallocated memory via an implicit and explicit <code>this</code> pointer. The <code>this</code> pointer (implicit or explicit) is a native pointer, and like any other native pointer, is unsafe and can/should be replaced with a safer substitute:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
    <span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
    
    <span class="kw">class</span> CI {
    <span class="kw">public</span>:
        <span class="kw">template</span>&lt;<span class="kw">class</span> <span class="dt">safe_this_type</span>, <span class="kw">class</span> <span class="dt">safe_vector_pointer_type</span>&gt;
        <span class="at">static</span> <span class="dt">void</span> foo2(<span class="dt">safe_this_type</span> safe_this, <span class="dt">safe_vector_pointer_type</span> vec_ptr) {
            vec_ptr-&gt;clear();
    
            <span class="co">/* The safe_this pointer will catch the attempted invalid memory access. */</span>
            safe_this-&gt;<span class="va">m_i</span> += <span class="dv">2</span>;
        }
    
        <span class="dt">int</span> <span class="va">m_i</span> = <span class="dv">0</span>;
    };
    
    <span class="dt">void</span> main() {
        mse::TXScopeObj&lt;mse::mstd::vector&lt;CI&gt;&gt; vec1;
        vec1.resize(<span class="dv">1</span>);
        <span class="kw">auto</span> iter = vec1.begin();
        iter-&gt;foo2(iter, &amp;vec1);
    }</code></pre></div>
<p>So technically, in situations where a complete lifetime checker is not available, achieving complete memory safety requires passing a safe <code>this</code> pointer parameter as an argument to every member function that accesses a member variable. (I.e. Make your member functions <code>static</code>. Or &quot;<a href="https://www.youtube.com/watch?v=nWJHhtmWYcY">free</a>&quot;.)</p>
<p>But certain member functions can't be made static. Namely constructors, destructors and member operators. If all the constructors and destructors in the program are compiler-generated defaults (or are otherwise known to be &quot;well behaved&quot;) then they would all be perfectly safe. The (theoretical) problem is that user-defined constructors or destructors aren't guaranteed to be &quot;well behaved&quot;. Specifically, in conventional C++ they could cause objects to be deleted in the middle of their constructor/destructor(/non-static member function) calls. And not just their own object, but, for example, a misbehaving constructor that is invoked by a parent constructor could cause that parent object to be deleted before its construction is completed.</p>
<p>Fortunately, with the SaferCPlusPlus subset it's not quite so bad. Let's consider the possibility of an object's <code>this</code> pointer being invalidated (i.e. the object being destroyed) while in the middle of executing its constructor. In the SaferCPlusPlus subset there are a limited number of circumstances when a constructor is invoked. One is when calling <code>make_refcounting&lt;&gt;()</code>. In this case, no direct or indirect reference to the object (other than the <code>this</code> pointer itself) is available until after the constructor has finished executing, so there's no opportunity for the object to be destroyed (and the <code>this</code> pointer invalidated) before then. Same goes for <code>registered_new()</code> and <code>norad_new()</code>.</p>
<p>A more complicated case is when a container, like say, <code>mstd::vector&lt;&gt;</code> causes the invocation of child object constructors. Consider this example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;msescope.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdvector.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;msemstdstring.h&quot;</span>

<span class="kw">class</span> CMisbehaver1 {
<span class="kw">public</span>:
    <span class="kw">template</span>&lt;<span class="kw">typename</span> TVectorPtr&gt;
    CMisbehaver1(TVectorPtr vector_ptr) {
        vector_ptr-&gt;clear(); <span class="co">// potentially dangerous behavior in a constructor</span>

        <span class="co">// is the &quot;this&quot; pointer still valid here?</span>

        <span class="kw">this</span>-&gt;<span class="va">m_string1</span> = <span class="st">&quot;some text&quot;</span>;
    }
    mse::mstd::string <span class="va">m_string1</span>;
};

<span class="dt">void</span> main() {
    <span class="kw">typedef</span> mse::mstd::vector&lt;CMisbehaver1&gt; <span class="dt">misb1_vec_t</span>;
    <span class="kw">typedef</span> mse::mstd::vector&lt;<span class="dt">misb1_vec_t</span>&gt; <span class="dt">misb1_vec_vec_t</span>;
    mse::TXScopeObj&lt;<span class="dt">misb1_vec_vec_t</span>&gt; xs_vv1;
    xs_vv1.resize(<span class="dv">1</span>);
    xs_vv1[<span class="dv">0</span>].emplace_back(&amp;xs_vv1);
}</code></pre></div>
<p>It's a little bit tricky, but the <code>emplace_back()</code> call on the last line of the <code>main()</code> function is going to cause the constructor of <code>CMisbehaver1</code> to be invoked. But in its first line, the constructor seemingly causes its parent container to be deleted, making its own <code>this</code> pointer invalid.</p>
<p>But because the parent container (i.e. the thing invoking the constructor) is an element of the library, it has run-time checks to ensure that its destructor is not executed while in the middle of one of its (non-static) member functions, like <code>emplace_back()</code> (or a constructor or the destructor). So in this case, rather than execute its destructor in the middle of the <code>emplace_back()</code> call, the program will terminate.</p>
<p>Because constructors and destructors of dynamically (i.e. heap) allocated objects can only be invoked via elements of the library, those elements can (and do) ensure that the <code>this</code> pointer remains valid for the whole constructor/destructor call in all cases.</p>
<p>The remaining case is when a local variable is declared (on the stack). In this case the <code>this</code> pointer is intrinsically guaranteed to point to a validly allocated object, not just for the duration of the constructor, but indeed for the duration of the scope. Unfortunately, C++ does permit you to reference the object before the completion of its construction. For example, in this declaration</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    {
        <span class="bu">std::</span>vector&lt;<span class="dt">size_t</span>&gt; v1 { v1.at(<span class="dv">3</span>) };
    }</code></pre></div>
<p>the local variable <code>v1</code> is used after it has been allocated, but before its constructor has been executed. In theory, the library's elements could attempt to detect use-before-construction at run-time, but this kind of bug is probably quite rare and probably more appropriately addressed by a static tool, like the lifetime checker, or frankly, the compiler itself. (Same goes for variables with static or thread_local storage if you're using those.)</p>
<p>While we can generally ensure that the <code>this</code> pointer remains valid in constructors/destructors, we cannot do the same for native reference parameters. This means that technically, without a lifetime checker, the safety of (user-defined) constructors which take native reference parameters, like copy and move constructors, cannot be ensured.</p>
<p>Also note that explicitly calling <code>std::move()</code> (the one in the <code>&lt;utility&gt;</code> library, not the one in the <code>&lt;algorithm&gt;</code> library) is not really in the spirit of the library and could cause problems if applied to certain scope objects. <code>std::forward&lt;&gt;()</code> is fine. Basically, just let the compiler decide when a reference is an rvalue reference.</p>
<p>And also, SaferCPlusPlus does not yet provide safer substitutes for all of the standard library containers, just the ones responsible for the most problems (vector and array). So be careful with your maps, sets, etc. In many cases lists can be replaced with <a href="#ivector"><code>ivector&lt;&gt;</code></a>s that support list-style iterators, often with a performance benefit.</p>
<h3 id="questions-and-comments">Questions and comments</h3>
<p>If you have questions or comments you can create a post in the <a href="https://github.com/duneroadrunner/SaferCPlusPlus/issues">issues section</a>.</p>
