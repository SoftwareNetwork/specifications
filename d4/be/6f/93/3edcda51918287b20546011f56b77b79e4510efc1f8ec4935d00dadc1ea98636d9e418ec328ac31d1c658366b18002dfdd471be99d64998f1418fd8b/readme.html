<h1 id="mainpage">The C++ client library for PostgreSQL</h1>
<p>The Dmitigr Pgfe (<a href="https://www.postgresql.org/">PostgreSQL</a> Frontend) is a client API to <a href="https://www.postgresql.org/">PostgreSQL</a> servers written in C++. The development is focused on easines and robustness of use rather than super-duper performance. <strong>ATTENTION, this software is &quot;beta&quot; quality, and the API is a subject to change</strong>. Any <a href="mailto:dmitigr@gmail.com">feedback</a> (<em>especially results of testing</em>) is highly appreciated! Together we can make Pgfe library <em>really</em> production-ready!</p>
<p>Please note, this tutorial can also be viewed at <a href="http://dmitigr.ru/en/projects/pgfe/doc/">the official Pgfe documentation site</a>. Because of the Pgfe documentation is generated by <a href="http://doxygen.org/">Doxygen</a>, most of references to the classes and methods on the official documentation site are clickable, which makes the familiarization more convenient. Also there are <a href="http://dmitigr.ru/en/projects/pgfe/doc/pgfe.class.violet.html">overview class diagram</a> of the API for better understanding.</p>
<h1 id="hello-world">Hello, World</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;dmitigr/pgfe.hpp&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
  <span class="kw">namespace</span> pgfe = dmitigr::pgfe;
  <span class="cf">try</span> {
    <span class="at">const</span> <span class="kw">auto</span> conn = pgfe::Connection_options::make()-&gt;
      set(pgfe::Communication_mode::tcp)-&gt;
      set_tcp_host_name(<span class="st">&quot;localhost&quot;</span>)-&gt;
      set_database(<span class="st">&quot;pgfe_test&quot;</span>)-&gt;
      set_username(<span class="st">&quot;pgfe_test&quot;</span>)-&gt;
      set_password(<span class="st">&quot;pgfe_test&quot;</span>)-&gt;
      make_connection();

    conn-&gt;<span class="fu">connect</span>();
    conn-&gt;execute(<span class="st">&quot;SELECT generate_series($1::int, $2::int) AS natural&quot;</span>, <span class="dv">1</span>, <span class="dv">3</span>);
    conn-&gt;for_each([](<span class="at">const</span> <span class="kw">auto</span>* <span class="at">const</span> row) {
      <span class="bu">std::</span>cout &lt;&lt; pgfe::to&lt;<span class="dt">int</span>&gt;(row-&gt;data(<span class="st">&quot;natural&quot;</span>)) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
    });
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;The &quot;</span> &lt;&lt; conn-&gt;completion()-&gt;operation_name() &lt;&lt; <span class="st">&quot; query is done.</span><span class="sc">\n</span><span class="st">&quot;</span>;

    <span class="co">// As a sample of error handling let&#39;s provoke syntax error and handle it away.</span>
    <span class="cf">try</span> {
      conn-&gt;perform(<span class="st">&quot;PROVOKE SYNTAX ERROR&quot;</span>);
    } <span class="cf">catch</span> (<span class="at">const</span> pgfe::Server_exception&amp; e) {
      <span class="cf">if</span> (e.error()-&gt;code() == pgfe::Server_errc::c42_syntax_error)
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Error &quot;</span> &lt;&lt; e.error()-&gt;sqlstate() &lt;&lt; <span class="st">&quot; is handled as expected.</span><span class="sc">\n</span><span class="st">&quot;</span>;
      <span class="cf">else</span>
        <span class="cf">throw</span>;
    }
  } <span class="cf">catch</span> (<span class="at">const</span> <span class="bu">std::</span>exception&amp; e) {
    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;Oops: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;
  }
}</code></pre></div>
<h1 id="features">Features</h1>
<p>Current API allows to work with:</p>
<ul>
<li>database connections (in both blocking and non-blocking IO manner);</li>
<li>prepared statements (named parameters are supported);</li>
<li><a href="https://www.postgresql.org/docs/current/static/errcodes-appendix.html">SQLSTATE</a> codes (as simple as with enums);</li>
<li>extensible data type conversions (including support of <a href="https://www.postgresql.org/">PostgreSQL</a> arrays to/from STL containers conversions);</li>
<li>dynamic SQL;</li>
<li>SQL queries separately of C++ code.</li>
</ul>
<h2 id="features-of-the-near-future">Features of the near future</h2>
<p>The urgent TODO-list includes support of:</p>
<ul>
<li><a href="https://www.postgresql.org/docs/current/static/largeobjects.html">Large Objects</a> via IO streams of the Standard C++ library;</li>
<li>conversions for <code>dmitigr::pgfe::Composite</code> data type;</li>
<li>yet more convenient work with arrays of variable dimensions at runtime;</li>
<li>COPY command;</li>
<li>C API.</li>
</ul>
<h1 id="tutorial">Tutorial</h1>
<p>Client programs that use Pgfe should include header file <code>dmitigr/pgfe.hpp</code> and must link with <code>dmitigr_pgfe</code> (or the debug build - <code>dmitigr_pgfed</code>) library. Logically Pgfe library consists of the following parts:</p>
<ul>
<li>Main (client/server communication);</li>
<li>Large objects (future feature, see the above TODO-list);</li>
<li>Data types conversions;</li>
<li>Errors (exceptions and error codes);</li>
<li>Utilities.</li>
</ul>
<p><strong>WARNING</strong> Headers other than <code>dmitigr/pgfe.hpp</code> should be <em>avoided</em> to use in applications since that headers are subject to reorganize. Also the namespace <code>dmitigr::pgfe::detail</code> consists of the implementation details and <em>should not</em> be used in the client code.</p>
<h2 id="connecting-to-a-server">Connecting to a server</h2>
<p>The class dmitigr::pgfe::Connection is a central abstraction of Pgfe library. By using methods of this class it is possible to:</p>
<ul>
<li>send requests to a server;</li>
<li>receive responses from a server (see dmitigr::pgfe::Response);</li>
<li>receive signals from a server (see dmitigr::pgfe::Signal);</li>
<li>perform other operations that depend on a server data (such as dmitigr::pgfe::Connection::to_quoted_literal()).</li>
</ul>
<p>To make an instance of the class dmitigr::pgfe::Connection, the instance of the class dmitigr::pgfe::Connection_options is required. A copy of this instance is always <em>read-only</em> accessible via dmitigr::pgfe::Connection::options().</p>
<p>Example 1. Creation of the connection with customized options:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;dmitigr::pgfe::Connection&gt; create_customized_connection()
{
  <span class="cf">return</span> pgfe::Connection_options::make()-&gt;
    set(Communication_mode::tcp)-&gt;
    set_tcp_host_name(<span class="st">&quot;localhost&quot;</span>)-&gt;
    set_database(<span class="st">&quot;db&quot;</span>)-&gt;
    set_username(<span class="st">&quot;user&quot;</span>)-&gt;
    set_password(<span class="st">&quot;password&quot;</span>)-&gt;
    make_connection();
}</code></pre></div>
<p>Example 2. Creation of the connection with default options:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;dmitigr::pgfe::Connection&gt; create_default_connection_1()
{
  <span class="at">const</span> <span class="kw">auto</span> opts = pgfe::Connection_options::make();
  <span class="cf">return</span> pgfe::Connection::make(opts.get());
}</code></pre></div>
<p>Example 3. Creation of the connection with default options:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>unique_ptr&lt;dmitigr::pgfe::Connection&gt; create_default_connection_2()
{
  <span class="cf">return</span> pgfe::Connection::make();
}</code></pre></div>
<p>After creation of an object of type dmitigr::pgfe::Connection there are two ways to connect available:</p>
<ul>
<li>synchronous by using dmitigr::pgfe::Connection::connect();</li>
<li>asynchronous by using dmitigr::pgfe::Connection::connect_async().</li>
</ul>
<h2 id="executing-commands">Executing commands</h2>
<p>SQL commands can be executed through either of two ways:</p>
<ol style="list-style-type: decimal">
<li>by using &quot;simple query&quot; protocol (which implies parsing and executing a query by a server on each request) with dmitigr::pgfe::Connection::perform();</li>
<li>by using &quot;extended query&quot; protocol (which implies using of parameterizable prepared statements):
<ul>
<li>by explicitly preparing a statement with dmitigr::pgfe::Connection::prepare_statement() and executing it with dmitigr::pgfe::Prepared_statement::execute();</li>
<li>by implicitly preparing and executing an unnamed prepared statement with dmitigr::pgfe::Connection::execute().</li>
</ul></li>
</ol>
<p>Commands can be executed and processed asynchronously, i.e. without need of waiting a server response(-s), and thus, without thread blocking. For this purpose the methods of the class dmitigr::pgfe::Connection with the suffix <code>_async</code> shall be used, such as dmitigr::pgfe::Connection::perform_async() or dmitigr::pgfe::Connection::prepare_statement_async().</p>
<p>Prepared statements can be parameterized with either positional or named parameters. In order to use the named parameters, a SQL string must be preparsed by Pgfe. Preparsed SQL strings are represented by the class dmitigr::pgfe::Sql_string. Unparameterized prepared statements, or prepared statements parameterized by only positional parameters <em>does not</em> require to be preparsed. Thus, there is no need to create an instance of dmitigr::pgfe::Sql_string and <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> should be used instead.</p>
<p>To set a value of a prepared statement's parameter it should be converted to an object of the class dmitigr::pgfe::Data. For convenience, there is the templated method dmitigr::pgfe::Prepared_statement::set_parameter(std::size_t, T&amp;&amp;) which do such a conversion by using one of the specialization of the template structure dmitigr::pgfe::Conversions.</p>
<p>Example 1. Simple querying.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simple_query(dmitigr::pgfe::Connection* conn)
{
  conn-&gt;perform(<span class="st">&quot;SELECT generate_series(1, 3) AS num&quot;</span>);
}</code></pre></div>
<p>Example 2. Implicit execution of the unnamed prepared statement.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> implicit_prepare_and_execute(dmitigr::pgfe::Connection* conn)
{
  conn-&gt;execute(<span class="st">&quot;SELECT generate_series($1::int, $2::int) AS num&quot;</span>, <span class="dv">1</span>, <span class="dv">3</span>);
}</code></pre></div>
<p>Example 3. Explicit execution of the named prepared statement with named parameters.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> explicit_prepare_and_execute(<span class="at">const</span> <span class="bu">std::</span>string&amp; name, dmitigr::pgfe::Connection* conn)
{
  <span class="at">static</span> <span class="at">const</span> <span class="kw">auto</span> sql = dmitigr::pgfe::Sql_string::make(<span class="st">&quot;SELECT generate_series(:infinum::int, :supremum::int) AS num&quot;</span>);
  <span class="kw">auto</span> ps = conn-&gt;prepare_statement(sql.get(), name);
  ps-&gt;set_parameter(<span class="st">&quot;infinum&quot;</span>,  <span class="dv">1</span>);
  ps-&gt;set_parameter(<span class="st">&quot;supremum&quot;</span>, <span class="dv">3</span>);
  ps-&gt;execute();
}</code></pre></div>
<h2 id="responses-handling">Responses handling</h2>
<p>Server responses are represented by the classes, inherited from dmitigr::pgfe::Response:</p>
<ul>
<li>Responses that are server errors are represented by the class dmitigr::pgfe::Error. Each server error is identifiable by a so-called <a href="https://www.postgresql.org/docs/current/static/errcodes-appendix.html">SQLSTATE</a> code. In Pgfe <em>each</em> such a code is represented by the member of the enum class dmitigr::pgfe::Server_errc, integrated in framework for reporting errors provided by the standard library in <a href="https://en.cppreference.com/w/cpp/header/system_error"><code>&lt;system_error&gt;</code></a>. Therefore, working with <a href="https://www.postgresql.org/docs/current/static/errcodes-appendix.html">SQLSTATE</a> codes is as simple and safe as with <a href="https://en.cppreference.com/w/cpp/error/error_code"><code>std::error_code</code></a> and enumerated types! For example:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> handle_error_example(dmitigr::pgfe::Connection* conn)
{
  <span class="cf">try</span> {
    conn-&gt;perform(<span class="st">&quot;PROVOKE SYNTAX ERROR&quot;</span>);
  } <span class="cf">catch</span> (<span class="at">const</span> dmitigr::pgfe::Server_exception&amp; e) {
    assert(e.error()-&gt;code() == dmitigr::pgfe::Server_errc::c42_syntax_error);
  }
}</code></pre></div>
<ul>
<li><p>Responses that are rows are represented by the class dmitigr::pgfe::Row. Objects of this class can be accessed by using dmitigr::pgfe::Connection::row() and/or dmitigr::pgfe::Connection::release_row(). However, it is best to use the method dmitigr::pgfe::Connection::for_each() for rows processing. Be aware, that before executing the subsequent operations, all of the rows <strong>must</strong> be processed.</p></li>
<li><p>Responses that are prepared statements are represented by the class dmitigr::pgfe::Prepared_statement. Prepared statements are accessible via the method dmitigr::pgfe::Connection::prepared_statement().</p></li>
<li><p>Responses that indicates success of operations are represented by the class dmitigr::pgfe::Completion. Such responses can be accessed by calling dmitigr::pgfe::Connection::completion() and/or dmitigr::pgfe::Connection::release_completion(). Alternatively, to process completion responses the method dmitigr::pgfe::Connection::complete() can be used.</p></li>
</ul>
<p>To <em>initiate</em> asynchronous retrieving of the <em>first</em> response (i.e. with no blocking the thread), methods of the class dmitigr::pgfe::Connection with the suffix &quot;_async&quot; must be used. Otherwise, Pgfe will wait for the first response and if that response is dmitigr::pgfe::Error, an object of type dmitigr::pgfe::Server_exception will be thrown as exception. This object provides access to the retrieved object of type dmitigr::pgfe::Error, which contains the error details.</p>
<p>Server responses can be <em>retrieved</em>: - synchronously by using the methods such as dmitigr::pgfe::Connection::wait_response() and dmitigr::pgfe::Connection::wait_last_response(); - asynchronously by using the methods such as dmitigr::pgfe::Connection::collect_server_messages() and dmitigr::pgfe::Connection::socket_readiness();</p>
<h2 id="data-type-conversions">Data type conversions</h2>
<p>Pgfe ships with support of conversions for <em>fundamental and standard C++ types</em>. Conversions for special PostgreSQL types such as <a href="https://www.postgresql.org/docs/current/datatype-datetime.html">Date/Time Types</a> aren't provided out of the box, since many implementations of these types are possible at the client side. Instead it's up to the user to deside what implementation to use. (If such conversions are needed at all.) For example, the template structure dmitigr::pgfe::Conversions can be easily specialized to perform conversions between PostgreSQL <a href="https://www.postgresql.org/docs/current/datatype-datetime.html">Date/Time Types</a> and types from the <a href="https://www.boost.org/doc/libs/release/libs/date_time/">Boost.Date_Time</a> library.</p>
<p>The class dmitigr::pgfe::Data is designed to store:</p>
<ul>
<li>the values of prepared statements' parameters;</li>
<li>the data retrieved from <a href="https://www.postgresql.org/">PostgreSQL</a> server.</li>
</ul>
<p>The template structure dmitigr::pgfe::Conversions are used by:</p>
<ul>
<li>dmitigr::pgfe::Prepared_statement::set_parameter(std::size_t, T&amp;&amp;) - to perfrom data conversions from objects or type <code>T</code> to objects of type dmitigr::pgfe::Data;</li>
<li>dmitigr::pgfe::to() - to perform data conversions from objects of type dmitigr::pgfe::Data to objects of the specified type <code>T</code>.</li>
</ul>
<p>There is the partial specialization of the template structure dmitigr::pgfe::Conversions to perform conversions from/to <a href="https://www.postgresql.org/">PostgreSQL</a> arrays representation to any combination of the STL containers. (At the moment, arrays conversions are only implemented for dmitigr::pgfe::Data_format::text format.) In general, any <a href="https://www.postgresql.org/">PostgreSQL</a> array can be represented as <code>Container&lt;Optional&lt;T&gt;&gt;</code>, where:</p>
<ul>
<li><code>Container</code> - is the template class of the container such as <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> or <a href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a> or <a href="https://en.cppreference.com/w/cpp/container/deque"><code>std::deque</code></a>;</li>
<li><code>Optional</code> - is the template class of the optional value holder such as <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> or <code>boost::optional</code>. The special value like <a href="https://en.cppreference.com/w/cpp/utility/optional/nullopt"><code>std::nullopt</code></a> represents the SQL <code>NULL</code>;</li>
<li>T - is the type of elements of the array. It can be <code>Container&lt;Optional&lt;T&gt;&gt;</code> to represent the multidimensional array.</li>
</ul>
<p>In case when all the array elements are non-NULL, such an array can be represented as just the container with elements of type T (ie no need to make it optional). But in case when the source array (which comes from the PostgreSQL server) contain at least one NULL element a runtime exception will be thrown.</p>
<p>In light of the above:</p>
<ul>
<li><p>the types <code>Container&lt;Optional&lt;T&gt;&gt;</code>, <code>Container&lt;Optional&lt;Container&lt;Optional&lt;T&gt;&gt;&gt;&gt;</code>, ... can be used to represent N-dimensional arrays of <code>T</code> which <em>can</em> contain NULL values;</p></li>
<li><p>the types <code>Container&lt;T&gt;</code>, <code>Container&lt;Container&lt;T&gt;&gt;</code>, ... can be used to represent N-dimensional arrays of <code>T</code> which <em>cannot</em> contain NULL values;</p></li>
</ul>
<p>User-defined data conversions could be implemented by either:</p>
<ul>
<li>implementing the overloads of <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> for <a href="https://en.cppreference.com/w/cpp/io/basic_ostream"><code>std::ostream</code></a> and <a href="https://en.cppreference.com/w/cpp/io/basic_istream"><code>std::istream</code></a> respectively;</li>
<li>specializing the template structure dmitigr::pgfe::Conversions. (With this approach overheads of standard IO streams can be avoided.)</li>
</ul>
<h2 id="signals-handling">Signals handling</h2>
<p>Server signals are represented by the classes, inherited from dmitigr::pgfe::Signal:</p>
<ul>
<li>signals that are server notices are represented by the class dmitigr::pgfe::Notice;</li>
<li>signals that are server notifications are represented by the class dmitigr::pgfe::Notification.</li>
</ul>
<p>Signals can be handled:</p>
<ul>
<li>synchronously, by using the signal handlers (see dmitigr::pgfe::Connection::set_notice_handler(), dmitigr::pgfe::Connection::set_notification_handler());</li>
<li>asynchronously, by using the methods that provides access to the retrieved signals directly (see dmitigr::pgfe::Connection::notice(), dmitigr::pgfe::Connection::notification()).</li>
</ul>
<p>Signal handlers, being set, called by dmitigr::pgfe::Connection::handle_signals(). The latter is called automatically while waiting a response. If no handler is set, corresponding signals will be collected in the internal storage and can be popped up by using dmitigr::pgfe::Connection::pop_notice() and/or dmitigr::pgfe::Connection::pop_notification() depending on the type of signal.</p>
<p><strong>WARNING</strong> If signals are not popped up from the internal storage it may cause memory exhaustion! Thus, signals must be handled anyway!</p>
<h2 id="dynamic-sql">Dynamic SQL</h2>
<p>The standard tools like <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> or <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream"><code>std::ostringstream</code></a> can be used to make SQL strings dynamically. However, in some cases it is more convenient to use the class dmitigr::pgfe::Sql_string for this purpose.</p>
<p>Consider the following statement:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sql = dmitigr::pgfe::Sql_string::make(<span class="st">&quot;SELECT :expr::int, &#39;:expr&#39;&quot;</span>);</code></pre></div>
<p>This statement has one named parameter <code>expr</code> and one string constant <code>':expr'</code>. If prepare this statement with dmitigr::pgfe::Connection::prepare_statement(), the actual prepared statement parsed by the server will looks like:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> $<span class="dv">1</span>:<span class="ch">:int</span>, <span class="st">&#39;:expr&#39;</span></code></pre></div>
<p>Before preparing the statement, it is possible to replace the named parameters of the SQL string with another SQL string by using dmitigr::pgfe::Sql_string::replace_parameter(). For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sql = dmitigr::pgfe::Sql_string::make(<span class="st">&quot;SELECT :expr::int, &#39;:expr&#39;&quot;</span>);
sql-&gt;replace_parameter(<span class="st">&quot;expr&quot;</span>, <span class="st">&quot;sin(:expr1::int), cos(:expr2::int)&quot;</span>);</code></pre></div>
<p>Now the statement has two named parameters, and looks like:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="fu">sin</span>(<span class="ch">:expr1</span>:<span class="ch">:int</span>), <span class="fu">cos</span>(<span class="ch">:expr2</span>:<span class="ch">:int</span>), <span class="st">&#39;:expr&#39;</span></code></pre></div>
<p>Note, that the quoted string <code>:expr</code> is not affected by the replacement operation!</p>
<h2 id="working-with-sql-queries-separately-of-c-code">Working with SQL queries separately of C++ code</h2>
<p>The idea of the approach is to store the SQL queries in the separate place, such as a text file. First, the content of this file must be read into the object of type <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>. Next, the object of type dmitigr::pgfe::Sql_vector should be created with dmitigr::pgfe::Sql_vector::make(). Finally, the required SQL string can be accessed by the index or by the extra data, such as, for example, the SQL string identifier which was specified in advance in the related comments of the query. Let's consider the simple SQL input:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="co">-- This is query 1</span>
<span class="co">--</span>
<span class="co">-- $id$plus-one$id$</span>
<span class="kw">SELECT</span> <span class="ch">:n</span>:<span class="ch">:int</span> + <span class="dv">1</span>, <span class="st">&#39;;&#39;</span>; <span class="co">-- note, the semicolons in quotes are allowed!</span>

<span class="co">/* This is query 2</span>
<span class="co"> *</span>
<span class="co"> * $id$minus-one$id$</span>
<span class="co"> */</span>
<span class="kw">SELECT</span> <span class="ch">:n</span>:<span class="ch">:int</span> - <span class="dv">1</span></code></pre></div>
<p>The vector of two SQL strings can be created from this input with dmitigr::pgfe::Sql_vector::make(). These objects has an extra data specified by the dollar-quoted string constants. (<a href="https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING">The dollar quoting syntax</a> are well-know way of quoting string literals in <a href="https://www.postgresql.org/">PostgreSQL</a>.) Next, these queries can be easily accessed by using the dmitigr::pgfe::Sql_vector API, for example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>string read_file(<span class="at">const</span> <span class="bu">std::</span>filesystem<span class="bu">::</span>path&amp; path);

<span class="dt">void</span> foo()
{
  <span class="kw">namespace</span> pgfe = dmitigr::pgfe;
  <span class="at">const</span> <span class="bu">std::</span>string input = read_file(<span class="st">&quot;bunch.sql&quot;</span>);
  <span class="kw">auto</span> bunch = pgfe::Sql_vector::make(input);
  <span class="kw">auto</span>* minus_one = bunch-&gt;sql_string(<span class="st">&quot;id&quot;</span>, <span class="st">&quot;minus-one&quot;</span>); <span class="co">// SELECT :n::int - 1</span>
  <span class="kw">auto</span>*  plus_one = bunch-&gt;sql_string(<span class="st">&quot;id&quot;</span>,  <span class="st">&quot;plus-one&quot;</span>); <span class="co">// SELECT :n::int + 1, &#39;;&#39;</span>
  <span class="co">// Next, working with the queries ...</span>
}</code></pre></div>
<h2 id="exceptions">Exceptions</h2>
<p>Pgfe may throw:</p>
<ul>
<li>an instance of the type <a href="https://en.cppreference.com/w/cpp/error/logic_error"><code>std::logic_error</code></a> when:
<ul>
<li>API contract requirements are violated;</li>
<li>an assertion failure has occurred (it is possible only with the &quot;debug&quot; build of Pgfe);</li>
</ul></li>
<li>an instance of the types <a href="https://en.cppreference.com/w/cpp/error/runtime_error"><code>std::runtime_error</code></a> or dmitigr::pgfe::Client_exception when some kind of runtime error occured on the client side;</li>
<li>the instance of the type dmitigr::pgfe::Server_exception when some error occured on the server side and the methods like dmitigr::pgfe::Connection::wait_response_throw() is in use (which is case when using dmitigr::pgfe::Connection::perform(), dmitigr::pgfe::Connection::execute() etc).</li>
</ul>
<h2 id="thread-safety">Thread safety</h2>
<p>By default, if not explicitly documented, all functions and methods of Pgfe are <em>not</em> thread safe. Thus, in most cases, some of the synchronization mechanisms (like mutexes) must be used to work with the same object from several threads.</p>
<h1 id="documentation">Documentation</h1>
<p>The Dmitigr Pgfe documentation is located at the official site <a href="http://dmitigr.ru/en/projects/pgfe/doc/">here</a>.</p>
<h1 id="download">Download</h1>
<p>The Dmitigr Pgfe repository is located at Github <a href="https://github.com/dmitigr/pgfe.git">here</a>.</p>
<h1 id="installation-and-consuming">Installation and consuming</h1>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><a href="https://cmake.org/">CMake</a> build system version 3.13+;</li>
<li>C++17 compiler (<a href="https://gcc.gnu.org/">GCC</a> 8+ or <a href="https://www.visualstudio.com/">Microsoft Visual C++</a> 15.7+);</li>
<li><a href="https://github.com/dmitigr/common.git">dmitigr_common</a> library;</li>
<li><a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> library (the underlying engine).</li>
</ul>
<h2 id="build-time-settings">Build time settings</h2>
<p>Settings that may be specified at build time by using <a href="https://cmake.org/">CMake</a> variables are: 1. the type of the build (only meaningful to single-configuration generators); 2. the flag to build the shared library; 3. the flag to build the tests (default is on); 4. dependencies; 5. installation directories; 6. default values of the connection options.</p>
<p>Details (may need to use horizontal scrolling for full view):</p>
<table style="width:92%;">
<colgroup>
<col width="20%" />
<col width="22%" />
<col width="22%" />
<col width="26%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">CMake variable</th>
<th align="left">Possible values</th>
<th align="left">Default on Unix</th>
<th align="left">Default on Windows</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>The type of the build</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">CMAKE_BUILD_TYPE</td>
<td align="left">Debug | Release | RelWithDebInfo | MinSizeRel</td>
<td align="left">Debug</td>
<td align="left">Debug</td>
</tr>
<tr class="odd">
<td align="left"><strong>The flag to build the shared library</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">BUILD_SHARED_LIBS</td>
<td align="left">On | Off</td>
<td align="left">On</td>
<td align="left">On</td>
</tr>
<tr class="odd">
<td align="left"><strong>The flag to build the tests</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_BUILD_TESTS</td>
<td align="left">On | Off</td>
<td align="left">On</td>
<td align="left">On</td>
</tr>
<tr class="odd">
<td align="left"><strong>Dependencies</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">LIBPQ_PREFIX</td>
<td align="left"><em>a path</em></td>
<td align="left"><em>not set (rely on CMake)</em></td>
<td align="left"><em>not set (rely on CMake)</em></td>
</tr>
<tr class="odd">
<td align="left">LIBPQ_LIB_PREFIX</td>
<td align="left"><em>a path</em></td>
<td align="left">${LIBPQ_PREFIX}</td>
<td align="left">${LIBPQ_PREFIX}</td>
</tr>
<tr class="even">
<td align="left">LIBPQ_INCLUDE_PREFIX</td>
<td align="left"><em>a path</em></td>
<td align="left">${LIBPQ_PREFIX}</td>
<td align="left">${LIBPQ_PREFIX}</td>
</tr>
<tr class="odd">
<td align="left"><strong>Installation directories</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">CMAKE_INSTALL_PREFIX</td>
<td align="left"><em>an absolute path</em></td>
<td align="left">&quot;/usr/local&quot;</td>
<td align="left">&quot;%ProgramFiles%_pgfe&quot;</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CMAKE_INSTALL_DIR</td>
<td align="left"><em>a path relative to CMAKE_INSTALL_PREFIX</em></td>
<td align="left">&quot;share/dmitigr_pgfe/cmake&quot;</td>
<td align="left">&quot;cmake&quot;</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_DOC_INSTALL_DIR</td>
<td align="left"><em>a path relative to CMAKE_INSTALL_PREFIX</em></td>
<td align="left">&quot;share/dmitigr_pgfe/doc&quot;</td>
<td align="left">&quot;doc&quot;</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_LIB_INSTALL_DIR</td>
<td align="left"><em>a path relative to CMAKE_INSTALL_PREFIX</em></td>
<td align="left">&quot;lib&quot;</td>
<td align="left">&quot;lib&quot;</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_INCLUDE_INSTALL_DIR</td>
<td align="left"><em>a path relative to CMAKE_INSTALL_PREFIX</em></td>
<td align="left">&quot;include&quot;</td>
<td align="left">&quot;include&quot;</td>
</tr>
<tr class="odd">
<td align="left"><strong>Default values of the connection options</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_COMMUNICATION_MODE</td>
<td align="left">uds | tcp</td>
<td align="left">uds</td>
<td align="left">tcp</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_UDS_DIRECTORY</td>
<td align="left"><em>an absolute path</em></td>
<td align="left">/tmp</td>
<td align="left"><em>unavailable</em></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_UDS_FILE_EXTENSION</td>
<td align="left"><em>a string</em></td>
<td align="left">5432</td>
<td align="left"><em>unavailable</em></td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_UDS_REQUIRE_SERVER_PROCESS_USERNAME</td>
<td align="left"><em>a string</em></td>
<td align="left"><em>not set</em></td>
<td align="left"><em>unavailable</em></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_KEEPALIVES_ENABLED</td>
<td align="left">On | Off</td>
<td align="left">Off</td>
<td align="left">Off</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_KEEPALIVES_IDLE</td>
<td align="left"><em>non-negative number</em></td>
<td align="left"><em>null (system default)</em></td>
<td align="left"><em>null (system default)</em></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_KEEPALIVES_INTERVAL</td>
<td align="left"><em>non-negative number</em></td>
<td align="left"><em>null (system default)</em></td>
<td align="left"><em>null (system default)</em></td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_KEEPALIVES_COUNT</td>
<td align="left"><em>non-negative number</em></td>
<td align="left"><em>null (system default)</em></td>
<td align="left"><em>null (system default)</em></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_HOST_ADDRESS</td>
<td align="left"><em>IPv4(v6) address</em></td>
<td align="left">127.0.0.1</td>
<td align="left">127.0.0.1</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_HOST_NAME</td>
<td align="left"><em>a string</em></td>
<td align="left">localhost</td>
<td align="left">localhost</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_TCP_HOST_PORT</td>
<td align="left"><em>a number</em></td>
<td align="left">5432</td>
<td align="left">5432</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_USERNAME</td>
<td align="left"><em>a string</em></td>
<td align="left">postgres</td>
<td align="left">postgres</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_DATABASE</td>
<td align="left"><em>a string</em></td>
<td align="left">postgres</td>
<td align="left">postgres</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_PASSWORD</td>
<td align="left"><em>a string</em></td>
<td align="left">&quot;&quot;</td>
<td align="left">&quot;&quot;</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_KERBEROS_SERVICE_NAME</td>
<td align="left"><em>a string</em></td>
<td align="left"><em>null (not used)</em></td>
<td align="left"><em>null (not used)</em></td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_ENABLED</td>
<td align="left">On | Off</td>
<td align="left">Off</td>
<td align="left">Off</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_SERVER_HOST_NAME_VERIFICATION_ENABLED</td>
<td align="left">On | Off</td>
<td align="left">Off</td>
<td align="left">Off</td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_COMPRESSION_ENABLED</td>
<td align="left">On | Off</td>
<td align="left">Off</td>
<td align="left">Off</td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_CERTIFICATE_FILE</td>
<td align="left"><em>an absolute path</em></td>
<td align="left"><em>null (libpq's default)</em></td>
<td align="left"><em>null (libpq's default)</em></td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_PRIVATE_KEY_FILE</td>
<td align="left"><em>an absolute path</em></td>
<td align="left"><em>null (libpq's default)</em></td>
<td align="left"><em>null (libpq's default)</em></td>
</tr>
<tr class="even">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_CERTIFICATE_AUTHORITY_FILE</td>
<td align="left"><em>an absolute path</em></td>
<td align="left"><em>null (libpq's default)</em></td>
<td align="left"><em>null (libpq's default)</em></td>
</tr>
<tr class="odd">
<td align="left">DMITIGR_PGFE_CONNECTION_SSL_CERTIFICATE_REVOCATION_LIST_FILE</td>
<td align="left"><em>an absolute path</em></td>
<td align="left"><em>null (libpq's default)</em></td>
<td align="left"><em>null (libpq's default)</em></td>
</tr>
</tbody>
</table>
<h2 id="installation-in-common">Installation in common</h2>
<p>The only dependences of Pgfe are <a href="https://github.com/dmitigr/common.git">dmitigr_common</a> and <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a>.</p>
<p>First, <a href="https://github.com/dmitigr/common.git">dmitigr_common</a> must be installed. The installation is trivial as described on its page.</p>
<p><strong>WARNING</strong> It's highly recommended to update the <a href="https://github.com/dmitigr/common.git">dmitigr_common</a> library (just pull and reinstall) before building the Pgfe library!</p>
<p>As for <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a>, <a href="https://cmake.org/">CMake</a> will try to locate it automatically. Although, it's possible to manually specify the location of <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> by using the following <a href="https://cmake.org/">CMake</a> variables:</p>
<ul>
<li><code>LIBPQ_PREFIX</code> - can be used to speficy a prefix for both binary and headers of <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a>. For example, if <a href="https://www.postgresql.org/">PostgreSQL</a> installed relocatably into <code>/usr/local/pgsql</code>, the value of <code>LIBPQ_PREFIX</code> may be set accordingly at command line such as: <code>-DLIBPQ_PREFIX=/usr/local/pgsql</code>;</li>
<li><code>LIBPQ_LIB_PREFIX</code> - similar to the above, but specifies a <em>prefix</em> of the <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> binary file (SO or DLL);</li>
<li><code>LIBPQ_INCLUDE_PREFIX</code> - similar to the above, but specifies a <em>prefix</em> of the <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> headers (namely, <code>libpq-fe.h</code>).</li>
</ul>
<h2 id="installation-on-linux">Installation on Linux</h2>
<pre><code>$ git clone https://github.com/dmitigr/pgfe.git
$ mkdir -p pgfe/build
$ cd pgfe/build
$ cmake -DCMAKE_BUILD_TYPE=Debug ..
$ make
$ sudo make install</code></pre>
<p>The value of the <code>CMAKE_BUILD_TYPE</code> could be replaced. Also, remember about the possibility to specify location of <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> if <a href="https://cmake.org/">CMake</a> could not detect it automatically (see &quot;Installation in common&quot; section above).</p>
<h2 id="installation-on-microsoft-windows">Installation on Microsoft Windows</h2>
<p>Run the Developer Command Prompt for Visual Studio and type:</p>
<pre><code>&gt; git clone https://github.com/dmitigr/pgfe.git
&gt; mkdir pgfe\build
&gt; cd pgfe\build
&gt; cmake -G &quot;Visual Studio 15 2017 Win64&quot; ..
&gt; cmake --build . --config Debug</code></pre>
<p>Next, run the Elevated Command Prompt (i.e. the command prompt with administrator privileges) and type:</p>
<pre><code>&gt; cd pgfe\build
&gt; cmake -DBUILD_TYPE=Debug -P cmake_install.cmake</code></pre>
<p>If the target architecture is Win32 or ARM, then &quot;Win64&quot; should be replaced by &quot;Win32&quot; or &quot;ARM&quot; accordingly.</p>
<p>To make the installed DLL available for <em>any</em> application that depends on it, the symbolic link to the dmitigr_pgfe.dll (or to the debug version - dmitigr_pgfed.dll) should be created:</p>
<ul>
<li>in %SYSTEMROOT%32 for the 64-bit DLL on 64-bit host (or for 32-bit DLL on 32-bit host);</li>
<li>in %SYSTEMROOT%64 for the 32-bit DLL on 64-bit host.</li>
</ul>
<p>To create the symbolic link run the Elevated Command Prompt and use <code>mklink</code> command, for example:</p>
<pre><code>&gt; cd /d %SYSTEMROOT%\System32
&gt; mklink dmitigr_pgfed.dll &quot;%ProgramFiles%\dmitigr_pgfe\lib\dmitigr_pgfed.dll&quot;</code></pre>
<p>The value of the <code>BUILD_TYPE</code> could be replaced. Also, remember about the possibility to specify location of <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> if <a href="https://cmake.org/">CMake</a> could not detect it automatically (see &quot;Installation in common&quot; section above).</p>
<p><strong>WARNING</strong> The target architecture must corresponds to the bitness of <a href="https://www.postgresql.org/docs/current/static/libpq.html">libpq</a> to link!</p>
<h2 id="consuming">Consuming</h2>
<p>If you are using CMake the consuming of the Pgfe library is quite simple. For example:</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> 3.13)
<span class="kw">project</span>(foo)
<span class="kw">find_package</span>(dmitigr_pgfe <span class="ot">REQUIRED</span>)
<span class="kw">set</span>(<span class="va">CMAKE_CXX_STANDARD</span> 17)
<span class="kw">set</span>(<span class="ot">CXX_STANDARD_REQUIRED</span> <span class="ot">ON</span>)
<span class="kw">add_executable</span>(foo foo.cpp)
<span class="kw">target_link_libraries</span>(foo dmitigr_pgfe)</code></pre></div>
<p>The above code snippet is minimal CMakeLists.txt that enough to build the application <code>foo</code> that depends on the Pgfe library.</p>
<h1 id="license">License</h1>
<p>Pgfe library is distributed under zlib license. For conditions of distribution and use, see files <code>LICENSE.txt</code> or <code>pgfe.hpp</code>.</p>
<h1 id="contributions-sponsorship-partnership">Contributions, sponsorship, partnership</h1>
<p>Pgfe has been developed on the own funds. Donations are welcome!</p>
<p>If you are using Pgfe for commercial purposes it is reasonable to donate or even sponsor the further development of Pgfe.</p>
<p>To make a donation, via <a href="https://paypal.com/">PayPal</a> please go <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;business=38TY2K8KYKYJC&amp;lc=US&amp;item_name=Pgfe%20library&amp;item_number=1&amp;currency_code=USD&amp;bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted">here</a> or <a href="https://paypal.me/dmitigr">here</a>.</p>
<p>If you need a commercial support, or you need to develop a custom client-side or server-side software based on <a href="https://www.postgresql.org/">PostgreSQL</a>, please contact us by sending email to <a href="mailto:dmitigr@gmail.com">dmitigr@gmail.com</a>.</p>
<p>Pgfe is a free software. Enjoy using it!</p>
<h1 id="feedback">Feedback</h1>
<p>Any feedback are welcome. Contact us by sending email to <a href="mailto:dmitigr@gmail.com">dmitigr@gmail.com</a>.</p>
<h1 id="copyright">Copyright</h1>
<p>Copyright (C) Dmitry Igrishin</p>
